<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>排序 | Moist</title><meta name="author" content="SDUMoist"><meta name="copyright" content="SDUMoist"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html 考点总结 堆插入删除过程中，关键字对比次数  知识总结              基本概念定义 排序（sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程 输入：n 个记录 R1,R2,…,Rn对应的关键字为 k1，k2，k3 输出：输入序列的一个重排">
<meta property="og:type" content="article">
<meta property="og:title" content="排序">
<meta property="og:url" content="https://sdumoist.github.io/2023/07/24/%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="Moist">
<meta property="og:description" content="排序https:&#x2F;&#x2F;www.cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html 考点总结 堆插入删除过程中，关键字对比次数  知识总结              基本概念定义 排序（sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程 输入：n 个记录 R1,R2,…,Rn对应的关键字为 k1，k2，k3 输出：输入序列的一个重排">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sdumoist.github.io/img/background/7.jpeg">
<meta property="article:published_time" content="2023-07-24T14:41:52.306Z">
<meta property="article:modified_time" content="2024-03-30T19:25:38.631Z">
<meta property="article:author" content="SDUMoist">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sdumoist.github.io/img/background/7.jpeg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://sdumoist.github.io/2023/07/24/%E6%8E%92%E5%BA%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: SDUMoist","link":"链接: ","source":"来源: Moist","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '排序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-31 03:25:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Moist" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background/7.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Moist"><img class="site-icon" src="/img/logo.png"/><span class="site-name">Moist</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">排序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-24T14:41:52.306Z" title="发表于 2023-07-24 22:41:52">2023-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-30T19:25:38.631Z" title="更新于 2024-03-31 03:25:38">2024-03-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/">408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="排序"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul>
<li>堆插入删除过程中，关键字对比次数</li>
</ul>
<h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230724224004190.png" alt="image-20230724224004190"></p>
<p><img src="/../image/assets/image-20230725152123705.png" alt="image-20230725152123705"></p>
<p><img src="/../image/assets/image-20230725160050422.png" alt="image-20230725160050422"></p>
<p><img src="/../image/assets/image-20230725162425916.png" alt="image-20230725162425916"></p>
<p><img src="/../image/assets/image-20230725174048936.png" alt="image-20230725174048936"></p>
<p><img src="/../image/assets/image-20230725175748489.png" alt="image-20230725175748489"></p>
<p><img src="/../image/assets/image-20230725195653067.png" alt="image-20230725195653067"></p>
<p><img src="/../image/assets/image-20230725201620490.png" alt="image-20230725201620490"></p>
<p><img src="/../image/assets/image-20230725210510348.png" alt="image-20230725210510348"></p>
<p><img src="/../image/assets/image-20230725215127204.png" alt="image-20230725215127204"></p>
<p><img src="/../image/assets/image-20230725224348354.png" alt="image-20230725224348354"></p>
<p><img src="/../image/assets/image-20230726143444178.png" alt="image-20230726143444178"></p>
<p><img src="/../image/assets/image-20230726145617274.png" alt="image-20230726145617274"></p>
<p><img src="/../image/assets/image-20230726152812736.png" alt="image-20230726152812736"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>排序（sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程<ul>
<li>输入：n 个记录 R1,R2,…,Rn对应的关键字为 k1，k2，k3</li>
<li>输出：输入序列的一个重排，使得有 K1&lt;&#x3D;K2&lt;&#x3D;K3…&lt;&#x3D;KN（也可以递减）</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230724223313575.png" alt="image-20230724223313575"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul>
<li><p>若待排序表中有两个元素<em>Ri</em>和<em>Rj</em>，其对应的关键字相同即key<em>i</em> &#x3D; key<em>j</em>，且在排序前<em>Ri</em>在<em>Rj</em>的前⾯，若使⽤某⼀排序算法排序后，<em>Ri</em>仍然在<em>Rj</em>的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p>
<ul>
<li><p>稳定的：关键字相同的元素在排序之后<strong>相对位置</strong>不变</p>
</li>
<li><p>不稳定的：排序之后相对位置会改变</p>
</li>
</ul>
</li>
<li><p>稳定的排序算法不一定比不稳定排序算法好，看实际需求</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230724223453761.png" alt="image-20230724223453761"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h4><ul>
<li>数据都在内存中</li>
<li>关注点：如何让算法时空复杂度更低</li>
</ul>
<h4 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h4><ul>
<li><p>数据太多，无法全部放入内存</p>
</li>
<li><p>关注点：如何使读、写磁盘次数更少</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230724223944694.png" alt="image-20230724223944694"></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成</li>
</ul>
<p><img src="/../image/assets/image-20230724225344906.png" alt="image-20230724225344906"></p>
<p><img src="/../image/assets/image-20230724225359534.png" alt="image-20230724225359534"></p>
<p><img src="/../image/assets/image-20230724225409283.png" alt="image-20230724225409283"></p>
<p><img src="/../image/assets/image-20230724225419234.png" alt="image-20230724225419234"></p>
<p><img src="/../image/assets/image-20230724225435427.png" alt="image-20230724225435427"></p>
<p><img src="/../image/assets/image-20230724225445134.png" alt="image-20230724225445134"></p>
<p><img src="/../image/assets/image-20230724225455508.png" alt="image-20230724225455508"></p>
<p><img src="/../image/assets/image-20230724225506642.png" alt="image-20230724225506642"></p>
<p><img src="/../image/assets/image-20230724225520263.png" alt="image-20230724225520263"></p>
<p><img src="/../image/assets/image-20230724225529427.png" alt="image-20230724225529427"></p>
<p><img src="/../image/assets/image-20230724225539069.png" alt="image-20230724225539069"></p>
<p><img src="/../image/assets/image-20230724225548863.png" alt="image-20230724225548863"><br><img src="/../image/assets/image-20230725144652437.png" alt="image-20230725144652437"></p>
<p><img src="/../image/assets/image-20230725144701573.png" alt="image-20230725144701573"></p>
<p><img src="/../image/assets/image-20230725144713594.png" alt="image-20230725144713594"></p>
<p><img src="/../image/assets/image-20230725144722865.png" alt="image-20230725144722865"></p>
<p><img src="/../image/assets/image-20230725144735499.png" alt="image-20230725144735499"></p>
<p><img src="/../image/assets/image-20230725144756848.png" alt="image-20230725144756848"></p>
<p><img src="/../image/assets/image-20230725144807505.png" alt="image-20230725144807505"></p>
<p><img src="/../image/assets/image-20230725144818286.png" alt="image-20230725144818286"></p>
<p><img src="/../image/assets/image-20230725144829170.png" alt="image-20230725144829170"></p>
<p><img src="/../image/assets/image-20230725144837620.png" alt="image-20230725144837620"></p>
<p><img src="/../image/assets/image-20230725144846993.png" alt="image-20230725144846993"></p>
<p><img src="/../image/assets/image-20230725144855740.png" alt="image-20230725144855740"></p>
<p><img src="/../image/assets/image-20230725144906674.png" alt="image-20230725144906674"></p>
<p><img src="/../image/assets/image-20230725144915837.png" alt="image-20230725144915837"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="/../image/assets/image-20230725144949809.png" alt="image-20230725144949809"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i ++)&#123;             <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;                <span class="comment">//若A[i]关键字小于前驱</span></span><br><span class="line">            temp=A[i];                  <span class="comment">//用temp暂存A[i]</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; temp; j --)      <span class="comment">//检查所有前面已经排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];            <span class="comment">//所有大于temp的元素都将向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法实现（带哨兵）"><a href="#算法实现（带哨兵）" class="headerlink" title="算法实现（带哨兵）"></a>算法实现（带哨兵）</h3><ul>
<li>优点：不用每轮循环都判断 j&gt;&#x3D;0</li>
</ul>
<p><img src="/../image/assets/image-20230725145012208.png" alt="image-20230725145012208"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序（带哨兵）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort2</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i ++)                <span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;                    <span class="comment">//若A[0]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];                    <span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; A[<span class="number">0</span>]&lt;A[j]; --j)    <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];              <span class="comment">//向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];                  <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul>
<li><p>空间复杂度：O(1)</p>
</li>
<li><p>时间复杂度：主要来自对比关键字、移动元素</p>
<ul>
<li>若有n个元素，则需要n-1次处理</li>
<li>最好情况：原本有序<ul>
<li>共n-1次处理，每一次都只需要对比关键字1次，不用移动元素</li>
<li>最好时间复杂度：O(n)</li>
</ul>
</li>
<li>最坏情况：原本是倒序<ul>
<li>第一趟：对比关键字2次，移动元素3次</li>
<li>第二趟：对比关键字3次，移动元素4次</li>
<li>…</li>
<li>第 i 趟，对比关键字i+1次，移动元素i+2次</li>
<li>…</li>
<li>第n-1趟，对比关键字n次，移动元素n+1次</li>
<li>最坏时间复杂度：O(n^2)</li>
</ul>
</li>
</ul>
</li>
<li><p>稳定性：稳定</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725145527757.png" alt="image-20230725145527757"></p>
<p><img src="/../image/assets/image-20230725145539397.png" alt="image-20230725145539397"></p>
<p><img src="/../image/assets/image-20230725145603222.png" alt="image-20230725145603222"></p>
<p><img src="/../image/assets/image-20230725145616707.png" alt="image-20230725145616707"></p>
<h3 id="算法优化（折半查找）"><a href="#算法优化（折半查找）" class="headerlink" title="算法优化（折半查找）"></a>算法优化（折半查找）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li><p>先用折半查找找到应该插入的位置，再移动元素</p>
</li>
<li><p>折半查找的终点都是low &gt; high</p>
<ul>
<li>将 [low, i-1]内的元素全部右移，并将 A[0]复制到low所指位置</li>
<li>当 A[mid] &#x3D;&#x3D; A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插入位置</li>
<li>为了保证算法的稳定性，即使前面排好序的元素中出现与待插入元素相同的元素，也不能停止查找，直到 low &gt; high</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725150749312.png" alt="image-20230725150749312"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化——折半插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i ++)&#123;               <span class="comment">//依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];                        <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;                <span class="comment">//设置折半查找范围</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;                  <span class="comment">//折半查找（默认递增有序）</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;           <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>]) high = mid <span class="number">-1</span>;<span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;             <span class="comment">//查找右半子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">            A[j<span class="number">-1</span>] = A[j];                  <span class="comment">//统一后移元素</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];                     <span class="comment">//插入操作</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><ul>
<li>比起“直接插入排序”，比较关键字的次数减少了，但是移动元素的次数没变</li>
<li>整体来看时间复杂度依然是O(n^2)</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="元素不相等"><a href="#元素不相等" class="headerlink" title="元素不相等"></a>元素不相等</h5><p><img src="/../image/assets/image-20230725145928376.png" alt="image-20230725145928376"></p>
<p><img src="/../image/assets/image-20230725145938369.png" alt="image-20230725145938369"></p>
<p><img src="/../image/assets/image-20230725145947543.png" alt="image-20230725145947543"></p>
<p><img src="/../image/assets/image-20230725145959257.png" alt="image-20230725145959257"></p>
<p><img src="/../image/assets/image-20230725150008971.png" alt="image-20230725150008971"></p>
<p><img src="/../image/assets/image-20230725150018986.png" alt="image-20230725150018986"></p>
<h5 id="元素相等"><a href="#元素相等" class="headerlink" title="元素相等"></a>元素相等</h5><p><img src="/../image/assets/image-20230725150112106.png" alt="image-20230725150112106"></p>
<p><img src="/../image/assets/image-20230725150123491.png" alt="image-20230725150123491"></p>
<p><img src="/../image/assets/image-20230725150136440.png" alt="image-20230725150136440"></p>
<p><img src="/../image/assets/image-20230725150146489.png" alt="image-20230725150146489"></p>
<p><img src="/../image/assets/image-20230725150159984.png" alt="image-20230725150159984"></p>
<p><img src="/../image/assets/image-20230725150211713.png" alt="image-20230725150211713"></p>
<h5 id="元素最大"><a href="#元素最大" class="headerlink" title="元素最大"></a>元素最大</h5><p><img src="/../image/assets/image-20230725150352312.png" alt="image-20230725150352312"></p>
<p><img src="/../image/assets/image-20230725150402243.png" alt="image-20230725150402243"></p>
<h5 id="元素最小"><a href="#元素最小" class="headerlink" title="元素最小"></a>元素最小</h5><p><img src="/../image/assets/image-20230725150416321.png" alt="image-20230725150416321"></p>
<p><img src="/../image/assets/image-20230725150426528.png" alt="image-20230725150426528"></p>
<p><img src="/../image/assets/image-20230725150436234.png" alt="image-20230725150436234"></p>
<p><img src="/../image/assets/image-20230725150448588.png" alt="image-20230725150448588"></p>
<p><img src="/../image/assets/image-20230725150500677.png" alt="image-20230725150500677"></p>
<h3 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a>对链表进行插入排序</h3><ul>
<li>移动元素的次数变少，但是关键字对比的次数依然是O(n^2)数量级</li>
<li>整体来看时间复杂度依然是O(n^2)</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li><p>对直接插入排序对优化</p>
</li>
<li><p>先追求表中元素部分有序，再逐渐逼近全局有序</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725152824128.png" alt="image-20230725152824128"></p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>先将待排序表分割成若干形如 L[i, i+的, i+2d,… , i +kd] 的“特殊”子表，对各个子表分别进行直接插入排序。</li>
<li>缩小增量的，重复上述过程，直到 d&#x3D;1</li>
<li>希尔本人建议：每次将增量缩小一半</li>
</ul>
<p><img src="/../image/assets/image-20230725152928019.png" alt="image-20230725152928019"></p>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><ul>
<li><p>d1 &#x3D; n&#x2F;2 &#x3D; 4		d2 &#x3D; d1&#x2F;2 &#x3D; 2		d3 &#x3D; d2 &#x2F;2 &#x3D; 1</p>
</li>
<li><p>结果</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725153128418.png" alt="image-20230725153128418"></p>
<ul>
<li>第一趟</li>
</ul>
<p><img src="/../image/assets/image-20230725153144613.png" alt="image-20230725153144613"></p>
<p><img src="/../image/assets/image-20230725153200461.png" alt="image-20230725153200461"></p>
<p><img src="/../image/assets/image-20230725153222915.png" alt="image-20230725153222915"></p>
<p><img src="/../image/assets/image-20230725153211788.png" alt="image-20230725153211788"></p>
<ul>
<li>第二趟</li>
</ul>
<p><img src="/../image/assets/image-20230725153247144.png" alt="image-20230725153247144"></p>
<p><img src="/../image/assets/image-20230725153257347.png" alt="image-20230725153257347"></p>
<p><img src="/../image/assets/image-20230725153307380.png" alt="image-20230725153307380"></p>
<p><img src="/../image/assets/image-20230725153317170.png" alt="image-20230725153317170"></p>
<ul>
<li>第三趟</li>
</ul>
<p><img src="/../image/assets/image-20230725153331420.png" alt="image-20230725153331420"></p>
<p><img src="/../image/assets/image-20230725153343624.png" alt="image-20230725153343624"></p>
<p><img src="/../image/assets/image-20230725153355778.png" alt="image-20230725153355778"></p>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><ul>
<li>d1 &#x3D; 3		d2 &#x3D; 1</li>
</ul>
<p><img src="/../image/assets/image-20230725153630391.png" alt="image-20230725153630391"></p>
<p><img src="/../image/assets/image-20230725153645310.png" alt="image-20230725153645310"></p>
<p><img src="/../image/assets/image-20230725153656108.png" alt="image-20230725153656108"></p>
<p><img src="/../image/assets/image-20230725153713761.png" alt="image-20230725153713761"></p>
<p><img src="/../image/assets/image-20230725153724639.png" alt="image-20230725153724639"></p>
<p><img src="/../image/assets/image-20230725153734875.png" alt="image-20230725153734875"></p>
<p><img src="/../image/assets/image-20230725153746266.png" alt="image-20230725153746266"></p>
<p><img src="/../image/assets/image-20230725153757283.png" alt="image-20230725153757283"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="/../image/assets/image-20230725154406706.png" alt="image-20230725154406706"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d, i, j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已经找到</span></span><br><span class="line">    <span class="keyword">for</span>(d = n/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d = d/<span class="number">2</span>)           <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i-d])&#123;              <span class="comment">//需要将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i];                <span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j = i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j]; j-=d)</span><br><span class="line">                    A[j+d]=A[<span class="number">0</span>];</span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];                <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../image/assets/image-20230725154806049.png" alt="image-20230725154806049"></p>
<p><img src="/../image/assets/image-20230725154816418.png" alt="image-20230725154816418"></p>
<p><img src="/../image/assets/image-20230725154825639.png" alt="image-20230725154825639"></p>
<p><img src="/../image/assets/image-20230725154838147.png" alt="image-20230725154838147"></p>
<p><img src="/../image/assets/image-20230725154848777.png" alt="image-20230725154848777"></p>
<p><img src="/../image/assets/image-20230725154900428.png" alt="image-20230725154900428"></p>
<p><img src="/../image/assets/image-20230725154910366.png" alt="image-20230725154910366"></p>
<p><img src="/../image/assets/image-20230725154920906.png" alt="image-20230725154920906"></p>
<p><img src="/../image/assets/image-20230725154931179.png" alt="image-20230725154931179"></p>
<p><img src="/../image/assets/image-20230725154949914.png" alt="image-20230725154949914"></p>
<p><img src="/../image/assets/image-20230725155000546.png" alt="image-20230725155000546"></p>
<p><img src="/../image/assets/image-20230725155011353.png" alt="image-20230725155011353"></p>
<p><img src="/../image/assets/image-20230725155022441.png" alt="image-20230725155022441"></p>
<p><img src="/../image/assets/image-20230725155032485.png" alt="image-20230725155032485"></p>
<p><img src="/../image/assets/image-20230725155042949.png" alt="image-20230725155042949"></p>
<p><img src="/../image/assets/image-20230725155052204.png" alt="image-20230725155052204"></p>
<p><img src="/../image/assets/image-20230725155102115.png" alt="image-20230725155102115"></p>
<p><img src="/../image/assets/image-20230725155111446.png" alt="image-20230725155111446"></p>
<p><img src="/../image/assets/image-20230725155121248.png" alt="image-20230725155121248"></p>
<p><img src="/../image/assets/image-20230725155130511.png" alt="image-20230725155130511"></p>
<p><img src="/../image/assets/image-20230725155140432.png" alt="image-20230725155140432"></p>
<p><img src="/../image/assets/image-20230725155149787.png" alt="image-20230725155149787"></p>
<p><img src="/../image/assets/image-20230725155159735.png" alt="image-20230725155159735"></p>
<p><img src="/../image/assets/image-20230725155241905.png" alt="image-20230725155241905"></p>
<p><img src="/../image/assets/image-20230725155300190.png" alt="image-20230725155300190"></p>
<p><img src="/../image/assets/image-20230725155310963.png" alt="image-20230725155310963"></p>
<p><img src="/../image/assets/image-20230725155321528.png" alt="image-20230725155321528"></p>
<p><img src="/../image/assets/image-20230725155332944.png" alt="image-20230725155332944"></p>
<p><img src="/../image/assets/image-20230725155341856.png" alt="image-20230725155341856"></p>
<p><img src="/../image/assets/image-20230725155351319.png" alt="image-20230725155351319"></p>
<p><img src="/../image/assets/image-20230725155402164.png" alt="image-20230725155402164"></p>
<p><img src="/../image/assets/image-20230725155411779.png" alt="image-20230725155411779"></p>
<p><img src="/../image/assets/image-20230725155433187.png" alt="image-20230725155433187"></p>
<p><img src="/../image/assets/image-20230725155444532.png" alt="image-20230725155444532"></p>
<p><img src="/../image/assets/image-20230725155454050.png" alt="image-20230725155454050"></p>
<p><img src="/../image/assets/image-20230725155502906.png" alt="image-20230725155502906"></p>
<p><img src="/../image/assets/image-20230725155514600.png" alt="image-20230725155514600"></p>
<p><img src="/../image/assets/image-20230725155523879.png" alt="image-20230725155523879"></p>
<p><img src="/../image/assets/image-20230725155533912.png" alt="image-20230725155533912"></p>
<p><img src="/../image/assets/image-20230725155543142.png" alt="image-20230725155543142"></p>
<p><img src="/../image/assets/image-20230725155555358.png" alt="image-20230725155555358"></p>
<p><img src="/../image/assets/image-20230725155606363.png" alt="image-20230725155606363"></p>
<p><img src="/../image/assets/image-20230725155616005.png" alt="image-20230725155616005"></p>
<h3 id="算法实现2"><a href="#算法实现2" class="headerlink" title="算法实现2"></a>算法实现2</h3><ul>
<li>先处理完一个子表，再处理另一个子表</li>
</ul>
<h3 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h3><ul>
<li>时间复杂度<ul>
<li>和增量序列 d1, d2, d3… 的选择有关，目前无法通过数学手段证明确切的时间复杂度</li>
<li>最坏时间复杂度为O(n^2),</li>
<li>当n再某个范围时，可以达到 O(n^1.3)</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725155914064.png" alt="image-20230725155914064"></p>
<ul>
<li>稳定性：不稳定</li>
<li>适用性：仅适用于顺序表，不适用于链表</li>
</ul>
<p><img src="/../image/assets/image-20230725155953367.png" alt="image-20230725155953367"></p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul>
<li>基于交换的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><ul>
<li>从后往前（或者从前往后）两两比较元素的值，若为逆序（即A[i-1] &gt; A[i]），则交换它们，直到序列比较完</li>
<li>这样的过程为一趟冒泡排序</li>
<li>每趟冒泡都可以将最小值放到前面（后面），前面已经确定最终位置的元素不用再进行比较</li>
<li>总共进行n-1趟冒泡排序</li>
</ul>
<p><img src="/../image/assets/image-20230725160550692.png" alt="image-20230725160550692"></p>
<p><img src="/../image/assets/image-20230725160600170.png" alt="image-20230725160600170"></p>
<p><img src="/../image/assets/image-20230725160611438.png" alt="image-20230725160611438"></p>
<p><img src="/../image/assets/image-20230725160620131.png" alt="image-20230725160620131"></p>
<p><img src="/../image/assets/image-20230725160628231.png" alt="image-20230725160628231"></p>
<p><img src="/../image/assets/image-20230725160641034.png" alt="image-20230725160641034"></p>
<p><img src="/../image/assets/image-20230725160649382.png" alt="image-20230725160649382"></p>
<p><img src="/../image/assets/image-20230725160700096.png" alt="image-20230725160700096"></p>
<p><img src="/../image/assets/image-20230725160708412.png" alt="image-20230725160708412"></p>
<p><img src="/../image/assets/image-20230725160724568.png" alt="image-20230725160724568"></p>
<p><img src="/../image/assets/image-20230725160733336.png" alt="image-20230725160733336"></p>
<p><img src="/../image/assets/image-20230725160741865.png" alt="image-20230725160741865"></p>
<p><img src="/../image/assets/image-20230725160750306.png" alt="image-20230725160750306"></p>
<p><img src="/../image/assets/image-20230725160853234.png" alt="image-20230725160853234"></p>
<p><img src="/../image/assets/image-20230725160902405.png" alt="image-20230725160902405"></p>
<p><img src="/../image/assets/image-20230725160910616.png" alt="image-20230725160910616"></p>
<p><img src="/../image/assets/image-20230725160920542.png" alt="image-20230725160920542"></p>
<p><img src="/../image/assets/image-20230725161020538.png" alt="image-20230725161020538"></p>
<p><img src="/../image/assets/image-20230725161030698.png" alt="image-20230725161030698"></p>
<p><img src="/../image/assets/image-20230725161038965.png" alt="image-20230725161038965"></p>
<p><img src="/../image/assets/image-20230725161047632.png" alt="image-20230725161047632"></p>
<p><img src="/../image/assets/image-20230725161056330.png" alt="image-20230725161056330"></p>
<p><img src="/../image/assets/image-20230725161105270.png" alt="image-20230725161105270"></p>
<p><img src="/../image/assets/image-20230725161115357.png" alt="image-20230725161115357"></p>
<p><img src="/../image/assets/image-20230725161124407.png" alt="image-20230725161124407"></p>
<p><img src="/../image/assets/image-20230725161154940.png" alt="image-20230725161154940"></p>
<p><img src="/../image/assets/image-20230725161332713.png" alt="image-20230725161332713"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/../image/assets/image-20230725161925763.png" alt="image-20230725161925763"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;                  <span class="comment">//表示本趟冒泡排序是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>; j &gt; i; j--)        <span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123;              <span class="comment">//若为逆序</span></span><br><span class="line">                <span class="built_in">swap</span>(A[j<span class="number">-1</span>], A[j]);         <span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;           <span class="comment">//本趟遍历没有发生交换，表示表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="算法性能分析-1"><a href="#算法性能分析-1" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><ul>
<li><p>空间复杂度：O(n)</p>
</li>
<li><p>时间复杂度</p>
<ul>
<li>最好情况：有序<ul>
<li>比较次数 &#x3D; n-1；交换次数 &#x3D; 0;</li>
<li>最好时间复杂度：O(n)</li>
</ul>
</li>
<li>最坏情况：逆序<ul>
<li>比较次数 &#x3D; (n-1)+(n-2)+…+1&#x3D; n(n-1)&#x2F;2 &#x3D; 交换次数</li>
<li>最坏时间复杂度 &#x3D; O(n^2)</li>
</ul>
</li>
<li>平均时间复杂度 &#x3D; O(n^2)</li>
</ul>
</li>
<li><p>稳定性：稳定的</p>
</li>
<li><p>适用性：顺序表和链表都适用</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725162404997.png" alt="image-20230725162404997"></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h4><ul>
<li><p>在待排序表[1..n]中选取一个元素 pivot 作为枢纽（或基准，通常取首元素）</p>
</li>
<li><p>通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1,n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1,n]中的所有元素大于等于pivot</p>
</li>
<li><p>pivot放在了最终位置 L[k]上</p>
</li>
<li><p>这个过程称为一次“划分”</p>
</li>
<li><p>然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725164902540.png" alt="image-20230725164902540"></p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li>一次划分</li>
</ul>
<p><img src="/../image/assets/image-20230725165217109.png" alt="image-20230725165217109"></p>
<p><img src="/../image/assets/image-20230725165229896.png" alt="image-20230725165229896"></p>
<p><img src="/../image/assets/image-20230725165242031.png" alt="image-20230725165242031"></p>
<p><img src="/../image/assets/image-20230725165253940.png" alt="image-20230725165253940"></p>
<p><img src="/../image/assets/image-20230725165304030.png" alt="image-20230725165304030"></p>
<p><img src="/../image/assets/image-20230725165312840.png" alt="image-20230725165312840"></p>
<p><img src="/../image/assets/image-20230725165326259.png" alt="image-20230725165326259"></p>
<p><img src="/../image/assets/image-20230725165335459.png" alt="image-20230725165335459"></p>
<p><img src="/../image/assets/image-20230725165344946.png" alt="image-20230725165344946"></p>
<p><img src="/../image/assets/image-20230725165355208.png" alt="image-20230725165355208"></p>
<p><img src="/../image/assets/image-20230725165404411.png" alt="image-20230725165404411"></p>
<p><img src="/../image/assets/image-20230725165414180.png" alt="image-20230725165414180"></p>
<p><img src="/../image/assets/image-20230725165425152.png" alt="image-20230725165425152"></p>
<p><img src="/../image/assets/image-20230725165438932.png" alt="image-20230725165438932"></p>
<ul>
<li>第二次划分（左子表）</li>
</ul>
<p><img src="/../image/assets/image-20230725165550539.png" alt="image-20230725165550539"></p>
<p><img src="/../image/assets/image-20230725165646400.png" alt="image-20230725165646400"></p>
<p><img src="/../image/assets/image-20230725165655414.png" alt="image-20230725165655414"></p>
<p><img src="/../image/assets/image-20230725165705841.png" alt="image-20230725165705841"></p>
<p><img src="/../image/assets/image-20230725165714818.png" alt="image-20230725165714818"></p>
<p><img src="/../image/assets/image-20230725165728560.png" alt="image-20230725165728560"></p>
<p><img src="/../image/assets/image-20230725165737305.png" alt="image-20230725165737305"></p>
<ul>
<li>第二次划分（右子表）</li>
</ul>
<p><img src="/../image/assets/image-20230725165748596.png" alt="image-20230725165748596"></p>
<p><img src="/../image/assets/image-20230725165757908.png" alt="image-20230725165757908"></p>
<p><img src="/../image/assets/image-20230725165807664.png" alt="image-20230725165807664"></p>
<p><img src="/../image/assets/image-20230725165817572.png" alt="image-20230725165817572"></p>
<p><img src="/../image/assets/image-20230725165828077.png" alt="image-20230725165828077"></p>
<p><img src="/../image/assets/image-20230725165838514.png" alt="image-20230725165838514"></p>
<p><img src="/../image/assets/image-20230725165849058.png" alt="image-20230725165849058"></p>
<p><img src="/../image/assets/image-20230725165906203.png" alt="image-20230725165906203"></p>
<p><img src="/../image/assets/image-20230725170039023.png" alt="image-20230725170039023"></p>
<ul>
<li>第三次划分（左子表）</li>
</ul>
<p><img src="/../image/assets/image-20230725170025626.png" alt="image-20230725170025626"></p>
<p><img src="/../image/assets/image-20230725170057204.png" alt="image-20230725170057204"></p>
<p><img src="/../image/assets/image-20230725170107198.png" alt="image-20230725170107198"></p>
<p><img src="/../image/assets/image-20230725170117092.png" alt="image-20230725170117092"></p>
<p><img src="/../image/assets/image-20230725170133088.png" alt="image-20230725170133088"></p>
<p><img src="/../image/assets/image-20230725170918658.png" alt="image-20230725170918658"></p>
<p><img src="/../image/assets/image-20230725170927903.png" alt="image-20230725170927903"></p>
<h4 id="代码实现（最重要）"><a href="#代码实现（最重要）" class="headerlink" title="代码实现（最重要）"></a>代码实现（最重要）</h4><p><img src="/../image/assets/image-20230725170943141.png" alt="image-20230725170943141"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];                       <span class="comment">//第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;                      <span class="comment">//用low、high搜索枢纽的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high];                   <span class="comment">//比枢纽小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) ++high;    </span><br><span class="line">        A[high]=A[low];                     <span class="comment">//比枢纽大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;                         <span class="comment">//枢纽元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;                             <span class="comment">//返回存放枢纽的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;                         <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high); <span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A, low, pivotpos<span class="number">-1</span>);      <span class="comment">//划分左子表</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivotpos + <span class="number">1</span>, high);   <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../image/assets/image-20230726162750805.png" alt="image-20230726162750805"></p>
<h4 id="算法效率分析-1"><a href="#算法效率分析-1" class="headerlink" title="算法效率分析"></a>算法效率分析</h4><ul>
<li><p>所有内部排序算法中，平均性能最优秀的排序算法</p>
</li>
<li><p>时间复杂度</p>
<ul>
<li><p><strong>每⼀层的</strong> QuickSort <strong>只需要处理剩余的</strong> <strong>待排序元素，时间复杂度不超过</strong>O(n)</p>
</li>
<li><p>时间复杂度&#x3D;O(n*递归层数)</p>
</li>
</ul>
</li>
<li><p>空间复杂度</p>
<ul>
<li>空间复杂度 &#x3D; O(递归层数)</li>
</ul>
</li>
<li><p>把n个元素组织成二叉树，二叉树的层数就是递归调用的层数</p>
<ul>
<li>n个节点的二叉树<ul>
<li>最小高度 &#x3D; log2n + 1</li>
<li>最大高度 &#x3D; n</li>
</ul>
</li>
<li>最好时间复杂度 &#x3D;  O(nlog2n)</li>
<li>最坏时间复杂度 &#x3D;  O(n^2)</li>
<li>平均时间复杂度 &#x3D; O(nlog2n)</li>
<li>最好空间复杂度 &#x3D;  O(log2n)</li>
<li>最坏空间复杂度 &#x3D; O(n)</li>
<li>最好情况（枢纽在中间）<ul>
<li>若每一次选中的“枢纽：将排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高</li>
<li>若每次选中的“枢纽”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高</li>
</ul>
</li>
<li>最坏情况（有序或逆序）<ul>
<li>若每一次选中的“枢纽”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低</li>
<li>若初始序列有序或逆序，则快速排序的性能最差（每次选中的都是最靠边的元素）</li>
</ul>
</li>
</ul>
</li>
<li><p>优化思路</p>
<ul>
<li>尽量选择可以把数据中分的枢纽元素<ul>
<li>选中头、中、尾三个位置的元素，取中间值作为枢纽元素</li>
<li>随机选一个元素作为枢轴元素</li>
</ul>
</li>
</ul>
</li>
<li><p>稳定性：不稳定</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725173927315.png" alt="image-20230725173927315"></p>
<p><img src="/../image/assets/image-20230725173943495.png" alt="image-20230725173943495"></p>
<ul>
<li>时间复杂度</li>
</ul>
<p><img src="/../image/assets/image-20230725172049560.png" alt="image-20230725172049560"></p>
<ul>
<li>空间复杂度</li>
</ul>
<p><img src="/../image/assets/image-20230725172443319.png" alt="image-20230725172443319"></p>
<ul>
<li>转换成二叉排序树</li>
</ul>
<p><img src="/../image/assets/image-20230725172555373.png" alt="image-20230725172555373"></p>
<ul>
<li>最坏的情况（逆序）</li>
</ul>
<p><img src="/../image/assets/image-20230725173155889.png" alt="image-20230725173155889"></p>
<ul>
<li>比较好的情况</li>
</ul>
<p><img src="/../image/assets/image-20230725173438773.png" alt="image-20230725173438773"></p>
<h4 id="一趟排序-一次划分"><a href="#一趟排序-一次划分" class="headerlink" title="一趟排序 !&#x3D; 一次划分"></a>一趟排序 !&#x3D; 一次划分</h4><ul>
<li>一趟排序：可以确定多个元素的位置</li>
<li>一次划分：只能确定一个元素的位置</li>
</ul>
<p><img src="/../image/assets/image-20230725174202608.png" alt="image-20230725174202608"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列</li>
</ul>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h4><ul>
<li>每一趟在待排序元素中选取关键字最小的元素加入有序子序列<ul>
<li>如果遇到两个相同的最小元素，则选择位置靠前的</li>
</ul>
</li>
<li>最后剩一个不用处理<ul>
<li>n个元素的简单选择排序需要n-1趟处理</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725174457542.png" alt="image-20230725174457542"></p>
<p><img src="/../image/assets/image-20230725174506146.png" alt="image-20230725174506146"></p>
<p><img src="/../image/assets/image-20230725174515310.png" alt="image-20230725174515310"></p>
<p><img src="/../image/assets/image-20230725174523975.png" alt="image-20230725174523975"></p>
<p><img src="/../image/assets/image-20230725174534231.png" alt="image-20230725174534231"></p>
<p><img src="/../image/assets/image-20230725174547275.png" alt="image-20230725174547275"></p>
<p><img src="/../image/assets/image-20230725174555452.png" alt="image-20230725174555452"></p>
<p><img src="/../image/assets/image-20230725174614500.png" alt="image-20230725174614500"></p>
<p><img src="/../image/assets/image-20230725174627664.png" alt="image-20230725174627664"></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/../image/assets/image-20230725175408335.png" alt="image-20230725175408335"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;           <span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min =i;                         <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)      <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min]) min = i;      <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(A[i], A[min]);    <span class="comment">//封装的swap()函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法性能分析-2"><a href="#算法性能分析-2" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><ul>
<li><p>空间复杂度 &#x3D; O(1)</p>
</li>
<li><p>时间复杂度 &#x3D; O(n^2)</p>
<ul>
<li>无论有序、逆序、还输乱序，一定需要n-1趟处理</li>
<li>总共需要对比关键字（n-1)+(n-2)+(n-3)+….+1 &#x3D; n(n-1)&#x2F;2 次</li>
</ul>
</li>
<li><p>稳定性：不稳定</p>
</li>
<li><p>适用性：既可以用于顺序表，也可以用于链表</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725175721087.png" alt="image-20230725175721087"></p>
<p><img src="/../image/assets/image-20230725175730921.png" alt="image-20230725175730921"></p>
<h3 id="堆排序（重点）"><a href="#堆排序（重点）" class="headerlink" title="堆排序（重点）"></a>堆排序（重点）</h3><h4 id="堆-heap-顺序存储的完全二叉树"><a href="#堆-heap-顺序存储的完全二叉树" class="headerlink" title="堆(heap):顺序存储的完全二叉树"></a>堆(heap):顺序存储的完全二叉树</h4><ul>
<li>若n个关键字序列L[1….n] 满足下面某一条性质，则称为堆（Heap）<ul>
<li>大根堆（大顶堆）：若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>&#x2F;2 ）<ul>
<li>完全二叉树中：根 &gt;&#x3D; 左右</li>
</ul>
</li>
<li>小根堆（小顶堆）：若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>&#x2F;2 ） <ul>
<li>完全二叉树中：根 &lt;&#x3D; 左右</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725180409165.png" alt="image-20230725180409165"></p>
<h5 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h5><p><img src="/../image/assets/image-20230725180215700.png" alt="image-20230725180215700"></p>
<h4 id="构建操作"><a href="#构建操作" class="headerlink" title="构建操作"></a>构建操作</h4><h5 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h5><ul>
<li>堆顶元素关键字最大</li>
</ul>
<h5 id="简单选择排序-VS-堆排序"><a href="#简单选择排序-VS-堆排序" class="headerlink" title="简单选择排序 VS 堆排序"></a>简单选择排序 VS 堆排序</h5><ul>
<li><p>简单选择排序：每⼀趟在待排序元素中选取关键字最⼤的元素加⼊有序⼦序列</p>
</li>
<li><p>堆排序：每⼀趟将堆顶元素加⼊有序⼦序列（与待排序序列中的最后⼀个元素交换）</p>
</li>
</ul>
<h5 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h5><ul>
<li><p>思路</p>
<ul>
<li>把所有非终端节点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</li>
<li><strong>在顺序存储的完全二叉树中，非终端节点编号i &lt;&#x3D; [n&#x2F;2]</strong></li>
</ul>
</li>
<li><p>调整</p>
<ul>
<li>从 i &#x3D; n&#x2F;2 开始检查当前节点（i &lt;&#x3D; n&#x2F;2）是否满足 <strong>根 &gt;&#x3D; 左、右</strong></li>
<li>若不满足，将当前节点与更大的一个孩子互换</li>
<li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整<strong>（小元素不断“下坠”）</strong></li>
<li>小元素无法下坠，则调整完成</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725185515129.png" alt="image-20230725185515129"></p>
<p><img src="/../image/assets/image-20230725185543386.png" alt="image-20230725185543386"></p>
<p><img src="/../image/assets/image-20230725190017364.png" alt="image-20230725190017364"></p>
<p><img src="/../image/assets/image-20230725190026570.png" alt="image-20230725190026570"></p>
<p><img src="/../image/assets/image-20230725190036919.png" alt="image-20230725190036919"></p>
<p><img src="/../image/assets/image-20230725190045953.png" alt="image-20230725190045953"></p>
<p><img src="/../image/assets/image-20230725190056157.png" alt="image-20230725190056157"></p>
<p><img src="/../image/assets/image-20230725190105695.png" alt="image-20230725190105695"></p>
<p><img src="/../image/assets/image-20230725190114473.png" alt="image-20230725190114473"></p>
<p><img src="/../image/assets/image-20230725190125706.png" alt="image-20230725190125706"></p>
<p><img src="/../image/assets/image-20230725190137290.png" alt="image-20230725190137290"></p>
<p><img src="/../image/assets/image-20230725190145791.png" alt="image-20230725190145791"></p>
<h5 id="构建的代码实现"><a href="#构建的代码实现" class="headerlink" title="构建的代码实现"></a>构建的代码实现</h5><p><img src="/../image/assets/image-20230725190229628.png" alt="image-20230725190229628"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                            <span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])  </span><br><span class="line">            i++;                            <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;             <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                               </span><br><span class="line">            A[k] =A[i];                     <span class="comment">//将A[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                          <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];                            <span class="comment">//被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)          <span class="comment">//从后往前调整所有非终端节点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../image/assets/image-20230725191359187.png" alt="image-20230725191359187"></p>
<p><img src="../image/assets/image-20230725191411362.png" alt="image-20230725191411362" style="zoom: 33%;" /><img src="../image/assets/image-20230725191632663.png" alt="image-20230725191632663" style="zoom:33%;" /></p>
<p><img src="../image/assets/image-20230725191716515.png" alt="image-20230725191716515" style="zoom:33%;" /><img src="../image/assets/image-20230725191732707.png" alt="image-20230725191732707" style="zoom:33%;" /></p>
<p><img src="../image/assets/image-20230725191841331.png" alt="image-20230725191841331" style="zoom:33%;" /><img src="../image/assets/image-20230725191856662.png" alt="image-20230725191856662" style="zoom:33%;" /></p>
<p><img src="../image/assets/image-20230725191938091.png" alt="image-20230725191938091" style="zoom:33%;" /><img src="../image/assets/image-20230725191951907.png" alt="image-20230725191951907" style="zoom:33%;" /></p>
<p><img src="../image/assets/image-20230725192011696.png" alt="image-20230725192011696" style="zoom:33%;" /><img src="../image/assets/image-20230725192034371.png" alt="image-20230725192034371" style="zoom:33%;" /></p>
<h5 id="排序操作（基于大根堆）"><a href="#排序操作（基于大根堆）" class="headerlink" title="排序操作（基于大根堆）"></a>排序操作（基于大根堆）</h5><ul>
<li>选择排序：每一趟在待排序元素中选取关键字最大的元素加入有序子序列</li>
<li>堆排序：每一趟将<strong>堆顶元素</strong>加入有序子序列（与待排序序列中的最后一个元素交换），并将<strong>待排序元素序列</strong>再次调整为大根堆<ul>
<li>堆排序的堆顶元素就是整个堆中最大的元素</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725192820097.png" alt="image-20230725192820097"></p>
<p><img src="/../image/assets/image-20230725193119688.png" alt="image-20230725193119688"></p>
<p><img src="/../image/assets/image-20230725193139538.png" alt="image-20230725193139538"></p>
<p><img src="/../image/assets/image-20230725193148450.png" alt="image-20230725193148450"></p>
<p><img src="/../image/assets/image-20230725193158206.png" alt="image-20230725193158206"></p>
<p><img src="/../image/assets/image-20230725193210680.png" alt="image-20230725193210680"></p>
<p><img src="/../image/assets/image-20230725193221058.png" alt="image-20230725193221058"></p>
<p><img src="/../image/assets/image-20230725193230826.png" alt="image-20230725193230826"></p>
<p><img src="/../image/assets/image-20230725193241459.png" alt="image-20230725193241459"></p>
<p><img src="/../image/assets/image-20230725193253337.png" alt="image-20230725193253337"></p>
<p><img src="/../image/assets/image-20230725193302782.png" alt="image-20230725193302782"></p>
<p><img src="/../image/assets/image-20230725193311833.png" alt="image-20230725193311833"></p>
<p><img src="/../image/assets/image-20230725193321733.png" alt="image-20230725193321733"></p>
<p><img src="/../image/assets/image-20230725193331222.png" alt="image-20230725193331222"></p>
<p><img src="/../image/assets/image-20230725193340233.png" alt="image-20230725193340233"></p>
<p><img src="/../image/assets/image-20230725193349899.png" alt="image-20230725193349899"></p>
<p><img src="/../image/assets/image-20230725193359389.png" alt="image-20230725193359389"></p>
<p><img src="/../image/assets/image-20230725193410553.png" alt="image-20230725193410553"></p>
<p><img src="/../image/assets/image-20230725193422264.png" alt="image-20230725193422264"></p>
<p><img src="/../image/assets/image-20230725193432992.png" alt="image-20230725193432992"></p>
<p><img src="/../image/assets/image-20230725193442820.png" alt="image-20230725193442820"></p>
<p><img src="/../image/assets/image-20230725193452779.png" alt="image-20230725193452779"></p>
<p><img src="/../image/assets/image-20230725193502129.png" alt="image-20230725193502129"></p>
<p><img src="/../image/assets/image-20230725193511012.png" alt="image-20230725193511012"></p>
<p><img src="/../image/assets/image-20230725193532774.png" alt="image-20230725193532774"></p>
<p><img src="/../image/assets/image-20230725193543015.png" alt="image-20230725193543015"></p>
<p><img src="/../image/assets/image-20230725193552731.png" alt="image-20230725193552731"></p>
<p><img src="/../image/assets/image-20230725193602185.png" alt="image-20230725193602185"></p>
<p><img src="/../image/assets/image-20230725193612890.png" alt="image-20230725193612890"></p>
<p><img src="/../image/assets/image-20230725193717193.png" alt="image-20230725193717193"></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/../image/assets/image-20230725193745319.png" alt="image-20230725193745319"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                            <span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])  </span><br><span class="line">            i++;                            <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;             <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                               </span><br><span class="line">            A[k] =A[i];                     <span class="comment">//将A[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                          <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];                            <span class="comment">//被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)          <span class="comment">//从后往前调整所有非终端节点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(A, len);                   <span class="comment">//初始建模</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len; i&gt;<span class="number">1</span>; i--)&#123;             <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[<span class="number">1</span>]);                   <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, <span class="number">1</span>, i<span class="number">-1</span>);              <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法效率分析-2"><a href="#算法效率分析-2" class="headerlink" title="算法效率分析"></a>算法效率分析</h4><p><img src="/../image/assets/image-20230725195011852.png" alt="image-20230725195011852"></p>
<ul>
<li><p>时间复杂度</p>
<ul>
<li><p>BuildMaxHeap(int A[], int len)</p>
<ul>
<li>一个节点，每下坠一层，最多只需对比关键字2次</li>
<li>若树高为h，某节点在第 i 层，则将这个节点向下调整最多只需要下坠 h-i 层，关键字对比次数不超过 2(h-i)</li>
<li>n个节点的完全二叉树树高 h &#x3D; [log2n] + 1</li>
<li>第 i 层最多有 2^(i-1) 个节点，而只有第 1～(h-1)层的节点才有可能需要下坠调整</li>
<li>结论：建立初始堆的过程中，关键字对比次数不超过4n，<strong>建堆时间复杂度&#x3D; O(n)</strong></li>
</ul>
</li>
<li><p>HeapSort(int A[], int len)</p>
<ul>
<li>总共需要下坠n-1层</li>
<li>每下坠一层，最多只需对比关键字2次，每一趟排序复杂度不超过 O(h) &#x3D; O(log2n)</li>
<li>结论：总的时间复杂度 &#x3D; O(nlog2n)</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序的时间复杂度 &#x3D; <em>O</em>(<em>n</em>) + <em>O</em>(<em>nlog</em>2<em>n</em>) &#x3D; <em>O</em>(<em>nlog</em>2<em>n</em>) </p>
</li>
<li><p>堆排序的空间复杂度 &#x3D; <em>O</em>(1)</p>
</li>
<li><p>稳定性：不稳定</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725194857989.png" alt="image-20230725194857989"></p>
<p>  <img src="/../image/assets/image-20230725194925131.png" alt="image-20230725194925131"></p>
<p><img src="/../image/assets/image-20230725195413220.png" alt="image-20230725195413220"></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul>
<li>对于小根堆<ul>
<li>新元素放到表尾，与父节点对比</li>
<li>若新元素比父节点<strong>更小</strong>，则将两者互换</li>
<li>新元素这样一路上升，直到无法继续上升为止</li>
</ul>
</li>
<li>对于大根堆<ul>
<li>新元素放到表尾，与父节点对比</li>
<li>若新元素比父节点<strong>更大</strong>，则将两者互换</li>
<li>新元素这样一路上升，直到无法继续上升为止</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725200533958.png" alt="image-20230725200533958"></p>
<p><img src="/../image/assets/image-20230725200823026.png" alt="image-20230725200823026"></p>
<p><img src="/../image/assets/image-20230725200832805.png" alt="image-20230725200832805"></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul>
<li>对于小根堆<ul>
<li>被删除的元素用堆底元素替代</li>
<li>比较该元素与<strong>更小的孩子节点</strong>的元素，如果<strong>大于孩子节点</strong>，让该元素不断下坠</li>
<li>直到无法下坠为止</li>
</ul>
</li>
<li>对于大根堆<ul>
<li>被删除的元素用堆底元素替代</li>
<li>比较该元素与<strong>更大的孩子节点</strong>的元素，如果<strong>小于孩子节点</strong>，让该元素下坠</li>
<li>直到无法下坠为止</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725201337325.png" alt="image-20230725201337325"></p>
<p><img src="/../image/assets/image-20230725201352015.png" alt="image-20230725201352015"></p>
<p><img src="/../image/assets/image-20230725201401545.png" alt="image-20230725201401545"></p>
<p><img src="/../image/assets/image-20230725201320610.png" alt="image-20230725201320610"></p>
<p><img src="/../image/assets/image-20230725201416696.png" alt="image-20230725201416696"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>归并：把两个或多个已经有序的序列合并为一个</li>
</ul>
<h4 id="二路归并"><a href="#二路归并" class="headerlink" title="二路归并"></a>二路归并</h4><ul>
<li><p><strong>对比 i 、j 所指元素，选择更小的一个放入 k 所指位置</strong></p>
</li>
<li><p>当一个有序序列已经放完之后，另一个有序序列剩下的值可以依次放入合并序列</p>
</li>
<li><p>2个有序序列合并成一个</p>
</li>
<li><p>每选出一个小元素需要对比关键字1次</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725203021969.png" alt="image-20230725203021969"></p>
<ul>
<li>二路归并操作</li>
</ul>
<p><img src="/../image/assets/image-20230725202651174.png" alt="image-20230725202651174"></p>
<p><img src="/../image/assets/image-20230725203038524.png" alt="image-20230725203038524"></p>
<p><img src="/../image/assets/image-20230725203047872.png" alt="image-20230725203047872"></p>
<p><img src="/../image/assets/image-20230725203059487.png" alt="image-20230725203059487"></p>
<p><img src="/../image/assets/image-20230725203109773.png" alt="image-20230725203109773"></p>
<p><img src="/../image/assets/image-20230725203119949.png" alt="image-20230725203119949"></p>
<p><img src="/../image/assets/image-20230725203130240.png" alt="image-20230725203130240"></p>
<p><img src="/../image/assets/image-20230725203140609.png" alt="image-20230725203140609"></p>
<p><img src="/../image/assets/image-20230725203152316.png" alt="image-20230725203152316"></p>
<p><img src="/../image/assets/image-20230725203207077.png" alt="image-20230725203207077"></p>
<p><img src="/../image/assets/image-20230725203219245.png" alt="image-20230725203219245"></p>
<h4 id="4路归并"><a href="#4路归并" class="headerlink" title="4路归并"></a>4路归并</h4><ul>
<li><p>4个有序序列合并成一个</p>
</li>
<li><p>每选出一个小元素需要对比关键字3次</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725203402908.png" alt="image-20230725203402908"></p>
<h4 id="m路归并"><a href="#m路归并" class="headerlink" title="m路归并"></a>m路归并</h4><ul>
<li><p>M个有序序列合并成一个</p>
</li>
<li><p>每选出一个小元素需要对比关键字m -1次</p>
</li>
</ul>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li>内部排序中一般采用2路归并</li>
</ul>
<p><img src="/../image/assets/image-20230725203421526.png" alt="image-20230725203421526"></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="一次归并"><a href="#一次归并" class="headerlink" title="一次归并"></a>一次归并</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> *B = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k&lt;=high; k++)</span><br><span class="line">        B[k]=A[k];                          <span class="comment">//将A中所有的元素复制到B中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) A[k]=B[i++];         <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span> A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../image/assets/image-20230725204009409.png" alt="image-20230725204009409"></p>
<p><img src="/../image/assets/image-20230725204827555.png" alt="image-20230725204827555"></p>
<p><img src="/../image/assets/image-20230725204838432.png" alt="image-20230725204838432"></p>
<p><img src="/../image/assets/image-20230725204849672.png" alt="image-20230725204849672"></p>
<p><img src="/../image/assets/image-20230725204859933.png" alt="image-20230725204859933"></p>
<p><img src="/../image/assets/image-20230725204915610.png" alt="image-20230725204915610"></p>
<p><img src="/../image/assets/image-20230725204926506.png" alt="image-20230725204926506"></p>
<p><img src="/../image/assets/image-20230725204937719.png" alt="image-20230725204937719"></p>
<p><img src="/../image/assets/image-20230725204947549.png" alt="image-20230725204947549"></p>
<p><img src="/../image/assets/image-20230725205003729.png" alt="image-20230725205003729"></p>
<p><img src="/../image/assets/image-20230725205017025.png" alt="image-20230725205017025"></p>
<p><img src="/../image/assets/image-20230725205033397.png" alt="image-20230725205033397"></p>
<p><img src="/../image/assets/image-20230725205043997.png" alt="image-20230725205043997"></p>
<p><img src="/../image/assets/image-20230725205055844.png" alt="image-20230725205055844"></p>
<p><img src="/../image/assets/image-20230725205114216.png" alt="image-20230725205114216"></p>
<h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li><p>将一个序列从中间分成两个子序列</p>
</li>
<li><p>将左右两个子序列分别进行归并排序得到两个有序子序列</p>
</li>
<li><p>然后两个子序列进行归并</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> *B = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k&lt;=high; k++)</span><br><span class="line">        B[k]=A[k];                          <span class="comment">//将A中所有的元素复制到B中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) A[k]=B[i++];         <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span> A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;           <span class="comment">//从中间划分</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A,low,mid);               <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A,mid+<span class="number">1</span>,high);            <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(A,low,mid,high);              <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../image/assets/image-20230725205700754.png" alt="image-20230725205700754"></p>
<h3 id="算法效率分析-3"><a href="#算法效率分析-3" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul>
<li><strong>时间复杂度：归并排序——O(nlog2n)     每趟归并——O(n)    归并次数——O(log2n)</strong><ul>
<li>2路归并到归并树——形态上就是一棵倒立的二叉树<ul>
<li>二叉树的第h层最多有2^(h-1)个节点</li>
<li>若树高为h，则应满足 n&lt;&#x3D;2^(h-1)</li>
<li>即 h-1 &#x3D; log2n</li>
</ul>
</li>
<li>结论：n个元素进行二路归并排序，归并的趟数log2n，每趟归并时间复杂度O(n)，算法时间复杂度O(n*log2n)</li>
</ul>
</li>
<li><strong>空间复杂度 &#x3D; O(n)，辅助数组B</strong></li>
<li>稳定性：稳定的</li>
</ul>
<p><img src="/../image/assets/image-20230725205921824.png" alt="image-20230725205921824"></p>
<h2 id="基数排序（Radix-Sort）（手算）"><a href="#基数排序（Radix-Sort）（手算）" class="headerlink" title="基数排序（Radix Sort）（手算）"></a>基数排序（Radix Sort）（手算）</h2><ul>
<li>不是基于比较的排序算法</li>
<li>通常基于链式存储实现</li>
</ul>
<p><img src="/../image/assets/image-20230725214935131.png" alt="image-20230725214935131"></p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li><p>从<strong>个位</strong>开始进行<strong>分配入队</strong>（队列先进先出），直到最大数字的最高位</p>
</li>
<li><p>每次分配完都进行一次收集，按照从9~0的顺序，下一次分配也按照上一次收集的顺序进行分配</p>
</li>
<li><p>例子</p>
<ul>
<li><p>第一趟</p>
<ul>
<li>按个位进行分配，<strong>先分配的先入队</strong></li>
<li>收集结束：得到按<strong>个位递减</strong>排序的序列</li>
</ul>
</li>
<li><p>第二趟</p>
<ul>
<li>将第一趟收集得到的序列，按十位进行分配，<strong>个位越大的越先入队</strong></li>
<li>收集结束：得到按<strong>十位递减</strong>排序的序列，<strong>十位相同的按照个位递减</strong>排序</li>
</ul>
</li>
<li><p>第三趟</p>
<ul>
<li>将第二趟收集得到的序列，按百位进行分配，<strong>十位越大的越先入队</strong></li>
<li>收集结束：得到按<strong>百位递减</strong>排序的序列，百位相同的按照十位递减排序，十位相同的按照个位递减排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725212520973.png" alt="image-20230725212520973"></p>
<ul>
<li><p>文字描述</p>
<ul>
<li><p>假设⻓度为n的线性表中每个结点<em>a**j</em>的关键字由<em>d</em>元组 (<em>kjd</em>−1, <em>kjd</em>−2, <em>kjd</em>−3, . . . , <em>kj</em>1, <em>kj</em>0) 组成</p>
<p>其中，0≤kij ≤ r - 1（0≤j＜n, 0≤i≤d - 1），r 称为“基数”（0～9，r&#x3D;10）</p>
<ul>
<li>例如：985 由 (9,8,5) 组成<ul>
<li>最高位关键字（最主位关键字）：9</li>
<li>最低位关键字（最次位关键字）：5</li>
</ul>
</li>
</ul>
</li>
<li><p>基数排序得到递减序列的过程如下</p>
<ul>
<li>初始化： 设置 <strong>r 个空队列</strong>，Qr-1, Qr-2,…, Q0 </li>
<li>按照各个 <strong>关键字位</strong> <strong>权重递增</strong>的次序（个、⼗、百），对 d 个关键字位分别做“分配”和“收集”</li>
<li>分配：顺序扫描各个元素，若当前处理的关键字位&#x3D;x，则将元素插⼊ Qx 队尾</li>
<li>收集：把 Qr-1, Qr-2,…, Q0 各个队列中的结点依次出队并链接</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725213040387.png" alt="image-20230725213040387"></p>
<ul>
<li>第一趟 分配+收集</li>
</ul>
<p><img src="/../image/assets/image-20230725210817695.png" alt="image-20230725210817695"></p>
<p><img src="/../image/assets/image-20230725210828667.png" alt="image-20230725210828667"></p>
<p><img src="/../image/assets/image-20230725210844009.png" alt="image-20230725210844009"></p>
<p><img src="/../image/assets/image-20230725211001130.png" alt="image-20230725211001130"></p>
<p><img src="/../image/assets/image-20230725210940638.png" alt="image-20230725210940638"></p>
<ul>
<li>第二趟</li>
</ul>
<p><img src="/../image/assets/image-20230725211633444.png" alt="image-20230725211633444"></p>
<p><img src="/../image/assets/image-20230725211905553.png" alt="image-20230725211905553"></p>
<p><img src="/../image/assets/image-20230725211919446.png" alt="image-20230725211919446"></p>
<p><img src="/../image/assets/image-20230725211931366.png" alt="image-20230725211931366"></p>
<p><img src="/../image/assets/image-20230725211949903.png" alt="image-20230725211949903"></p>
<ul>
<li>第三趟</li>
</ul>
<p><img src="/../image/assets/image-20230725212348607.png" alt="image-20230725212348607"></p>
<p><img src="/../image/assets/image-20230725212406668.png" alt="image-20230725212406668"></p>
<p><img src="/../image/assets/image-20230725212420245.png" alt="image-20230725212420245"></p>
<p><img src="/../image/assets/image-20230725212430973.png" alt="image-20230725212430973"></p>
<p><img src="/../image/assets/image-20230725212450165.png" alt="image-20230725212450165"></p>
<h3 id="算法效率分析-4"><a href="#算法效率分析-4" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elemtype int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li>基数排序通常基于链式存储实现</li>
<li>空间复杂度 &#x3D; O(r)：需要 r 个辅助队列</li>
<li>时间复杂度 &#x3D; O(d*(n+r))：一趟分配O(n)，一趟收集O(r)，总共d趟分配收集</li>
<li>稳定性：稳定的</li>
</ul>
<p><img src="/../image/assets/image-20230725213852693.png" alt="image-20230725213852693"></p>
<ul>
<li>收集一个队列只需要O(1)</li>
</ul>
<p><img src="/../image/assets/image-20230725214449076.png" alt="image-20230725214449076"></p>
<p><img src="/../image/assets/image-20230725214510767.png" alt="image-20230725214510767"></p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p><img src="/../image/assets/image-20230725214715643.png" alt="image-20230725214715643"></p>
<h4 id="适合解决的问题"><a href="#适合解决的问题" class="headerlink" title="适合解决的问题"></a>适合解决的问题</h4><ul>
<li>数据元素的关键字可以方便的拆分为 d 组，且d较小</li>
<li>每组关键字的取值范围不大，即 r 较小</li>
<li>数据元素个数 n 较大</li>
</ul>
<p><img src="/../image/assets/image-20230725214834606.png" alt="image-20230725214834606"></p>
<h4 id="不适合解决的问题"><a href="#不适合解决的问题" class="headerlink" title="不适合解决的问题"></a>不适合解决的问题</h4><p><img src="/../image/assets/image-20230725215006532.png" alt="image-20230725215006532"></p>
<h2 id="外部排序-1"><a href="#外部排序-1" class="headerlink" title="外部排序"></a>外部排序</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="外存与内存之间的数据交换"><a href="#外存与内存之间的数据交换" class="headerlink" title="外存与内存之间的数据交换"></a>外存与内存之间的数据交换</h4><ul>
<li>外存：磁盘</li>
<li>内存</li>
<li>操作系统以“块”为单位对磁盘存储空间进行管理，如：每块大小1KB；各个磁盘块内存放着各种各样的数据</li>
<li>磁盘的读&#x2F;写以“块”为单位，数据读入内存后才能被修改，修改完了还要写回磁盘</li>
</ul>
<p><img src="/../image/assets/image-20230725215415099.png" alt="image-20230725215415099"></p>
<p><img src="/../image/assets/image-20230725220134285.png" alt="image-20230725220134285"></p>
<p><img src="/../image/assets/image-20230725220151257.png" alt="image-20230725220151257"></p>
<p><img src="/../image/assets/image-20230725220446105.png" alt="image-20230725220446105"></p>
<h4 id="外部排序的原理"><a href="#外部排序的原理" class="headerlink" title="外部排序的原理"></a>外部排序的原理</h4><ul>
<li>原因：数据元素太多，无法一次全部读入内存进行排序</li>
<li>使用<strong>归并排序</strong>的方法，最少只需要在内存中分配 3 块大小的缓冲区即可对任意一个大文件进行排序<ul>
<li>先将两个块的数据传入内存的输入缓冲区1，2</li>
<li>对输入缓冲区1，2的数据进行归并排序，得到有序序列</li>
<li>将输入缓冲区去1，2的数据依次放入输出缓冲区，写回磁盘块</li>
<li>得到一个有序的“<strong>归并段</strong>”（两个磁盘块组成的有序序列）</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725220216598.png" alt="image-20230725220216598"></p>
<h5 id="构造初始归并段"><a href="#构造初始归并段" class="headerlink" title="构造初始归并段"></a>构造初始归并段</h5><ul>
<li>读入到输入缓冲区</li>
</ul>
<p><img src="/../image/assets/image-20230725220526055.png" alt="image-20230725220526055"></p>
<ul>
<li>归并排序</li>
</ul>
<p><img src="/../image/assets/image-20230725220545500.png" alt="image-20230725220545500"></p>
<ul>
<li>写入磁盘</li>
</ul>
<p><img src="/../image/assets/image-20230725220848703.png" alt="image-20230725220848703"></p>
<p><img src="/../image/assets/image-20230725220900378.png" alt="image-20230725220900378"></p>
<ul>
<li>得到有序的归并段</li>
</ul>
<p><img src="/../image/assets/image-20230725220924221.png" alt="image-20230725220924221"></p>
<p><img src="/../image/assets/image-20230725220953274.png" alt="image-20230725220953274"></p>
<h5 id="第一趟归并"><a href="#第一趟归并" class="headerlink" title="第一趟归并"></a>第一趟归并</h5><ul>
<li>把8个有序子序列（初始归并段）两两归并<ul>
<li>将归并好的元素放到输出缓冲区</li>
<li>当输出缓冲区满的时候，写回磁盘块中</li>
<li>缓冲区1 空了就要<strong>⽴即</strong>⽤归并段1 的下⼀块补上</li>
<li>缓冲区2 空了就要<strong>⽴即</strong>⽤归并段2 的下⼀块补上<ul>
<li>如果空了，必须要先补上才能进行下一次归并</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725221326699.png" alt="image-20230725221326699"></p>
<ul>
<li>读入归并段1的第一块 和 归并段2的第一块</li>
</ul>
<p><img src="/../image/assets/image-20230725221426212.png" alt="image-20230725221426212"></p>
<ul>
<li>进行归并排序</li>
</ul>
<p><img src="/../image/assets/image-20230725221505754.png" alt="image-20230725221505754"></p>
<p><img src="/../image/assets/image-20230725221532802.png" alt="image-20230725221532802"></p>
<p><img src="/../image/assets/image-20230725221544580.png" alt="image-20230725221544580"></p>
<ul>
<li>输出缓冲区满，写回磁盘块</li>
</ul>
<p><img src="/../image/assets/image-20230725221558304.png" alt="image-20230725221558304"></p>
<p><img src="/../image/assets/image-20230725221717104.png" alt="image-20230725221717104"></p>
<ul>
<li>输入缓冲区1空了要立即用归并段1的下一块补上</li>
</ul>
<p><img src="/../image/assets/image-20230725221805157.png" alt="image-20230725221805157"></p>
<p><img src="/../image/assets/image-20230725221852638.png" alt="image-20230725221852638"></p>
<p><img src="/../image/assets/image-20230725221903474.png" alt="image-20230725221903474"></p>
<ul>
<li>缓冲区2空了就要立即用归并段2的下一块补上</li>
</ul>
<p><img src="/../image/assets/image-20230725221915227.png" alt="image-20230725221915227"></p>
<p><img src="/../image/assets/image-20230725221927162.png" alt="image-20230725221927162"></p>
<p><img src="/../image/assets/image-20230725221946571.png" alt="image-20230725221946571"></p>
<p><img src="/../image/assets/image-20230725221956549.png" alt="image-20230725221956549"></p>
<p><img src="/../image/assets/image-20230725222007523.png" alt="image-20230725222007523"></p>
<p><img src="/../image/assets/image-20230725222017595.png" alt="image-20230725222017595"></p>
<ul>
<li>结束</li>
</ul>
<p><img src="/../image/assets/image-20230725222035954.png" alt="image-20230725222035954"></p>
<p><img src="/../image/assets/image-20230725222317107.png" alt="image-20230725222317107"></p>
<h5 id="第二趟归并"><a href="#第二趟归并" class="headerlink" title="第二趟归并"></a>第二趟归并</h5><ul>
<li>与第一趟相同</li>
</ul>
<p><img src="/../image/assets/image-20230725222526263.png" alt="image-20230725222526263"></p>
<p><img src="/../image/assets/image-20230725222630409.png" alt="image-20230725222630409"></p>
<p><img src="/../image/assets/image-20230725222558152.png" alt="image-20230725222558152"></p>
<p><img src="/../image/assets/image-20230725222736300.png" alt="image-20230725222736300"></p>
<p><img src="/../image/assets/image-20230725222748185.png" alt="image-20230725222748185"></p>
<h5 id="第三趟归并"><a href="#第三趟归并" class="headerlink" title="第三趟归并"></a>第三趟归并</h5><p><img src="/../image/assets/image-20230725222836718.png" alt="image-20230725222836718"></p>
<p><img src="/../image/assets/image-20230725222847815.png" alt="image-20230725222847815"></p>
<h4 id="时间开销分析"><a href="#时间开销分析" class="headerlink" title="时间开销分析"></a>时间开销分析</h4><ul>
<li>外部排序时间开销 &#x3D; 读写外存的时间 + 内部排序所需时间 + 内部归并所需时间</li>
</ul>
<p><img src="/../image/assets/image-20230725223001449.png" alt="image-20230725223001449"></p>
<h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h5 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h5><ul>
<li><p>优点</p>
<ul>
<li><p>可以减少归并趟数，从而减少磁盘I&#x2F;O（读写）次数</p>
<ul>
<li><p>对 r 个初始归并段，做k路归并，则归并树可⽤ <strong>k</strong> 叉树表示，若树⾼为h，则归并趟数 <strong>&#x3D; h-1 &#x3D;</strong> ⌈logkr⌉</p>
</li>
<li><p>k越⼤，r越⼩，归并趟数越少，读写磁盘次数越少</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><p>k路归并时，需要开辟k个缓冲区，内存开销增加</p>
</li>
<li><p>每挑选一个关键字需要对比关键字（k-1）次，内部归并所需时间增加</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230725223809286.png" alt="image-20230725223809286"></p>
<p><img src="/../image/assets/image-20230725223208211.png" alt="image-20230725223208211"></p>
<p><img src="/../image/assets/image-20230725223256627.png" alt="image-20230725223256627"></p>
<h5 id="减少初始归并段数量"><a href="#减少初始归并段数量" class="headerlink" title="减少初始归并段数量"></a>减少初始归并段数量</h5><ul>
<li>对r个初始归并段，做k路归并，则归并树可用k叉树表示</li>
<li>树高为h，则归并趟数 &#x3D; h-1 &#x3D; [logkr]<ul>
<li>k越大，r越小，归并趟数越少，读写磁盘次数越少</li>
</ul>
</li>
<li>结论：若能增加初始归并段的长度，则可减少初始归并段数量r</li>
</ul>
<p><img src="/../image/assets/image-20230725224140759.png" alt="image-20230725224140759"></p>
<p><img src="/../image/assets/image-20230725224049117.png" alt="image-20230725224049117"></p>
<p><img src="/../image/assets/image-20230725224104863.png" alt="image-20230725224104863"></p>
<p><img src="/../image/assets/image-20230725224115937.png" alt="image-20230725224115937"></p>
<p><img src="/../image/assets/image-20230725224126575.png" alt="image-20230725224126575"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/../image/assets/image-20230725224424029.png" alt="image-20230725224424029"></p>
<h4 id="纠正：多路平衡归并"><a href="#纠正：多路平衡归并" class="headerlink" title="纠正：多路平衡归并"></a>纠正：多路平衡归并</h4><ul>
<li>k路平衡归并<ul>
<li>最多只能有k个段归并为一个</li>
<li>每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到[m&#x2F;k]个新的归并段</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725224535205.png" alt="image-20230725224535205"></p>
<h5 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h5><p><img src="/../image/assets/image-20230725224742543.png" alt="image-20230725224742543"></p>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><h4 id="多路平衡归并带来的问题"><a href="#多路平衡归并带来的问题" class="headerlink" title="多路平衡归并带来的问题"></a>多路平衡归并带来的问题</h4><ul>
<li>使用k路平衡归并策略，选出一个最小元素需要对比关键字（k-1）次，导致内部归并所需时间增加</li>
</ul>
<p><img src="/../image/assets/image-20230725224915899.png" alt="image-20230725224915899"></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p>通俗定义</p>
<ul>
<li><p>失败者留在这一回合，胜利者进入下一回合比拼</p>
</li>
<li><p>最后只有一个冠军在所有比拼中获胜</p>
<ul>
<li>若有8位参赛者，则构造败者树需要7次比拼</li>
</ul>
</li>
</ul>
</li>
<li><p>败者树——可视为⼀棵完全⼆叉树（多了⼀个头头）。</p>
<ul>
<li><em>k</em>个叶结点分别是当前参加⽐较的元素</li>
<li>⾮叶⼦结点⽤来记忆左右⼦树中的“失败者”</li>
<li>⽽胜者往上继续进⾏⽐较，⼀直到根结点。</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230725225342850.png" alt="image-20230725225342850"></p>
<h4 id="败者树的使用"><a href="#败者树的使用" class="headerlink" title="败者树的使用"></a>败者树的使用</h4><ul>
<li>基于已经构建好的败者树，选出新的胜者只需进行3场比赛</li>
</ul>
<p><img src="/../image/assets/image-20230725225554880.png" alt="image-20230725225554880"></p>
<p><img src="/../image/assets/image-20230725225605389.png" alt="image-20230725225605389"></p>
<p><img src="/../image/assets/image-20230725225615486.png" alt="image-20230725225615486"></p>
<p><img src="/../image/assets/image-20230725225626003.png" alt="image-20230725225626003"></p>
<h4 id="败者树在多路平衡归并中的应用"><a href="#败者树在多路平衡归并中的应用" class="headerlink" title="败者树在多路平衡归并中的应用"></a>败者树在多路平衡归并中的应用</h4><ul>
<li><p>构成</p>
<ul>
<li><p>每个叶子节点对应一个归并段</p>
</li>
<li><p>分支节点记录失败败者来自哪个归并段</p>
</li>
<li><p>根节点记录冠军来自哪个归并段</p>
</li>
</ul>
</li>
<li><p>操作</p>
<ul>
<li><p>k路归并，第一次构造败者树需要对比关键字k-1次</p>
</li>
<li><p>有了败者树，选出最小元素，只需对比关键字[log2k]（向上取整）次</p>
</li>
</ul>
</li>
<li><p>第一次构造败者树</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230726142220567.png" alt="image-20230726142220567"></p>
<p><img src="/../image/assets/image-20230726142241497.png" alt="image-20230726142241497"></p>
<p><img src="/../image/assets/image-20230726142253675.png" alt="image-20230726142253675"></p>
<ul>
<li>选出第二个元素</li>
</ul>
<p><img src="/../image/assets/image-20230726142700556.png" alt="image-20230726142700556"></p>
<p><img src="/../image/assets/image-20230726142712402.png" alt="image-20230726142712402"></p>
<p><img src="/../image/assets/image-20230726142742972.png" alt="image-20230726142742972"></p>
<p><img src="/../image/assets/image-20230726143016081.png" alt="image-20230726143016081"></p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul>
<li>k路归并的败者树只需要定义一个长度为k的数组即可</li>
<li>数组中的数据<ul>
<li>Ls[0]代表胜者</li>
<li>Ls[1…k-1]代表失败者</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230726143314546.png" alt="image-20230726143314546"></p>
<p><img src="/../image/assets/image-20230726143325058.png" alt="image-20230726143325058"></p>
<h3 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h3><h4 id="土方法构造初始归并段"><a href="#土方法构造初始归并段" class="headerlink" title="土方法构造初始归并段"></a>土方法构造初始归并段</h4><ul>
<li>可以用一片更大的内存区域来进行内部排序<ul>
<li>如：可容纳18个记录</li>
<li>每个“初始归并段”可包含18个记录</li>
</ul>
</li>
<li>用于内部排序的内存工作区WA可容纳 l 个记录，则每个初始归并段也只能包含 l 个记录，若文件共有 n 个记录，则初始归并段的数量 r &#x3D; n &#x2F; l</li>
</ul>
<p><img src="/../image/assets/image-20230726143821823.png" alt="image-20230726143821823"></p>
<h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><ul>
<li><p>使⽤<strong>置换-选择</strong>排序，可以让每个初始归并段的⻓度超越内存⼯作区⼤⼩的限制</p>
</li>
<li><p>实现过程</p>
<ul>
<li><p>初始化归并段输出文件FO</p>
</li>
<li><p>将初始待排序文件 FI 输入到内存工作区 WA 中，将其填满</p>
</li>
<li><p>置换</p>
<ul>
<li>把内存工作区中最小的元素置换出去，并且记录这一最小元素 MINIMAX</li>
<li>如果后来输入的元素比 MINIMAX 小，则将其进行标记，不输出；而是选择比 MINIMAX 大的最小值进行输出</li>
<li>当被标记的元素满的时候（内存工作区中所有元素都小于 MINIMAX），将之前的输出元素作为一个归并段</li>
<li>选择一个新的归并段</li>
</ul>
</li>
<li><p>重复置换直到待排序文件为空</p>
</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230726145427072.png" alt="image-20230726145427072"></p>
<ul>
<li>初始化</li>
</ul>
<p><img src="/../image/assets/image-20230726144452814.png" alt="image-20230726144452814"></p>
<ul>
<li>第一趟置换</li>
</ul>
<p><img src="/../image/assets/image-20230726144508572.png" alt="image-20230726144508572"></p>
<p><img src="/../image/assets/image-20230726144520465.png" alt="image-20230726144520465"></p>
<p><img src="/../image/assets/image-20230726144539913.png" alt="image-20230726144539913"></p>
<p><img src="/../image/assets/image-20230726144552112.png" alt="image-20230726144552112"></p>
<p><img src="/../image/assets/image-20230726144605976.png" alt="image-20230726144605976"></p>
<p><img src="/../image/assets/image-20230726144617031.png" alt="image-20230726144617031"></p>
<p><img src="/../image/assets/image-20230726144633311.png" alt="image-20230726144633311"></p>
<ul>
<li>第二趟置换</li>
</ul>
<p><img src="/../image/assets/image-20230726145142679.png" alt="image-20230726145142679"></p>
<p><img src="/../image/assets/image-20230726145159914.png" alt="image-20230726145159914"></p>
<ul>
<li>第三趟置换</li>
</ul>
<p><img src="/../image/assets/image-20230726145214685.png" alt="image-20230726145214685"></p>
<p><img src="/../image/assets/image-20230726145228519.png" alt="image-20230726145228519"></p>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><h4 id="归并树的性质"><a href="#归并树的性质" class="headerlink" title="归并树的性质"></a>归并树的性质</h4><ul>
<li>每个初始归并段看作一个叶子节点，归并段的长度作为节点权值，则<ul>
<li><strong>归并树的带权路径长度 WPL &#x3D; 读磁盘的次数 &#x3D; 写磁盘的次数</strong></li>
</ul>
</li>
<li>结论：归并过程中的磁盘 I&#x2F;O 次数 &#x3D; 归并树的WPL * 2</li>
<li>要让磁盘 I&#x2F;O 次数最少，就要使归并树 WPL 最小 —— 哈夫曼树</li>
</ul>
<p><img src="/../image/assets/image-20230726145934146.png" alt="image-20230726145934146"></p>
<h4 id="构造二路归并的最佳归并树"><a href="#构造二路归并的最佳归并树" class="headerlink" title="构造二路归并的最佳归并树"></a>构造二路归并的最佳归并树</h4><p><img src="/../image/assets/image-20230726150334074.png" alt="image-20230726150334074"></p>
<h4 id="多路归并的最佳归并树"><a href="#多路归并的最佳归并树" class="headerlink" title="多路归并的最佳归并树"></a>多路归并的最佳归并树</h4><ul>
<li><p>只有<strong>叶子节点要 乘以 权值进行相加</strong></p>
</li>
<li><p>一般情况</p>
</li>
</ul>
<p><img src="/../image/assets/image-20230726150853636.png" alt="image-20230726150853636"></p>
<ul>
<li>最佳归并树</li>
</ul>
<p><img src="/../image/assets/image-20230726151115096.png" alt="image-20230726151115096"></p>
<h4 id="如果减少一个归并段，利用上述规则，无法得到最佳归并树"><a href="#如果减少一个归并段，利用上述规则，无法得到最佳归并树" class="headerlink" title="如果减少一个归并段，利用上述规则，无法得到最佳归并树"></a>如果减少一个归并段，利用上述规则，无法得到最佳归并树</h4><p><img src="/../image/assets/image-20230726151155031.png" alt="image-20230726151155031"></p>
<ul>
<li>正确做法<ul>
<li>对于 k 叉归并，若初始归并段的数量无法满足构成严格的 k 叉归并树，则需要补充几个长度为 0 的“虚段”，再进行 k 叉哈夫曼树的构造</li>
<li>长度为 0 的虚段：在输入缓冲区什么都不用放</li>
</ul>
</li>
</ul>
<p><img src="/../image/assets/image-20230726151253362.png" alt="image-20230726151253362"></p>
<p><img src="/../image/assets/image-20230726151446916.png" alt="image-20230726151446916"></p>
<h4 id="添加虚段的数量（k-1-u）"><a href="#添加虚段的数量（k-1-u）" class="headerlink" title="添加虚段的数量（k - 1 - u）"></a>添加虚段的数量（k - 1 - u）</h4><ul>
<li>对于 k  叉归并，若初始归并段的数量无法构成严格的 k 叉归并树，则需要补充几个长度为 0的虚段，再进行 k 叉哈夫曼树的构造</li>
<li>k 叉的最佳归并树一定是一棵严格的 k 叉树，即树中只包含度为 k、度为 0的节点<ul>
<li>设度为 k的节点有nk个，度为0的节点有 n0个，归并树的总节点数&#x3D;n</li>
<li>初始归并段数量 + 虚段数量 &#x3D; n0</li>
<li>n &#x3D; n0 + nk</li>
<li>k * nk &#x3D; n - 1</li>
<li>得到：n0 &#x3D; (k-1) * nk + 1</li>
<li>结论：**nk &#x3D; (n0 - 1)&#x2F;(k - 1)**（如果是严格k叉树，一定能除得尽（所有的数都是整数））</li>
</ul>
</li>
<li><strong>若（初始归并段数量 - 1）% （k - 1）&#x3D; 0；说明刚好可以构成严格 k 叉树，此时不需要添加虚段</strong></li>
<li><strong>若（初始归并段数量 - 1）% （k - 1）&#x3D; u !&#x3D; 0；则需要补充（k - 1）- u 个虚段</strong></li>
</ul>
<p><img src="/../image/assets/image-20230726151816101.png" alt="image-20230726151816101"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-基于小根堆如何建堆、排序"><a href="#1-基于小根堆如何建堆、排序" class="headerlink" title="1. 基于小根堆如何建堆、排序"></a>1. 基于小根堆如何建堆、排序</h3><p><img src="/../image/assets/image-20230725195756007.png" alt="image-20230725195756007"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sdumoist.github.io">SDUMoist</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sdumoist.github.io/2023/07/24/%E6%8E%92%E5%BA%8F/">https://sdumoist.github.io/2023/07/24/%E6%8E%92%E5%BA%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sdumoist.github.io" target="_blank">Moist</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a></div><div class="post_share"><div class="social-share" data-image="/img/background/7.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="计算机系统概述"><img class="cover" src="/img/background/24.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机系统概述</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/20/%E6%9F%A5%E6%89%BE/" title="查找"><img class="cover" src="/img/background/11.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">查找</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SDUMoist</div><div class="author-info__description">一个会点拍照，会点写作，会点生活的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sdumoist"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/sdumoist" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/2076520410@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">考点总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">知识总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">1.3.3.</span> <span class="toc-text">评价指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">内部排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">外部排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%B8%A6%E5%93%A8%E5%85%B5%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">算法实现（带哨兵）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">1.4.4.</span> <span class="toc-text">算法效率分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%EF%BC%88%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">算法优化（折半查找）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">效率分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E4%B8%8D%E7%9B%B8%E7%AD%89"><span class="toc-number">1.4.5.3.1.</span> <span class="toc-text">元素不相等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89"><span class="toc-number">1.4.5.3.2.</span> <span class="toc-text">元素相等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%9C%80%E5%A4%A7"><span class="toc-number">1.4.5.3.3.</span> <span class="toc-text">元素最大</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%9C%80%E5%B0%8F"><span class="toc-number">1.4.5.3.4.</span> <span class="toc-text">元素最小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.6.</span> <span class="toc-text">对链表进行插入排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%901"><span class="toc-number">1.5.2.</span> <span class="toc-text">例子1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%902"><span class="toc-number">1.5.3.</span> <span class="toc-text">例子2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B02"><span class="toc-number">1.5.5.</span> <span class="toc-text">算法实现2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.5.6.</span> <span class="toc-text">算法性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-1"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">算法性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-3"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%9C%80%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">代码实现（最重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-1"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">算法效率分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%B6%9F%E6%8E%92%E5%BA%8F-%E4%B8%80%E6%AC%A1%E5%88%92%E5%88%86"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">一趟排序 !&#x3D; 一次划分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">简单选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-4"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-2"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">算法性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">堆排序（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86-heap-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">堆(heap):顺序存储的完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.7.2.1.1.</span> <span class="toc-text">二叉树的顺序存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">构建操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.7.2.2.1.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-VS-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.2.2.2.</span> <span class="toc-text">简单选择排序 VS 堆排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%80%9D%E8%B7%AF"><span class="toc-number">1.7.2.2.3.</span> <span class="toc-text">构建思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.2.4.</span> <span class="toc-text">构建的代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A0%B9%E5%A0%86%EF%BC%89"><span class="toc-number">1.7.2.2.5.</span> <span class="toc-text">排序操作（基于大根堆）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-2"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">算法效率分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.2.6.</span> <span class="toc-text">删除操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.8.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">二路归并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E8%B7%AF%E5%BD%92%E5%B9%B6"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">4路归并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#m%E8%B7%AF%E5%BD%92%E5%B9%B6"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">m路归并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.8.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.8.3.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E5%BD%92%E5%B9%B6"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">一次归并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">归并排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-3"><span class="toc-number">1.8.4.</span> <span class="toc-text">算法效率分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89%EF%BC%88%E6%89%8B%E7%AE%97%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">基数排序（Radix Sort）（手算）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">1.9.1.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-4"><span class="toc-number">1.9.2.</span> <span class="toc-text">算法效率分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">1.9.3.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E5%90%88%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">适合解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">不适合解决的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.10.</span> <span class="toc-text">外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">1.10.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">外存与内存之间的数据交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">外部排序的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%88%9D%E5%A7%8B%E5%BD%92%E5%B9%B6%E6%AE%B5"><span class="toc-number">1.10.1.2.1.</span> <span class="toc-text">构造初始归并段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%B6%9F%E5%BD%92%E5%B9%B6"><span class="toc-number">1.10.1.2.2.</span> <span class="toc-text">第一趟归并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%B6%9F%E5%BD%92%E5%B9%B6"><span class="toc-number">1.10.1.2.3.</span> <span class="toc-text">第二趟归并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%B6%9F%E5%BD%92%E5%B9%B6"><span class="toc-number">1.10.1.2.4.</span> <span class="toc-text">第三趟归并</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BC%80%E9%94%80%E5%88%86%E6%9E%90"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">时间开销分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">优化思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6"><span class="toc-number">1.10.1.4.1.</span> <span class="toc-text">多路归并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%88%9D%E5%A7%8B%E5%BD%92%E5%B9%B6%E6%AE%B5%E6%95%B0%E9%87%8F"><span class="toc-number">1.10.1.4.2.</span> <span class="toc-text">减少初始归并段数量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A0%E6%AD%A3%EF%BC%9A%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E5%BD%92%E5%B9%B6"><span class="toc-number">1.10.1.6.</span> <span class="toc-text">纠正：多路平衡归并</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E4%BE%8B"><span class="toc-number">1.10.1.6.1.</span> <span class="toc-text">反例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91"><span class="toc-number">1.10.2.</span> <span class="toc-text">败者树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E5%BD%92%E5%B9%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">多路平衡归并带来的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">败者树的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91%E5%9C%A8%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E5%BD%92%E5%B9%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">败者树在多路平衡归并中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.10.2.5.</span> <span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.10.3.</span> <span class="toc-text">置换选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%9F%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%88%9D%E5%A7%8B%E5%BD%92%E5%B9%B6%E6%AE%B5"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">土方法构造初始归并段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">算法实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">1.10.4.</span> <span class="toc-text">最佳归并树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">归并树的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">构造二路归并的最佳归并树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">多路归并的最佳归并树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%87%8F%E5%B0%91%E4%B8%80%E4%B8%AA%E5%BD%92%E5%B9%B6%E6%AE%B5%EF%BC%8C%E5%88%A9%E7%94%A8%E4%B8%8A%E8%BF%B0%E8%A7%84%E5%88%99%EF%BC%8C%E6%97%A0%E6%B3%95%E5%BE%97%E5%88%B0%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">1.10.4.4.</span> <span class="toc-text">如果减少一个归并段，利用上述规则，无法得到最佳归并树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%AE%B5%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%88k-1-u%EF%BC%89"><span class="toc-number">1.10.4.5.</span> <span class="toc-text">添加虚段的数量（k - 1 - u）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.11.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%A6%82%E4%BD%95%E5%BB%BA%E5%A0%86%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">1. 基于小根堆如何建堆、排序</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/31/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/" title="331. 验证二叉树的前序序列化"><img src="/img/background/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="331. 验证二叉树的前序序列化"/></a><div class="content"><a class="title" href="/2024/03/31/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/" title="331. 验证二叉树的前序序列化">331. 验证二叉树的前序序列化</a><time datetime="2024-03-30T22:21:41.000Z" title="发表于 2024-03-31 06:21:41">2024-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/31/2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/" title="2952. 需要添加的硬币的最小数量"><img src="/img/background/5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2952. 需要添加的硬币的最小数量"/></a><div class="content"><a class="title" href="/2024/03/31/2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/" title="2952. 需要添加的硬币的最小数量">2952. 需要添加的硬币的最小数量</a><time datetime="2024-03-30T17:46:49.000Z" title="发表于 2024-03-31 01:46:49">2024-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/30/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" title="5. 最长回文子串"><img src="/img/background/6.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="5. 最长回文子串"/></a><div class="content"><a class="title" href="/2024/03/30/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" title="5. 最长回文子串">5. 最长回文子串</a><time datetime="2024-03-29T17:53:06.000Z" title="发表于 2024-03-30 01:53:06">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/29/2908-%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%BD%A2%E4%B8%89%E5%85%83%E7%BB%84-I/" title="2908. 元素和最小的山形三元组 I"><img src="/img/background/16.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2908. 元素和最小的山形三元组 I"/></a><div class="content"><a class="title" href="/2024/03/29/2908-%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%BD%A2%E4%B8%89%E5%85%83%E7%BB%84-I/" title="2908. 元素和最小的山形三元组 I">2908. 元素和最小的山形三元组 I</a><time datetime="2024-03-29T10:31:26.000Z" title="发表于 2024-03-29 18:31:26">2024-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/29/1997-%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="1997. 访问完所有房间的第一天"><img src="/img/background/25.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1997. 访问完所有房间的第一天"/></a><div class="content"><a class="title" href="/2024/03/29/1997-%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="1997. 访问完所有房间的第一天">1997. 访问完所有房间的第一天</a><time datetime="2024-03-28T18:27:49.000Z" title="发表于 2024-03-29 02:27:49">2024-03-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By SDUMoist</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://sdumoist.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>