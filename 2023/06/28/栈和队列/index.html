<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>栈和队列 | Moist</title><meta name="author" content="SDUMoist"><meta name="copyright" content="SDUMoist"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="栈和队列做题总结考点 栈的应用（先进后出）：括号匹配、表达式求值、中缀转后缀、中缀转前缀、递归、迷宫求解（深度优先算法）、进制转换 队列的应用（先进先出）：层次遍历（广度优先算法）、缓冲区、资源分配、矩阵压缩、页面替换算法 中缀转后缀表达式算法：栈中存储运算符 后缀表达式的计算：栈中存储操作数 递归求解  易错点中缀转后缀的手算方法 确定中缀表达式中各个运算符的运算顺序 选择下一个运算符，按照[左">
<meta property="og:type" content="article">
<meta property="og:title" content="栈和队列">
<meta property="og:url" content="https://sdumoist.github.io/2023/06/28/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/index.html">
<meta property="og:site_name" content="Moist">
<meta property="og:description" content="栈和队列做题总结考点 栈的应用（先进后出）：括号匹配、表达式求值、中缀转后缀、中缀转前缀、递归、迷宫求解（深度优先算法）、进制转换 队列的应用（先进先出）：层次遍历（广度优先算法）、缓冲区、资源分配、矩阵压缩、页面替换算法 中缀转后缀表达式算法：栈中存储运算符 后缀表达式的计算：栈中存储操作数 递归求解  易错点中缀转后缀的手算方法 确定中缀表达式中各个运算符的运算顺序 选择下一个运算符，按照[左">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sdumoist.github.io/img/background/15.jpeg">
<meta property="article:published_time" content="2023-06-28T15:10:59.230Z">
<meta property="article:modified_time" content="2024-03-30T19:26:02.715Z">
<meta property="article:author" content="SDUMoist">
<meta property="article:tag" content="栈">
<meta property="article:tag" content="队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sdumoist.github.io/img/background/15.jpeg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://sdumoist.github.io/2023/06/28/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: SDUMoist","link":"链接: ","source":"来源: Moist","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '栈和队列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-31 03:26:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Moist" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background/15.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Moist"><img class="site-icon" src="/img/logo.png"/><span class="site-name">Moist</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">栈和队列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-28T15:10:59.230Z" title="发表于 2023-06-28 23:10:59">2023-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-30T19:26:02.715Z" title="更新于 2024-03-31 03:26:02">2024-03-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/">408</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="栈和队列"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ul>
<li>栈的应用（先进后出）：括号匹配、表达式求值、中缀转后缀、中缀转前缀、递归、迷宫求解（深度优先算法）、进制转换</li>
<li>队列的应用（先进先出）：层次遍历（广度优先算法）、缓冲区、资源分配、矩阵压缩、页面替换算法</li>
<li>中缀转后缀表达式算法：栈中存储运算符</li>
<li>后缀表达式的计算：栈中存储操作数</li>
<li>递归求解</li>
</ul>
<h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><h4 id="中缀转后缀的手算方法"><a href="#中缀转后缀的手算方法" class="headerlink" title="中缀转后缀的手算方法"></a>中缀转后缀的手算方法</h4><ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li>
<li>如果还有运算符没被处理，就继续2</li>
</ol>
<h4 id="中缀表达式转后缀表达式（机算）"><a href="#中缀表达式转后缀表达式（机算）" class="headerlink" title="中缀表达式转后缀表达式（机算）"></a>中缀表达式转后缀表达式（机算）</h4><ul>
<li><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符</p>
</li>
<li><p>从左向右处理各个元素，直到末尾。</p>
</li>
<li><p>可能遇到三种情况：</p>
<ol>
<li><p>遇到操作数。直接加入后缀表达式</p>
</li>
<li><p>遇到界限符。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。注意：”(“不加入后缀表达式</p>
</li>
<li><p>遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再将当前运算符入栈。</p>
</li>
</ol>
</li>
<li><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
</li>
</ul>
<h4 id="后缀表达式的机算"><a href="#后缀表达式的机算" class="headerlink" title="后缀表达式的机算"></a>后缀表达式的机算</h4><p>用栈实现后缀表达式：</p>
<ol>
<li>从左往右扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，并回到1；否则执行3</li>
<li>若扫描到运算符，则弹出两个栈顶元素（<strong>先出栈的是右操作数</strong>），执行相应运算，运算结果压回栈顶，回到1</li>
</ol>
<p><img src="/../image/assets/image-20230629103009744.png" alt="image-20230629103009744"></p>
<p><img src="/../image/assets/image-20230630170830221.png" alt="image-20230630170830221"></p>
<h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>数据结构三要素：逻辑结构、数据的运算、存储结构（物理结构）</p>
<p><img src="/../image/assets/image-20230628203720101.png" alt="image-20230628203720101"></p>
<p><img src="/../image/assets/image-20230628223246084.png" alt="image-20230628223246084"></p>
<p><img src="/../image/assets/image-20230628223758471.png" alt="image-20230628223758471"></p>
<p><img src="/../image/assets/image-20230629093704498.png" alt="image-20230629093704498"></p>
<p><img src="/../image/assets/image-20230629102936204.png" alt="image-20230629102936204"></p>
<p><img src="/../image/assets/image-20230629122344731.png" alt="image-20230629122344731"></p>
<p><img src="/../image/assets/image-20230629193720289.png" alt="image-20230629193720289"></p>
<p><img src="/../image/assets/image-20230629203040235.png" alt="image-20230629203040235"></p>
<p><img src="/../image/assets/image-20230629214408162.png" alt="image-20230629214408162"></p>
<p><img src="/../image/assets/image-20230629224617293.png" alt="image-20230629224617293"></p>
<p><img src="/../image/assets/image-20230630144103407.png" alt="image-20230630144103407"></p>
<p><img src="/../image/assets/image-20230630170813811.png" alt="image-20230630170813811"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>线性表是具有相同数据类型的n（n&gt;&#x3D;0）个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表，若用L命名线性表，则其一般表示为L&#x3D;(a1,a2,a2……,an)</li>
<li>栈(Stack)是只允许一段进行插入或删除操作的<strong>线性表</strong></li>
</ul>
<h4 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h4><h4 id="栈顶"><a href="#栈顶" class="headerlink" title="栈顶"></a>栈顶</h4><p>允许进行插入和删除的一端</p>
<h4 id="栈底"><a href="#栈底" class="headerlink" title="栈底"></a>栈底</h4><p>不允许进行插入和删除的一端</p>
<h4 id="空栈"><a href="#空栈" class="headerlink" title="空栈"></a>空栈</h4><p>空表（没有元素）</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>后进先出（FILO）</p>
<p><img src="/../image/assets/image-20230628202312363.png" alt="image-20230628202312363"></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h4><ol>
<li>初始化</li>
<li>销毁</li>
<li>插入</li>
<li>删除</li>
<li>按值查找</li>
<li>按位查找</li>
<li>求表长</li>
<li>输出</li>
<li>判空</li>
</ol>
<p><img src="/../image/assets/image-20230628202547870.png" alt="image-20230628202547870"></p>
<h4 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h4><ol>
<li>InitStack(&amp;S): 初始化栈。创造一个空栈S，分配内存空间</li>
<li>DestroyStack(&amp;L): 销毁栈。销毁并释放栈S所占用的内存空间</li>
<li>Push(&amp;S, x): 进栈， 若栈S非满，则将x加入使之成为新栈顶</li>
<li>Pop(&amp;S, &amp;x): 出栈， 若栈S非空，则弹出栈顶元素，并用x返回              删除栈顶元素</li>
<li>GetTop(S, &amp;x): 读栈顶元素。若栈S非空，则用x返回栈顶元素               不删除栈顶元素</li>
<li>StackEmpty(S): 判断一个栈S是否为空，若S为空，则返回true，否则返回false</li>
</ol>
<p><img src="/../image/assets/image-20230628203238863.png" alt="image-20230628203238863"></p>
<h3 id="栈的常考题型"><a href="#栈的常考题型" class="headerlink" title="栈的常考题型"></a>栈的常考题型</h3><p>进栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e</p>
<p>出栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e   e-&gt;d-&gt;c-&gt;b-&gt;a……..</p>
<h4 id="n个不同元素进栈，出栈元素的不同排列的个数有1-n-1-Cn-2n"><a href="#n个不同元素进栈，出栈元素的不同排列的个数有1-n-1-Cn-2n" class="headerlink" title="n个不同元素进栈，出栈元素的不同排列的个数有1&#x2F;n+1 * Cn 2n"></a>n个不同元素进栈，出栈元素的不同排列的个数有1&#x2F;n+1 * Cn 2n</h4><p><img src="/../image/assets/image-20230628203530876.png" alt="image-20230628203530876"></p>
<h3 id="顺序栈（顺序存储方式的实现）"><a href="#顺序栈（顺序存储方式的实现）" class="headerlink" title="顺序栈（顺序存储方式的实现）"></a>顺序栈（顺序存储方式的实现）</h3><h4 id="顺序存储的定义"><a href="#顺序存储的定义" class="headerlink" title="顺序存储的定义"></a>顺序存储的定义</h4><p>缺点：栈的大小不可变</p>
<p>顺序存储：给各个数据元素分配连续的存储空间。 MaxSize*sizeof(ElemType)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struck&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br></pre></td></tr></table></figure>

<p><img src="/../image/assets/image-20230628204412528.png" alt="image-20230628204412528"></p>
<h4 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="新元素入栈（Push）"><a href="#新元素入栈（Push）" class="headerlink" title="新元素入栈（Push）"></a>新元素入栈（Push）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="出栈-Pop"><a href="#出栈-Pop" class="headerlink" title="出栈(Pop)"></a>出栈(Pop)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struck&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack s;</span><br><span class="line">    <span class="built_in">InitStack</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="共享栈-顺序栈的一种"><a href="#共享栈-顺序栈的一种" class="headerlink" title="共享栈(顺序栈的一种)"></a>共享栈(顺序栈的一种)</h3><h4 id="共享栈定义"><a href="#共享栈定义" class="headerlink" title="共享栈定义"></a>共享栈定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top0;</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br></pre></td></tr></table></figure>



<h4 id="初始化共享栈"><a href="#初始化共享栈" class="headerlink" title="初始化共享栈"></a>初始化共享栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="判断栈满"><a href="#判断栈满" class="headerlink" title="判断栈满"></a>判断栈满</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈满条件：top0 + 1 == top1;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(top0 +<span class="number">1</span> == top1);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="总代码-1"><a href="#总代码-1" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    共享栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top0;</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满条件：top0 + 1 == top1;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(top0 +<span class="number">1</span> == top1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ShStack s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况</p>
<h4 id="链栈结构定义"><a href="#链栈结构定义" class="headerlink" title="链栈结构定义"></a>链栈结构定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;      <span class="comment">//数据域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>



<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack2</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    S -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="判断栈空-1"><a href="#判断栈空-1" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty2</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进栈（Push）不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push2</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S -&gt; next;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S -&gt; next= p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈 (Pop) 不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop2</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    S -&gt; next = S -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="读取栈顶元素"><a href="#读取栈顶元素" class="headerlink" title="读取栈顶元素"></a>读取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem2</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="总代码-2"><a href="#总代码-2" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    链栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;      <span class="comment">//数据域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack2</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    S -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty2</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push2</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S -&gt; next;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S -&gt; next= p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop2</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    S -&gt; next = S -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem2</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LiStack s;</span><br><span class="line">    <span class="built_in">InitStack</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The Stack is empty: %d\n&quot;</span>,<span class="built_in">StackEmpty</span>(s));</span><br><span class="line">    <span class="type">int</span> choise;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    <span class="keyword">while</span>(choise != <span class="number">0</span>)&#123;</span><br><span class="line">        ElemType x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter value: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;Successfully!!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Erorr!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">GetElem</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;The value is:%d &quot;</span>, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Erorr!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choise2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise2);</span><br><span class="line">    <span class="keyword">while</span>(choise2 != <span class="number">0</span>)&#123;</span><br><span class="line">        ElemType x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Pop</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>队列是只允许在一端进行插入，在另一端进行删除的线性表</p>
<h4 id="重要术语-1"><a href="#重要术语-1" class="headerlink" title="重要术语"></a>重要术语</h4><h4 id="队头"><a href="#队头" class="headerlink" title="队头"></a>队头</h4><p>允许删除的一端</p>
<h4 id="队尾"><a href="#队尾" class="headerlink" title="队尾"></a>队尾</h4><p>允许插入的一端</p>
<h4 id="空队列"><a href="#空队列" class="headerlink" title="空队列"></a>空队列</h4><p>没有元素的队列</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>先进先出（FIFO）</p>
<p><img src="/../image/assets/image-20230629093336205.png" alt="image-20230629093336205"></p>
<h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><blockquote>
<p>创建 销毁 增删改查</p>
</blockquote>
<p><img src="/../image/assets/image-20230629093630075.png" alt="image-20230629093630075"></p>
<ol>
<li>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q</li>
<li>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间</li>
<li>EnQueue(&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾</li>
<li>DeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回</li>
<li>GetHead(Q, &amp;x)：读队头元素，若队列非空，则将队头元素赋值给x</li>
<li>QueueEmpty(Q): 判断队列是否为空</li>
</ol>
<h3 id="顺序队列（队列的顺序实现）"><a href="#顺序队列（队列的顺序实现）" class="headerlink" title="顺序队列（队列的顺序实现）"></a>顺序队列（队列的顺序实现）</h3><h4 id="定义-浪费一个存储空间"><a href="#定义-浪费一个存储空间" class="headerlink" title="定义(浪费一个存储空间)"></a>定义(浪费一个存储空间)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;        <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<p>连续的存储空间，大小：MaxSize*sizeof(ElemType);</p>
<p><img src="/../image/assets/image-20230629094736245.png" alt="image-20230629094736245"></p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="判断队空"><a href="#判断队空" class="headerlink" title="判断队空"></a>判断队空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);<span class="comment">//队空条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>)%MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front=[Q.front+<span class="number">1</span>]%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取队列元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + MaxSize - Q.front) % MaxSize); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总代码-3"><a href="#总代码-3" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    队列的顺序实现(浪费空间)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;        <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);<span class="comment">//队空条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>)%MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front=[Q.front+<span class="number">1</span>]%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + MaxSize - Q.front) % MaxSize); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（不浪费存储空间的方法）"><a href="#（不浪费存储空间的方法）" class="headerlink" title="（不浪费存储空间的方法）"></a>（不浪费存储空间的方法）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个size进行判空和判满</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用tag来判空和判满</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>



<p><img src="/../image/assets/image-20230629102348180.png" alt="image-20230629102348180"></p>
<p><img src="/../image/assets/image-20230629102511110.png" alt="image-20230629102511110"></p>
<h3 id="链队（队列的链式实现）"><a href="#链队（队列的链式实现）" class="headerlink" title="链队（队列的链式实现）"></a>链队（队列的链式实现）</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;     <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/../image/assets/image-20230629103917368.png" alt="image-20230629103917368"></p>
<h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../image/assets/image-20230629120620415.png" alt="image-20230629120620415"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../image/assets/image-20230629120711292.png" alt="image-20230629120711292"></p>
<h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判空（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty2</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新节点赋值</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入其他元素</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear -&gt; next = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s -&gt; data = x;</span><br><span class="line">    s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">        Q.front == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空队列</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//返回值和修改</span></span><br><span class="line">    x = p -&gt; data;</span><br><span class="line">    Q.front -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="comment">//检验是否为最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总代码-4"><a href="#总代码-4" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    队列的链式实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;     <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue2</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty2</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新节点赋值</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入其他元素</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear -&gt; next = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s -&gt; data = x;</span><br><span class="line">    s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">        Q.front == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空队列</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//返回值和修改</span></span><br><span class="line">    x = p -&gt; data;</span><br><span class="line">    Q.front -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="comment">//检验是否为最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue q;        <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(q);       <span class="comment">//初始化队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>可以在两端进行输入和输出的队列</p>
<p><img src="/../image/assets/image-20230629165606815.png" alt="image-20230629165606815"></p>
<p><img src="/../image/assets/image-20230629165638917.png" alt="image-20230629165638917"> </p>
<h4 id="考点：判断输出序列合法性"><a href="#考点：判断输出序列合法性" class="headerlink" title="考点：判断输出序列合法性"></a>考点：判断输出序列合法性</h4><p>若数据元素输入序列为1，2，3，4，则哪些输出序列是合法的，哪些是非法的？</p>
<h4 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h4><p><img src="/../image/assets/image-20230629165955894.png" alt="image-20230629165955894"></p>
<p><img src="/../image/assets/image-20230629193200265.png" alt="image-20230629193200265"></p>
<p> <img src="/../image/assets/image-20230629193540166.png" alt="image-20230629193540166"></p>
<h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><h3 id="1-栈的第一个应用：括号匹配中的应用"><a href="#1-栈的第一个应用：括号匹配中的应用" class="headerlink" title="1.栈的第一个应用：括号匹配中的应用"></a>1.栈的第一个应用：括号匹配中的应用</h3><h4 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);   <span class="comment">//初始化一个栈 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length;i ++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">Push</span>(S, str[i]);   <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);    <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总代码（可运行）"><a href="#总代码（可运行）" class="headerlink" title="总代码（可运行）"></a>总代码（可运行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈在括号匹配中的应用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);   <span class="comment">//初始化一个栈 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length;i ++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">Push</span>(S, str[i]);   <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);    <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[]=<span class="string">&quot;&#123;&#125;[&#123;((()))&#125;]&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bracketCheck</span>(s,<span class="built_in">strlen</span>(s))) <span class="built_in">printf</span>(<span class="string">&quot;Right!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-栈的第二个应用：表达式的求值"><a href="#2-栈的第二个应用：表达式的求值" class="headerlink" title="2.栈的第二个应用：表达式的求值"></a>2.栈的第二个应用：表达式的求值</h3><h4 id="中缀、后缀、前缀表达式"><a href="#中缀、后缀、前缀表达式" class="headerlink" title="中缀、后缀、前缀表达式"></a>中缀、后缀、前缀表达式</h4><ul>
<li>中缀表达式：运算符在两个操作数中间</li>
<li>后缀表达式：运算符在两个操作数后面</li>
<li>前缀表达式：运算符在两个操作数前面</li>
</ul>
<p><img src="/../image/assets/image-20230629205620005.png" alt="image-20230629205620005"></p>
<h4 id="中缀转后缀的手算方法-1"><a href="#中缀转后缀的手算方法-1" class="headerlink" title="中缀转后缀的手算方法"></a>中缀转后缀的手算方法</h4><ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li>
<li>如果还有运算符没被处理，就继续2</li>
</ol>
<p><img src="/../image/assets/image-20230629212626321.png" alt="image-20230629212626321"></p>
<p>运算顺序不唯一，因此对应的后缀表达式也不唯一</p>
<p>“左优先原则”，不要Freestyle，保证手算和机算结果相同：只要左边的运算符能先计算，就优先算左边（可保证表达式唯一）</p>
<h4 id="中缀表达式转后缀表达式（机算）-1"><a href="#中缀表达式转后缀表达式（机算）-1" class="headerlink" title="中缀表达式转后缀表达式（机算）"></a>中缀表达式转后缀表达式（机算）</h4><ul>
<li><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符</p>
</li>
<li><p>从左向右处理各个元素，直到末尾。</p>
</li>
<li><p>可能遇到三种情况：</p>
<ol>
<li><p>遇到操作数。直接加入后缀表达式</p>
</li>
<li><p>遇到界限符。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。注意：”(“不加入后缀表达式</p>
</li>
<li><p>遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再将当前运算符入栈。</p>
</li>
</ol>
</li>
<li><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 后缀表达式的机算</span><br><span class="line"></span><br><span class="line">用栈实现后缀表达式：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 从左往右扫描下一个元素，直到处理完所有元素</span><br><span class="line"><span class="number">2.</span> 若扫描到操作数则压入栈，并回到<span class="number">1</span>；否则执行<span class="number">3</span></span><br><span class="line"><span class="number">3.</span> 若扫描到运算符，则弹出两个栈顶元素（先出栈的是右操作数），执行相应运算，运算结果压回栈顶，回到<span class="number">1</span></span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629214241531</span>](../image/assets/image<span class="number">-20230629214241531.</span>png)</span><br><span class="line"></span><br><span class="line">```C++</span><br></pre></td></tr></table></figure>



<h4 id="中缀转前缀的手算方法"><a href="#中缀转前缀的手算方法" class="headerlink" title="中缀转前缀的手算方法"></a>中缀转前缀的手算方法</h4><ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下个运算符，按照[运算符 左操作数 右操作数] 的方式组合成一个新的操作数</li>
<li>如果还有操作符没被处理，就继续2</li>
</ol>
<p>”右优先原则“：只要右边的运算符能先计算，就优先计算右边的</p>
<p><img src="/../image/assets/image-20230629214225723.png" alt="image-20230629214225723"></p>
<h4 id="前缀表达式的机算"><a href="#前缀表达式的机算" class="headerlink" title="前缀表达式的机算"></a>前缀表达式的机算</h4><p>用栈实现前缀表达式的机算：</p>
<ol>
<li>从右往左扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，并回到1；否则执行3</li>
<li>若扫描到运算符，则弹出两个栈顶元素（先出栈的元素是左操作数），执行相应运算，运算结果压回栈顶，回到1</li>
</ol>
<p><img src="/../image/assets/image-20230629214129572.png" alt="image-20230629214129572"></p>
<h4 id="中缀表达式的机算（用栈实现）"><a href="#中缀表达式的机算（用栈实现）" class="headerlink" title="中缀表达式的机算（用栈实现）"></a>中缀表达式的机算（用栈实现）</h4><p>中缀转后缀 + 后缀表达式求值       两个算法结合</p>
<p>用栈实现中缀表达式的计算：</p>
<ol>
<li>初始化两个字栈：操作数栈和运算符栈</li>
<li>若扫描到操作数，压入操作数栈</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈<strong>（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">3.</span>栈的第三个应用：递归</span><br><span class="line"></span><br><span class="line">函数调用背后的过程：</span><br><span class="line"></span><br><span class="line">#### 函数调用的特点：最后被调用的函数最先被执行结束（FILO）</span><br><span class="line"></span><br><span class="line">#### 函数调用的过程</span><br><span class="line"></span><br><span class="line">函数调用时，需要用一个栈存储：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 调用返回地址</span><br><span class="line"><span class="number">2.</span> 实参</span><br><span class="line"><span class="number">3.</span> 局部变量</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225015684</span>](../image/assets/image<span class="number">-20230629225015684.</span>png)</span><br><span class="line"></span><br><span class="line">栈在递归中的应用：</span><br><span class="line"></span><br><span class="line">**适合用递归算法解决：可以把原始问题转换为属性相同，但规模更小的问题**</span><br><span class="line"></span><br><span class="line">#### 求阶乘和斐波那契数列的和</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225405960</span>](../image/assets/image<span class="number">-20230629225405960.</span>png)</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225517294</span>](../image/assets/image<span class="number">-20230629225517294.</span>png)</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230630143943097</span>](../image/assets/image<span class="number">-20230630143943097.</span>png)</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">/计算阶乘</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span> <span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Fib</span>(n<span class="number">-1</span>)+<span class="built_in">Fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;阶乘是：%d  ,斐波那契数列是：%d&quot;</span>, <span class="built_in">factorial</span>(num),<span class="built_in">Fib</span>(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈应用的缺点"><a href="#栈应用的缺点" class="headerlink" title="栈应用的缺点"></a>栈应用的缺点</h4><p>效率低，太多层递归可能会导致栈溢出；可能包含很多重复计算</p>
<h4 id="栈的改善方法"><a href="#栈的改善方法" class="headerlink" title="栈的改善方法"></a>栈的改善方法</h4><p>可以自定义栈将递归算法改造成非递归算法</p>
<h3 id="4-栈的第四个应用：进制转换"><a href="#4-栈的第四个应用：进制转换" class="headerlink" title="4.栈的第四个应用：进制转换"></a>4.栈的第四个应用：进制转换</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>使用stack<int>来存储每一位的数字。</li>
<li>在函数decimalToBase中，通过不断将十进制数除以目标进制数并取余数，将余数压入栈中。</li>
<li>将栈中的元素依次弹出，并将其转换为字符串类型，连接起来形成最终的转换结果。</li>
</ul>
<h4 id="总代码-5"><a href="#总代码-5" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈在进制转换中的应用</span></span><br><span class="line"><span class="comment">    使用stack&lt;int&gt;来存储每一位的数字。</span></span><br><span class="line"><span class="comment">    在函数decimalToBase中，通过不断将十进制数除以目标进制数并取余数，将余数压入栈中。</span></span><br><span class="line"><span class="comment">    将栈中的元素依次弹出，并将其转换为字符串类型，连接起来形成最终的转换结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制数转换为指定进制数</span></span><br><span class="line"><span class="function">string <span class="title">decimalToBase</span><span class="params">(<span class="type">int</span> number, <span class="type">int</span> base)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; digits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> remainder = number % base;</span><br><span class="line">        digits.<span class="built_in">push</span>(remainder);</span><br><span class="line">        number /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">while</span> (!digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> digit = digits.<span class="built_in">top</span>();</span><br><span class="line">        digits.<span class="built_in">pop</span>();</span><br><span class="line">        result += <span class="built_in">to_string</span>(digit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a decimal number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the base to convert to: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; base;</span><br><span class="line"></span><br><span class="line">    string result = <span class="built_in">decimalToBase</span>(number, base);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-栈的第五个应用：迷宫求解（深度优先算法）"><a href="#5-栈的第五个应用：迷宫求解（深度优先算法）" class="headerlink" title="5. 栈的第五个应用：迷宫求解（深度优先算法）"></a>5. 栈的第五个应用：迷宫求解（深度优先算法）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>栈在迷宫求解中有广泛的应用，主要用于实现<strong>深度优先搜索算法</strong>。下面是栈在迷宫求解中的具体应用：</p>
<ol>
<li><p>迷宫表示：首先，我们可以使用二维数组或者矩阵来表示迷宫。迷宫的每个位置可以用0表示可通行的路径，用1表示墙壁或障碍物。这样的表示方式可以方便我们在后续的求解过程中进行遍历和判断。</p>
</li>
<li><p>深度优先搜索：在迷宫求解过程中，我们通常采用深度优先搜索算法来寻找从入口到出口的路径。<strong>深度优先搜索算法的核心思想是沿着一个方向尽可能深入地探索迷宫，直到无法继续为止，然后回溯到上一个位置，选择其他的方向进行探索。</strong></p>
</li>
<li><p>栈的应用：为了实现深度优先搜索算法，我们可以借助栈来保存当前位置和搜索路径的信息。具体操作如下：</p>
<ul>
<li>将起始位置入栈。</li>
<li>不断出栈并探索当前位置的相邻可通行位置。</li>
<li>将可通行位置入栈，并标记为已访问。</li>
<li>重复上述步骤，直到找到出口或者栈为空。</li>
<li>如果找到出口，则可以通过栈中保存的路径信息来追踪整个路径。</li>
</ul>
</li>
</ol>
<p>通过使用栈，我们可以有效地管理搜索过程中的状态信息，避免了递归调用带来的函数调用开销，同时也方便了路径的回溯和记录。</p>
<p>总结起来，栈在迷宫求解中的应用主要体现在深度优先搜索算法的实现中，通过栈来管理搜索状态和路径信息，以便找到从入口到出口的路径。</p>
<h3 id="1-队列应用——树的层次遍历"><a href="#1-队列应用——树的层次遍历" class="headerlink" title="1.队列应用——树的层次遍历"></a>1.队列应用——树的层次遍历</h3><p><img src="/../image/assets/image-20230630145425126.png" alt="image-20230630145425126"></p>
<p><img src="/../image/assets/image-20230630145117386.png" alt="image-20230630145117386"></p>
<p><img src="/../image/assets/image-20230630145256711.png" alt="image-20230630145256711"></p>
<p><img src="/../image/assets/image-20230630145358106.png" alt="image-20230630145358106"></p>
<h3 id="2-队列的应用：页面替换算法"><a href="#2-队列的应用：页面替换算法" class="headerlink" title="2.队列的应用：页面替换算法"></a>2.队列的应用：页面替换算法</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><strong>页面替换算法是操作系统中用于管理虚拟内存的一种策略。在计算机系统中，虚拟内存是一种将主存（RAM）扩展到硬盘上的技术。由于硬盘的访问速度较慢，所以在内存空间不足时，操作系统需要根据一定的策略将部分主存中的页面（页框）置换到硬盘上，从而腾出空间供其他页面使用。</strong></p>
<p>页面替换算法的目标是使得整体的页面访问效率最大化，减少页面置换带来的性能损失。常见的页面替换算法有以下几种：</p>
<ol>
<li><p><strong>最佳(OPT)算法</strong>：选择将来最长时间内不再被访问的页面进行置换。该算法是一种理想化的算法，但实际上很难预测将来页面的访问模式。</p>
</li>
<li><p><strong>先进先出(FIFO)算法</strong>：选择最早进入内存的页面进行置换。该算法简单直观，但可能会导致”先进入”的页面在后续访问中仍然频繁使用，造成性能下降，即所谓的”Belady现象”。</p>
</li>
<li><p><strong>最近最少使用(LRU)算法</strong>：选择最近一段时间内最少被访问的页面进行置换。该算法基于局部性原理，认为最近被访问的页面可能在将来继续被访问，适应了大多数程序的访问模式。</p>
</li>
<li><p><strong>最不经常使用(LFU)算法</strong>：选择最近一段时间内访问次数最少的页面进行置换。该算法认为访问次数少的页面可能是不常用的页面，适用于具有较强访问模式的程序。</p>
</li>
<li><p><strong>时钟(Clock)算法</strong>：基于FIFO算法的基础上，使用一个”访问位”（也称为”引用位”）来判断页面是否被访问过，将未被访问的页面进行置换。</p>
</li>
</ol>
<p>不同的页面替换算法在不同的工作负载下表现不同，没有一种算法能够适用于所有情况。因此，在实际应用中，根据系统特点和工作负载的特点选择合适的页面替换算法。</p>
<h4 id="先进先出-FIFO-算法使用队列"><a href="#先进先出-FIFO-算法使用队列" class="headerlink" title="先进先出(FIFO)算法使用队列"></a><strong>先进先出(FIFO)算法</strong>使用队列</h4><h4 id="LRU（最近最少使用）算法也可以使用双端队列"><a href="#LRU（最近最少使用）算法也可以使用双端队列" class="headerlink" title="LRU（最近最少使用）算法也可以使用双端队列"></a>LRU（最近最少使用）算法也可以使用双端队列</h4><h3 id="3-队列的应用：缓冲区"><a href="#3-队列的应用：缓冲区" class="headerlink" title="3.队列的应用：缓冲区"></a>3.队列的应用：缓冲区</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul>
<li>解决主机 与外部设备之间速度不匹配的问题</li>
<li>例如：主机输出数据给打印机打印，输出数据的速度比打印数据的速度快很多，由于速度不匹配，若直接把输出的数据给打印机打印显然是不行的。解决方法是设置一个<strong>打印数据缓冲区</strong>，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他事情。打印机就从缓冲区中按照<strong>先进先出</strong>的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求之后再向缓冲区写入打印数据。</li>
<li>这样做既保证了打印数据的正确，又使主机提高了效率。</li>
<li>打印数据缓冲区中所存储的数据就是一个队列</li>
</ul>
<h3 id="4-队列的应用：CPU资源分配"><a href="#4-队列的应用：CPU资源分配" class="headerlink" title="4. 队列的应用：CPU资源分配"></a>4. 队列的应用：CPU资源分配</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><ul>
<li>解决由多用户引起的资源竞争问题</li>
<li>在一个多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，分别通过各自的终端向操作系统提出占用CPU的请求，操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或者用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。</li>
<li>既能满足每个用户的请求，又使CPU能够正常运行</li>
</ul>
<h3 id="5-队列的应用：图的广度优先搜索"><a href="#5-队列的应用：图的广度优先搜索" class="headerlink" title="5.队列的应用：图的广度优先搜索"></a>5.队列的应用：图的广度优先搜索</h3><p>队列在图的广度优先搜索(BFS)中扮演了关键的角色，用于管理待访问的顶点和控制搜索的顺序。下面是队列在图的广度优先搜索中的具体应用：</p>
<ol>
<li><p>图的表示：首先，我们需要使用适当的数据结构来表示图。常见的表示方式有邻接矩阵和邻接表。邻接矩阵适用于稠密图，而邻接表适用于稀疏图。无论使用哪种表示方式，我们需要确保能够存储图中顶点之间的连接关系。</p>
</li>
<li><p>广度优先搜索：广度优先搜索是一种用于图的遍历的算法，它从图中的一个顶点开始，逐层地访问与该顶点相邻的顶点，直到达到目标顶点或者遍历完所有可达的顶点。这种搜索方式确保了先访问离起始顶点最近的顶点，然后再逐渐扩展到离起始顶点更远的顶点。</p>
</li>
<li><p>队列的应用：为了实现广度优先搜索算法，我们需要使用队列来管理待访问的顶点。具体操作如下：</p>
<ul>
<li>将起始顶点入队列。</li>
<li>从队列中取出一个顶点并标记为已访问。</li>
<li>遍历该顶点的所有相邻顶点，将未访问的顶点入队列。</li>
<li>重复上述步骤，直到队列为空或者找到目标顶点。</li>
<li>如果找到目标顶点，则可以通过记录顶点间的连接关系来追踪整个路径。</li>
</ul>
</li>
</ol>
<p>通过使用队列，我们能够按照广度优先的顺序逐层遍历图中的顶点，保证了离起始顶点近的顶点优先被访问。队列的先进先出(FIFO)特性确保了每个顶点在队列中只被访问一次。</p>
<p>综上所述，队列在图的广度优先搜索中的应用主要体现在管理待访问的顶点和控制搜索顺序方面，通过队列来按照广度优先的方式遍历图中的顶点，并追踪整个路径。</p>
<h3 id="6-队列的应用：特殊矩阵的压缩"><a href="#6-队列的应用：特殊矩阵的压缩" class="headerlink" title="6.队列的应用：特殊矩阵的压缩"></a>6.队列的应用：特殊矩阵的压缩</h3><h4 id="主要术语"><a href="#主要术语" class="headerlink" title="主要术语"></a>主要术语</h4><ul>
<li><strong>压缩存储</strong>：为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。目的是节省存储空间</li>
<li><strong>特殊矩阵</strong>：具有许多相同矩阵元素或零元素，这些相同的矩阵元素或零元素的分布有一定规律的矩阵。 常见有：对称矩阵、上（下）三角矩阵、对角矩阵</li>
<li><strong>特殊矩阵的压缩存储方法</strong>：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间</li>
</ul>
<h4 id="二维数组的存储结构"><a href="#二维数组的存储结构" class="headerlink" title="二维数组的存储结构"></a>二维数组的存储结构</h4><p><img src="/../image/assets/image-20230630151537264.png" alt="image-20230630151537264"></p>
<h4 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h4><p><img src="/../image/assets/image-20230630152013425.png" alt="image-20230630152013425"></p>
<p>矩阵下标  a(i,j)           一维数组下标B[k]</p>
<p>a(i,j)  (i &gt;&#x3D; j):  k &#x3D; i*(i-1)&#x2F;2+j-1;</p>
<p>a(i,j)  (i &lt; j):  k &#x3D; j*(j-1)&#x2F;2+i-1;</p>
<h4 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h4><p><img src="/../image/assets/image-20230630152935003.png" alt="image-20230630152935003"></p>
<p><img src="/../image/assets/image-20230630165439721.png" alt="image-20230630165439721"></p>
<h4 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h4><p><img src="/../image/assets/image-20230630165850992.png" alt="image-20230630165850992"></p>
<p><img src="/../image/assets/image-20230630170018814.png" alt="image-20230630170018814"></p>
<h4 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h4><p>非零元素远远少于矩阵元素的个数</p>
<h4 id="顺序存储——三元组"><a href="#顺序存储——三元组" class="headerlink" title="顺序存储——三元组&lt;行，列，值&gt;"></a>顺序存储——三元组&lt;行，列，值&gt;</h4><p><img src="/../image/assets/image-20230630170531882.png" alt="image-20230630170531882"></p>
<h4 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42185999/article/details/105083274">十字链表法的实现</a></li>
</ul>
<p><img src="/../image/assets/image-20230630170726655.png" alt="image-20230630170726655"></p>
<p><strong>使用条件</strong>：当矩阵的非零元个数和位置在操作过程中变化较大时，就不宜采用顺序存储结构来表示三元组的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a>。对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。</p>
<p><strong>使用方法</strong>：在链表中，每个非零元可用一个含 5 个域的结点表示，其中 i , j , e 这 3 个域分别表示该非零元所在的行、列和非零元的值，向右域 right 用以链接同一行中下一个非零元，向下域 down 用以链接同一列中下一个非零元。</p>
<p>同一行的非零元通过 right 域链接成一个线性链表，同一列的非零元通过 down 域链接成一个线性链表，每个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表，故称这样的存储结构为十字链表。<br>可用两个分别存储行链表的头指针和列链表的头指针的一维数组表示之</p>
<p><img src="/../image/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><em><strong>采用十字链表存储稀疏矩阵的示例：</strong></em></p>
<p> <img src="/../image/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70-20230630181803252.png" alt="img"></p>
<blockquote>
<p>由于十字链表存储结构中的非零元素是按其所在行、列插入相应的链表的，所以，在创建稀疏矩阵输入非零元时，可以按<strong>任意顺序</strong>输入非零元素。每个非零元结点按升序被插入到两个没有头结点的单链表中：一个是所在行链表；另一个是所在列链表。当插入或删除结点时，只要修改相关的行、列链表即可，比较灵活。</p>
</blockquote>
<p>总代码（不知道能不能运行）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean; <span class="comment">/* Boolean是布尔类型,其值是TRUE或FALSE */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span> <span class="comment">/* malloc()等 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* EOF(=^Z或F6),NULL */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;process.h&gt;</span> <span class="comment">/* exit() */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span> <span class="comment">/* 标准头文件，提供宏va_start，va_arg和va_end， */</span></span></span><br><span class="line"><span class="comment">/* 用于存取变长参数表 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数结果状态代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2 </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ---------------------------    稀疏矩阵的十字链表存储表示    ------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">OLNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j; <span class="comment">/* 该非零元的行和列下标 */</span></span><br><span class="line">	ElemType e; <span class="comment">/* 非零元素值 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">OLNode</span> *right, *down; <span class="comment">/* 该非零元所在行表和列表的后继链域 */</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	OLink *rhead, *chead; <span class="comment">/* 行和列链表头指针向量基址,由CreatSMatrix_OL()分配 */</span></span><br><span class="line">	<span class="type">int</span> mu, nu, tu; <span class="comment">/* 稀疏矩阵的行数、列数和非零元个数 */</span></span><br><span class="line">&#125;CrossList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ---------------------------  稀疏矩阵的十字链表存储的基本操作(9个)  --------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitSMatrix</span><span class="params">(CrossList *M)</span> <span class="comment">/* 加 */</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始化M(CrossList类型的变量必须初始化,否则创建、复制矩阵将出错) */</span></span><br><span class="line">	(*M).rhead = (*M).chead = <span class="literal">NULL</span>;</span><br><span class="line">	(*M).mu = (*M).nu = (*M).tu = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DestroySMatrix</span><span class="params">(CrossList *M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 销毁稀疏矩阵M */</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	OLNode *p, *q;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*M).mu; i++) <span class="comment">/* 按行释放结点 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = *((*M).rhead + i);</span><br><span class="line">		<span class="keyword">while</span> (p)</span><br><span class="line">		&#123;</span><br><span class="line">			q = p;</span><br><span class="line">			p = p-&gt;right;</span><br><span class="line">			<span class="built_in">free</span>(q);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>((*M).rhead);</span><br><span class="line">	<span class="built_in">free</span>((*M).chead);</span><br><span class="line">	(*M).rhead = (*M).chead = <span class="literal">NULL</span>;</span><br><span class="line">	(*M).mu = (*M).nu = (*M).tu = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateSMatrix</span><span class="params">(CrossList *M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 创建稀疏矩阵M,采用十字链表存储表示。算法5.4 */</span></span><br><span class="line">	<span class="type">int</span> i, j, k, m, n, t;</span><br><span class="line">	ElemType e;</span><br><span class="line">	OLNode *p, *q;</span><br><span class="line">	<span class="keyword">if</span> ((*M).rhead)</span><br><span class="line">		<span class="built_in">DestroySMatrix</span>(M);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入稀疏矩阵的行数 列数 非零元个数: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;t);</span><br><span class="line">	(*M).mu = m;</span><br><span class="line">	(*M).nu = n;</span><br><span class="line">	(*M).tu = t;</span><br><span class="line">	(*M).rhead = (OLink*)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*M).rhead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*M).chead = (OLink*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*M).chead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= m; k++) <span class="comment">/* 初始化行头指针向量;各行链表为空链表 */</span></span><br><span class="line">		(*M).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++) <span class="comment">/* 初始化列头指针向量;各列链表为空链表 */</span></span><br><span class="line">		(*M).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请按任意次序输入%d个非零元的行 列 元素值:\n&quot;</span>, (*M).tu);</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;i, &amp;j, &amp;e);</span><br><span class="line">		p = (OLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode));</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		p-&gt;i = i; <span class="comment">/* 生成结点 */</span></span><br><span class="line">		p-&gt;j = j;</span><br><span class="line">		p-&gt;e = e;</span><br><span class="line">		<span class="keyword">if</span> ((*M).rhead[i] == <span class="literal">NULL</span> || (*M).rhead[i]-&gt;j &gt; j) <span class="comment">/* p插在该行的第一个结点处 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;right = (*M).rhead[i];</span><br><span class="line">			(*M).rhead[i] = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">/* 寻查在行表中的插入位置 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (q = (*M).rhead[i]; q-&gt;right&amp;&amp;q-&gt;right-&gt;j &lt; j; q = q-&gt;right);</span><br><span class="line">			p-&gt;right = q-&gt;right; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">			q-&gt;right = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((*M).chead[j] == <span class="literal">NULL</span> || (*M).chead[j]-&gt;i &gt; i) <span class="comment">/* p插在该列的第一个结点处 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;down = (*M).chead[j];</span><br><span class="line">			(*M).chead[j] = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">/* 寻查在列表中的插入位置 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (q = (*M).chead[j]; q-&gt;down&amp;&amp;q-&gt;down-&gt;i &lt; i; q = q-&gt;down);</span><br><span class="line">			p-&gt;down = q-&gt;down; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">			q-&gt;down = p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">PrintSMatrix</span><span class="params">(CrossList M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 按行或按列输出稀疏矩阵M */</span></span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	OLink p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d行%d列%d个非零元素\n&quot;</span>, M.mu, M.nu, M.tu);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入选择(1.按行输出 2.按列输出): &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">	<span class="keyword">switch</span> (i)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.mu; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = M.rhead[j];</span><br><span class="line">		<span class="keyword">while</span> (p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d行%d列值为%d\n&quot;</span>, p-&gt;i, p-&gt;j, p-&gt;e);</span><br><span class="line">			p = p-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.nu; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = M.chead[j];</span><br><span class="line">		<span class="keyword">while</span> (p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d行%d列值为%d\n&quot;</span>, p-&gt;i, p-&gt;j, p-&gt;e);</span><br><span class="line">			p = p-&gt;down;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSMatrix1</span><span class="params">(CrossList M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 按矩阵形式输出M</span></span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	OLink p;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++)</span><br><span class="line">	&#123; <span class="comment">// 从第1行到最后1行</span></span><br><span class="line">		p = M.rhead[i]; <span class="comment">// p指向该行的第1个非零元素</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.nu; j++) <span class="comment">// 从第1列到最后1列</span></span><br><span class="line">			<span class="keyword">if</span> (!p || p-&gt;j != j) <span class="comment">// 已到该行表尾或当前结点的列值不等于当前列值</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, <span class="number">0</span>); <span class="comment">// 输出0</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, p-&gt;e);</span><br><span class="line">				p = p-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CopySMatrix</span><span class="params">(CrossList M, CrossList *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 由稀疏矩阵M复制得到T */</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	OLink p, q = <span class="literal">NULL</span>, q1 = <span class="literal">NULL</span>, q2;</span><br><span class="line">	<span class="keyword">if</span> ((*T).rhead)</span><br><span class="line">		<span class="built_in">DestroySMatrix</span>(T);</span><br><span class="line">	(*T).mu = M.mu;</span><br><span class="line">	(*T).nu = M.nu;</span><br><span class="line">	(*T).tu = M.tu;</span><br><span class="line">	(*T).rhead = (OLink*)<span class="built_in">malloc</span>((M.mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*T).rhead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*T).chead = (OLink*)<span class="built_in">malloc</span>((M.nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*T).chead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 初始化矩阵T的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">		(*T).rhead[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.nu; i++) <span class="comment">/* 初始化矩阵T的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">		(*T).chead[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行复制 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = M.rhead[i];</span><br><span class="line">		<span class="keyword">while</span> (p) <span class="comment">/* 没到行尾 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			q = (OLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成结点 */</span></span><br><span class="line">			<span class="keyword">if</span> (!q)</span><br><span class="line">				<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">			q-&gt;i = p-&gt;i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">			q-&gt;j = p-&gt;j;</span><br><span class="line">			q-&gt;e = p-&gt;e;</span><br><span class="line">			<span class="keyword">if</span> (!(*T).rhead[i]) <span class="comment">/* 插在行表头 */</span></span><br><span class="line">				(*T).rhead[i] = q1 = q;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在行表尾 */</span></span><br><span class="line">				q1 = q1-&gt;right = q;</span><br><span class="line">			<span class="keyword">if</span> (!(*T).chead[q-&gt;j]) <span class="comment">/* 插在列表头 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				(*T).chead[q-&gt;j] = q;</span><br><span class="line">				q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在列表尾 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				q2 = (*T).chead[q-&gt;j];</span><br><span class="line">				<span class="keyword">while</span> (q2-&gt;down)</span><br><span class="line">					q2 = q2-&gt;down;</span><br><span class="line">				q2-&gt;down = q;</span><br><span class="line">				q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">AddSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M与N的行数和列数对应相等。 */</span></span><br><span class="line">  <span class="comment">/* 操作结果: 求稀疏矩阵的和Q=M+N */</span></span><br><span class="line">	<span class="type">int</span> i, k;</span><br><span class="line">	OLink p, pq = <span class="literal">NULL</span>, pm, pn;</span><br><span class="line">	OLink *col;</span><br><span class="line">	<span class="keyword">if</span> (M.mu != N.mu || M.nu != N.nu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;两个矩阵不是同类型的,不能相加\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	&#125;</span><br><span class="line">	(*Q).mu = M.mu; <span class="comment">/* 初始化Q矩阵 */</span></span><br><span class="line">	(*Q).nu = M.nu;</span><br><span class="line">	(*Q).tu = <span class="number">0</span>; <span class="comment">/* 元素个数的初值 */</span></span><br><span class="line">	(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).mu; k++) <span class="comment">/* 初始化Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">		(*Q).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 初始化Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">		(*Q).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line">	col = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink)); <span class="comment">/* 生成指向列的最后结点的数组 */</span></span><br><span class="line">	<span class="keyword">if</span> (!col)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 赋初值 */</span></span><br><span class="line">		col[k] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行的顺序相加 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		pm = M.rhead[i]; <span class="comment">/* pm指向矩阵M的第i行的第1个结点 */</span></span><br><span class="line">		pn = N.rhead[i]; <span class="comment">/* pn指向矩阵N的第i行的第1个结点 */</span></span><br><span class="line">		<span class="keyword">while</span> (pm&amp;&amp;pn) <span class="comment">/* pm和pn均不空 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (pm-&gt;j &lt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列小于矩阵N当前结点的列 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">				<span class="keyword">if</span> (!p)</span><br><span class="line">					<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">				(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">				p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">				p-&gt;j = pm-&gt;j;</span><br><span class="line">				p-&gt;e = pm-&gt;e;</span><br><span class="line">				p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">				pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;j &gt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列大于矩阵N当前结点的列 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">				<span class="keyword">if</span> (!p)</span><br><span class="line">					<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">				(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">				p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">				p-&gt;j = pn-&gt;j;</span><br><span class="line">				p-&gt;e = pn-&gt;e;</span><br><span class="line">				p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">				pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;e + pn-&gt;e) <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和不为0 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">				<span class="keyword">if</span> (!p)</span><br><span class="line">					<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">				(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">				p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">				p-&gt;j = pn-&gt;j;</span><br><span class="line">				p-&gt;e = pm-&gt;e + pn-&gt;e;</span><br><span class="line">				p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">				pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">				pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和为0 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">				pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">				(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">				pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">				(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;]所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">				col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (pm) <span class="comment">/* 将矩阵M该行的剩余元素插入矩阵Q */</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">			<span class="keyword">if</span> (!p)</span><br><span class="line">				<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">			(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">			p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">			p-&gt;j = pm-&gt;j;</span><br><span class="line">			p-&gt;e = pm-&gt;e;</span><br><span class="line">			p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">			pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">			<span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">				(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">				pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">				(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">				col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (pn) <span class="comment">/* 将矩阵N该行的剩余元素插入矩阵Q */</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">			<span class="keyword">if</span> (!p)</span><br><span class="line">				<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">			(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">			p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">			p-&gt;j = pn-&gt;j;</span><br><span class="line">			p-&gt;e = pn-&gt;e;</span><br><span class="line">			p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">			pn = pn-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">			<span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">				(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">				pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">				(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">				col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++)</span><br><span class="line">		<span class="keyword">if</span> (col[k]) <span class="comment">/* k列有结点 */</span></span><br><span class="line">			col[k]-&gt;down = <span class="literal">NULL</span>; <span class="comment">/*  令该列最后一个结点的down指针为空 */</span></span><br><span class="line">	<span class="built_in">free</span>(col);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">SubtSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M与N的行数和列数对应相等。 */</span></span><br><span class="line">  <span class="comment">/* 操作结果: 求稀疏矩阵的差Q=M-N */</span></span><br><span class="line">	<span class="type">int</span> i, k;</span><br><span class="line">	OLink p, pq = <span class="literal">NULL</span>, pm, pn;</span><br><span class="line">	OLink *col;</span><br><span class="line">	<span class="keyword">if</span> (M.mu != N.mu || M.nu != N.nu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;两个矩阵不是同类型的,不能相加\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	&#125;</span><br><span class="line">	(*Q).mu = M.mu; <span class="comment">/* 初始化Q矩阵 */</span></span><br><span class="line">	(*Q).nu = M.nu;</span><br><span class="line">	(*Q).tu = <span class="number">0</span>; <span class="comment">/* 元素个数的初值 */</span></span><br><span class="line">	(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).mu; k++) <span class="comment">/* 初始化Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">		(*Q).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 初始化Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">		(*Q).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line">	col = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink)); <span class="comment">/* 生成指向列的最后结点的数组 */</span></span><br><span class="line">	<span class="keyword">if</span> (!col)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 赋初值 */</span></span><br><span class="line">		col[k] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行的顺序相减 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		pm = M.rhead[i]; <span class="comment">/* pm指向矩阵M的第i行的第1个结点 */</span></span><br><span class="line">		pn = N.rhead[i]; <span class="comment">/* pn指向矩阵N的第i行的第1个结点 */</span></span><br><span class="line">		<span class="keyword">while</span> (pm&amp;&amp;pn) <span class="comment">/* pm和pn均不空 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (pm-&gt;j &lt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列小于矩阵N当前结点的列 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">				<span class="keyword">if</span> (!p)</span><br><span class="line">					<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">				(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">				p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">				p-&gt;j = pm-&gt;j;</span><br><span class="line">				p-&gt;e = pm-&gt;e;</span><br><span class="line">				p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">				pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;j &gt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列大于矩阵N当前结点的列 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">				<span class="keyword">if</span> (!p)</span><br><span class="line">					<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">				(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">				p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">				p-&gt;j = pn-&gt;j;</span><br><span class="line">				p-&gt;e = -pn-&gt;e;</span><br><span class="line">				p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">				pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;e - pn-&gt;e) <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之差不为0 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">				<span class="keyword">if</span> (!p)</span><br><span class="line">					<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">				(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">				p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">				p-&gt;j = pn-&gt;j;</span><br><span class="line">				p-&gt;e = pm-&gt;e - pn-&gt;e;</span><br><span class="line">				p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">				pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">				pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之差为0 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">				pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">				(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">				pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">				(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;]所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">				col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (pm) <span class="comment">/* 将矩阵M该行的剩余元素插入矩阵Q */</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">			<span class="keyword">if</span> (!p)</span><br><span class="line">				<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">			(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">			p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">			p-&gt;j = pm-&gt;j;</span><br><span class="line">			p-&gt;e = pm-&gt;e;</span><br><span class="line">			p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">			pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">			<span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">				(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">				pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">				(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">				col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (pn) <span class="comment">/* 将矩阵N该行的剩余元素插入矩阵Q */</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line">			<span class="keyword">if</span> (!p)</span><br><span class="line">				<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">			(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">			p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">			p-&gt;j = pn-&gt;j;</span><br><span class="line">			p-&gt;e = -pn-&gt;e;</span><br><span class="line">			p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">			pn = pn-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">			<span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">				(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">				pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">				(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">				col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++)</span><br><span class="line">		<span class="keyword">if</span> (col[k]) <span class="comment">/* k列有结点 */</span></span><br><span class="line">			col[k]-&gt;down = <span class="literal">NULL</span>; <span class="comment">/* 令该列最后一个结点的down指针为空 */</span></span><br><span class="line">	<span class="built_in">free</span>(col);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">MultSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M的列数等于N的行数。操作结果: 求稀疏矩阵乘积Q=M*N */</span></span><br><span class="line">	<span class="type">int</span> i, j, e;</span><br><span class="line">	OLink q = <span class="literal">NULL</span>, p0, q0, q1 = <span class="literal">NULL</span>, q2;</span><br><span class="line">	<span class="built_in">InitSMatrix</span>(Q);</span><br><span class="line">	(*Q).mu = M.mu;</span><br><span class="line">	(*Q).nu = N.nu;</span><br><span class="line">	(*Q).tu = <span class="number">0</span>;</span><br><span class="line">	(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line">	<span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).mu; i++) <span class="comment">/* 初始化矩阵Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">		(*Q).rhead[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).nu; i++) <span class="comment">/* 初始化矩阵Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">		(*Q).chead[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).mu; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= (*Q).nu; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			p0 = M.rhead[i];</span><br><span class="line">			q0 = N.chead[j];</span><br><span class="line">			e = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (p0&amp;&amp;q0)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (q0-&gt;i &lt; p0-&gt;j)</span><br><span class="line">					q0 = q0-&gt;down; <span class="comment">/* 列指针后移 */</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (q0-&gt;i &gt; p0-&gt;j)</span><br><span class="line">					p0 = p0-&gt;right; <span class="comment">/* 行指针后移 */</span></span><br><span class="line">				<span class="keyword">else</span> <span class="comment">/* q0-&gt;i==p0-&gt;j */</span></span><br><span class="line">				&#123;</span><br><span class="line">					e += p0-&gt;e*q0-&gt;e; <span class="comment">/* 乘积累加 */</span></span><br><span class="line">					q0 = q0-&gt;down; <span class="comment">/* 行列指针均后移 */</span></span><br><span class="line">					p0 = p0-&gt;right;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (e) <span class="comment">/* 值不为0 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">				q = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成结点 */</span></span><br><span class="line">				<span class="keyword">if</span> (!q) <span class="comment">/* 生成结点失败 */</span></span><br><span class="line">					<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">				q-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">				q-&gt;j = j;</span><br><span class="line">				q-&gt;e = e;</span><br><span class="line">				q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">				q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">if</span> (!(*Q).rhead[i]) <span class="comment">/* 行表空时插在行表头 */</span></span><br><span class="line">					(*Q).rhead[i] = q1 = q;</span><br><span class="line">				<span class="keyword">else</span> <span class="comment">/* 否则插在行表尾 */</span></span><br><span class="line">					q1 = q1-&gt;right = q;</span><br><span class="line">				<span class="keyword">if</span> (!(*Q).chead[j]) <span class="comment">/* 列表空时插在列表头 */</span></span><br><span class="line">					(*Q).chead[j] = q;</span><br><span class="line">				<span class="keyword">else</span> <span class="comment">/* 否则插在列表尾 */</span></span><br><span class="line">				&#123;</span><br><span class="line">					q2 = (*Q).chead[j]; <span class="comment">/* q2指向j行第1个结点 */</span></span><br><span class="line">					<span class="keyword">while</span> (q2-&gt;down)</span><br><span class="line">						q2 = q2-&gt;down; <span class="comment">/* q2指向j行最后1个结点 */</span></span><br><span class="line">					q2-&gt;down = q;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">TransposeSMatrix</span><span class="params">(CrossList M, CrossList *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 求稀疏矩阵M的转置矩阵T */</span></span><br><span class="line">	<span class="type">int</span> u, i;</span><br><span class="line">	OLink *head, p, q, r;</span><br><span class="line">	<span class="keyword">if</span> ((*T).rhead)</span><br><span class="line">		<span class="built_in">DestroySMatrix</span>(T);</span><br><span class="line">	<span class="built_in">CopySMatrix</span>(M, T); <span class="comment">/* T=M */</span></span><br><span class="line">	u = (*T).mu; <span class="comment">/* 交换(*T).mu和(*T).nu */</span></span><br><span class="line">	(*T).mu = (*T).nu;</span><br><span class="line">	(*T).nu = u;</span><br><span class="line">	head = (*T).rhead; <span class="comment">/* 交换(*T).rhead和(*T).chead */</span></span><br><span class="line">	(*T).rhead = (*T).chead;</span><br><span class="line">	(*T).chead = head;</span><br><span class="line">	<span class="keyword">for</span> (u = <span class="number">1</span>; u &lt;= (*T).mu; u++) <span class="comment">/* 对T的每一行 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = (*T).rhead[u]; <span class="comment">/* p为行表头 */</span></span><br><span class="line">		<span class="keyword">while</span> (p) <span class="comment">/* 没到表尾,对T的每一结点 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			q = p-&gt;down; <span class="comment">/* q指向下一个结点 */</span></span><br><span class="line">			i = p-&gt;i; <span class="comment">/* 交换.i和.j */</span></span><br><span class="line">			p-&gt;i = p-&gt;j;</span><br><span class="line">			p-&gt;j = i;</span><br><span class="line">			r = p-&gt;down; <span class="comment">/* 交换.down.和right */</span></span><br><span class="line">			p-&gt;down = p-&gt;right;</span><br><span class="line">			p-&gt;right = r;</span><br><span class="line">			p = q; <span class="comment">/* p指向下一个结点 */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*  检验以上操作的主程序 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CrossList A, B, C;</span><br><span class="line">	<span class="built_in">InitSMatrix</span>(&amp;A); <span class="comment">/* CrossList类型的变量在初次使用之前必须初始化 */</span></span><br><span class="line">	<span class="built_in">InitSMatrix</span>(&amp;B);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建矩阵A: &quot;</span>);</span><br><span class="line">	<span class="built_in">CreateSMatrix</span>(&amp;A);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(A);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;由矩阵A复制矩阵B: &quot;</span>);</span><br><span class="line">	<span class="built_in">CopySMatrix</span>(A, &amp;B);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;B); <span class="comment">/* CrossList类型的变量在再次使用之前必须先销毁 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;销毁矩阵B后:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">PrintSMatrix</span>(B);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建矩阵B2:(与矩阵A的行、列数相同，行、列分别为%d,%d)\n&quot;</span>, A.mu, A.nu);</span><br><span class="line">	<span class="built_in">CreateSMatrix</span>(&amp;B);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;矩阵C1(A+B): &quot;</span>);</span><br><span class="line">	<span class="built_in">AddSMatrix</span>(A, B, &amp;C);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;矩阵C2(A-B): &quot;</span>);</span><br><span class="line">	<span class="built_in">SubtSMatrix</span>(A, B, &amp;C);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;矩阵C3(A的转置): &quot;</span>);</span><br><span class="line">	<span class="built_in">TransposeSMatrix</span>(A, &amp;C);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;A);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;B);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建矩阵A2: &quot;</span>);</span><br><span class="line">	<span class="built_in">CreateSMatrix</span>(&amp;A);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(A);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;创建矩阵B3:(行数应与矩阵A2的列数相同=%d)\n&quot;</span>, A.nu);</span><br><span class="line">	<span class="built_in">CreateSMatrix</span>(&amp;B);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;矩阵C5(A*B): &quot;</span>);</span><br><span class="line">	<span class="built_in">MultSMatrix</span>(A, B, &amp;C);</span><br><span class="line">	<span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;A);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;B);</span><br><span class="line">	<span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p><img src="/../image/assets/image-20230630183803349.png" alt="image-20230630183803349"></p>
<p>答：C</p>
<p>存储空间是数组A[21],说明空间大小是MaxSize &#x3D; 21；</p>
<p>rear指向队尾元素，front指向队头元素前一个位置 &#x3D;&#x3D;  rear指向队尾元素下一个的位置，front指向队头元素</p>
<p>所以 长度length &#x3D; rear + MaxSize - front</p>
<p><img src="/../image/assets/image-20230630184303469.png" alt="image-20230630184303469"></p>
<p><img src="/../image/assets/image-20230630184318704.png" alt="image-20230630184318704"></p>
<p>一般情况下队列不为空，删除操作只要修改头指针：head -&gt; next  &#x3D; head -&gt; next -&gt; next;</p>
<p>但是只有一个元素的时候，尾指针也要修改: head -&gt; next &#x3D; NULL; rear &#x3D; head;</p>
<p><img src="/../image/assets/image-20230630184604551.png" alt="image-20230630184604551"></p>
<p><img src="/../image/assets/image-20230630184548970.png" alt="image-20230630184548970"></p>
<p>读题要认真！！！！！！！做法要严谨！！！！！！ 在复习一遍：</p>
<p>入队操作有三步: rear -&gt; next &#x3D; x; x -&gt; next &#x3D; NULL; rear &#x3D; x;</p>
<p><img src="/../image/assets/image-20230630184752987.png" alt="image-20230630184752987"></p>
<p><img src="/../image/assets/image-20230630184808759.png" alt="image-20230630184808759"></p>
<p>进队操作在队尾！！！！！！出队操作在队头！！！！</p>
<p>出队是O(1), 入队是O(n)</p>
<p><img src="/../image/assets/image-20230630185223956.png" alt="image-20230630185223956"></p>
<p><img src="/../image/assets/image-20230630185318491.png" alt="image-20230630185318491"></p>
<p><img src="/../image/assets/image-20230630222455612.png" alt="image-20230630222455612"></p>
<p><img src="/../image/assets/image-20230630222439474.png" alt="image-20230630222439474"></p>
<p>答：A</p>
<p>若存放一个元素A[0]，end1为0，end2为1，所以没有元素（队空）的时候，end1&#x3D;&#x3D;end2</p>
<p>若队满，end1 &#x3D; 0，end2 &#x3D; m-1，所以条件为end1 &#x3D;&#x3D; (end2+1) mod M</p>
<p><img src="/../image/assets/image-20230703220139729.png" alt="image-20230703220139729"></p>
<p><img src="/../image/assets/image-20230703220200177.png" alt="image-20230703220200177"></p>
<p>答：A. ABCD- * -    B. AB-C * D-     C. ABC * -D-    D. AB-CD-*</p>
<p>将ABCD四个后缀表达式写出来，会发现只有B最多两个数存在栈里</p>
<p><img src="/../image/assets/image-20230703220611030.png" alt="image-20230703220611030"></p>
<p><img src="/../image/assets/image-20230703220531448.png" alt="image-20230703220531448"></p>
<p><img src="/../image/assets/image-20230703220549091.png" alt="image-20230703220549091"></p>
<p><img src="/../image/assets/image-20230703220640471.png" alt="image-20230703220640471"></p>
<p><img src="/../image/assets/image-20230703220704632.png" alt="image-20230703220704632"></p>
<p><img src="/../image/assets/image-20230703220816968.png" alt="image-20230703220816968"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sdumoist.github.io">SDUMoist</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sdumoist.github.io/2023/06/28/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">https://sdumoist.github.io/2023/06/28/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sdumoist.github.io" target="_blank">Moist</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%88/">栈</a><a class="post-meta__tags" href="/tags/%E9%98%9F%E5%88%97/">队列</a></div><div class="post_share"><div class="social-share" data-image="/img/background/15.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/01/%E4%B8%B2/" title="字符串"><img class="cover" src="/img/background/25.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">字符串</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/26/%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表"><img class="cover" src="/img/background/15.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线性表</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">SDUMoist</div><div class="author-info__description">一个会点拍照，会点写作，会点生活的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sdumoist"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/sdumoist" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/2076520410@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">做题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">考点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">易错点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E7%9A%84%E6%89%8B%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">中缀转后缀的手算方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E6%9C%BA%E7%AE%97%EF%BC%89"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">中缀表达式转后缀表达式（机算）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9C%BA%E7%AE%97"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">后缀表达式的机算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">知识总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">重要术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">栈顶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%BA%95"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">栈底</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%A0%88"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">空栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">线性表的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">栈的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%B8%B8%E8%80%83%E9%A2%98%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">栈的常考题型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#n%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0%E8%BF%9B%E6%A0%88%EF%BC%8C%E5%87%BA%E6%A0%88%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8D%E5%90%8C%E6%8E%92%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0%E6%9C%891-n-1-Cn-2n"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">n个不同元素进栈，出栈元素的不同排列的个数有1&#x2F;n+1 * Cn 2n</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">顺序栈（顺序存储方式的实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">顺序存储的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">初始化栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">判断栈空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%85%83%E7%B4%A0%E5%85%A5%E6%A0%88%EF%BC%88Push%EF%BC%89"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">新元素入栈（Push）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88-Pop"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">出栈(Pop)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">读栈顶元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">总代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E4%B8%80%E7%A7%8D"><span class="toc-number">1.3.5.</span> <span class="toc-text">共享栈(顺序栈的一种)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">共享栈定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">初始化共享栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%BB%A1"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">判断栈满</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">总代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">1.3.6.</span> <span class="toc-text">链栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.7.</span> <span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">链栈结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA-1"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">判断栈空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88"><span class="toc-number">1.3.7.5.</span> <span class="toc-text">出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.7.6.</span> <span class="toc-text">读取栈顶元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.3.7.7.</span> <span class="toc-text">总代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%9C%AF%E8%AF%AD-1"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">重要术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%A4%B4"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">队头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%B0%BE"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">队尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%98%9F%E5%88%97"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">空队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">队列的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%EF%BC%88%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">顺序队列（队列的顺序实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-%E6%B5%AA%E8%B4%B9%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">定义(浪费一个存储空间)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">判断队空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%98%9F"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E9%98%9F"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">获取队头元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">获取元素个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.4.3.8.</span> <span class="toc-text">总代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%8D%E6%B5%AA%E8%B4%B9%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">1.4.3.9.</span> <span class="toc-text">（不浪费存储空间的方法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%EF%BC%88%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">链队（队列的链式实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">结构体定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E7%A9%BA"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">判空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%98%9F-1"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E9%98%9F-1"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">总代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.4.5.</span> <span class="toc-text">双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B9%EF%BC%9A%E5%88%A4%E6%96%AD%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E5%90%88%E6%B3%95%E6%80%A7"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">考点：判断输出序列合法性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88-1"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">栈和队列的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%EF%BC%9A%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.栈的第一个应用：括号匹配中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">函数代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8F%AF%E8%BF%90%E8%A1%8C%EF%BC%89"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">总代码（可运行）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%BA%94%E7%94%A8%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.栈的第二个应用：表达式的求值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E3%80%81%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">中缀、后缀、前缀表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E7%9A%84%E6%89%8B%E7%AE%97%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">中缀转后缀的手算方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E6%9C%BA%E7%AE%97%EF%BC%89-1"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">中缀表达式转后缀表达式（机算）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%89%8D%E7%BC%80%E7%9A%84%E6%89%8B%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">中缀转前缀的手算方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9C%BA%E7%AE%97"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">前缀表达式的机算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9C%BA%E7%AE%97%EF%BC%88%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">中缀表达式的机算（用栈实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%BA%94%E7%94%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">栈应用的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%94%B9%E5%96%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.8.</span> <span class="toc-text">栈的改善方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%88%E7%9A%84%E7%AC%AC%E5%9B%9B%E4%B8%AA%E5%BA%94%E7%94%A8%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.栈的第四个应用：进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BB%A3%E7%A0%81-5"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">总代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%88%E7%9A%84%E7%AC%AC%E4%BA%94%E4%B8%AA%E5%BA%94%E7%94%A8%EF%BC%9A%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">5. 栈的第五个应用：迷宫求解（深度优先算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">1.队列应用——树的层次遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.6.</span> <span class="toc-text">2.队列的应用：页面替换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-FIFO-%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">先进先出(FIFO)算法使用队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU%EF%BC%88%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%EF%BC%89%E7%AE%97%E6%B3%95%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">LRU（最近最少使用）算法也可以使用双端队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.5.7.</span> <span class="toc-text">3.队列的应用：缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">问题描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9ACPU%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D"><span class="toc-number">1.5.8.</span> <span class="toc-text">4. 队列的应用：CPU资源分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">问题描述：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.5.9.</span> <span class="toc-text">5.队列的应用：图的广度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.5.10.</span> <span class="toc-text">6.队列的应用：特殊矩阵的压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">主要术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">二维数组的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.10.3.</span> <span class="toc-text">对称矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.10.4.</span> <span class="toc-text">三角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.10.5.</span> <span class="toc-text">三对角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.10.6.</span> <span class="toc-text">稀疏矩阵的压缩存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E2%80%94%E2%80%94%E4%B8%89%E5%85%83%E7%BB%84"><span class="toc-number">1.5.10.7.</span> <span class="toc-text">顺序存储——三元组&lt;行，列，值&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">1.5.10.8.</span> <span class="toc-text">十字链表法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.6.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">选择题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/31/2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/" title="2952. 需要添加的硬币的最小数量"><img src="/img/background/7.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2952. 需要添加的硬币的最小数量"/></a><div class="content"><a class="title" href="/2024/03/31/2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/" title="2952. 需要添加的硬币的最小数量">2952. 需要添加的硬币的最小数量</a><time datetime="2024-03-30T17:46:49.000Z" title="发表于 2024-03-31 01:46:49">2024-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/30/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" title="5. 最长回文子串"><img src="/img/background/17.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="5. 最长回文子串"/></a><div class="content"><a class="title" href="/2024/03/30/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" title="5. 最长回文子串">5. 最长回文子串</a><time datetime="2024-03-29T17:53:06.000Z" title="发表于 2024-03-30 01:53:06">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/29/2908-%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%BD%A2%E4%B8%89%E5%85%83%E7%BB%84-I/" title="2908. 元素和最小的山形三元组 I"><img src="/img/background/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2908. 元素和最小的山形三元组 I"/></a><div class="content"><a class="title" href="/2024/03/29/2908-%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%BD%A2%E4%B8%89%E5%85%83%E7%BB%84-I/" title="2908. 元素和最小的山形三元组 I">2908. 元素和最小的山形三元组 I</a><time datetime="2024-03-29T10:31:26.000Z" title="发表于 2024-03-29 18:31:26">2024-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/29/1997-%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="1997. 访问完所有房间的第一天"><img src="/img/background/20.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1997. 访问完所有房间的第一天"/></a><div class="content"><a class="title" href="/2024/03/29/1997-%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/" title="1997. 访问完所有房间的第一天">1997. 访问完所有房间的第一天</a><time datetime="2024-03-28T18:27:49.000Z" title="发表于 2024-03-29 02:27:49">2024-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/26/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/" title="121. 买卖股票的最佳时机"><img src="/img/background/13.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="121. 买卖股票的最佳时机"/></a><div class="content"><a class="title" href="/2024/03/26/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/" title="121. 买卖股票的最佳时机">121. 买卖股票的最佳时机</a><time datetime="2024-03-26T12:09:11.000Z" title="发表于 2024-03-26 20:09:11">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By SDUMoist</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://sdumoist.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>