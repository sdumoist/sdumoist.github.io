<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moist</title>
  
  
  <link href="https://sdumoist.github.io/atom.xml" rel="self"/>
  
  <link href="https://sdumoist.github.io/"/>
  <updated>2024-03-26T12:30:26.920Z</updated>
  <id>https://sdumoist.github.io/</id>
  
  <author>
    <name>SDUMoist</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <link href="https://sdumoist.github.io/2024/03/26/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://sdumoist.github.io/2024/03/26/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2024-03-26T12:09:11.000Z</published>
    <updated>2024-03-26T12:30:26.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为没有系统的总结过解题的方法，所以一般遇到问题习惯于暴力解题</p><p>很不巧，这个题暴力会直接超时</p><p>最一开始，直接暴力遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, len = prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                max = Math.max(prices[i] - prices[j], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后稍微优化还是不行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length, max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len -<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i -<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; prices[j]) min = prices[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; prices[i]-min) max = prices[i]-min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然想到其实可以只遍历一次，毕竟只有数组右边的减去左边的才是有效的，所以采用双指针，慢指针记录数组最小值，快指针负责遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length, max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fastIndex &lt; len)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> prices[fastIndex] -prices[slowIndex];</span><br><span class="line">            <span class="keyword">if</span>(money &gt; max) max = money;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(money &lt; <span class="number">0</span>) slowIndex = fastIndex;</span><br><span class="line"></span><br><span class="line">            fastIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后查看题解，嗯比我想的还要简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minPrice=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            minPrice=Math.min(minPrice, prices[i]);</span><br><span class="line">            ans=Math.max(ans, prices[i]-minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些补充知识"><a href="#一些补充知识" class="headerlink" title="一些补充知识"></a>一些补充知识</h3><p>一开始想着要不要先排序再查找，但是数组号和值的对应是个问题，补充一下二分查找和排序的知识吧</p><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArraySort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//升序</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">      Arrays.sort(arr1);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> values : arr1) &#123;</span><br><span class="line">            System.out.print(values + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="comment">// 1, 2, 5, 8, 10,</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//部分升序</span></span><br><span class="line">      <span class="comment">//Arrays.sort(int[] a, int fromIndex, int toIndex)</span></span><br><span class="line"><span class="comment">//这种形式是对数组部分排序，也就是对数组a的下标从fromIndex到toIndex-1的元素排序</span></span><br><span class="line">      <span class="comment">//注意：下标为toIndex的元素不参与排序哦！</span></span><br><span class="line">      <span class="type">int</span>[] a = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(a, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class="line">        System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="comment">//7 8 9 2 3 4 1 0 6 5</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//降序</span></span><br><span class="line">      <span class="comment">//数组必须是对象数组(Integer)才可以使用上述的逆序排列，原始数组(int)则不能 / 只有泛型数组能传比较器，换句话说必须是Object</span></span><br><span class="line">        Integer[] arr2 = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        Arrays.sort(arr2, Collections.reverseOrder());</span><br><span class="line">      </span><br><span class="line">      Arrays.sort(arr, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">//返回值&gt;0交换</span></span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">       Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">//重写compare方法，最好加注解，不加也没事</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">              <span class="comment">//返回值&gt;0交换</span></span><br><span class="line">                <span class="keyword">return</span> b-a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> values : arr2) &#123;</span><br><span class="line">            System.out.print(values + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="comment">// 10, 8, 5, 2, 1,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数组中查找目标元素的下标。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  被查找的数组（这个必须已经排序的）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> -1 表示该元素不存在，其他表示返回目标元素的下标。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    <span class="comment">// 开始下标。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结束下标.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始元素下标只要在结束元素下标的左边，就有机会继续循环。</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// 中间元素下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == dest) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; dest) &#123;</span><br><span class="line">            <span class="comment">// 目标在“中间“的右边。</span></span><br><span class="line">            <span class="comment">// 开始元素下标需要发生变化（开始元素的下标需要重新赋值）。</span></span><br><span class="line">            begin = mid + <span class="number">1</span>; <span class="comment">// 一直增。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// arr[mid] &gt; dest</span></span><br><span class="line">            <span class="comment">// 目标元素在”中间“左边</span></span><br><span class="line">            <span class="comment">// 修改结束元素下标</span></span><br><span class="line">            end = mid - <span class="number">1</span>; <span class="comment">// 一直减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;121. 买卖股票的最佳时机&quot;&gt;&lt;/a&gt;121. 买卖股票的最佳时机&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; c</summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心" scheme="https://sdumoist.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="简单" scheme="https://sdumoist.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="双指针" scheme="https://sdumoist.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E6%8E%92%E5%BA%8F/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E6%8E%92%E5%BA%8F/</id>
    <published>2024-03-26T10:37:39.000Z</published>
    <updated>2024-03-26T12:38:57.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul><li>堆插入删除过程中，关键字对比次数</li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/./assets/image-20230724224004190.png" alt="image-20230724224004190"></p><p><img src="/./assets/image-20230725152123705.png" alt="image-20230725152123705"></p><p><img src="/./assets/image-20230725160050422.png" alt="image-20230725160050422"></p><p><img src="/./assets/image-20230725162425916.png" alt="image-20230725162425916"></p><p><img src="/./assets/image-20230725174048936.png" alt="image-20230725174048936"></p><p><img src="/./assets/image-20230725175748489.png" alt="image-20230725175748489"></p><p><img src="/./assets/image-20230725195653067.png" alt="image-20230725195653067"></p><p><img src="/./assets/image-20230725201620490.png" alt="image-20230725201620490"></p><p><img src="/./assets/image-20230725210510348.png" alt="image-20230725210510348"></p><p><img src="/./assets/image-20230725215127204.png" alt="image-20230725215127204"></p><p><img src="/./assets/image-20230725224348354.png" alt="image-20230725224348354"></p><p><img src="/./assets/image-20230726143444178.png" alt="image-20230726143444178"></p><p><img src="/./assets/image-20230726145617274.png" alt="image-20230726145617274"></p><p><img src="/./assets/image-20230726152812736.png" alt="image-20230726152812736"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>排序（sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程<ul><li>输入：n 个记录 R1,R2,…,Rn对应的关键字为 k1，k2，k3</li><li>输出：输入序列的一个重排，使得有 K1&lt;&#x3D;K2&lt;&#x3D;K3…&lt;&#x3D;KN（也可以递减）</li></ul></li></ul><p><img src="/./assets/image-20230724223313575.png" alt="image-20230724223313575"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li><p>若待排序表中有两个元素<em>Ri</em>和<em>Rj</em>，其对应的关键字相同即key<em>i</em> &#x3D; key<em>j</em>，且在排序前<em>Ri</em>在<em>Rj</em>的前⾯，若使⽤某⼀排序算法排序后，<em>Ri</em>仍然在<em>Rj</em>的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p><ul><li><p>稳定的：关键字相同的元素在排序之后<strong>相对位置</strong>不变</p></li><li><p>不稳定的：排序之后相对位置会改变</p></li></ul></li><li><p>稳定的排序算法不一定比不稳定排序算法好，看实际需求</p></li></ul><p><img src="/./assets/image-20230724223453761.png" alt="image-20230724223453761"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h4><ul><li>数据都在内存中</li><li>关注点：如何让算法时空复杂度更低</li></ul><h4 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h4><ul><li><p>数据太多，无法全部放入内存</p></li><li><p>关注点：如何使读、写磁盘次数更少</p></li></ul><p><img src="/./assets/image-20230724223944694.png" alt="image-20230724223944694"></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成</li></ul><p><img src="/./assets/image-20230724225344906.png" alt="image-20230724225344906"></p><p><img src="/./assets/image-20230724225359534.png" alt="image-20230724225359534"></p><p><img src="/./assets/image-20230724225409283.png" alt="image-20230724225409283"></p><p><img src="/./assets/image-20230724225419234.png" alt="image-20230724225419234"></p><p><img src="/./assets/image-20230724225435427.png" alt="image-20230724225435427"></p><p><img src="/./assets/image-20230724225445134.png" alt="image-20230724225445134"></p><p><img src="/./assets/image-20230724225455508.png" alt="image-20230724225455508"></p><p><img src="/./assets/image-20230724225506642.png" alt="image-20230724225506642"></p><p><img src="/./assets/image-20230724225520263.png" alt="image-20230724225520263"></p><p><img src="/./assets/image-20230724225529427.png" alt="image-20230724225529427"></p><p><img src="/./assets/image-20230724225539069.png" alt="image-20230724225539069"></p><p><img src="/./assets/image-20230724225548863.png" alt="image-20230724225548863"><br><img src="/./assets/image-20230725144652437.png" alt="image-20230725144652437"></p><p><img src="/./assets/image-20230725144701573.png" alt="image-20230725144701573"></p><p><img src="/./assets/image-20230725144713594.png" alt="image-20230725144713594"></p><p><img src="/./assets/image-20230725144722865.png" alt="image-20230725144722865"></p><p><img src="/./assets/image-20230725144735499.png" alt="image-20230725144735499"></p><p><img src="/./assets/image-20230725144756848.png" alt="image-20230725144756848"></p><p><img src="/./assets/image-20230725144807505.png" alt="image-20230725144807505"></p><p><img src="/./assets/image-20230725144818286.png" alt="image-20230725144818286"></p><p><img src="/./assets/image-20230725144829170.png" alt="image-20230725144829170"></p><p><img src="/./assets/image-20230725144837620.png" alt="image-20230725144837620"></p><p><img src="/./assets/image-20230725144846993.png" alt="image-20230725144846993"></p><p><img src="/./assets/image-20230725144855740.png" alt="image-20230725144855740"></p><p><img src="/./assets/image-20230725144906674.png" alt="image-20230725144906674"></p><p><img src="/./assets/image-20230725144915837.png" alt="image-20230725144915837"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="/./assets/image-20230725144949809.png" alt="image-20230725144949809"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i ++)&#123;             <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;                <span class="comment">//若A[i]关键字小于前驱</span></span><br><span class="line">            temp=A[i];                  <span class="comment">//用temp暂存A[i]</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; temp; j --)      <span class="comment">//检查所有前面已经排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];            <span class="comment">//所有大于temp的元素都将向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法实现（带哨兵）"><a href="#算法实现（带哨兵）" class="headerlink" title="算法实现（带哨兵）"></a>算法实现（带哨兵）</h3><ul><li>优点：不用每轮循环都判断 j&gt;&#x3D;0</li></ul><p><img src="/./assets/image-20230725145012208.png" alt="image-20230725145012208"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序（带哨兵）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort2</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i ++)                <span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;                    <span class="comment">//若A[0]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];                    <span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; A[<span class="number">0</span>]&lt;A[j]; --j)    <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];              <span class="comment">//向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];                  <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul><li><p>空间复杂度：O(1)</p></li><li><p>时间复杂度：主要来自对比关键字、移动元素</p><ul><li>若有n个元素，则需要n-1次处理</li><li>最好情况：原本有序<ul><li>共n-1次处理，每一次都只需要对比关键字1次，不用移动元素</li><li>最好时间复杂度：O(n)</li></ul></li><li>最坏情况：原本是倒序<ul><li>第一趟：对比关键字2次，移动元素3次</li><li>第二趟：对比关键字3次，移动元素4次</li><li>…</li><li>第 i 趟，对比关键字i+1次，移动元素i+2次</li><li>…</li><li>第n-1趟，对比关键字n次，移动元素n+1次</li><li>最坏时间复杂度：O(n^2)</li></ul></li></ul></li><li><p>稳定性：稳定</p></li></ul><p><img src="/./assets/image-20230725145527757.png" alt="image-20230725145527757"></p><p><img src="/./assets/image-20230725145539397.png" alt="image-20230725145539397"></p><p><img src="/./assets/image-20230725145603222.png" alt="image-20230725145603222"></p><p><img src="/./assets/image-20230725145616707.png" alt="image-20230725145616707"></p><h3 id="算法优化（折半查找）"><a href="#算法优化（折半查找）" class="headerlink" title="算法优化（折半查找）"></a>算法优化（折半查找）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>先用折半查找找到应该插入的位置，再移动元素</p></li><li><p>折半查找的终点都是low &gt; high</p><ul><li>将 [low, i-1]内的元素全部右移，并将 A[0]复制到low所指位置</li><li>当 A[mid] &#x3D;&#x3D; A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插入位置</li><li>为了保证算法的稳定性，即使前面排好序的元素中出现与待插入元素相同的元素，也不能停止查找，直到 low &gt; high</li></ul></li></ul><p><img src="/./assets/image-20230725150749312.png" alt="image-20230725150749312"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化——折半插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i ++)&#123;               <span class="comment">//依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];                        <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;                <span class="comment">//设置折半查找范围</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;                  <span class="comment">//折半查找（默认递增有序）</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;           <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>]) high = mid <span class="number">-1</span>;<span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;             <span class="comment">//查找右半子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">            A[j<span class="number">-1</span>] = A[j];                  <span class="comment">//统一后移元素</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];                     <span class="comment">//插入操作</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><ul><li>比起“直接插入排序”，比较关键字的次数减少了，但是移动元素的次数没变</li><li>整体来看时间复杂度依然是O(n^2)</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="元素不相等"><a href="#元素不相等" class="headerlink" title="元素不相等"></a>元素不相等</h5><p><img src="/./assets/image-20230725145928376.png" alt="image-20230725145928376"></p><p><img src="/./assets/image-20230725145938369.png" alt="image-20230725145938369"></p><p><img src="/./assets/image-20230725145947543.png" alt="image-20230725145947543"></p><p><img src="/./assets/image-20230725145959257.png" alt="image-20230725145959257"></p><p><img src="/./assets/image-20230725150008971.png" alt="image-20230725150008971"></p><p><img src="/./assets/image-20230725150018986.png" alt="image-20230725150018986"></p><h5 id="元素相等"><a href="#元素相等" class="headerlink" title="元素相等"></a>元素相等</h5><p><img src="/./assets/image-20230725150112106.png" alt="image-20230725150112106"></p><p><img src="/./assets/image-20230725150123491.png" alt="image-20230725150123491"></p><p><img src="/./assets/image-20230725150136440.png" alt="image-20230725150136440"></p><p><img src="/./assets/image-20230725150146489.png" alt="image-20230725150146489"></p><p><img src="/./assets/image-20230725150159984.png" alt="image-20230725150159984"></p><p><img src="/./assets/image-20230725150211713.png" alt="image-20230725150211713"></p><h5 id="元素最大"><a href="#元素最大" class="headerlink" title="元素最大"></a>元素最大</h5><p><img src="/./assets/image-20230725150352312.png" alt="image-20230725150352312"></p><p><img src="/./assets/image-20230725150402243.png" alt="image-20230725150402243"></p><h5 id="元素最小"><a href="#元素最小" class="headerlink" title="元素最小"></a>元素最小</h5><p><img src="/./assets/image-20230725150416321.png" alt="image-20230725150416321"></p><p><img src="/./assets/image-20230725150426528.png" alt="image-20230725150426528"></p><p><img src="/./assets/image-20230725150436234.png" alt="image-20230725150436234"></p><p><img src="/./assets/image-20230725150448588.png" alt="image-20230725150448588"></p><p><img src="/./assets/image-20230725150500677.png" alt="image-20230725150500677"></p><h3 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a>对链表进行插入排序</h3><ul><li>移动元素的次数变少，但是关键字对比的次数依然是O(n^2)数量级</li><li>整体来看时间复杂度依然是O(n^2)</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul><li><p>对直接插入排序对优化</p></li><li><p>先追求表中元素部分有序，再逐渐逼近全局有序</p></li></ul><p><img src="/./assets/image-20230725152824128.png" alt="image-20230725152824128"></p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>先将待排序表分割成若干形如 L[i, i+的, i+2d,… , i +kd] 的“特殊”子表，对各个子表分别进行直接插入排序。</li><li>缩小增量的，重复上述过程，直到 d&#x3D;1</li><li>希尔本人建议：每次将增量缩小一半</li></ul><p><img src="/./assets/image-20230725152928019.png" alt="image-20230725152928019"></p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><ul><li><p>d1 &#x3D; n&#x2F;2 &#x3D; 4d2 &#x3D; d1&#x2F;2 &#x3D; 2d3 &#x3D; d2 &#x2F;2 &#x3D; 1</p></li><li><p>结果</p></li></ul><p><img src="/./assets/image-20230725153128418.png" alt="image-20230725153128418"></p><ul><li>第一趟</li></ul><p><img src="/./assets/image-20230725153144613.png" alt="image-20230725153144613"></p><p><img src="/./assets/image-20230725153200461.png" alt="image-20230725153200461"></p><p><img src="/./assets/image-20230725153222915.png" alt="image-20230725153222915"></p><p><img src="/./assets/image-20230725153211788.png" alt="image-20230725153211788"></p><ul><li>第二趟</li></ul><p><img src="/./assets/image-20230725153247144.png" alt="image-20230725153247144"></p><p><img src="/./assets/image-20230725153257347.png" alt="image-20230725153257347"></p><p><img src="/./assets/image-20230725153307380.png" alt="image-20230725153307380"></p><p><img src="/./assets/image-20230725153317170.png" alt="image-20230725153317170"></p><ul><li>第三趟</li></ul><p><img src="/./assets/image-20230725153331420.png" alt="image-20230725153331420"></p><p><img src="/./assets/image-20230725153343624.png" alt="image-20230725153343624"></p><p><img src="/./assets/image-20230725153355778.png" alt="image-20230725153355778"></p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><ul><li>d1 &#x3D; 3d2 &#x3D; 1</li></ul><p><img src="/./assets/image-20230725153630391.png" alt="image-20230725153630391"></p><p><img src="/./assets/image-20230725153645310.png" alt="image-20230725153645310"></p><p><img src="/./assets/image-20230725153656108.png" alt="image-20230725153656108"></p><p><img src="/./assets/image-20230725153713761.png" alt="image-20230725153713761"></p><p><img src="/./assets/image-20230725153724639.png" alt="image-20230725153724639"></p><p><img src="/./assets/image-20230725153734875.png" alt="image-20230725153734875"></p><p><img src="/./assets/image-20230725153746266.png" alt="image-20230725153746266"></p><p><img src="/./assets/image-20230725153757283.png" alt="image-20230725153757283"></p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="/./assets/image-20230725154406706.png" alt="image-20230725154406706"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d, i, j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已经找到</span></span><br><span class="line">    <span class="keyword">for</span>(d = n/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d = d/<span class="number">2</span>)           <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i-d])&#123;              <span class="comment">//需要将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i];                <span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j = i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j]; j-=d)</span><br><span class="line">                    A[j+d]=A[<span class="number">0</span>];</span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];                <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230725154806049.png" alt="image-20230725154806049"></p><p><img src="/./assets/image-20230725154816418.png" alt="image-20230725154816418"></p><p><img src="/./assets/image-20230725154825639.png" alt="image-20230725154825639"></p><p><img src="/./assets/image-20230725154838147.png" alt="image-20230725154838147"></p><p><img src="/./assets/image-20230725154848777.png" alt="image-20230725154848777"></p><p><img src="/./assets/image-20230725154900428.png" alt="image-20230725154900428"></p><p><img src="/./assets/image-20230725154910366.png" alt="image-20230725154910366"></p><p><img src="/./assets/image-20230725154920906.png" alt="image-20230725154920906"></p><p><img src="/./assets/image-20230725154931179.png" alt="image-20230725154931179"></p><p><img src="/./assets/image-20230725154949914.png" alt="image-20230725154949914"></p><p><img src="/./assets/image-20230725155000546.png" alt="image-20230725155000546"></p><p><img src="/./assets/image-20230725155011353.png" alt="image-20230725155011353"></p><p><img src="/./assets/image-20230725155022441.png" alt="image-20230725155022441"></p><p><img src="/./assets/image-20230725155032485.png" alt="image-20230725155032485"></p><p><img src="/./assets/image-20230725155042949.png" alt="image-20230725155042949"></p><p><img src="/./assets/image-20230725155052204.png" alt="image-20230725155052204"></p><p><img src="/./assets/image-20230725155102115.png" alt="image-20230725155102115"></p><p><img src="/./assets/image-20230725155111446.png" alt="image-20230725155111446"></p><p><img src="/./assets/image-20230725155121248.png" alt="image-20230725155121248"></p><p><img src="/./assets/image-20230725155130511.png" alt="image-20230725155130511"></p><p><img src="/./assets/image-20230725155140432.png" alt="image-20230725155140432"></p><p><img src="/./assets/image-20230725155149787.png" alt="image-20230725155149787"></p><p><img src="/./assets/image-20230725155159735.png" alt="image-20230725155159735"></p><p><img src="/./assets/image-20230725155241905.png" alt="image-20230725155241905"></p><p><img src="/./assets/image-20230725155300190.png" alt="image-20230725155300190"></p><p><img src="/./assets/image-20230725155310963.png" alt="image-20230725155310963"></p><p><img src="/./assets/image-20230725155321528.png" alt="image-20230725155321528"></p><p><img src="/./assets/image-20230725155332944.png" alt="image-20230725155332944"></p><p><img src="/./assets/image-20230725155341856.png" alt="image-20230725155341856"></p><p><img src="/./assets/image-20230725155351319.png" alt="image-20230725155351319"></p><p><img src="/./assets/image-20230725155402164.png" alt="image-20230725155402164"></p><p><img src="/./assets/image-20230725155411779.png" alt="image-20230725155411779"></p><p><img src="/./assets/image-20230725155433187.png" alt="image-20230725155433187"></p><p><img src="/./assets/image-20230725155444532.png" alt="image-20230725155444532"></p><p><img src="/./assets/image-20230725155454050.png" alt="image-20230725155454050"></p><p><img src="/./assets/image-20230725155502906.png" alt="image-20230725155502906"></p><p><img src="/./assets/image-20230725155514600.png" alt="image-20230725155514600"></p><p><img src="/./assets/image-20230725155523879.png" alt="image-20230725155523879"></p><p><img src="/./assets/image-20230725155533912.png" alt="image-20230725155533912"></p><p><img src="/./assets/image-20230725155543142.png" alt="image-20230725155543142"></p><p><img src="/./assets/image-20230725155555358.png" alt="image-20230725155555358"></p><p><img src="/./assets/image-20230725155606363.png" alt="image-20230725155606363"></p><p><img src="/./assets/image-20230725155616005.png" alt="image-20230725155616005"></p><h3 id="算法实现2"><a href="#算法实现2" class="headerlink" title="算法实现2"></a>算法实现2</h3><ul><li>先处理完一个子表，再处理另一个子表</li></ul><h3 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h3><ul><li>时间复杂度<ul><li>和增量序列 d1, d2, d3… 的选择有关，目前无法通过数学手段证明确切的时间复杂度</li><li>最坏时间复杂度为O(n^2),</li><li>当n再某个范围时，可以达到 O(n^1.3)</li></ul></li></ul><p><img src="/./assets/image-20230725155914064.png" alt="image-20230725155914064"></p><ul><li>稳定性：不稳定</li><li>适用性：仅适用于顺序表，不适用于链表</li></ul><p><img src="/./assets/image-20230725155953367.png" alt="image-20230725155953367"></p><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul><li>基于交换的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>从后往前（或者从前往后）两两比较元素的值，若为逆序（即A[i-1] &gt; A[i]），则交换它们，直到序列比较完</li><li>这样的过程为一趟冒泡排序</li><li>每趟冒泡都可以将最小值放到前面（后面），前面已经确定最终位置的元素不用再进行比较</li><li>总共进行n-1趟冒泡排序</li></ul><p><img src="/./assets/image-20230725160550692.png" alt="image-20230725160550692"></p><p><img src="/./assets/image-20230725160600170.png" alt="image-20230725160600170"></p><p><img src="/./assets/image-20230725160611438.png" alt="image-20230725160611438"></p><p><img src="/./assets/image-20230725160620131.png" alt="image-20230725160620131"></p><p><img src="/./assets/image-20230725160628231.png" alt="image-20230725160628231"></p><p><img src="/./assets/image-20230725160641034.png" alt="image-20230725160641034"></p><p><img src="/./assets/image-20230725160649382.png" alt="image-20230725160649382"></p><p><img src="/./assets/image-20230725160700096.png" alt="image-20230725160700096"></p><p><img src="/./assets/image-20230725160708412.png" alt="image-20230725160708412"></p><p><img src="/./assets/image-20230725160724568.png" alt="image-20230725160724568"></p><p><img src="/./assets/image-20230725160733336.png" alt="image-20230725160733336"></p><p><img src="/./assets/image-20230725160741865.png" alt="image-20230725160741865"></p><p><img src="/./assets/image-20230725160750306.png" alt="image-20230725160750306"></p><p><img src="/./assets/image-20230725160853234.png" alt="image-20230725160853234"></p><p><img src="/./assets/image-20230725160902405.png" alt="image-20230725160902405"></p><p><img src="/./assets/image-20230725160910616.png" alt="image-20230725160910616"></p><p><img src="/./assets/image-20230725160920542.png" alt="image-20230725160920542"></p><p><img src="/./assets/image-20230725161020538.png" alt="image-20230725161020538"></p><p><img src="/./assets/image-20230725161030698.png" alt="image-20230725161030698"></p><p><img src="/./assets/image-20230725161038965.png" alt="image-20230725161038965"></p><p><img src="/./assets/image-20230725161047632.png" alt="image-20230725161047632"></p><p><img src="/./assets/image-20230725161056330.png" alt="image-20230725161056330"></p><p><img src="/./assets/image-20230725161105270.png" alt="image-20230725161105270"></p><p><img src="/./assets/image-20230725161115357.png" alt="image-20230725161115357"></p><p><img src="/./assets/image-20230725161124407.png" alt="image-20230725161124407"></p><p><img src="/./assets/image-20230725161154940.png" alt="image-20230725161154940"></p><p><img src="/./assets/image-20230725161332713.png" alt="image-20230725161332713"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/./assets/image-20230725161925763.png" alt="image-20230725161925763"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;                  <span class="comment">//表示本趟冒泡排序是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>; j &gt; i; j--)        <span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123;              <span class="comment">//若为逆序</span></span><br><span class="line">                <span class="built_in">swap</span>(A[j<span class="number">-1</span>], A[j]);         <span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;           <span class="comment">//本趟遍历没有发生交换，表示表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法性能分析-1"><a href="#算法性能分析-1" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><ul><li><p>空间复杂度：O(n)</p></li><li><p>时间复杂度</p><ul><li>最好情况：有序<ul><li>比较次数 &#x3D; n-1；交换次数 &#x3D; 0;</li><li>最好时间复杂度：O(n)</li></ul></li><li>最坏情况：逆序<ul><li>比较次数 &#x3D; (n-1)+(n-2)+…+1&#x3D; n(n-1)&#x2F;2 &#x3D; 交换次数</li><li>最坏时间复杂度 &#x3D; O(n^2)</li></ul></li><li>平均时间复杂度 &#x3D; O(n^2)</li></ul></li><li><p>稳定性：稳定的</p></li><li><p>适用性：顺序表和链表都适用</p></li></ul><p><img src="/./assets/image-20230725162404997.png" alt="image-20230725162404997"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li><p>在待排序表[1..n]中选取一个元素 pivot 作为枢纽（或基准，通常取首元素）</p></li><li><p>通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1,n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1,n]中的所有元素大于等于pivot</p></li><li><p>pivot放在了最终位置 L[k]上</p></li><li><p>这个过程称为一次“划分”</p></li><li><p>然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上</p></li></ul><p><img src="/./assets/image-20230725164902540.png" alt="image-20230725164902540"></p><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li>一次划分</li></ul><p><img src="/./assets/image-20230725165217109.png" alt="image-20230725165217109"></p><p><img src="/./assets/image-20230725165229896.png" alt="image-20230725165229896"></p><p><img src="/./assets/image-20230725165242031.png" alt="image-20230725165242031"></p><p><img src="/./assets/image-20230725165253940.png" alt="image-20230725165253940"></p><p><img src="/./assets/image-20230725165304030.png" alt="image-20230725165304030"></p><p><img src="/./assets/image-20230725165312840.png" alt="image-20230725165312840"></p><p><img src="/./assets/image-20230725165326259.png" alt="image-20230725165326259"></p><p><img src="/./assets/image-20230725165335459.png" alt="image-20230725165335459"></p><p><img src="/./assets/image-20230725165344946.png" alt="image-20230725165344946"></p><p><img src="/./assets/image-20230725165355208.png" alt="image-20230725165355208"></p><p><img src="/./assets/image-20230725165404411.png" alt="image-20230725165404411"></p><p><img src="/./assets/image-20230725165414180.png" alt="image-20230725165414180"></p><p><img src="/./assets/image-20230725165425152.png" alt="image-20230725165425152"></p><p><img src="/./assets/image-20230725165438932.png" alt="image-20230725165438932"></p><ul><li>第二次划分（左子表）</li></ul><p><img src="/./assets/image-20230725165550539.png" alt="image-20230725165550539"></p><p><img src="/./assets/image-20230725165646400.png" alt="image-20230725165646400"></p><p><img src="/./assets/image-20230725165655414.png" alt="image-20230725165655414"></p><p><img src="/./assets/image-20230725165705841.png" alt="image-20230725165705841"></p><p><img src="/./assets/image-20230725165714818.png" alt="image-20230725165714818"></p><p><img src="/./assets/image-20230725165728560.png" alt="image-20230725165728560"></p><p><img src="/./assets/image-20230725165737305.png" alt="image-20230725165737305"></p><ul><li>第二次划分（右子表）</li></ul><p><img src="/./assets/image-20230725165748596.png" alt="image-20230725165748596"></p><p><img src="/./assets/image-20230725165757908.png" alt="image-20230725165757908"></p><p><img src="/./assets/image-20230725165807664.png" alt="image-20230725165807664"></p><p><img src="/./assets/image-20230725165817572.png" alt="image-20230725165817572"></p><p><img src="/./assets/image-20230725165828077.png" alt="image-20230725165828077"></p><p><img src="/./assets/image-20230725165838514.png" alt="image-20230725165838514"></p><p><img src="/./assets/image-20230725165849058.png" alt="image-20230725165849058"></p><p><img src="/./assets/image-20230725165906203.png" alt="image-20230725165906203"></p><p><img src="/./assets/image-20230725170039023.png" alt="image-20230725170039023"></p><ul><li>第三次划分（左子表）</li></ul><p><img src="/./assets/image-20230725170025626.png" alt="image-20230725170025626"></p><p><img src="/./assets/image-20230725170057204.png" alt="image-20230725170057204"></p><p><img src="/./assets/image-20230725170107198.png" alt="image-20230725170107198"></p><p><img src="/./assets/image-20230725170117092.png" alt="image-20230725170117092"></p><p><img src="/./assets/image-20230725170133088.png" alt="image-20230725170133088"></p><p><img src="/./assets/image-20230725170918658.png" alt="image-20230725170918658"></p><p><img src="/./assets/image-20230725170927903.png" alt="image-20230725170927903"></p><h4 id="代码实现（最重要）"><a href="#代码实现（最重要）" class="headerlink" title="代码实现（最重要）"></a>代码实现（最重要）</h4><p><img src="/./assets/image-20230725170943141.png" alt="image-20230725170943141"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];                       <span class="comment">//第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;                      <span class="comment">//用low、high搜索枢纽的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high];                   <span class="comment">//比枢纽小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) ++high;    </span><br><span class="line">        A[high]=A[low];                     <span class="comment">//比枢纽大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;                         <span class="comment">//枢纽元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;                             <span class="comment">//返回存放枢纽的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;                         <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high); <span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A, low, pivotpos<span class="number">-1</span>);      <span class="comment">//划分左子表</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivotpos + <span class="number">1</span>, high);   <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230726162750805.png" alt="image-20230726162750805"></p><h4 id="算法效率分析-1"><a href="#算法效率分析-1" class="headerlink" title="算法效率分析"></a>算法效率分析</h4><ul><li><p>所有内部排序算法中，平均性能最优秀的排序算法</p></li><li><p>时间复杂度</p><ul><li><p><strong>每⼀层的</strong> QuickSort <strong>只需要处理剩余的</strong> <strong>待排序元素，时间复杂度不超过</strong>O(n)</p></li><li><p>时间复杂度&#x3D;O(n*递归层数)</p></li></ul></li><li><p>空间复杂度</p><ul><li>空间复杂度 &#x3D; O(递归层数)</li></ul></li><li><p>把n个元素组织成二叉树，二叉树的层数就是递归调用的层数</p><ul><li>n个节点的二叉树<ul><li>最小高度 &#x3D; log2n + 1</li><li>最大高度 &#x3D; n</li></ul></li><li>最好时间复杂度 &#x3D;  O(nlog2n)</li><li>最坏时间复杂度 &#x3D;  O(n^2)</li><li>平均时间复杂度 &#x3D; O(nlog2n)</li><li>最好空间复杂度 &#x3D;  O(log2n)</li><li>最坏空间复杂度 &#x3D; O(n)</li><li>最好情况（枢纽在中间）<ul><li>若每一次选中的“枢纽：将排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高</li><li>若每次选中的“枢纽”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高</li></ul></li><li>最坏情况（有序或逆序）<ul><li>若每一次选中的“枢纽”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低</li><li>若初始序列有序或逆序，则快速排序的性能最差（每次选中的都是最靠边的元素）</li></ul></li></ul></li><li><p>优化思路</p><ul><li>尽量选择可以把数据中分的枢纽元素<ul><li>选中头、中、尾三个位置的元素，取中间值作为枢纽元素</li><li>随机选一个元素作为枢轴元素</li></ul></li></ul></li><li><p>稳定性：不稳定</p></li></ul><p><img src="/./assets/image-20230725173927315.png" alt="image-20230725173927315"></p><p><img src="/./assets/image-20230725173943495.png" alt="image-20230725173943495"></p><ul><li>时间复杂度</li></ul><p><img src="/./assets/image-20230725172049560.png" alt="image-20230725172049560"></p><ul><li>空间复杂度</li></ul><p><img src="/./assets/image-20230725172443319.png" alt="image-20230725172443319"></p><ul><li>转换成二叉排序树</li></ul><p><img src="/./assets/image-20230725172555373.png" alt="image-20230725172555373"></p><ul><li>最坏的情况（逆序）</li></ul><p><img src="/./assets/image-20230725173155889.png" alt="image-20230725173155889"></p><ul><li>比较好的情况</li></ul><p><img src="/./assets/image-20230725173438773.png" alt="image-20230725173438773"></p><h4 id="一趟排序-一次划分"><a href="#一趟排序-一次划分" class="headerlink" title="一趟排序 !&#x3D; 一次划分"></a>一趟排序 !&#x3D; 一次划分</h4><ul><li>一趟排序：可以确定多个元素的位置</li><li>一次划分：只能确定一个元素的位置</li></ul><p><img src="/./assets/image-20230725174202608.png" alt="image-20230725174202608"></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列</li></ul><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>每一趟在待排序元素中选取关键字最小的元素加入有序子序列<ul><li>如果遇到两个相同的最小元素，则选择位置靠前的</li></ul></li><li>最后剩一个不用处理<ul><li>n个元素的简单选择排序需要n-1趟处理</li></ul></li></ul><p><img src="/./assets/image-20230725174457542.png" alt="image-20230725174457542"></p><p><img src="/./assets/image-20230725174506146.png" alt="image-20230725174506146"></p><p><img src="/./assets/image-20230725174515310.png" alt="image-20230725174515310"></p><p><img src="/./assets/image-20230725174523975.png" alt="image-20230725174523975"></p><p><img src="/./assets/image-20230725174534231.png" alt="image-20230725174534231"></p><p><img src="/./assets/image-20230725174547275.png" alt="image-20230725174547275"></p><p><img src="/./assets/image-20230725174555452.png" alt="image-20230725174555452"></p><p><img src="/./assets/image-20230725174614500.png" alt="image-20230725174614500"></p><p><img src="/./assets/image-20230725174627664.png" alt="image-20230725174627664"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/./assets/image-20230725175408335.png" alt="image-20230725175408335"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;           <span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min =i;                         <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)      <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min]) min = i;      <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(A[i], A[min]);    <span class="comment">//封装的swap()函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法性能分析-2"><a href="#算法性能分析-2" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><ul><li><p>空间复杂度 &#x3D; O(1)</p></li><li><p>时间复杂度 &#x3D; O(n^2)</p><ul><li>无论有序、逆序、还输乱序，一定需要n-1趟处理</li><li>总共需要对比关键字（n-1)+(n-2)+(n-3)+….+1 &#x3D; n(n-1)&#x2F;2 次</li></ul></li><li><p>稳定性：不稳定</p></li><li><p>适用性：既可以用于顺序表，也可以用于链表</p></li></ul><p><img src="/./assets/image-20230725175721087.png" alt="image-20230725175721087"></p><p><img src="/./assets/image-20230725175730921.png" alt="image-20230725175730921"></p><h3 id="堆排序（重点）"><a href="#堆排序（重点）" class="headerlink" title="堆排序（重点）"></a>堆排序（重点）</h3><h4 id="堆-heap-顺序存储的完全二叉树"><a href="#堆-heap-顺序存储的完全二叉树" class="headerlink" title="堆(heap):顺序存储的完全二叉树"></a>堆(heap):顺序存储的完全二叉树</h4><ul><li>若n个关键字序列L[1….n] 满足下面某一条性质，则称为堆（Heap）<ul><li>大根堆（大顶堆）：若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>&#x2F;2 ）<ul><li>完全二叉树中：根 &gt;&#x3D; 左右</li></ul></li><li>小根堆（小顶堆）：若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>&#x2F;2 ） <ul><li>完全二叉树中：根 &lt;&#x3D; 左右</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230725180409165.png" alt="image-20230725180409165"></p><h5 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h5><p><img src="/./assets/image-20230725180215700.png" alt="image-20230725180215700"></p><h4 id="构建操作"><a href="#构建操作" class="headerlink" title="构建操作"></a>构建操作</h4><h5 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h5><ul><li>堆顶元素关键字最大</li></ul><h5 id="简单选择排序-VS-堆排序"><a href="#简单选择排序-VS-堆排序" class="headerlink" title="简单选择排序 VS 堆排序"></a>简单选择排序 VS 堆排序</h5><ul><li><p>简单选择排序：每⼀趟在待排序元素中选取关键字最⼤的元素加⼊有序⼦序列</p></li><li><p>堆排序：每⼀趟将堆顶元素加⼊有序⼦序列（与待排序序列中的最后⼀个元素交换）</p></li></ul><h5 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h5><ul><li><p>思路</p><ul><li>把所有非终端节点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</li><li><strong>在顺序存储的完全二叉树中，非终端节点编号i &lt;&#x3D; [n&#x2F;2]</strong></li></ul></li><li><p>调整</p><ul><li>从 i &#x3D; n&#x2F;2 开始检查当前节点（i &lt;&#x3D; n&#x2F;2）是否满足 <strong>根 &gt;&#x3D; 左、右</strong></li><li>若不满足，将当前节点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整<strong>（小元素不断“下坠”）</strong></li><li>小元素无法下坠，则调整完成</li></ul></li></ul><p><img src="/./assets/image-20230725185515129.png" alt="image-20230725185515129"></p><p><img src="/./assets/image-20230725185543386.png" alt="image-20230725185543386"></p><p><img src="/./assets/image-20230725190017364.png" alt="image-20230725190017364"></p><p><img src="/./assets/image-20230725190026570.png" alt="image-20230725190026570"></p><p><img src="/./assets/image-20230725190036919.png" alt="image-20230725190036919"></p><p><img src="/./assets/image-20230725190045953.png" alt="image-20230725190045953"></p><p><img src="/./assets/image-20230725190056157.png" alt="image-20230725190056157"></p><p><img src="/./assets/image-20230725190105695.png" alt="image-20230725190105695"></p><p><img src="/./assets/image-20230725190114473.png" alt="image-20230725190114473"></p><p><img src="/./assets/image-20230725190125706.png" alt="image-20230725190125706"></p><p><img src="/./assets/image-20230725190137290.png" alt="image-20230725190137290"></p><p><img src="/./assets/image-20230725190145791.png" alt="image-20230725190145791"></p><h5 id="构建的代码实现"><a href="#构建的代码实现" class="headerlink" title="构建的代码实现"></a>构建的代码实现</h5><p><img src="/./assets/image-20230725190229628.png" alt="image-20230725190229628"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                            <span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])  </span><br><span class="line">            i++;                            <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;             <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                               </span><br><span class="line">            A[k] =A[i];                     <span class="comment">//将A[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                          <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];                            <span class="comment">//被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)          <span class="comment">//从后往前调整所有非终端节点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230725191359187.png" alt="image-20230725191359187"></p><p><img src="./assets/image-20230725191411362.png" alt="image-20230725191411362" style="zoom: 33%;" /><img src="./assets/image-20230725191632663.png" alt="image-20230725191632663" style="zoom:33%;" /></p><p><img src="./assets/image-20230725191716515.png" alt="image-20230725191716515" style="zoom:33%;" /><img src="./assets/image-20230725191732707.png" alt="image-20230725191732707" style="zoom:33%;" /></p><p><img src="./assets/image-20230725191841331.png" alt="image-20230725191841331" style="zoom:33%;" /><img src="./assets/image-20230725191856662.png" alt="image-20230725191856662" style="zoom:33%;" /></p><p><img src="./assets/image-20230725191938091.png" alt="image-20230725191938091" style="zoom:33%;" /><img src="./assets/image-20230725191951907.png" alt="image-20230725191951907" style="zoom:33%;" /></p><p><img src="./assets/image-20230725192011696.png" alt="image-20230725192011696" style="zoom:33%;" /><img src="./assets/image-20230725192034371.png" alt="image-20230725192034371" style="zoom:33%;" /></p><h5 id="排序操作（基于大根堆）"><a href="#排序操作（基于大根堆）" class="headerlink" title="排序操作（基于大根堆）"></a>排序操作（基于大根堆）</h5><ul><li>选择排序：每一趟在待排序元素中选取关键字最大的元素加入有序子序列</li><li>堆排序：每一趟将<strong>堆顶元素</strong>加入有序子序列（与待排序序列中的最后一个元素交换），并将<strong>待排序元素序列</strong>再次调整为大根堆<ul><li>堆排序的堆顶元素就是整个堆中最大的元素</li></ul></li></ul><p><img src="/./assets/image-20230725192820097.png" alt="image-20230725192820097"></p><p><img src="/./assets/image-20230725193119688.png" alt="image-20230725193119688"></p><p><img src="/./assets/image-20230725193139538.png" alt="image-20230725193139538"></p><p><img src="/./assets/image-20230725193148450.png" alt="image-20230725193148450"></p><p><img src="/./assets/image-20230725193158206.png" alt="image-20230725193158206"></p><p><img src="/./assets/image-20230725193210680.png" alt="image-20230725193210680"></p><p><img src="/./assets/image-20230725193221058.png" alt="image-20230725193221058"></p><p><img src="/./assets/image-20230725193230826.png" alt="image-20230725193230826"></p><p><img src="/./assets/image-20230725193241459.png" alt="image-20230725193241459"></p><p><img src="/./assets/image-20230725193253337.png" alt="image-20230725193253337"></p><p><img src="/./assets/image-20230725193302782.png" alt="image-20230725193302782"></p><p><img src="/./assets/image-20230725193311833.png" alt="image-20230725193311833"></p><p><img src="/./assets/image-20230725193321733.png" alt="image-20230725193321733"></p><p><img src="/./assets/image-20230725193331222.png" alt="image-20230725193331222"></p><p><img src="/./assets/image-20230725193340233.png" alt="image-20230725193340233"></p><p><img src="/./assets/image-20230725193349899.png" alt="image-20230725193349899"></p><p><img src="/./assets/image-20230725193359389.png" alt="image-20230725193359389"></p><p><img src="/./assets/image-20230725193410553.png" alt="image-20230725193410553"></p><p><img src="/./assets/image-20230725193422264.png" alt="image-20230725193422264"></p><p><img src="/./assets/image-20230725193432992.png" alt="image-20230725193432992"></p><p><img src="/./assets/image-20230725193442820.png" alt="image-20230725193442820"></p><p><img src="/./assets/image-20230725193452779.png" alt="image-20230725193452779"></p><p><img src="/./assets/image-20230725193502129.png" alt="image-20230725193502129"></p><p><img src="/./assets/image-20230725193511012.png" alt="image-20230725193511012"></p><p><img src="/./assets/image-20230725193532774.png" alt="image-20230725193532774"></p><p><img src="/./assets/image-20230725193543015.png" alt="image-20230725193543015"></p><p><img src="/./assets/image-20230725193552731.png" alt="image-20230725193552731"></p><p><img src="/./assets/image-20230725193602185.png" alt="image-20230725193602185"></p><p><img src="/./assets/image-20230725193612890.png" alt="image-20230725193612890"></p><p><img src="/./assets/image-20230725193717193.png" alt="image-20230725193717193"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/./assets/image-20230725193745319.png" alt="image-20230725193745319"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                            <span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])  </span><br><span class="line">            i++;                            <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;             <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                               </span><br><span class="line">            A[k] =A[i];                     <span class="comment">//将A[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                          <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];                            <span class="comment">//被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)          <span class="comment">//从后往前调整所有非终端节点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(A, len);                   <span class="comment">//初始建模</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len; i&gt;<span class="number">1</span>; i--)&#123;             <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[<span class="number">1</span>]);                   <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, <span class="number">1</span>, i<span class="number">-1</span>);              <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法效率分析-2"><a href="#算法效率分析-2" class="headerlink" title="算法效率分析"></a>算法效率分析</h4><p><img src="/./assets/image-20230725195011852.png" alt="image-20230725195011852"></p><ul><li><p>时间复杂度</p><ul><li><p>BuildMaxHeap(int A[], int len)</p><ul><li>一个节点，每下坠一层，最多只需对比关键字2次</li><li>若树高为h，某节点在第 i 层，则将这个节点向下调整最多只需要下坠 h-i 层，关键字对比次数不超过 2(h-i)</li><li>n个节点的完全二叉树树高 h &#x3D; [log2n] + 1</li><li>第 i 层最多有 2^(i-1) 个节点，而只有第 1～(h-1)层的节点才有可能需要下坠调整</li><li>结论：建立初始堆的过程中，关键字对比次数不超过4n，<strong>建堆时间复杂度&#x3D; O(n)</strong></li></ul></li><li><p>HeapSort(int A[], int len)</p><ul><li>总共需要下坠n-1层</li><li>每下坠一层，最多只需对比关键字2次，每一趟排序复杂度不超过 O(h) &#x3D; O(log2n)</li><li>结论：总的时间复杂度 &#x3D; O(nlog2n)</li></ul></li></ul></li><li><p>堆排序的时间复杂度 &#x3D; <em>O</em>(<em>n</em>) + <em>O</em>(<em>nlog</em>2<em>n</em>) &#x3D; <em>O</em>(<em>nlog</em>2<em>n</em>) </p></li><li><p>堆排序的空间复杂度 &#x3D; <em>O</em>(1)</p></li><li><p>稳定性：不稳定</p></li></ul><p><img src="/./assets/image-20230725194857989.png" alt="image-20230725194857989"></p><p>  <img src="/./assets/image-20230725194925131.png" alt="image-20230725194925131"></p><p><img src="/./assets/image-20230725195413220.png" alt="image-20230725195413220"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>对于小根堆<ul><li>新元素放到表尾，与父节点对比</li><li>若新元素比父节点<strong>更小</strong>，则将两者互换</li><li>新元素这样一路上升，直到无法继续上升为止</li></ul></li><li>对于大根堆<ul><li>新元素放到表尾，与父节点对比</li><li>若新元素比父节点<strong>更大</strong>，则将两者互换</li><li>新元素这样一路上升，直到无法继续上升为止</li></ul></li></ul><p><img src="/./assets/image-20230725200533958.png" alt="image-20230725200533958"></p><p><img src="/./assets/image-20230725200823026.png" alt="image-20230725200823026"></p><p><img src="/./assets/image-20230725200832805.png" alt="image-20230725200832805"></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>对于小根堆<ul><li>被删除的元素用堆底元素替代</li><li>比较该元素与<strong>更小的孩子节点</strong>的元素，如果<strong>大于孩子节点</strong>，让该元素不断下坠</li><li>直到无法下坠为止</li></ul></li><li>对于大根堆<ul><li>被删除的元素用堆底元素替代</li><li>比较该元素与<strong>更大的孩子节点</strong>的元素，如果<strong>小于孩子节点</strong>，让该元素下坠</li><li>直到无法下坠为止</li></ul></li></ul><p><img src="/./assets/image-20230725201337325.png" alt="image-20230725201337325"></p><p><img src="/./assets/image-20230725201352015.png" alt="image-20230725201352015"></p><p><img src="/./assets/image-20230725201401545.png" alt="image-20230725201401545"></p><p><img src="/./assets/image-20230725201320610.png" alt="image-20230725201320610"></p><p><img src="/./assets/image-20230725201416696.png" alt="image-20230725201416696"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>归并：把两个或多个已经有序的序列合并为一个</li></ul><h4 id="二路归并"><a href="#二路归并" class="headerlink" title="二路归并"></a>二路归并</h4><ul><li><p><strong>对比 i 、j 所指元素，选择更小的一个放入 k 所指位置</strong></p></li><li><p>当一个有序序列已经放完之后，另一个有序序列剩下的值可以依次放入合并序列</p></li><li><p>2个有序序列合并成一个</p></li><li><p>每选出一个小元素需要对比关键字1次</p></li></ul><p><img src="/./assets/image-20230725203021969.png" alt="image-20230725203021969"></p><ul><li>二路归并操作</li></ul><p><img src="/./assets/image-20230725202651174.png" alt="image-20230725202651174"></p><p><img src="/./assets/image-20230725203038524.png" alt="image-20230725203038524"></p><p><img src="/./assets/image-20230725203047872.png" alt="image-20230725203047872"></p><p><img src="/./assets/image-20230725203059487.png" alt="image-20230725203059487"></p><p><img src="/./assets/image-20230725203109773.png" alt="image-20230725203109773"></p><p><img src="/./assets/image-20230725203119949.png" alt="image-20230725203119949"></p><p><img src="/./assets/image-20230725203130240.png" alt="image-20230725203130240"></p><p><img src="/./assets/image-20230725203140609.png" alt="image-20230725203140609"></p><p><img src="/./assets/image-20230725203152316.png" alt="image-20230725203152316"></p><p><img src="/./assets/image-20230725203207077.png" alt="image-20230725203207077"></p><p><img src="/./assets/image-20230725203219245.png" alt="image-20230725203219245"></p><h4 id="4路归并"><a href="#4路归并" class="headerlink" title="4路归并"></a>4路归并</h4><ul><li><p>4个有序序列合并成一个</p></li><li><p>每选出一个小元素需要对比关键字3次</p></li></ul><p><img src="/./assets/image-20230725203402908.png" alt="image-20230725203402908"></p><h4 id="m路归并"><a href="#m路归并" class="headerlink" title="m路归并"></a>m路归并</h4><ul><li><p>M个有序序列合并成一个</p></li><li><p>每选出一个小元素需要对比关键字m -1次</p></li></ul><h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><ul><li>内部排序中一般采用2路归并</li></ul><p><img src="/./assets/image-20230725203421526.png" alt="image-20230725203421526"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="一次归并"><a href="#一次归并" class="headerlink" title="一次归并"></a>一次归并</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> *B = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k&lt;=high; k++)</span><br><span class="line">        B[k]=A[k];                          <span class="comment">//将A中所有的元素复制到B中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) A[k]=B[i++];         <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span> A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230725204009409.png" alt="image-20230725204009409"></p><p><img src="/./assets/image-20230725204827555.png" alt="image-20230725204827555"></p><p><img src="/./assets/image-20230725204838432.png" alt="image-20230725204838432"></p><p><img src="/./assets/image-20230725204849672.png" alt="image-20230725204849672"></p><p><img src="/./assets/image-20230725204859933.png" alt="image-20230725204859933"></p><p><img src="/./assets/image-20230725204915610.png" alt="image-20230725204915610"></p><p><img src="/./assets/image-20230725204926506.png" alt="image-20230725204926506"></p><p><img src="/./assets/image-20230725204937719.png" alt="image-20230725204937719"></p><p><img src="/./assets/image-20230725204947549.png" alt="image-20230725204947549"></p><p><img src="/./assets/image-20230725205003729.png" alt="image-20230725205003729"></p><p><img src="/./assets/image-20230725205017025.png" alt="image-20230725205017025"></p><p><img src="/./assets/image-20230725205033397.png" alt="image-20230725205033397"></p><p><img src="/./assets/image-20230725205043997.png" alt="image-20230725205043997"></p><p><img src="/./assets/image-20230725205055844.png" alt="image-20230725205055844"></p><p><img src="/./assets/image-20230725205114216.png" alt="image-20230725205114216"></p><h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><ul><li><p>将一个序列从中间分成两个子序列</p></li><li><p>将左右两个子序列分别进行归并排序得到两个有序子序列</p></li><li><p>然后两个子序列进行归并</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> *B = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k&lt;=high; k++)</span><br><span class="line">        B[k]=A[k];                          <span class="comment">//将A中所有的元素复制到B中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) A[k]=B[i++];         <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span> A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;           <span class="comment">//从中间划分</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A,low,mid);               <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A,mid+<span class="number">1</span>,high);            <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(A,low,mid,high);              <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230725205700754.png" alt="image-20230725205700754"></p><h3 id="算法效率分析-3"><a href="#算法效率分析-3" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul><li><strong>时间复杂度：归并排序——O(nlog2n)     每趟归并——O(n)    归并次数——O(log2n)</strong><ul><li>2路归并到归并树——形态上就是一棵倒立的二叉树<ul><li>二叉树的第h层最多有2^(h-1)个节点</li><li>若树高为h，则应满足 n&lt;&#x3D;2^(h-1)</li><li>即 h-1 &#x3D; log2n</li></ul></li><li>结论：n个元素进行二路归并排序，归并的趟数log2n，每趟归并时间复杂度O(n)，算法时间复杂度O(n*log2n)</li></ul></li><li><strong>空间复杂度 &#x3D; O(n)，辅助数组B</strong></li><li>稳定性：稳定的</li></ul><p><img src="/./assets/image-20230725205921824.png" alt="image-20230725205921824"></p><h2 id="基数排序（Radix-Sort）（手算）"><a href="#基数排序（Radix-Sort）（手算）" class="headerlink" title="基数排序（Radix Sort）（手算）"></a>基数排序（Radix Sort）（手算）</h2><ul><li>不是基于比较的排序算法</li><li>通常基于链式存储实现</li></ul><p><img src="/./assets/image-20230725214935131.png" alt="image-20230725214935131"></p><h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><ul><li><p>从<strong>个位</strong>开始进行<strong>分配入队</strong>（队列先进先出），直到最大数字的最高位</p></li><li><p>每次分配完都进行一次收集，按照从9~0的顺序，下一次分配也按照上一次收集的顺序进行分配</p></li><li><p>例子</p><ul><li><p>第一趟</p><ul><li>按个位进行分配，<strong>先分配的先入队</strong></li><li>收集结束：得到按<strong>个位递减</strong>排序的序列</li></ul></li><li><p>第二趟</p><ul><li>将第一趟收集得到的序列，按十位进行分配，<strong>个位越大的越先入队</strong></li><li>收集结束：得到按<strong>十位递减</strong>排序的序列，<strong>十位相同的按照个位递减</strong>排序</li></ul></li><li><p>第三趟</p><ul><li>将第二趟收集得到的序列，按百位进行分配，<strong>十位越大的越先入队</strong></li><li>收集结束：得到按<strong>百位递减</strong>排序的序列，百位相同的按照十位递减排序，十位相同的按照个位递减排序</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230725212520973.png" alt="image-20230725212520973"></p><ul><li><p>文字描述</p><ul><li><p>假设⻓度为n的线性表中每个结点<em>a**j</em>的关键字由<em>d</em>元组 (<em>kjd</em>−1, <em>kjd</em>−2, <em>kjd</em>−3, . . . , <em>kj</em>1, <em>kj</em>0) 组成</p><p>其中，0≤kij ≤ r - 1（0≤j＜n, 0≤i≤d - 1），r 称为“基数”（0～9，r&#x3D;10）</p><ul><li>例如：985 由 (9,8,5) 组成<ul><li>最高位关键字（最主位关键字）：9</li><li>最低位关键字（最次位关键字）：5</li></ul></li></ul></li><li><p>基数排序得到递减序列的过程如下</p><ul><li>初始化： 设置 <strong>r 个空队列</strong>，Qr-1, Qr-2,…, Q0 </li><li>按照各个 <strong>关键字位</strong> <strong>权重递增</strong>的次序（个、⼗、百），对 d 个关键字位分别做“分配”和“收集”</li><li>分配：顺序扫描各个元素，若当前处理的关键字位&#x3D;x，则将元素插⼊ Qx 队尾</li><li>收集：把 Qr-1, Qr-2,…, Q0 各个队列中的结点依次出队并链接</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230725213040387.png" alt="image-20230725213040387"></p><ul><li>第一趟 分配+收集</li></ul><p><img src="/./assets/image-20230725210817695.png" alt="image-20230725210817695"></p><p><img src="/./assets/image-20230725210828667.png" alt="image-20230725210828667"></p><p><img src="/./assets/image-20230725210844009.png" alt="image-20230725210844009"></p><p><img src="/./assets/image-20230725211001130.png" alt="image-20230725211001130"></p><p><img src="/./assets/image-20230725210940638.png" alt="image-20230725210940638"></p><ul><li>第二趟</li></ul><p><img src="/./assets/image-20230725211633444.png" alt="image-20230725211633444"></p><p><img src="/./assets/image-20230725211905553.png" alt="image-20230725211905553"></p><p><img src="/./assets/image-20230725211919446.png" alt="image-20230725211919446"></p><p><img src="/./assets/image-20230725211931366.png" alt="image-20230725211931366"></p><p><img src="/./assets/image-20230725211949903.png" alt="image-20230725211949903"></p><ul><li>第三趟</li></ul><p><img src="/./assets/image-20230725212348607.png" alt="image-20230725212348607"></p><p><img src="/./assets/image-20230725212406668.png" alt="image-20230725212406668"></p><p><img src="/./assets/image-20230725212420245.png" alt="image-20230725212420245"></p><p><img src="/./assets/image-20230725212430973.png" alt="image-20230725212430973"></p><p><img src="/./assets/image-20230725212450165.png" alt="image-20230725212450165"></p><h3 id="算法效率分析-4"><a href="#算法效率分析-4" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elemtype int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><ul><li>基数排序通常基于链式存储实现</li><li>空间复杂度 &#x3D; O(r)：需要 r 个辅助队列</li><li>时间复杂度 &#x3D; O(d*(n+r))：一趟分配O(n)，一趟收集O(r)，总共d趟分配收集</li><li>稳定性：稳定的</li></ul><p><img src="/./assets/image-20230725213852693.png" alt="image-20230725213852693"></p><ul><li>收集一个队列只需要O(1)</li></ul><p><img src="/./assets/image-20230725214449076.png" alt="image-20230725214449076"></p><p><img src="/./assets/image-20230725214510767.png" alt="image-20230725214510767"></p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p><img src="/./assets/image-20230725214715643.png" alt="image-20230725214715643"></p><h4 id="适合解决的问题"><a href="#适合解决的问题" class="headerlink" title="适合解决的问题"></a>适合解决的问题</h4><ul><li>数据元素的关键字可以方便的拆分为 d 组，且d较小</li><li>每组关键字的取值范围不大，即 r 较小</li><li>数据元素个数 n 较大</li></ul><p><img src="/./assets/image-20230725214834606.png" alt="image-20230725214834606"></p><h4 id="不适合解决的问题"><a href="#不适合解决的问题" class="headerlink" title="不适合解决的问题"></a>不适合解决的问题</h4><p><img src="/./assets/image-20230725215006532.png" alt="image-20230725215006532"></p><h2 id="外部排序-1"><a href="#外部排序-1" class="headerlink" title="外部排序"></a>外部排序</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="外存与内存之间的数据交换"><a href="#外存与内存之间的数据交换" class="headerlink" title="外存与内存之间的数据交换"></a>外存与内存之间的数据交换</h4><ul><li>外存：磁盘</li><li>内存</li><li>操作系统以“块”为单位对磁盘存储空间进行管理，如：每块大小1KB；各个磁盘块内存放着各种各样的数据</li><li>磁盘的读&#x2F;写以“块”为单位，数据读入内存后才能被修改，修改完了还要写回磁盘</li></ul><p><img src="/./assets/image-20230725215415099.png" alt="image-20230725215415099"></p><p><img src="/./assets/image-20230725220134285.png" alt="image-20230725220134285"></p><p><img src="/./assets/image-20230725220151257.png" alt="image-20230725220151257"></p><p><img src="/./assets/image-20230725220446105.png" alt="image-20230725220446105"></p><h4 id="外部排序的原理"><a href="#外部排序的原理" class="headerlink" title="外部排序的原理"></a>外部排序的原理</h4><ul><li>原因：数据元素太多，无法一次全部读入内存进行排序</li><li>使用<strong>归并排序</strong>的方法，最少只需要在内存中分配 3 块大小的缓冲区即可对任意一个大文件进行排序<ul><li>先将两个块的数据传入内存的输入缓冲区1，2</li><li>对输入缓冲区1，2的数据进行归并排序，得到有序序列</li><li>将输入缓冲区去1，2的数据依次放入输出缓冲区，写回磁盘块</li><li>得到一个有序的“<strong>归并段</strong>”（两个磁盘块组成的有序序列）</li></ul></li></ul><p><img src="/./assets/image-20230725220216598.png" alt="image-20230725220216598"></p><h5 id="构造初始归并段"><a href="#构造初始归并段" class="headerlink" title="构造初始归并段"></a>构造初始归并段</h5><ul><li>读入到输入缓冲区</li></ul><p><img src="/./assets/image-20230725220526055.png" alt="image-20230725220526055"></p><ul><li>归并排序</li></ul><p><img src="/./assets/image-20230725220545500.png" alt="image-20230725220545500"></p><ul><li>写入磁盘</li></ul><p><img src="/./assets/image-20230725220848703.png" alt="image-20230725220848703"></p><p><img src="/./assets/image-20230725220900378.png" alt="image-20230725220900378"></p><ul><li>得到有序的归并段</li></ul><p><img src="/./assets/image-20230725220924221.png" alt="image-20230725220924221"></p><p><img src="/./assets/image-20230725220953274.png" alt="image-20230725220953274"></p><h5 id="第一趟归并"><a href="#第一趟归并" class="headerlink" title="第一趟归并"></a>第一趟归并</h5><ul><li>把8个有序子序列（初始归并段）两两归并<ul><li>将归并好的元素放到输出缓冲区</li><li>当输出缓冲区满的时候，写回磁盘块中</li><li>缓冲区1 空了就要<strong>⽴即</strong>⽤归并段1 的下⼀块补上</li><li>缓冲区2 空了就要<strong>⽴即</strong>⽤归并段2 的下⼀块补上<ul><li>如果空了，必须要先补上才能进行下一次归并</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230725221326699.png" alt="image-20230725221326699"></p><ul><li>读入归并段1的第一块 和 归并段2的第一块</li></ul><p><img src="/./assets/image-20230725221426212.png" alt="image-20230725221426212"></p><ul><li>进行归并排序</li></ul><p><img src="/./assets/image-20230725221505754.png" alt="image-20230725221505754"></p><p><img src="/./assets/image-20230725221532802.png" alt="image-20230725221532802"></p><p><img src="/./assets/image-20230725221544580.png" alt="image-20230725221544580"></p><ul><li>输出缓冲区满，写回磁盘块</li></ul><p><img src="/./assets/image-20230725221558304.png" alt="image-20230725221558304"></p><p><img src="/./assets/image-20230725221717104.png" alt="image-20230725221717104"></p><ul><li>输入缓冲区1空了要立即用归并段1的下一块补上</li></ul><p><img src="/./assets/image-20230725221805157.png" alt="image-20230725221805157"></p><p><img src="/./assets/image-20230725221852638.png" alt="image-20230725221852638"></p><p><img src="/./assets/image-20230725221903474.png" alt="image-20230725221903474"></p><ul><li>缓冲区2空了就要立即用归并段2的下一块补上</li></ul><p><img src="/./assets/image-20230725221915227.png" alt="image-20230725221915227"></p><p><img src="/./assets/image-20230725221927162.png" alt="image-20230725221927162"></p><p><img src="/./assets/image-20230725221946571.png" alt="image-20230725221946571"></p><p><img src="/./assets/image-20230725221956549.png" alt="image-20230725221956549"></p><p><img src="/./assets/image-20230725222007523.png" alt="image-20230725222007523"></p><p><img src="/./assets/image-20230725222017595.png" alt="image-20230725222017595"></p><ul><li>结束</li></ul><p><img src="/./assets/image-20230725222035954.png" alt="image-20230725222035954"></p><p><img src="/./assets/image-20230725222317107.png" alt="image-20230725222317107"></p><h5 id="第二趟归并"><a href="#第二趟归并" class="headerlink" title="第二趟归并"></a>第二趟归并</h5><ul><li>与第一趟相同</li></ul><p><img src="/./assets/image-20230725222526263.png" alt="image-20230725222526263"></p><p><img src="/./assets/image-20230725222630409.png" alt="image-20230725222630409"></p><p><img src="/./assets/image-20230725222558152.png" alt="image-20230725222558152"></p><p><img src="/./assets/image-20230725222736300.png" alt="image-20230725222736300"></p><p><img src="/./assets/image-20230725222748185.png" alt="image-20230725222748185"></p><h5 id="第三趟归并"><a href="#第三趟归并" class="headerlink" title="第三趟归并"></a>第三趟归并</h5><p><img src="/./assets/image-20230725222836718.png" alt="image-20230725222836718"></p><p><img src="/./assets/image-20230725222847815.png" alt="image-20230725222847815"></p><h4 id="时间开销分析"><a href="#时间开销分析" class="headerlink" title="时间开销分析"></a>时间开销分析</h4><ul><li>外部排序时间开销 &#x3D; 读写外存的时间 + 内部排序所需时间 + 内部归并所需时间</li></ul><p><img src="/./assets/image-20230725223001449.png" alt="image-20230725223001449"></p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h5 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h5><ul><li><p>优点</p><ul><li><p>可以减少归并趟数，从而减少磁盘I&#x2F;O（读写）次数</p><ul><li><p>对 r 个初始归并段，做k路归并，则归并树可⽤ <strong>k</strong> 叉树表示，若树⾼为h，则归并趟数 <strong>&#x3D; h-1 &#x3D;</strong> ⌈logkr⌉</p></li><li><p>k越⼤，r越⼩，归并趟数越少，读写磁盘次数越少</p></li></ul></li></ul></li><li><p>缺点</p></li><li><p>k路归并时，需要开辟k个缓冲区，内存开销增加</p></li><li><p>每挑选一个关键字需要对比关键字（k-1）次，内部归并所需时间增加</p></li></ul><p><img src="/./assets/image-20230725223809286.png" alt="image-20230725223809286"></p><p><img src="/./assets/image-20230725223208211.png" alt="image-20230725223208211"></p><p><img src="/./assets/image-20230725223256627.png" alt="image-20230725223256627"></p><h5 id="减少初始归并段数量"><a href="#减少初始归并段数量" class="headerlink" title="减少初始归并段数量"></a>减少初始归并段数量</h5><ul><li>对r个初始归并段，做k路归并，则归并树可用k叉树表示</li><li>树高为h，则归并趟数 &#x3D; h-1 &#x3D; [logkr]<ul><li>k越大，r越小，归并趟数越少，读写磁盘次数越少</li></ul></li><li>结论：若能增加初始归并段的长度，则可减少初始归并段数量r</li></ul><p><img src="/./assets/image-20230725224140759.png" alt="image-20230725224140759"></p><p><img src="/./assets/image-20230725224049117.png" alt="image-20230725224049117"></p><p><img src="/./assets/image-20230725224104863.png" alt="image-20230725224104863"></p><p><img src="/./assets/image-20230725224115937.png" alt="image-20230725224115937"></p><p><img src="/./assets/image-20230725224126575.png" alt="image-20230725224126575"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/./assets/image-20230725224424029.png" alt="image-20230725224424029"></p><h4 id="纠正：多路平衡归并"><a href="#纠正：多路平衡归并" class="headerlink" title="纠正：多路平衡归并"></a>纠正：多路平衡归并</h4><ul><li>k路平衡归并<ul><li>最多只能有k个段归并为一个</li><li>每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到[m&#x2F;k]个新的归并段</li></ul></li></ul><p><img src="/./assets/image-20230725224535205.png" alt="image-20230725224535205"></p><h5 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h5><p><img src="/./assets/image-20230725224742543.png" alt="image-20230725224742543"></p><h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><h4 id="多路平衡归并带来的问题"><a href="#多路平衡归并带来的问题" class="headerlink" title="多路平衡归并带来的问题"></a>多路平衡归并带来的问题</h4><ul><li>使用k路平衡归并策略，选出一个最小元素需要对比关键字（k-1）次，导致内部归并所需时间增加</li></ul><p><img src="/./assets/image-20230725224915899.png" alt="image-20230725224915899"></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>通俗定义</p><ul><li><p>失败者留在这一回合，胜利者进入下一回合比拼</p></li><li><p>最后只有一个冠军在所有比拼中获胜</p><ul><li>若有8位参赛者，则构造败者树需要7次比拼</li></ul></li></ul></li><li><p>败者树——可视为⼀棵完全⼆叉树（多了⼀个头头）。</p><ul><li><em>k</em>个叶结点分别是当前参加⽐较的元素</li><li>⾮叶⼦结点⽤来记忆左右⼦树中的“失败者”</li><li>⽽胜者往上继续进⾏⽐较，⼀直到根结点。</li></ul></li></ul><p><img src="/./assets/image-20230725225342850.png" alt="image-20230725225342850"></p><h4 id="败者树的使用"><a href="#败者树的使用" class="headerlink" title="败者树的使用"></a>败者树的使用</h4><ul><li>基于已经构建好的败者树，选出新的胜者只需进行3场比赛</li></ul><p><img src="/./assets/image-20230725225554880.png" alt="image-20230725225554880"></p><p><img src="/./assets/image-20230725225605389.png" alt="image-20230725225605389"></p><p><img src="/./assets/image-20230725225615486.png" alt="image-20230725225615486"></p><p><img src="/./assets/image-20230725225626003.png" alt="image-20230725225626003"></p><h4 id="败者树在多路平衡归并中的应用"><a href="#败者树在多路平衡归并中的应用" class="headerlink" title="败者树在多路平衡归并中的应用"></a>败者树在多路平衡归并中的应用</h4><ul><li><p>构成</p><ul><li><p>每个叶子节点对应一个归并段</p></li><li><p>分支节点记录失败败者来自哪个归并段</p></li><li><p>根节点记录冠军来自哪个归并段</p></li></ul></li><li><p>操作</p><ul><li><p>k路归并，第一次构造败者树需要对比关键字k-1次</p></li><li><p>有了败者树，选出最小元素，只需对比关键字[log2k]（向上取整）次</p></li></ul></li><li><p>第一次构造败者树</p></li></ul><p><img src="/./assets/image-20230726142220567.png" alt="image-20230726142220567"></p><p><img src="/./assets/image-20230726142241497.png" alt="image-20230726142241497"></p><p><img src="/./assets/image-20230726142253675.png" alt="image-20230726142253675"></p><ul><li>选出第二个元素</li></ul><p><img src="/./assets/image-20230726142700556.png" alt="image-20230726142700556"></p><p><img src="/./assets/image-20230726142712402.png" alt="image-20230726142712402"></p><p><img src="/./assets/image-20230726142742972.png" alt="image-20230726142742972"></p><p><img src="/./assets/image-20230726143016081.png" alt="image-20230726143016081"></p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li>k路归并的败者树只需要定义一个长度为k的数组即可</li><li>数组中的数据<ul><li>Ls[0]代表胜者</li><li>Ls[1…k-1]代表失败者</li></ul></li></ul><p><img src="/./assets/image-20230726143314546.png" alt="image-20230726143314546"></p><p><img src="/./assets/image-20230726143325058.png" alt="image-20230726143325058"></p><h3 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h3><h4 id="土方法构造初始归并段"><a href="#土方法构造初始归并段" class="headerlink" title="土方法构造初始归并段"></a>土方法构造初始归并段</h4><ul><li>可以用一片更大的内存区域来进行内部排序<ul><li>如：可容纳18个记录</li><li>每个“初始归并段”可包含18个记录</li></ul></li><li>用于内部排序的内存工作区WA可容纳 l 个记录，则每个初始归并段也只能包含 l 个记录，若文件共有 n 个记录，则初始归并段的数量 r &#x3D; n &#x2F; l</li></ul><p><img src="/./assets/image-20230726143821823.png" alt="image-20230726143821823"></p><h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li><p>使⽤<strong>置换-选择</strong>排序，可以让每个初始归并段的⻓度超越内存⼯作区⼤⼩的限制</p></li><li><p>实现过程</p><ul><li><p>初始化归并段输出文件FO</p></li><li><p>将初始待排序文件 FI 输入到内存工作区 WA 中，将其填满</p></li><li><p>置换</p><ul><li>把内存工作区中最小的元素置换出去，并且记录这一最小元素 MINIMAX</li><li>如果后来输入的元素比 MINIMAX 小，则将其进行标记，不输出；而是选择比 MINIMAX 大的最小值进行输出</li><li>当被标记的元素满的时候（内存工作区中所有元素都小于 MINIMAX），将之前的输出元素作为一个归并段</li><li>选择一个新的归并段</li></ul></li><li><p>重复置换直到待排序文件为空</p></li></ul></li></ul><p><img src="/./assets/image-20230726145427072.png" alt="image-20230726145427072"></p><ul><li>初始化</li></ul><p><img src="/./assets/image-20230726144452814.png" alt="image-20230726144452814"></p><ul><li>第一趟置换</li></ul><p><img src="/./assets/image-20230726144508572.png" alt="image-20230726144508572"></p><p><img src="/./assets/image-20230726144520465.png" alt="image-20230726144520465"></p><p><img src="/./assets/image-20230726144539913.png" alt="image-20230726144539913"></p><p><img src="/./assets/image-20230726144552112.png" alt="image-20230726144552112"></p><p><img src="/./assets/image-20230726144605976.png" alt="image-20230726144605976"></p><p><img src="/./assets/image-20230726144617031.png" alt="image-20230726144617031"></p><p><img src="/./assets/image-20230726144633311.png" alt="image-20230726144633311"></p><ul><li>第二趟置换</li></ul><p><img src="/./assets/image-20230726145142679.png" alt="image-20230726145142679"></p><p><img src="/./assets/image-20230726145159914.png" alt="image-20230726145159914"></p><ul><li>第三趟置换</li></ul><p><img src="/./assets/image-20230726145214685.png" alt="image-20230726145214685"></p><p><img src="/./assets/image-20230726145228519.png" alt="image-20230726145228519"></p><h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><h4 id="归并树的性质"><a href="#归并树的性质" class="headerlink" title="归并树的性质"></a>归并树的性质</h4><ul><li>每个初始归并段看作一个叶子节点，归并段的长度作为节点权值，则<ul><li><strong>归并树的带权路径长度 WPL &#x3D; 读磁盘的次数 &#x3D; 写磁盘的次数</strong></li></ul></li><li>结论：归并过程中的磁盘 I&#x2F;O 次数 &#x3D; 归并树的WPL * 2</li><li>要让磁盘 I&#x2F;O 次数最少，就要使归并树 WPL 最小 —— 哈夫曼树</li></ul><p><img src="/./assets/image-20230726145934146.png" alt="image-20230726145934146"></p><h4 id="构造二路归并的最佳归并树"><a href="#构造二路归并的最佳归并树" class="headerlink" title="构造二路归并的最佳归并树"></a>构造二路归并的最佳归并树</h4><p><img src="/./assets/image-20230726150334074.png" alt="image-20230726150334074"></p><h4 id="多路归并的最佳归并树"><a href="#多路归并的最佳归并树" class="headerlink" title="多路归并的最佳归并树"></a>多路归并的最佳归并树</h4><ul><li><p>只有<strong>叶子节点要 乘以 权值进行相加</strong></p></li><li><p>一般情况</p></li></ul><p><img src="/./assets/image-20230726150853636.png" alt="image-20230726150853636"></p><ul><li>最佳归并树</li></ul><p><img src="/./assets/image-20230726151115096.png" alt="image-20230726151115096"></p><h4 id="如果减少一个归并段，利用上述规则，无法得到最佳归并树"><a href="#如果减少一个归并段，利用上述规则，无法得到最佳归并树" class="headerlink" title="如果减少一个归并段，利用上述规则，无法得到最佳归并树"></a>如果减少一个归并段，利用上述规则，无法得到最佳归并树</h4><p><img src="/./assets/image-20230726151155031.png" alt="image-20230726151155031"></p><ul><li>正确做法<ul><li>对于 k 叉归并，若初始归并段的数量无法满足构成严格的 k 叉归并树，则需要补充几个长度为 0 的“虚段”，再进行 k 叉哈夫曼树的构造</li><li>长度为 0 的虚段：在输入缓冲区什么都不用放</li></ul></li></ul><p><img src="/./assets/image-20230726151253362.png" alt="image-20230726151253362"></p><p><img src="/./assets/image-20230726151446916.png" alt="image-20230726151446916"></p><h4 id="添加虚段的数量（k-1-u）"><a href="#添加虚段的数量（k-1-u）" class="headerlink" title="添加虚段的数量（k - 1 - u）"></a>添加虚段的数量（k - 1 - u）</h4><ul><li>对于 k  叉归并，若初始归并段的数量无法构成严格的 k 叉归并树，则需要补充几个长度为 0的虚段，再进行 k 叉哈夫曼树的构造</li><li>k 叉的最佳归并树一定是一棵严格的 k 叉树，即树中只包含度为 k、度为 0的节点<ul><li>设度为 k的节点有nk个，度为0的节点有 n0个，归并树的总节点数&#x3D;n</li><li>初始归并段数量 + 虚段数量 &#x3D; n0</li><li>n &#x3D; n0 + nk</li><li>k * nk &#x3D; n - 1</li><li>得到：n0 &#x3D; (k-1) * nk + 1</li><li>结论：**nk &#x3D; (n0 - 1)&#x2F;(k - 1)**（如果是严格k叉树，一定能除得尽（所有的数都是整数））</li></ul></li><li><strong>若（初始归并段数量 - 1）% （k - 1）&#x3D; 0；说明刚好可以构成严格 k 叉树，此时不需要添加虚段</strong></li><li><strong>若（初始归并段数量 - 1）% （k - 1）&#x3D; u !&#x3D; 0；则需要补充（k - 1）- u 个虚段</strong></li></ul><p><img src="/./assets/image-20230726151816101.png" alt="image-20230726151816101"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-基于小根堆如何建堆、排序"><a href="#1-基于小根堆如何建堆、排序" class="headerlink" title="1. 基于小根堆如何建堆、排序"></a>1. 基于小根堆如何建堆、排序</h3><p><img src="/./assets/image-20230725195756007.png" alt="image-20230725195756007"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.htm</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="排序" scheme="https://sdumoist.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E6%9F%A5%E6%89%BE/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E6%9F%A5%E6%89%BE/</id>
    <published>2024-03-26T10:36:39.000Z</published>
    <updated>2024-03-26T12:38:10.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/./assets/image-20230720151803579.png" alt="image-20230720151803579"></p><p><img src="/./assets/image-20230720163518914.png" alt="image-20230720163518914"></p><p><img src="/./assets/image-20230720171828290.png" alt="image-20230720171828290"></p><p><img src="/./assets/image-20230720193721514.png" alt="image-20230720193721514"></p><p><img src="/./assets/image-20230722161737579.png" alt="image-20230722161737579"></p><p><img src="/./assets/image-20230722202438050.png" alt="image-20230722202438050"></p><p><img src="/./assets/image-20230724142942715.png" alt="image-20230724142942715"></p><p><img src="/./assets/image-20230724163237627.png" alt="image-20230724163237627"></p><p><img src="/./assets/image-20230724163355112.png" alt="image-20230724163355112"></p><p><img src="/./assets/image-20230724163549182.png" alt="image-20230724163549182"></p><p><img src="/./assets/image-20230724173036104.png" alt="image-20230724173036104"></p><p><img src="/./assets/image-20230724181955470.png" alt="image-20230724181955470"></p><p><img src="/./assets/image-20230724195322682.png" alt="image-20230724195322682"></p><p><img src="/./assets/image-20230724202139255.png" alt="image-20230724202139255"></p><p><img src="/./assets/image-20230724213136956.png" alt="image-20230724213136956"></p><p><img src="/./assets/image-20230724220841760.png" alt="image-20230724220841760"></p><p><img src="/./assets/image-20230724221816325.png" alt="image-20230724221816325"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p><strong>在数据集合中寻找满足某种条件的数据元素的过程称为查找</strong></p><h3 id="查找表（查找结构）"><a href="#查找表（查找结构）" class="headerlink" title="查找表（查找结构）"></a>查找表（查找结构）</h3><p>用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成</p><h3 id="关键字（类似数据库的主键，唯一不重复）"><a href="#关键字（类似数据库的主键，唯一不重复）" class="headerlink" title="关键字（类似数据库的主键，唯一不重复）"></a>关键字（类似数据库的主键，唯一不重复）</h3><p>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结构应该是唯一的</p><p><img src="/./assets/image-20230720145132778.png" alt="image-20230720145132778"></p><p><img src="/./assets/image-20230720150747878.png" alt="image-20230720150747878"></p><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ul><li><p>操作</p><ol><li><p>查找复合条件的数据元素</p></li><li><p>插入、删除某个数据元素</p></li></ol></li><li><p>应用</p><ul><li><p>只需进行操作1——静态查找表（仅关注查找速度即可）</p></li><li><p>也要进行操作2——动态查找表（除了查找速度，也要关注插&#x2F;删操作是否方便实现）</p></li></ul></li></ul><p><img src="/./assets/image-20230720151115044.png" alt="image-20230720151115044"></p><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><h4 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h4><ul><li>在查找运算中，需要对比关键字的次数称为查找长度</li></ul><h4 id="平均查找长度（ASL，Average-Search-Length"><a href="#平均查找长度（ASL，Average-Search-Length" class="headerlink" title="平均查找长度（ASL，Average Search Length)"></a>平均查找长度（ASL，Average Search Length)</h4><ul><li><p>所有查找过程中进行关键字的比较次数的平均值</p></li><li><p><strong>ASL的数量级反映了查找算法的时间复杂度</strong></p></li></ul><p><img src="/./assets/image-20230720151601756.png" alt="image-20230720151601756"></p><p><img src="/./assets/image-20230720151629670.png" alt="image-20230720151629670"></p><p><img src="/./assets/image-20230720151732726.png" alt="image-20230720151732726"></p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul><li>顺序查找，又叫“线性查找”，通常用于线性表（顺序表，链表）</li></ul><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>从头到jio挨个找（反过来也ok）</li></ul><p><img src="/./assets/image-20230720152101739.png" alt="image-20230720152101739"></p><p><img src="/./assets/image-20230720152116493.png" alt="image-20230720152116493"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现（查找失败越界返回-1）"><a href="#代码实现（查找失败越界返回-1）" class="headerlink" title="代码实现（查找失败越界返回-1）"></a>代码实现（查找失败越界返回-1）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                     <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;                 <span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;                   <span class="comment">//表的长度</span></span><br><span class="line">&#125;   SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, Elemtype key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ST.TableLen &amp;&amp; ST.elem[i]!= key;++i);</span><br><span class="line">    <span class="comment">//查找成功，则返回元素下标；查找失败，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> i==ST.TableLen? <span class="number">-1</span>:i;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230720153446093.png" alt="image-20230720153446093"></p><p><img src="/./assets/image-20230720153617255.png" alt="image-20230720153617255"></p><h4 id="代码实现（哨兵）"><a href="#代码实现（哨兵）" class="headerlink" title="代码实现（哨兵）"></a>代码实现（哨兵）</h4><ul><li>优点：无需判断是否越界，效率更高</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找2（哨兵）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, Elemtype key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key;                 <span class="comment">//“哨兵”</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = ST.TableLen; ST.elem[i]!=key; --i);<span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">return</span> i;                       <span class="comment">//查找成功，则返回元素下标；查找失败，则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230720154028514.png" alt="image-20230720154028514"></p><p><img src="/./assets/image-20230720154051155.png" alt="image-20230720154051155"></p><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><p><img src="/./assets/image-20230720154501231.png" alt="image-20230720154501231"></p><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h4><ul><li>查找判定树</li></ul><p><img src="/./assets/image-20230720154713715.png" alt="image-20230720154713715"></p><h5 id="用查找判定树分析ASL"><a href="#用查找判定树分析ASL" class="headerlink" title="用查找判定树分析ASL"></a>用查找判定树分析ASL</h5><ul><li><p>一个成功节点的查找长度 &#x3D; 自身所在层数</p></li><li><p>一个失败节点的查找长度 &#x3D; 其父节点所在层数</p></li><li><p>默认情况下，各种失败情况或成功情况都等概率发生</p></li></ul><p><img src="/./assets/image-20230720154943367.png" alt="image-20230720154943367"></p><h4 id="被查概率不相等"><a href="#被查概率不相等" class="headerlink" title="被查概率不相等"></a>被查概率不相等</h4><ul><li>被查概率大的放在靠前位置</li></ul><p><img src="/./assets/image-20230720163441562.png" alt="image-20230720163441562"></p><h2 id="折半查找（有序的顺序表）"><a href="#折半查找（有序的顺序表）" class="headerlink" title="折半查找（有序的顺序表）"></a>折半查找（有序的顺序表）</h2><ul><li>折半查找，又叫“二分查找”，仅适用于<strong>有序的顺序表</strong></li><li>顺序表具有随机访问的特性，链表没有</li></ul><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><h4 id="查找成功"><a href="#查找成功" class="headerlink" title="查找成功"></a>查找成功</h4><p><img src="/./assets/image-20230720163809803.png" alt="image-20230720163809803"></p><p><img src="/./assets/image-20230720163832693.png" alt="image-20230720163832693"></p><p><img src="/./assets/image-20230720163850632.png" alt="image-20230720163850632"></p><p><img src="/./assets/image-20230720163947281.png" alt="image-20230720163947281"></p><h4 id="查找失败"><a href="#查找失败" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/./assets/image-20230720164025165.png" alt="image-20230720164025165"></p><p><img src="/./assets/image-20230720164043841.png" alt="image-20230720164043841"></p><p><img src="/./assets/image-20230720164059749.png" alt="image-20230720164059749"></p><p><img src="/./assets/image-20230720164111054.png" alt="image-20230720164111054"></p><p><img src="/./assets/image-20230720164144253.png" alt="image-20230720164144253"></p><p><img src="/./assets/image-20230720164129188.png" alt="image-20230720164129188"></p><p><img src="/./assets/image-20230720164229668.png" alt="image-20230720164229668"></p><p><img src="/./assets/image-20230720164240561.png" alt="image-20230720164240561"></p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现-升序数组"><a href="#代码实现-升序数组" class="headerlink" title="代码实现(升序数组)"></a>代码实现(升序数组)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                             <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;                         <span class="comment">//动态数组的基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;                           <span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable L,Elemtype key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>, high = L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;                   <span class="comment">//取中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key) <span class="keyword">return</span> mid;    <span class="comment">//查找成功则返回所在位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key) high = mid<span class="number">-1</span>;    <span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;                 <span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                              <span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230720164831854.png" alt="image-20230720164831854"></p><h4 id="效率分析-1"><a href="#效率分析-1" class="headerlink" title="效率分析"></a>效率分析</h4><p><img src="/./assets/image-20230720165155165.png" alt="image-20230720165155165"></p><p><img src="/./assets/image-20230720165232737.png" alt="image-20230720165232737"></p><h3 id="折半查找判定树的构造（重点）"><a href="#折半查找判定树的构造（重点）" class="headerlink" title="折半查找判定树的构造（重点）"></a>折半查找判定树的构造（重点）</h3><h4 id="奇数个"><a href="#奇数个" class="headerlink" title="奇数个"></a>奇数个</h4><p><img src="/./assets/image-20230720165422920.png" alt="image-20230720165422920"></p><p><img src="/./assets/image-20230720165449422.png" alt="image-20230720165449422"></p><h4 id="偶数个"><a href="#偶数个" class="headerlink" title="偶数个"></a>偶数个</h4><ul><li>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</li><li>如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</li><li>mid&#x3D;[(low+high)&#x2F;2]，则对任何一个节点，必有：<strong>右子树节点数-左子树节点数&#x3D;0&#x2F;1</strong>（右子树节点数比左子树多）</li></ul><p><img src="/./assets/image-20230720165535360.png" alt="image-20230720165535360"></p><p><img src="/./assets/image-20230720165555996.png" alt="image-20230720165555996"></p><p><img src="/./assets/image-20230720165908597.png" alt="image-20230720165908597"></p><h4 id="构造方法及性质"><a href="#构造方法及性质" class="headerlink" title="构造方法及性质"></a>构造方法及性质</h4><ul><li>构造的形状唯一</li><li>折半查找的判定树一定是平衡二叉树，只有最下面一层是不满的（元素个数为n时，树高h&#x3D;[log2(n+1)]向上取整）</li><li>新节点优先右子树，但是右子树只能最多比左子树多一个<ul><li>左右子树相等，新节点加到右子树</li><li>左右子树不相等（右子树比左子树节点多），新节点加到左子树</li></ul></li></ul><p><img src="/./assets/image-20230720170738197.png" alt="image-20230720170738197"><br><img src="/./assets/image-20230720171045853.png" alt="image-20230720171045853"></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>判定树节点关键字：左&lt;中&lt;右，满足二叉排序树的定义</li><li>失败节点：n+1个（等于成功节点的空链域数量）</li></ul><p><img src="/./assets/image-20230720171259153.png" alt="image-20230720171259153"></p><p><img src="/./assets/image-20230720171558671.png" alt="image-20230720171558671"></p><h4 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h4><ul><li>树高h &#x3D; [log2(n+1)]向上取整（不包括失败节点）<ul><li>查找成功：ASL &lt;&#x3D; h</li><li>查找失败：ASL &lt;&#x3D; h</li><li>时间复杂度 &#x3D; O(log2n)</li></ul></li></ul><p><img src="/./assets/image-20230720172600920.png" alt="image-20230720172600920"></p><h4 id="另一种情况的折半查找"><a href="#另一种情况的折半查找" class="headerlink" title="另一种情况的折半查找"></a>另一种情况的折半查找</h4><ul><li>mid &#x3D; [(low+high)&#x2F;2]向上取整</li></ul><p><img src="/./assets/image-20230720172215927.png" alt="image-20230720172215927"></p><p><img src="/./assets/image-20230720172253774.png" alt="image-20230720172253774"></p><p><img src="/./assets/image-20230720172400811.png" alt="image-20230720172400811"></p><h3 id="折半查找的速度一定比顺序查找更快？"><a href="#折半查找的速度一定比顺序查找更快？" class="headerlink" title="折半查找的速度一定比顺序查找更快？"></a>折半查找的速度一定比顺序查找更快？</h3><ul><li><p>大部分情况下，折半查找更快；但不是任何情况下都更快</p></li><li><p>折半查找时间复杂度 &#x3D; O(log2n)</p></li><li><p>顺序查找的时间复杂度 &#x3D; O(n)</p></li></ul><p><img src="/./assets/image-20230720172019138.png" alt="image-20230720172019138"></p><h2 id="分块查找（选择题）"><a href="#分块查找（选择题）" class="headerlink" title="分块查找（选择题）"></a>分块查找（选择题）</h2><ul><li><strong>分块查找</strong>，又称<strong>索引顺序查找</strong></li></ul><h3 id="算法思想（顺序查找和折半查找的结合）"><a href="#算法思想（顺序查找和折半查找的结合）" class="headerlink" title="算法思想（顺序查找和折半查找的结合）"></a>算法思想（顺序查找和折半查找的结合）</h3><ul><li>索引表：保存每个分块的最大关键字和分块的存储区间</li></ul><p><img src="/./assets/image-20230720174031300.png" alt="image-20230720174031300"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>算法过程如下：<ol><li>在索引表中确定待查记录所属的分块（可顺序、可折半）（索引表是有序的）<ul><li>查找目标 &gt; 索引值：下一个</li><li>查找目标 &lt;&#x3D; 索引值：选择该索引范围</li></ul></li><li>在块内顺序查找（块内的元素是无序的）</li></ol></li></ul><h4 id="查找成功-1"><a href="#查找成功-1" class="headerlink" title="查找成功"></a>查找成功</h4><p><img src="/./assets/image-20230720174148215.png" alt="image-20230720174148215"></p><p><img src="/./assets/image-20230720174234584.png" alt="image-20230720174234584"></p><p><img src="/./assets/image-20230720174246063.png" alt="image-20230720174246063"></p><p><img src="/./assets/image-20230720174502881.png" alt="image-20230720174502881"></p><p><img src="/./assets/image-20230720174518270.png" alt="image-20230720174518270"></p><h4 id="查找失败-1"><a href="#查找失败-1" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/./assets/image-20230720174607035.png" alt="image-20230720174607035"></p><p><img src="/./assets/image-20230720174620988.png" alt="image-20230720174620988"></p><p><img src="/./assets/image-20230720174630296.png" alt="image-20230720174630296"></p><p><img src="/./assets/image-20230720174656119.png" alt="image-20230720174656119"></p><p><img src="/./assets/image-20230720174704687.png" alt="image-20230720174704687"></p><p><img src="/./assets/image-20230720174716649.png" alt="image-20230720174716649"></p><p><img src="/./assets/image-20230720174724729.png" alt="image-20230720174724729"></p><p><img src="/./assets/image-20230720174750762.png" alt="image-20230720174750762"></p><h4 id="用折半查找查索引"><a href="#用折半查找查索引" class="headerlink" title="用折半查找查索引"></a>用折半查找查索引</h4><ul><li>查找目标在索引表里面</li></ul><p><img src="/./assets/image-20230720175129067.png" alt="image-20230720175129067"></p><p><img src="/./assets/image-20230720175213153.png" alt="image-20230720175213153"></p><p><img src="/./assets/image-20230720175252687.png" alt="image-20230720175252687"></p><p><img src="/./assets/image-20230720175232459.png" alt="image-20230720175232459"></p><h4 id="用折半查找查索引2"><a href="#用折半查找查索引2" class="headerlink" title="用折半查找查索引2"></a>用折半查找查索引2</h4><ul><li>查找目标不在索引表里面</li><li>若索引表中不包含目标关键字，则折半查找索引表最终停在low&gt;high,<strong>要在low所指分块中查找</strong><ul><li>原因：最终low左边一定小雨目标关键字，high右边一定大雨目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字</li></ul></li></ul><p><img src="/./assets/image-20230720175443863.png" alt="image-20230720175443863"></p><p><img src="/./assets/image-20230720175500012.png" alt="image-20230720175500012"></p><p><img src="/./assets/image-20230720175516433.png" alt="image-20230720175516433"></p><p><img src="/./assets/image-20230720175535318.png" alt="image-20230720175535318"></p><p><img src="/./assets/image-20230720175606707.png" alt="image-20230720175606707"></p><p><img src="/./assets/image-20230720175624368.png" alt="image-20230720175624368"></p><p><img src="/./assets/image-20230720192236475.png" alt="image-20230720192236475"></p><p><img src="/./assets/image-20230720192252235.png" alt="image-20230720192252235"></p><p><img src="/./assets/image-20230720192305940.png" alt="image-20230720192305940"></p><h4 id="查找失败-2"><a href="#查找失败-2" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/./assets/image-20230720192347781.png" alt="image-20230720192347781"></p><h3 id="查找效率分析（ASL）"><a href="#查找效率分析（ASL）" class="headerlink" title="查找效率分析（ASL）"></a>查找效率分析（ASL）</h3><h4 id="查找成功-2"><a href="#查找成功-2" class="headerlink" title="查找成功"></a>查找成功</h4><p><img src="/./assets/image-20230720192435475.png" alt="image-20230720192435475"></p><p><img src="/./assets/image-20230720192531733.png" alt="image-20230720192531733"></p><ul><li>30：4次</li><li>27：不是2次。因为27不在索引表中，要增加三次直到找到索引表的位置</li></ul><p><img src="/./assets/image-20230720192735045.png" alt="image-20230720192735045"></p><h4 id="查找失败-3"><a href="#查找失败-3" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/./assets/image-20230720192825925.png" alt="image-20230720192825925"></p><h4 id="效率优化"><a href="#效率优化" class="headerlink" title="效率优化"></a>效率优化</h4><ul><li><p>假设：长度为n的查找表被均匀地分为b块，每块s个元素          n&#x3D;s*b</p></li><li><p>设索引查找和块内查找的平均查找长度分别为L1、L2，则分块查找的平均查找长度为ASL&#x3D;Li+Ls</p><ul><li>用<strong>顺序查找</strong>查索引表<ul><li>ASL&#x3D;1&#x2F;2*s + n&#x2F;2*s + 1</li><li>最小的ASL &#x3D; 根号n+1（当s &#x3D; 根号n，b &#x3D; 根号n）</li></ul></li><li>用<strong>折半查找</strong>查索引表</li></ul></li></ul><p><img src="/./assets/image-20230720193338939.png" alt="image-20230720193338939"></p><p><img src="/./assets/image-20230720193658770.png" alt="image-20230720193658770"></p><h2 id="树形查找"><a href="#树形查找" class="headerlink" title="树形查找"></a>树形查找</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>二叉排序树，又称二叉查找树（<strong>BST</strong>，Binary Search Tree）</li><li>一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：<ul><li>左子树上所有节点的关键字均小于根节点的关键字</li><li>右子树上所有节点的关键字均大于根节点的关键字</li><li>左子树和右子树又各是一棵二叉排序树</li></ul></li><li>左子树节点值 &lt; 根节点值 &lt; 右子树节点值<ul><li>进行中序遍历，可以得到一个递增的有序序列</li></ul></li><li>二叉排序树可用于元素的有序组织、搜索</li></ul><p><img src="/./assets/image-20230721222332589.png" alt="image-20230721222332589"></p><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>若树非空，目标值与根节点的值比较：<ul><li>若相等，则查找成功</li><li>若小于根节点，则在左子树上查找，否则在右子树上查找</li></ul></li><li>查找成功，返回节点指针</li><li>查找失败返回NULL</li></ul><h5 id="查找成功-3"><a href="#查找成功-3" class="headerlink" title="查找成功"></a>查找成功</h5><p><img src="/./assets/image-20230721222616468.png" alt="image-20230721222616468"></p><p><img src="/./assets/image-20230721223154791.png" alt="image-20230721223154791"></p><h5 id="查找失败-4"><a href="#查找失败-4" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/./assets/image-20230721223604519.png" alt="image-20230721223604519"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>有两种实现方式<ul><li>一种是非递归<ul><li>while(T !&#x3D; NULL &amp;&amp; key !&#x3D; T-&gt;key);</li></ul></li><li>一种是递归<ul><li>return BST_Search2(T-&gt;lchild, key);</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的节点（非递归）</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;key)&#123;      <span class="comment">//若树空或等于根节点值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;key) T = T -&gt; lchild;   <span class="comment">//小于，则在左子树上查找</span></span><br><span class="line">        <span class="keyword">else</span> T = T-&gt;rchild;                 <span class="comment">//大于，则在右子树上查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树中寻找值为key的节点（递归）</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search2</span><span class="params">(BSTree T, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">//查找失败</span></span><br><span class="line">    <span class="keyword">if</span>(key == T-&gt;key)  <span class="keyword">return</span> T;            <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key) <span class="keyword">return</span> <span class="built_in">BST_Search2</span>(T-&gt;lchild, key);       <span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">BST_Search2</span>(T-&gt;rchild, key);                        <span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230722130753338.png" alt="image-20230722130753338"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>若原二叉排序树为空，则直接插入节点</li><li>若二叉排序树不为空<ul><li>若关键字k小于根节点值，则插入到左子树</li><li>若关键字k大于根节点值，则插入到右子树</li></ul></li></ul><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><p><img src="/./assets/image-20230722143338669.png" alt="image-20230722143338669"></p><h5 id="代码实现（递归）"><a href="#代码实现（递归）" class="headerlink" title="代码实现（递归）"></a>代码实现（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树插入关键字为k的新节点（递归实现）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;                            <span class="comment">//原数为空，新插入的节点为根节点</span></span><br><span class="line">        T=(BSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//T-&gt;lchild = T-&gt;rchild = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">//返回1，插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)                      <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)                       <span class="comment">//插入T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild, k);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild, k);   <span class="comment">//插入T的右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码实现（非递归）"><a href="#代码实现（非递归）" class="headerlink" title="代码实现（非递归）"></a>代码实现（非递归）</h5><h4 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h4><ul><li>不同的关键字序列可能得到同款二叉排序树</li></ul><p><img src="/./assets/image-20230722143918303.png" alt="image-20230722143918303"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;                               <span class="comment">//初始时，T为空树</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;                           <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        <span class="built_in">BST_Insert</span>(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相同的关键字，不同排列可能得到不同款的二叉排序树</li></ul><p><img src="/./assets/image-20230722143956854.png" alt="image-20230722143956854"></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>先搜索找到目标节点<ul><li>若被删除节点z是叶子节点，则直接删除，不会破坏二叉排序树的性质</li><li>若被删除节点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，代替z的位置</li><li>若被删除节点z有左右两棵子树，则令z的直接后继（或直接前驱）代替z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况<ul><li>原理<ul><li>左子树 &lt; 根节点 &lt; 右子树</li><li>进行中序遍历，可以得到一个递增的有序序列</li><li>所以将左子树中最后一个被中序遍历的（左边最大的），或者右子树中最早一个被中序遍历的（右边最小的）删去，放到删除的节点上，就可以保证中序遍历结果不变，且能保持二叉排序树</li></ul></li></ul></li></ul></li></ul><p><img src="/./assets/image-20230722144151517.png" alt="image-20230722144151517"></p><p><img src="/./assets/image-20230722144258357.png" alt="image-20230722144258357"></p><p><img src="/./assets/image-20230722144902838.png" alt="image-20230722144902838"></p><p><img src="/./assets/image-20230722145007236.png" alt="image-20230722145007236"></p><p><img src="/./assets/image-20230722145028053.png" alt="image-20230722145028053"></p><p><img src="/./assets/image-20230722145040306.png" alt="image-20230722145040306"></p><h4 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul><li>查找长度<ul><li>在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度</li></ul></li></ul><h5 id="查找成功-4"><a href="#查找成功-4" class="headerlink" title="查找成功"></a>查找成功</h5><ul><li><p>ASL，查找成功的平均查找长度</p></li><li><p>若树高h，找到最下层的一个节点需要对比h次</p></li><li><p>最好情况</p><ul><li>n个节点的二叉树最小高度为[log2n]向下取整+1</li><li>平均查找长度 &#x3D; O(log2n)</li></ul></li><li><p>最坏情况</p><ul><li>每个节点只有一个分支</li><li>树高h &#x3D; 节点数n</li><li>平均查找长度 &#x3D; O(n)</li></ul></li></ul><p><img src="/./assets/image-20230722145307895.png" alt="image-20230722145307895"></p><h5 id="查找失败-5"><a href="#查找失败-5" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/./assets/image-20230722145836191.png" alt="image-20230722145836191"></p><h5 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h5><ul><li>平衡二叉树，树上任一节点的左子树和右子树的深度之差不超过1</li></ul><p><img src="/./assets/image-20230722145755248.png" alt="image-20230722145755248"></p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树）<ul><li>树上任一节点的左子树和右子树的高度之差不超过1</li></ul></li><li>结点的平衡因子 &#x3D; 左子树高 - 右子树高<ul><li>平衡二叉树节点的平衡因子值只可能是-1，0，1</li><li>只要有任一节点的平衡因子绝对值大于1，就不是平衡二叉树</li></ul></li></ul><p><img src="/./assets/image-20230722151329439.png" alt="image-20230722151329439"></p><ul><li>结构体定义</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;                        <span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> balancel;                    <span class="comment">//平衡因子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *lchild, *rchild;    </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure><h4 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>每次插入新节点后，调整<strong>最小不平衡子树</strong></li><li>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先节点都会恢复平衡</li></ul><p><img src="/./assets/image-20230722151905858.png" alt="image-20230722151905858"></p><h4 id="插入新节点后如何调整“不平衡”问题"><a href="#插入新节点后如何调整“不平衡”问题" class="headerlink" title="插入新节点后如何调整“不平衡”问题"></a>插入新节点后如何调整“不平衡”问题</h4><h5 id="不平衡情况"><a href="#不平衡情况" class="headerlink" title="不平衡情况"></a>不平衡情况</h5><ul><li>LL：在A的左孩子的左子树中插入导致不平衡</li><li>RR：在A的右孩子的右子树中插入导致不平衡</li><li>LR：在A的左孩子的右子树中插入导致不平衡</li><li>RL：在A的右孩子的左子树中插入导致不平衡</li></ul><p><img src="/./assets/image-20230722152244959.png" alt="image-20230722152244959"></p><h5 id="调整最小不平衡子树"><a href="#调整最小不平衡子树" class="headerlink" title="调整最小不平衡子树"></a>调整最小不平衡子树</h5><ul><li><p>插入新节点前，应该是有平衡因子为1或-1的情况，即左子树与右子树不相等</p></li><li><p>插入新节点后，平衡因子为2或-2导致不平衡</p></li><li><p>目标</p><ul><li>恢复平衡</li><li>保持二叉排序树的特性<ul><li>左子树节点值 &lt; 根节点值 &lt; 右子树节点值</li></ul></li></ul></li><li><p>LL：右单旋转</p><ul><li>原因：在节点A的左孩子的左子树上插入了新节点，A的平衡因子由1增加到2</li><li>操作：将A的左孩子B向右上旋转代替A成为根节点，将A节点向右下旋转成为B右子树的根节点，B原右子树作为A的左子树</li></ul></li><li><p>RR：左单旋转</p><ul><li>在节点A的右孩子的右子树上插入了新节点，A的平衡因子由-1减小到-2</li><li>操作：将A的右孩子B向左上旋转代替A成为根节点，将A节点向左下旋转成为B的左子树的根节点，而B的原左子树则作为A节点的右子树</li></ul></li></ul><h6 id="LL：右旋"><a href="#LL：右旋" class="headerlink" title="LL：右旋"></a>LL：右旋</h6><ul><li>原因：在节点A的左孩子的左子树上插入了新节点，A的平衡因子由1增加到2</li><li>操作：将A的左孩子B向右上旋转代替A成为根节点，将A节点向右下旋转成为B右子树的根节点，B原右子树作为A的左子树</li></ul><p><img src="/./assets/image-20230722152648580.png" alt="image-20230722152648580"></p><h6 id="RR：左旋"><a href="#RR：左旋" class="headerlink" title="RR：左旋"></a>RR：左旋</h6><ul><li>在节点A的右孩子的右子树上插入了新节点，A的平衡因子由-1减小到-2</li><li>操作：将A的右孩子B向左上旋转代替A成为根节点，将A节点向左下旋转成为B的左子树的根节点，而B的原左子树则作为A节点的右子树</li></ul><p><img src="/./assets/image-20230722153725461.png" alt="image-20230722153725461"></p><h6 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h6><p><img src="/./assets/image-20230722154139187.png" alt="image-20230722154139187"></p><h6 id="LR：先左后右"><a href="#LR：先左后右" class="headerlink" title="LR：先左后右"></a>LR：先左后右</h6><ul><li>原因：由于在A的左孩子的右子树上插入新节点，A的平衡因子由1增加到2</li><li>操作：先将A节点的左孩子B的右子树的根节点C向左上旋转提升到B节点的位置，然后再把C节点向右上旋转提升到A节点的位置</li></ul><p><img src="/./assets/image-20230722154639021.png" alt="image-20230722154639021"></p><p><img src="/./assets/image-20230722154709712.png" alt="image-20230722154709712"></p><p><img src="/./assets/image-20230722154725853.png" alt="image-20230722154725853"></p><h6 id="RL：先右再左"><a href="#RL：先右再左" class="headerlink" title="RL：先右再左"></a>RL：先右再左</h6><ul><li>原因：在A的右孩子的左子树上插入新节点，A的平衡因子由-1减到-2，导致以A为根的子树失去平衡</li><li>操作：先将A节点的左孩子B的根节点C向右上旋转提升到B节点的位置，然后再把该C节点向左上旋转提升到A节点的位置</li></ul><p><img src="/./assets/image-20230722154920933.png" alt="image-20230722154920933"></p><p><img src="/./assets/image-20230722154933284.png" alt="image-20230722154933284"></p><p><img src="/./assets/image-20230722154945762.png" alt="image-20230722154945762"></p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul><li>只有左孩子才能右上旋</li><li>只有右孩子才能左上旋</li></ul><p><img src="/./assets/image-20230722155327108.png" alt="image-20230722155327108"></p><h5 id="只要调整最小平衡子树，其他祖先节点就能恢复平衡"><a href="#只要调整最小平衡子树，其他祖先节点就能恢复平衡" class="headerlink" title="只要调整最小平衡子树，其他祖先节点就能恢复平衡"></a>只要调整最小平衡子树，其他祖先节点就能恢复平衡</h5><ul><li>插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复</li></ul><p><img src="/./assets/image-20230722155532175.png" alt="image-20230722155532175"></p><p><img src="/./assets/image-20230722155716901.png" alt="image-20230722155716901"></p><p><img src="/./assets/image-20230722155730461.png" alt="image-20230722155730461"></p><h6 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h6><ul><li>RR<ul><li>找到第一个不平衡的点</li><li>往下数一个节点——作为新的跟节点</li><li>旧根节点作为新根节点的左子树</li><li>新根节点原来的左子树变成左子树的右子树</li></ul></li></ul><p><img src="/./assets/image-20230722160123223.png" alt="image-20230722160123223"></p><p><img src="/./assets/image-20230722160133825.png" alt="image-20230722160133825"></p><ul><li>RL<ul><li>找到第一个不平衡的节点</li><li>往下数两个节点——新的根节点</li><li>往下数的第一个节点是新根节点的左节点，旧根节点是新根节点的右节点</li><li>新根节点原先的左子树给到左边的右子树</li><li>新根节点原来的右子树给到右边的左子树</li></ul></li></ul><p><img src="/./assets/image-20230722160145092.png" alt="image-20230722160145092"></p><p><img src="/./assets/image-20230722160404268.png" alt="image-20230722160404268"></p><p><img src="/./assets/image-20230722160548581.png" alt="image-20230722160548581"></p><ul><li>LR</li></ul><p><img src="/./assets/image-20230722160839925.png" alt="image-20230722160839925"></p><p><img src="/./assets/image-20230722160851663.png" alt="image-20230722160851663"></p><h4 id="查找效率分析-1"><a href="#查找效率分析-1" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul><li>若树高为h，最坏情况下查找一个关键字最多需要对比h次，即查找操作的时间复杂度不肯呢个超过O(h)</li><li>所以应该尽可能降低树高<ul><li>假设以nh表示深度为h的平衡树中含有的最少节点数</li><li>则有n0 &#x3D; 0, n1 &#x3D; 1, n2 &#x3D; 2,并且nh &#x3D; n(h-1) + n(h-2) + 1（n(h-1)：h-1层最少的节点数；n(h-2)：h-2层最少的节点数）</li></ul></li><li>平均查找长度：O(log2n)</li></ul><p><img src="/./assets/image-20230722161325806.png" alt="image-20230722161325806"></p><h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="插入-VS-删除"><a href="#插入-VS-删除" class="headerlink" title="插入 VS 删除"></a>插入 VS 删除</h5><ul><li>平衡二叉树的插入操作<ul><li>插入新节点后，要保持二叉排序树的特性不变（左&lt;中&lt;右）</li><li>若插入新节点导致不平衡，则需要调整平衡</li></ul></li><li>平衡二叉树的删除操作<ul><li>删除节点后，要保持二叉排序树的特性不变</li><li>若删除节点导致不平衡，则需要调整平衡</li></ul></li></ul><h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><ul><li>平衡二叉树删除操作<ul><li>删除节点（方法同“二叉排序树”）<ul><li>若被删除节点z是叶子节点，则直接删除，不会破坏二叉排序树的性质</li><li>若被删除节点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，代替z的位置</li><li>若被删除节点z有左右两棵子树，则令z的直接后继（或直接前驱）代替z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况</li></ul></li><li>一路向上找到最小不平衡子树，找不到就完结撒花</li><li>找最小不平衡子树下，个头最高的儿子、孙子</li><li>根据孙子的位置，调整平衡（LL&#x2F;RR&#x2F;LR&#x2F;RL）</li><li>如果不平衡向上传导，继续2</li></ul></li></ul><h5 id="例一：未出现不平衡现象"><a href="#例一：未出现不平衡现象" class="headerlink" title="例一：未出现不平衡现象"></a>例一：未出现不平衡现象</h5><p><img src="/./assets/image-20230722170523667.png" alt="image-20230722170523667"></p><h5 id="例二：出现不平衡现象"><a href="#例二：出现不平衡现象" class="headerlink" title="例二：出现不平衡现象"></a>例二：出现不平衡现象</h5><p><img src="/./assets/image-20230722170659751.png" alt="image-20230722170659751"></p><ul><li>寻找最小不平衡子树</li></ul><p><img src="/./assets/image-20230722170711073.png" alt="image-20230722170711073"></p><ul><li>寻找个头最高的儿子、孙子</li></ul><p><img src="/./assets/image-20230722170841722.png" alt="image-20230722170841722"></p><ul><li>根据孙子的位置，调整平衡</li></ul><p><img src="/./assets/image-20230722171008471.png" alt="image-20230722171008471"></p><p><img src="/./assets/image-20230722171059051.png" alt="image-20230722171059051"></p><ul><li>检查不平衡性是否向上传导（高度减少引起的）</li></ul><p><img src="/./assets/image-20230722171140684.png" alt="image-20230722171140684"></p><h5 id="例三：出现不平衡现象"><a href="#例三：出现不平衡现象" class="headerlink" title="例三：出现不平衡现象"></a>例三：出现不平衡现象</h5><ul><li>删除节点</li></ul><p><img src="/./assets/image-20230722171239949.png" alt="image-20230722171239949"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/./assets/image-20230722171327214.png" alt="image-20230722171327214"></p><ul><li>找个头最高的儿子、孙子</li></ul><p><img src="/./assets/image-20230722171353783.png" alt="image-20230722171353783"></p><ul><li>根据孙子的位置，调整平衡</li></ul><p><img src="/./assets/image-20230722174330718.png" alt="image-20230722174330718"></p><p><img src="/./assets/image-20230722174426010.png" alt="image-20230722174426010"></p><p><img src="/./assets/image-20230722174437084.png" alt="image-20230722174437084"></p><ul><li>寻找传导</li></ul><p><img src="/./assets/image-20230722174450964.png" alt="image-20230722174450964"></p><h5 id="例四：出现不平衡传导现象"><a href="#例四：出现不平衡传导现象" class="headerlink" title="例四：出现不平衡传导现象"></a>例四：出现不平衡传导现象</h5><ul><li>删除节点</li></ul><p><img src="/./assets/image-20230722174533792.png" alt="image-20230722174533792"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/./assets/image-20230722174546095.png" alt="image-20230722174546095"></p><ul><li>找到向上传导的不平衡子树</li></ul><p><img src="/./assets/image-20230722174556963.png" alt="image-20230722174556963"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/./assets/image-20230722174608517.png" alt="image-20230722174608517"></p><ul><li>找到个头最高的儿子、孙子</li></ul><p><img src="/./assets/image-20230722174626038.png" alt="image-20230722174626038"></p><ul><li>根据孙子位置，调整平衡</li></ul><p><img src="/./assets/image-20230722174636891.png" alt="image-20230722174636891"></p><p><img src="/./assets/image-20230722174647349.png" alt="image-20230722174647349"></p><ul><li>寻找向上传导的不平衡</li></ul><p><img src="/./assets/image-20230722174747828.png" alt="image-20230722174747828"></p><h5 id="例五：删除的节点不是叶子节点（前驱-后继-不太可能考）"><a href="#例五：删除的节点不是叶子节点（前驱-后继-不太可能考）" class="headerlink" title="例五：删除的节点不是叶子节点（前驱&#x2F;后继  不太可能考）"></a>例五：删除的节点不是叶子节点（前驱&#x2F;后继  不太可能考）</h5><ul><li>按照二叉排序树的顺序，删除叶子节点</li></ul><p><img src="/./assets/image-20230722174804992.png" alt="image-20230722174804992"></p><p><img src="/./assets/image-20230722201032502.png" alt="image-20230722201032502"></p><p><img src="/./assets/image-20230722201306385.png" alt="image-20230722201306385"></p><ul><li>寻找最小不平衡树</li></ul><p><img src="/./assets/image-20230722201429690.png" alt="image-20230722201429690"></p><ul><li>找到个头最高的儿子、孙子</li></ul><p><img src="/./assets/image-20230722201455517.png" alt="image-20230722201455517"></p><ul><li>根据孙子的位置，调整平衡</li></ul><p><img src="/./assets/image-20230722201520289.png" alt="image-20230722201520289"></p><ul><li>寻找向上传导的不平衡子树</li></ul><p><img src="/./assets/image-20230722201551458.png" alt="image-20230722201551458"></p><h5 id="例六：孙子-儿子个头相等（不太可能考）"><a href="#例六：孙子-儿子个头相等（不太可能考）" class="headerlink" title="例六：孙子&#x2F;儿子个头相等（不太可能考）"></a>例六：孙子&#x2F;儿子个头相等（不太可能考）</h5><ul><li>删除节点</li></ul><p><img src="/./assets/image-20230722201847149.png" alt="image-20230722201847149"></p><p><img src="/./assets/image-20230722201857078.png" alt="image-20230722201857078"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/./assets/image-20230722201908691.png" alt="image-20230722201908691"></p><ul><li>找到个头最高的儿子、孙子（这里孙子个头相等）</li><li>假设选择右孙子</li></ul><p><img src="/./assets/image-20230722201921210.png" alt="image-20230722201921210"></p><p><img src="/./assets/image-20230722201955749.png" alt="image-20230722201955749"></p><ul><li>寻找传导</li></ul><p><img src="/./assets/image-20230722202222835.png" alt="image-20230722202222835"></p><ul><li>找到个头最高的儿子、孙子（这里孙子个头相等）</li><li>假设选择左孙子</li></ul><p><img src="/./assets/image-20230722202307745.png" alt="image-20230722202307745"></p><ul><li>RL：调整平衡</li></ul><p><img src="/./assets/image-20230722202329133.png" alt="image-20230722202329133"></p><p><img src="/./assets/image-20230722202346340.png" alt="image-20230722202346340"></p><ul><li>寻找传导</li></ul><p><img src="/./assets/image-20230722202402979.png" alt="image-20230722202402979"></p><h3 id="红黑树（RBT）"><a href="#红黑树（RBT）" class="headerlink" title="红黑树（RBT）"></a>红黑树（RBT）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><h5 id="为什么要发明红黑树？"><a href="#为什么要发明红黑树？" class="headerlink" title="为什么要发明红黑树？"></a>为什么要发明红黑树？</h5><ul><li><p>为什么要发明红黑树？</p><ul><li><p>平衡二叉树AVL</p><ul><li>插入&#x2F;删除太麻烦了，适用于以查为主，很少插入&#x2F;删除的场景</li><li>插入&#x2F;删除很容易破坏“平衡”特性，需要频繁调整树的形态</li><li>插入操作导致不平衡，则需先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL&#x2F;RR&#x2F;LR&#x2F;RL调整</li></ul></li><li><p>红黑树RBT</p><ul><li>适用于频繁删除&#x2F;插入的场景，实用性更强</li><li>插入&#x2F;删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。</li><li>即使需要调整，一般都可以在常数级时间内完成</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230722203124639.png" alt="image-20230722203124639"></p><h5 id="红黑树大概会怎么考？"><a href="#红黑树大概会怎么考？" class="headerlink" title="红黑树大概会怎么考？"></a>红黑树大概会怎么考？</h5><p><img src="/./assets/image-20230722204326527.png" alt="image-20230722204326527"></p><h5 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h5><ul><li>红黑树是二叉排序树<ul><li>左子树节点值 &lt; 根节点值 &lt; 右子树节点值</li></ul></li><li>与普通BST相比有什么要求？<ul><li>每个节点或是红的，或是黑的</li><li><strong>根节点是黑的</strong></li><li><strong>叶节点</strong>（外部节点、NULL节点、失败节点）均是<strong>黑色</strong>的</li><li><strong>不存在两个相邻的红节点</strong>（即红节点的父节点和孩子节点均是黑色的）</li><li>对每个节点，从该节点到任一叶节点的简单路径上，所含<strong>黑节点的数目</strong>相同</li></ul></li></ul><p><img src="/./assets/image-20230722205005924.png" alt="image-20230722205005924"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Elemtype int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBNode</span>&#123;              <span class="comment">//红黑树的节点定义</span></span><br><span class="line">    <span class="type">int</span> key;                <span class="comment">//关键字的值</span></span><br><span class="line">    RBNode* parent;         <span class="comment">//父节点指针</span></span><br><span class="line">    RBNode *lchild;         <span class="comment">//左孩子指针</span></span><br><span class="line">    RBNode *rchild;         <span class="comment">//右孩子指针</span></span><br><span class="line">    <span class="type">int</span> color;              <span class="comment">//节点颜色，如：可用0/1 表示 黑/红，也可以用枚举类型enum表示颜色</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230722205045602.png" alt="image-20230722205045602"></p><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p><img src="/./assets/image-20230722205411210.png" alt="image-20230722205411210"></p><p><img src="/./assets/image-20230722205423079.png" alt="image-20230722205423079"></p><p><img src="/./assets/image-20230722205753797.png" alt="image-20230722205753797"></p><p><img src="/./assets/image-20230722205902071.png" alt="image-20230722205902071"></p><p><img src="/./assets/image-20230722205918687.png" alt="image-20230722205918687"></p><h4 id="节点的黑高bh"><a href="#节点的黑高bh" class="headerlink" title="节点的黑高bh"></a>节点的黑高bh</h4><ul><li>从某节点出发（不含该节点）到达任一空叶节点的路径上黑节点总数</li></ul><p><img src="/./assets/image-20230722210040059.png" alt="image-20230722210040059"></p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul><li><p>节点的黑高bh——从某节点出发（不含该节点）到达任一叶节点的路径上黑节点总数</p></li><li><p>根节点黑高为h的红黑树，内部节点数（关键字）至少有多少个</p><ul><li>满二叉树，并且节点全为黑</li><li>内部节点个数至少为2^h-1</li></ul></li><li><p>根节点黑高为h的红黑树，内部节点最多有多少个？</p><ul><li>h层黑节点，每一层黑节点下都铺满一层红节点。共2h层的满树状态</li><li>最多有2^2h - 1个</li></ul></li><li><p>性质一：<strong>从根节点到叶节点的最长路径不大于最短路径的二倍</strong></p><ul><li>左右子树的高度相差不到2倍（条件更宽松，不太容易被破坏）</li><li>而平衡二叉树AVL要求左右子树高度差不超过1（条件更严格，很容易被破坏）</li><li>任何一条查找失败路径上黑节点数量都是相同的，而路径上不能连续出现两个红节点，即红节点只能穿插在各个黑节点中间</li></ul></li><li><p>性质二：<strong>有n个内部节点的红黑树高度 h &lt;&#x3D; 2log2(n+1)</strong></p><ul><li>若红黑树总高度&#x3D;h，则根节点黑高&gt;h&#x2F;2，因此内部节点数n&gt;&#x3D;2^(h&#x2F;2)-1，由此推出h &lt;&#x3D; 2log2(n+1)</li></ul></li><li><p>查找时间复杂度 &#x3D; O(log2n)</p></li></ul><p><img src="/./assets/image-20230724161947156.png" alt="image-20230724161947156"></p><p><img src="/./assets/image-20230724162337908.png" alt="image-20230724162337908"></p><p><img src="/./assets/image-20230722210146870.png" alt="image-20230722210146870"></p><p><img src="/./assets/image-20230724162601947.png" alt="image-20230724162601947"></p><h4 id="插入操作-2"><a href="#插入操作-2" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>先查找，确认插入位置（原理同二叉排序树），插入新节点</li><li>新节点是<strong>根</strong>——染为黑色</li><li>新节点是非根——染为红色<ul><li>若插入新节点后依然满足红黑树的定义，则插入结束</li><li>若插入新节点后不满足红黑树的定义，需要调整，使其重新满足红黑树定义<ul><li>黑叔：旋转+染色<ul><li>LL型：右单旋转，父换爷+染色</li><li>RR型：左单旋转，父换爷+染色</li><li>LR型：左、右双旋，儿换爷+染色</li><li>RL型：右、左双旋，儿换爷+染色</li></ul></li><li>红叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul></li></ul></li></ul><p><img src="/./assets/image-20230723233820042.png" alt="image-20230723233820042"></p><h5 id="插入操作举例"><a href="#插入操作举例" class="headerlink" title="插入操作举例"></a>插入操作举例</h5><ul><li><p>左根右：按照二叉排序树的方式插入</p></li><li><p>根叶黑：很容易添加和判断，根节点和为NULL的叶子节点</p></li><li><p>黑路同：添加的都是非根节点，都为红色，所以不会破坏</p></li><li><p><strong>不红红</strong></p><ul><li>是添加新节点所破坏的特性</li><li>看叔叔颜色</li></ul></li><li><p>黑叔叔：旋转+染色</p><ul><li>LL：右单旋转，父爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724135626653.png" alt="image-20230724135626653"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷（三个）染色，爷变为新节点（有可能爷违反不红红特性）</li></ul></li></ul><p><img src="/./assets/image-20230724140956016.png" alt="image-20230724140956016"></p><ul><li>黑叔叔：旋转+染色<ul><li>RR：左单旋转，父爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724141105719.png" alt="image-20230724141105719"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/./assets/image-20230724141150466.png" alt="image-20230724141150466"></p><ul><li>不需要变色</li></ul><p><img src="/./assets/image-20230724141235255.png" alt="image-20230724141235255"></p><ul><li>黑叔叔：旋转+染色<ul><li>LL：右单旋转，父爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724141251547.png" alt="image-20230724141251547"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/./assets/image-20230724141330082.png" alt="image-20230724141330082"></p><ul><li>不需要变色</li></ul><p><img src="/./assets/image-20230724141531171.png" alt="image-20230724141531171"></p><ul><li>不需要变色</li></ul><p><img src="/./assets/image-20230724141557266.png" alt="image-20230724141557266"></p><ul><li>不需要变色</li></ul><p><img src="/./assets/image-20230724141700165.png" alt="image-20230724141700165"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li><li>如果根节点变为红色，要变成黑色</li></ul></li></ul><p><img src="/./assets/image-20230724141717596.png" alt="image-20230724141717596"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142107748.png" alt="image-20230724142107748"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142204185.png" alt="image-20230724142204185"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142241883.png" alt="image-20230724142241883"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142320887.png" alt="image-20230724142320887"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/./assets/image-20230724142400447.png" alt="image-20230724142400447"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/./assets/image-20230724142430892.png" alt="image-20230724142430892"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142519774.png" alt="image-20230724142519774"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿换爷+染色</li></ul></li></ul><p><img src="/./assets/image-20230724142555702.png" alt="image-20230724142555702"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142634110.png" alt="image-20230724142634110"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142709720.png" alt="image-20230724142709720"></p><ul><li>不需要变色</li></ul><p><img src="/./assets/image-20230724142753160.png" alt="image-20230724142753160"></p><ul><li>黑叔叔：旋转+染色<ul><li>RL型：右左双旋，儿爷染色</li></ul></li></ul><p><img src="/./assets/image-20230724142805621.png" alt="image-20230724142805621"></p><p><img src="/./assets/image-20230724142851819.png" alt="image-20230724142851819"></p><p><img src="/./assets/image-20230724142908091.png" alt="image-20230724142908091"></p><p><img src="/./assets/image-20230724142918548.png" alt="image-20230724142918548"></p><h4 id="删除操作（不考）"><a href="#删除操作（不考）" class="headerlink" title="删除操作（不考）"></a>删除操作（不考）</h4><h5 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h5><ul><li>红黑树删除操作的时间复杂度&#x3D;O(log2n)</li><li>在红黑树中删除节点的处理方式和“二叉排序树的删除一样”</li><li>按上述删除节点后，可能破坏红黑树特性，此时需要调整及诶单颜色、位置，使其在此满足红黑树特性</li></ul><p><img src="/./assets/image-20230724163228077.png" alt="image-20230724163228077"></p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul><li>考察的主要是性质和手算方法</li><li>如果每个节点只有一个关键字——二叉排序树</li></ul><h4 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h4><p><img src="/./assets/image-20230724164208501.png" alt="image-20230724164208501"></p><ul><li>二叉排序树节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BSTNode, *BSTree;</span><br></pre></td></tr></table></figure><ul><li>5叉排序树</li></ul><p><img src="/./assets/image-20230724164413840.png" alt="image-20230724164413840"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Elemtype keys[<span class="number">4</span>];                   <span class="comment">//最多4个关键字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* child[<span class="number">55</span>];             <span class="comment">//最多5个孩子</span></span><br><span class="line">    <span class="type">int</span> num;                            <span class="comment">//节点中有几个关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>节点中keys是顺序排放的，每个节点内也可以采用折半查找</li></ul><h5 id="查找成功-5"><a href="#查找成功-5" class="headerlink" title="查找成功"></a>查找成功</h5><p><img src="/./assets/image-20230724165022783.png" alt="image-20230724165022783"></p><p><img src="/./assets/image-20230724165036215.png" alt="image-20230724165036215"></p><h5 id="查找失败-6"><a href="#查找失败-6" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/./assets/image-20230724165157934.png" alt="image-20230724165157934"></p><p><img src="/./assets/image-20230724165216572.png" alt="image-20230724165216572"></p><h4 id="如何保证查找效率"><a href="#如何保证查找效率" class="headerlink" title="如何保证查找效率"></a>如何保证查找效率</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li><p>若每个节点内关键字太少，导致树变高，要查更多层节点，效率变低</p></li><li><p>不够平衡，树会很高，要查很多层节点</p></li></ul><p><img src="/./assets/image-20230724170105992.png" alt="image-20230724170105992"></p><p><img src="/./assets/image-20230724170133321.png" alt="image-20230724170133321"></p><h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><ul><li><p>m叉查找树中，规定除了根节点外，任何节点至少有[m&#x2F;2]个分叉，即至少含有 [m&#x2F;2]-1 个关键字</p><ul><li><p>Eg：5叉排序树，规定除了根节点外，任何节点都至少有3个分叉，2个关键字</p></li><li><p>为什么除了根节点外？</p><ul><li>如果整个树只有一个元素，根节点只有两个分叉</li></ul></li></ul></li><li><p>m叉排序素中，规定对于任何一个节点，其所有子树的高度都要相同</p></li></ul><p><img src="/./assets/image-20230724165555484.png" alt="image-20230724165555484"></p><p><img src="/./assets/image-20230724165844965.png" alt="image-20230724165844965"></p><p><img src="/./assets/image-20230724170138709.png" alt="image-20230724170138709"></p><h4 id="B树定义"><a href="#B树定义" class="headerlink" title="B树定义"></a>B树定义</h4><ul><li>B树，又称多路平衡查找树<ul><li>B树中所被允许的孩子个数的最大值成为<strong>B树的阶</strong>，通常用m表示</li><li>一棵m阶B树或为空树，或为满足以下特性的m叉树<ul><li>树中每个节点最多有m棵子树，即至多含有m-1个关键字</li><li>若根节点不是终端节点，则至少有两棵子树</li><li>除根节点外的所有非叶节点至少有  <strong>[m&#x2F;2]向上取整</strong>  棵子树，即至少含有[m&#x2F;2]-1个关键字</li><li>所有的叶节点都出现在同一层次上，并且不带信息（可以视为外部节点或类似于折半查找判定树的查找失败节点，实际上这些节点不存在，指向这些节点的指针为空）</li><li>所有非叶子节点的结构如下：<ul><li>n：节点中关键字的个数（[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m-1）</li><li>Ki：节点的关键字，且满足 K1 &lt; K2 &lt; …. &lt; Kn</li><li>Pi：指向子树根节点的指针，且指针Pi-1所指子树中所有节点的关键字均小于Ki，Pi所指子树中所有节点的关键字均大于Ki</li></ul></li></ul></li></ul></li></ul><p><img src="/./assets/image-20230724170426451.png" alt="image-20230724170426451"></p><p><img src="/./assets/image-20230724171123621.png" alt="image-20230724171123621"></p><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ol><li><p>根节点的子树数[2,m]，关键字数[1,m-1]</p><p>其他节点的子树数[m&#x2F;2,m]，关键字数[[m&#x2F;2-1,m-1]]</p></li><li><p>对任一节点，其所有子树高度相同</p></li><li><p>关键字的值：子树0 &lt; 关键字1 &lt; 子树1 &lt; 关键字2 &lt; 子树2 &lt;…（类似二叉查找树 左 &lt; 中 &lt; 右）</p></li></ol><p><img src="/./assets/image-20230724171823380.png" alt="image-20230724171823380"></p><h4 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h4><ul><li><p>B树的高度不包括叶子节点（失败节点）</p></li><li><p>含有n个关键字的m阶B树，最小高度、最大高度是多少？</p><ul><li><p>最小高度——让每个节点尽可能的满，有m-1个关键字，m个分叉，则有</p><p>n &lt;&#x3D; (m-1)(1 + m + m^2 + m^3 +… + m^(h-1)) &#x3D; m^h -1</p><p>h &gt;&#x3D; logm(n+1)</p></li><li><p>最大高度——让各层的分叉尽可能的少，即根节点只有两个分叉，其他节点只有[m&#x2F;2]个分叉</p><p>各层的节点至少有：第一层 1、第二层 2、第三层 2[m&#x2F;2] … 第h层2([m&#x2F;2])^(h-2)</p><p>第h+1层共有叶子节点（失败节点） 2([m&#x2F;2])^(h-1) 个</p><p>n个关键字的B树必有n+1个叶子节点，则 n+1 &gt;&#x3D; 2([m&#x2F;2])^(h-1)，即 h&lt;&#x3D;log[m&#x2F;2]((n+1)&#x2F;2+1)</p></li></ul></li></ul><p><img src="/./assets/image-20230724172944340.png" alt="image-20230724172944340"></p><p><img src="/./assets/image-20230724171843466.png" alt="image-20230724171843466"></p><p><img src="/./assets/image-20230724172635714.png" alt="image-20230724172635714"></p><p><img src="/./assets/image-20230724172903538.png" alt="image-20230724172903538"></p><h4 id="插入操作-3"><a href="#插入操作-3" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li><p>在插入key后，若导致原节点关键字数超过上限</p><ul><li><p>从中间位置（[m&#x2F;2]）将其中的关键字分为两部分</p></li><li><p>左部分包含的关键字放在原节点中</p></li><li><p>右部分包含的关键字放到新节点中</p></li><li><p>中间位置（[m&#x2F;2]）的节点插入原节点的父节点</p></li><li><p>若此时导致其<strong>⽗结点的关键字个数</strong>也超过了上限，则继续进⾏这种分裂操作，直⾄这个过程传到根结点为⽌，进</p><p>⽽导致<em>B</em>树<strong>⾼度增<em>1</em></strong>。</p></li></ul></li><li><p>新元素一定是插入到最底层“终端节点”，用查找来确定插入位置</p><ul><li>原因：B树的失败节点只能出现在最下面一层</li></ul></li></ul><p><img src="/./assets/image-20230724173338522.png" alt="image-20230724173338522"></p><p><img src="/./assets/image-20230724173316457.png" alt="image-20230724173316457"></p><p><img src="/./assets/image-20230724174442318.png" alt="image-20230724174442318"></p><h5 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h5><p><img src="/./assets/image-20230724174452820.png" alt="image-20230724174452820"></p><h5 id="正确示范"><a href="#正确示范" class="headerlink" title="正确示范"></a>正确示范</h5><p><img src="/./assets/image-20230724174612505.png" alt="image-20230724174612505"></p><p><img src="/./assets/image-20230724174624053.png" alt="image-20230724174624053"></p><p><img src="/./assets/image-20230724174723342.png" alt="image-20230724174723342"></p><p><img src="/./assets/image-20230724174737753.png" alt="image-20230724174737753"></p><p><img src="/./assets/image-20230724174750008.png" alt="image-20230724174750008"></p><p><img src="/./assets/image-20230724174801298.png" alt="image-20230724174801298"></p><p><img src="/./assets/image-20230724174917720.png" alt="image-20230724174917720"></p><p><img src="/./assets/image-20230724174927975.png" alt="image-20230724174927975"></p><p><img src="/./assets/image-20230724174938113.png" alt="image-20230724174938113"></p><p><img src="/./assets/image-20230724174949101.png" alt="image-20230724174949101"></p><p><img src="/./assets/image-20230724174959449.png" alt="image-20230724174959449"></p><p><img src="/./assets/image-20230724175010391.png" alt="image-20230724175010391"></p><p><img src="/./assets/image-20230724175022162.png" alt="image-20230724175022162"></p><p><img src="/./assets/image-20230724175113722.png" alt="image-20230724175113722"></p><h5 id="核心要求"><a href="#核心要求" class="headerlink" title="核心要求"></a>核心要求</h5><ol><li>对于m阶B树——除根节点外，节点关键字个数[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m-1</li><li>子树0 &lt; 关键字1 &lt; 子树1 &lt; 关键字2 &lt; 子树2 &lt; …</li></ol><p>新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</p><p>在插入key后，若导致原节点关键字数超过上限</p><ul><li><p>从中间位置（[m&#x2F;2]）将其中的关键字分为两部分</p></li><li><p>左部分包含的关键字放在原节点中</p></li><li><p>右部分包含的关键字放到新节点中</p></li><li><p>中间位置（[m&#x2F;2]）的节点插入原节点的父节点</p></li><li><p>若此时导致其<strong>⽗结点的关键字个数</strong>也超过了上限，则继续进⾏这种分裂操作，直⾄这个过程传到根结点为⽌，进</p><p>⽽导致<em>B</em>树<strong>⾼度增<em>1</em></strong>。</p></li></ul><p><img src="/./assets/image-20230724175515975.png" alt="image-20230724175515975"></p><h4 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li><p>本质：要永远保证 ⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2&lt;…</p></li><li><p>若被删除关键字在<strong>终端节点</strong>，则直接删除该关键字（要注意节点关键字个数是否低于下限[m&#x2F;2]-1）</p><ul><li><p>关键字个数高于下限，直接删除</p></li><li><p>关键字个数低于下限</p><ul><li><p>兄弟够借：若与此节点右（或左）兄弟节点的关键字个数还很宽裕，则需要调整该节点、右（或左）兄弟节点及其双亲节点（父子换位法）</p><p>用当前节点的后继、后继的后继来填补空缺</p></li><li><p>兄弟不够：若被删除关键字所在节点删除前的关键字个数低于下限，且此时与该节点相邻的左、右兄弟节点的关键字个数均 &#x3D; [m&#x2F;2]-1，则将关键字删除后与<strong>左（或右）兄弟节点及双亲节点中的关键字</strong>进行合并</p><ul><li><p>在合并过程中，双亲结点中的关键字个数会减<em>1</em>。若<strong>其双亲结点是根结点且关键字个数减少⾄<em>0</em></strong>（根结点关键</p><p>字个数为<em>1</em>时，有<em>2</em>棵⼦树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关</p><p>键字个数减少到 ，则⼜要与它⾃⼰的兄弟结点进⾏调整或合并操作，并重复上述步骤，直⾄符合<em>B</em></p><p>树的要求为⽌。</p></li></ul></li></ul></li></ul></li><li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱</strong>或<strong>直接后继</strong>来替代被删除的关键字</p><ul><li>对非终端节点关键字的删除，必然可以转化为对终端节点的删除操作</li><li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</li><li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</li></ul></li><li><p>删除60（终端节点，关键字个数大于下限）</p></li></ul><p><img src="/./assets/image-20230724175642625.png" alt="image-20230724175642625"></p><p><img src="/./assets/image-20230724175703525.png" alt="image-20230724175703525"></p><ul><li>删除80（非终端节点）</li></ul><p><img src="/./assets/image-20230724180158230.png" alt="image-20230724180158230"></p><ul><li>删除38（终端节点，关键字个数低于下限（[m&#x2F;2]-1，右兄弟够借）</li></ul><p><img src="/./assets/image-20230724180706078.png" alt="image-20230724180706078"></p><p><img src="/./assets/image-20230724180801039.png" alt="image-20230724180801039"></p><p><img src="/./assets/image-20230724180743887.png" alt="image-20230724180743887"></p><p><img src="/./assets/image-20230724180820612.png" alt="image-20230724180820612"></p><p><img src="/./assets/image-20230724180834789.png" alt="image-20230724180834789"></p><ul><li>删除90（终端节点，关键字个数低于下限（[m&#x2F;2]-1，左兄弟够借）</li></ul><p><img src="/./assets/image-20230724181054994.png" alt="image-20230724181054994"></p><p><img src="/./assets/image-20230724181106247.png" alt="image-20230724181106247"></p><p><img src="/./assets/image-20230724181139105.png" alt="image-20230724181139105"></p><ul><li>删除49（终端节点，关键字个数低于下限（[m&#x2F;2]-1，左右兄弟不够借）</li></ul><p><img src="/./assets/image-20230724181548842.png" alt="image-20230724181548842"></p><p><img src="/./assets/image-20230724181600641.png" alt="image-20230724181600641"></p><p><img src="/./assets/image-20230724181612150.png" alt="image-20230724181612150"></p><p><img src="/./assets/image-20230724181623803.png" alt="image-20230724181623803"></p><p><img src="/./assets/image-20230724181640464.png" alt="image-20230724181640464"></p><p><img src="/./assets/image-20230724181710337.png" alt="image-20230724181710337"></p><p><img src="/./assets/image-20230724181721590.png" alt="image-20230724181721590"></p><p><img src="/./assets/image-20230724181735840.png" alt="image-20230724181735840"></p><p><img src="/./assets/image-20230724181748109.png" alt="image-20230724181748109"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="/./assets/image-20230724190455779.png" alt="image-20230724190455779"></p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p><img src="/./assets/image-20230724191732976.png" alt="image-20230724191732976"></p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>一棵m阶的B+树需满足下列条件：<ul><li>每个分支节点最多有m棵子树（孩子节点）</li><li>非叶根节点至少两棵子树，其他每个分支节点至少有[m&#x2F;2]棵子树（保证每个节点不要太空）</li><li><strong>节点的子树个数与关键字个数相等</strong></li><li>所有叶节点包含全部<strong>关键字及指向对应记录的指针</strong>，叶节点中将关键字<strong>按大小顺序排列</strong>，并且相邻叶节点按大小顺序相互连接起来</li><li>所有分支节点中仅包含它的各个子节点中关键字的最大值及指向其子节点的指针</li></ul></li><li>B+树支持顺序查找，每个节点中都有顺序，有节点p将叶子节点中的数据从小到大连接起来</li></ul><p><img src="/./assets/image-20230724191752521.png" alt="image-20230724191752521"></p><ul><li>非叶根节点至少两棵子树，其他每个分支节点至少有[m&#x2F;2]棵子树</li></ul><p><img src="/./assets/image-20230724192047266.png" alt="image-20230724192047266"></p><h4 id="查找操作-2"><a href="#查找操作-2" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>要一直找到<strong>叶子节点</strong></li></ul><h5 id="查找成功-6"><a href="#查找成功-6" class="headerlink" title="查找成功"></a>查找成功</h5><p><img src="/./assets/image-20230724192553775.png" alt="image-20230724192553775"></p><p><img src="/./assets/image-20230724193232557.png" alt="image-20230724193232557"></p><h5 id="查找失败-7"><a href="#查找失败-7" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/./assets/image-20230724193244882.png" alt="image-20230724193244882"></p><p><img src="/./assets/image-20230724193310419.png" alt="image-20230724193310419"></p><h5 id="对比：B树的查找"><a href="#对比：B树的查找" class="headerlink" title="对比：B树的查找"></a>对比：B树的查找</h5><ul><li>查找成功可能停在任何一层</li></ul><p><img src="/./assets/image-20230724193808032.png" alt="image-20230724193808032"></p><h5 id="顺序查找-1"><a href="#顺序查找-1" class="headerlink" title="顺序查找"></a>顺序查找</h5><p><img src="/./assets/image-20230724194007548.png" alt="image-20230724194007548"></p><p><img src="/./assets/image-20230724194017044.png" alt="image-20230724194017044"></p><h5 id="B树-VS-B-树"><a href="#B树-VS-B-树" class="headerlink" title="B树 VS B+树"></a>B树 VS B+树</h5><ul><li><p>m阶B+树</p><ul><li><p>节点中n个关键字对应n棵子树</p></li><li><p>根节点的关键字数n∈[1, m]</p><p> 其他结点的关键字数n∈[⌈<em>m</em>&#x2F;2⌉, m]</p></li><li><p>在B+树中，叶节点包含全部的关键字，非叶节点中出现过的关键字也会出现在叶节点中</p></li><li><p>在B+树中，<strong>叶结点包含信息</strong>，所有<strong>⾮叶结点仅起索引作⽤</strong>，⾮叶结点中的每个索引项只含有对应⼦</p><p>树的<strong>最⼤关键字</strong>和指向<strong>该⼦树的指针</strong>，不含有该关键字对应记录的存储地址</p></li></ul></li><li><p>m阶B树</p><ul><li><p>结点中的n个关键字对应n+1棵⼦树</p></li><li><p>根节点的关键字数n∈[1, m-1]。</p><p>其他结点的关键字数n∈[⌈<em>m</em>&#x2F;2⌉-1, m-1]</p></li><li><p>在B树中，各结点中包含的关键字是不重复的</p></li><li><p>B树的节点中都包含了关键字对应的记录的存储地址</p></li></ul></li></ul><p><img src="/./assets/image-20230724194041626.png" alt="image-20230724194041626"></p><p><img src="/./assets/image-20230724194115738.png" alt="image-20230724194115738"></p><p><img src="/./assets/image-20230724194707895.png" alt="image-20230724194707895"></p><h4 id="应用（与操作系统有关）"><a href="#应用（与操作系统有关）" class="headerlink" title="应用（与操作系统有关）"></a>应用（与操作系统有关）</h4><ul><li>B+树仅保存索引表，非叶节点不含有该关键字对应记录的存储地址<ul><li>可以使一个磁盘快可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快</li></ul></li></ul><p><img src="/./assets/image-20230724195012681.png" alt="image-20230724195012681"></p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul><li>通常不考代码，着重掌握手算分析方法</li></ul><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="散列表、散裂函数"><a href="#散列表、散裂函数" class="headerlink" title="散列表、散裂函数"></a>散列表、散裂函数</h4><ul><li><p>散列表（哈希表，Hash Table）</p><ul><li>一种数据结构</li><li>特点：可以根据数据元素的关键字计算出它在散列表中的存储地址<ul><li>查找<ul><li>先根据散列函数 H(key) 计算出目标元素在散列表中的存储地址</li><li>然后检查这个位置的元素就可以知道是查找成功还是失败</li></ul></li><li>理想情况下，在散列表中查找一个元素的时间复杂度为O(1)</li></ul></li></ul></li><li><p>散列函数（哈希函数）</p><ul><li>Addr &#x3D; H(key) 建立了<strong>“关键字”-&gt;“存储地址”</strong>的映射关系</li></ul></li></ul><p><img src="/./assets/image-20230724200816330.png" alt="image-20230724200816330"></p><h4 id="冲突、同义词"><a href="#冲突、同义词" class="headerlink" title="冲突、同义词"></a>冲突、同义词</h4><ul><li><p>冲突（碰撞）</p><ul><li>在散列表中插入一个数据元素时，需要根据关键字的值确定其存储地址</li><li>若该地址已经存储了其他元素，则称这种情况为“冲突（碰撞）”</li></ul></li><li><p>同义词</p><ul><li>若不同的关键字通过散列函数映射到同一个存储地址，则称它们为“同义词”</li></ul></li><li><p>如何减少冲突？</p><ul><li>构造更合适的散列函数，让各个关键字尽可能的映射到不同的存储位置，从而减少“冲突”</li></ul></li></ul><p><img src="/./assets/image-20230724201328970.png" alt="image-20230724201328970"></p><p><img src="/./assets/image-20230724201711759.png" alt="image-20230724201711759"></p><h4 id="如何处理冲突"><a href="#如何处理冲突" class="headerlink" title="如何处理冲突"></a>如何处理冲突</h4><h5 id="拉链法（链接法、链地址法）"><a href="#拉链法（链接法、链地址法）" class="headerlink" title="拉链法（链接法、链地址法）"></a>拉链法（链接法、链地址法）</h5><ul><li>把所有“同义词”存储到一个链表中</li></ul><p><img src="/./assets/image-20230724202026658.png" alt="image-20230724202026658"></p><h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><ul><li><p>如果发生冲突，就给新元素找一个空闲位置</p></li><li><p>用什么规则确定另一个空闲位置？</p></li></ul><h3 id="构造操作"><a href="#构造操作" class="headerlink" title="构造操作"></a>构造操作</h3><p><img src="/./assets/image-20230724202339055.png" alt="image-20230724202339055"></p><h4 id="设计散列函数"><a href="#设计散列函数" class="headerlink" title="设计散列函数"></a>设计散列函数</h4><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li><p>定义域必须涵盖<strong>所有</strong>可能出现的<strong>关键字</strong></p></li><li><p>值域<strong>不能超出</strong>散列表的地址范围</p></li><li><p>尽可能<strong>减少冲突</strong>。</p></li><li><p>散列表计算出来的地址应尽可能<strong>均匀分布</strong>在整个地址空间</p></li><li><p>散列函数尽可能<strong>简单</strong>，能够快速计算出任意一个关键字对应的散列地址</p></li></ul><p><img src="/./assets/image-20230724202936639.png" alt="image-20230724202936639"></p><h5 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h5><ul><li><strong>散列函数要尽可能减少冲突</strong></li></ul><h5 id="除留余数法（最常用）"><a href="#除留余数法（最常用）" class="headerlink" title="除留余数法（最常用）"></a>除留余数法（最常用）</h5><ul><li><strong>H(key) &#x3D; key % p</strong></li><li>散列表表长为m，取一个不大于m但最接近或等于m的质数p<ul><li>原因：对质数取余，可以分布更均匀，从而减少冲突</li></ul></li><li>使用场景：较为通用，只要关键字是整数即可</li></ul><p><img src="/./assets/image-20230724203058513.png" alt="image-20230724203058513"></p><p><img src="/./assets/image-20230724203405020.png" alt="image-20230724203405020"></p><h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><ul><li><strong>直接定址法 —— H(key) &#x3D; key 或 H(key) &#x3D; a*key + b</strong><ul><li>a和b是常数。</li><li>计算简单，且不会产生冲突。</li><li>缺点：若关键字分布不连续，空位较多，则会造成存储空间的浪费</li></ul></li><li>使用场景：关键字分布基本连续</li></ul><p><img src="/./assets/image-20230724203504603.png" alt="image-20230724203504603"></p><h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><ul><li>选取数码分布较为平均的若干位作为散列地址</li><li>设关键字是r进制数（如十进制数），而r个数码在各位上出现的概率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可以选取数码分布较为均匀的若干位作为散列地址</li><li>适用场景：<strong>关键字集合已知，且关键字的某几个数码位分布均匀</strong></li></ul><p><img src="/./assets/image-20230724203734399.png" alt="image-20230724203734399"></p><h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><ul><li>取关键字的平方值的中间几位作为散列地址</li><li>具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀</li><li>适用场景：<strong>关键字的每位取值都不够均匀</strong></li></ul><p><img src="/./assets/image-20230724210926083.png" alt="image-20230724210926083"></p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>把所有“同义词”存储在一个链表中</li></ul><h4 id="插入操作（默认头插法）"><a href="#插入操作（默认头插法）" class="headerlink" title="插入操作（默认头插法）"></a>插入操作（默认头插法）</h4><ul><li>结合散列函数计算新元素的散列地址</li><li>将新元素插入散列地址对应的链表（可用头插法，也可用尾插法）</li></ul><p><img src="/./assets/image-20230724212211642.png" alt="image-20230724212211642"></p><p><img src="/./assets/image-20230724212425671.png" alt="image-20230724212425671"></p><h5 id="插入操作的优化"><a href="#插入操作的优化" class="headerlink" title="插入操作的优化"></a>插入操作的优化</h5><ul><li>新元素插入链表时，保持链表有序，可以略微提高查找效率</li></ul><h4 id="查找操作-3"><a href="#查找操作-3" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>先计算散列地址</li><li>再查找散列地址里的链表元素</li></ul><h5 id="查找长度-1"><a href="#查找长度-1" class="headerlink" title="查找长度"></a>查找长度</h5><ul><li>在查找计算中，需要对比关键字的次数称为查找长度</li></ul><h5 id="查找成功-7"><a href="#查找成功-7" class="headerlink" title="查找成功"></a>查找成功</h5><ul><li>查找 27，查找长度&#x3D;2</li></ul><p><img src="/./assets/image-20230724212458312.png" alt="image-20230724212458312"></p><ul><li>查找 20，查找长度&#x3D;1</li></ul><p><img src="/./assets/image-20230724212608907.png" alt="image-20230724212608907"></p><h5 id="查找失败-8"><a href="#查找失败-8" class="headerlink" title="查找失败"></a>查找失败</h5><ul><li>查找 66，查找长度 &#x3D; 4</li></ul><p><img src="/./assets/image-20230724212708434.png" alt="image-20230724212708434"></p><ul><li>查找21，查找长度&#x3D;0</li></ul><p><img src="/./assets/image-20230724212849726.png" alt="image-20230724212849726"></p><h4 id="删除操作-3"><a href="#删除操作-3" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>先查找<ul><li>查找成功：删除成功</li><li>查找失败：删除失败</li></ul></li></ul><h5 id="删除成功"><a href="#删除成功" class="headerlink" title="删除成功"></a>删除成功</h5><p><img src="/./assets/image-20230724213007356.png" alt="image-20230724213007356"></p><p><img src="/./assets/image-20230724213021343.png" alt="image-20230724213021343"></p><h5 id="删除失败"><a href="#删除失败" class="headerlink" title="删除失败"></a>删除失败</h5><p><img src="/./assets/image-20230724213108823.png" alt="image-20230724213108823"></p><h3 id="开放定址法-1"><a href="#开放定址法-1" class="headerlink" title="开放定址法"></a>开放定址法</h3><p><img src="/./assets/image-20230724213538954.png" alt="image-20230724213538954"></p><h4 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>如果发生冲突，就给新元素找另一个空闲位置</li><li>开放定址？<ul><li>一个散列地址，既对同义词开放，也对非同义词开放</li></ul></li><li>用什么规则确定“另一个空闲位置”？<ul><li>需要确定一个探测顺序：从初始散列地址出发，去寻找下一个空闲位置</li></ul></li></ul><h4 id="插入操作（自己理解的）"><a href="#插入操作（自己理解的）" class="headerlink" title="插入操作（自己理解的）"></a>插入操作（自己理解的）</h4><ul><li>插入元素，先按照散列函数插入<ul><li>如果插入位置为空（一个位置一个元素），则直接插入</li><li>如果插入位置有人，则根据探测规则 Hi &#x3D; （H(key) + di）% m 找新位置进行插入，重复以上步骤</li></ul></li><li>查找元素，先按照散列函数求值查找<ul><li>如果查找的位置有元素<ul><li>查找的元素和存储的元素相同，则查找成功</li><li>查找的元素与存储的元素不同，则根据探测规则 Hi &#x3D; （H(key) + di）% m 找下一个元素进行对比，重复上述过程</li></ul></li><li>如果查找的位置没有元素，查找失败</li></ul></li></ul><h4 id="查找操作-4"><a href="#查找操作-4" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>（自己理解的）查找元素，先按照散列函数求值查找<ul><li>如果查找的位置有元素<ul><li>查找的元素和存储的元素相同，则查找成功</li><li>查找的元素与存储的元素不同，则根据探测规则 Hi &#x3D; （H(key) + di）% m 找下一个元素进行对比，重复上述过程</li></ul></li><li>如果查找的位置没有元素，查找失败</li></ul></li><li>（视频里的）查找操作<ul><li>与插入操作类似</li><li>根据探测序列依次对比各存储单元内的关键字<ul><li>若探测到目标关键字，则查找成功</li><li>若探测到空单元，则查找失败</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230724213643794.png" alt="image-20230724213643794"></p><p><img src="/./assets/image-20230724213917963.png" alt="image-20230724213917963"></p><p><img src="/./assets/image-20230724214018852.png" alt="image-20230724214018852"></p><h4 id="探测方法"><a href="#探测方法" class="headerlink" title="探测方法"></a>探测方法</h4><h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><ul><li><p>线性探测法，<strong>d****i</strong> <strong>&#x3D; 0, 1, 2, 3, …, m-1</strong></p></li><li><p>不同序列，探测规则相同</p></li><li><p>可以探测到散列表的每个地址</p></li><li><p>插入操作</p><ul><li>先根据散列函数计算插入的位置<ul><li>如果插入位置为空（一个位置一个元素），则直接插入</li><li>如果插入位置有人，则根据探测规则di 找新位置进行插入，重复以上步骤</li></ul></li></ul></li><li><p>查找操作</p><ul><li>与插入操作类似</li><li>根据探测序列依次对比各存储单元内的关键字<ul><li>若探测到目标关键字，则查找成功</li><li>若探测到空单元，则查找失败</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230724214234998.png" alt="image-20230724214234998"></p><h5 id="平方探测法（二次探测法）"><a href="#平方探测法（二次探测法）" class="headerlink" title="平方探测法（二次探测法）"></a>平方探测法（二次探测法）</h5><ul><li><p>跟线性探测法相同</p></li><li><p>平⽅探测法，<em>d**i</em> <em>&#x3D; 0*<em>2</em></em>, 1<strong>2</strong>, -1<strong>2</strong>, 2<strong>2</strong>, -2<strong>2</strong>, …, k<strong>2</strong>, -k*<em>2</em>。</p><p>其中<em>k≤m&#x2F;2</em></p></li></ul><p><img src="/./assets/image-20230724215054488.png" alt="image-20230724215054488"></p><h5 id="双散列法"><a href="#双散列法" class="headerlink" title="双散列法"></a>双散列法</h5><ul><li>双散列法，<em>di</em> <em>&#x3D; i×hash*<em>2</em></em>(key)*</li><li><em>hash*<em>2</em></em>(key)&#x3D;13-(key %13)&#x3D;12*</li><li>不同的序列，探测规则不同</li></ul><p><img src="/./assets/image-20230724215231918.png" alt="image-20230724215231918"></p><h5 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a>伪随机序列法</h5><ul><li><em>d**i</em> 是⼀个伪随机序列，由题⽬可知 <em>d*<em>i</em></em>&#x3D; 0, 5, 3, 11, …*</li></ul><p><img src="/./assets/image-20230724215728836.png" alt="image-20230724215728836"></p><h4 id="删除操作-4"><a href="#删除操作-4" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>先根据散列函数算出散列地址，并对比关键字是否匹配。<ul><li>若匹配，则查找成功</li><li>若不匹配，则根据“探测序列”对比下一个地址的关键字，直到“查找成功”或“查找失败”</li></ul></li><li>若查找成功，则删除找到的元素（逻辑删除，做一个已删除的标记）</li></ul><p><img src="/./assets/image-20230724220231531.png" alt="image-20230724220231531"></p><h5 id="特别注意（不能物理删除）"><a href="#特别注意（不能物理删除）" class="headerlink" title="特别注意（不能物理删除）"></a>特别注意（不能物理删除）</h5><ul><li>删除元素不能简单地将被删元素的空间置为零，否则将截断在它之后的探测路径，可以做一个“已删除”标记，进行<strong>逻辑删除</strong></li></ul><h6 id="错误示范-1"><a href="#错误示范-1" class="headerlink" title="错误示范"></a>错误示范</h6><p><img src="/./assets/image-20230724220319072.png" alt="image-20230724220319072"></p><p><img src="/./assets/image-20230724220328667.png" alt="image-20230724220328667"></p><h6 id="正确示范-1"><a href="#正确示范-1" class="headerlink" title="正确示范"></a>正确示范</h6><p><img src="/./assets/image-20230724220422397.png" alt="image-20230724220422397"></p><p><img src="/./assets/image-20230724220634586.png" alt="image-20230724220634586"></p><h6 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h6><ul><li>查找效率低下，散列表看起来很满，实则很空</li><li>需要<strong>不定期整理</strong>散列表内的数据</li><li><strong>新元素可以插入到已被逻辑删除的地址</strong></li></ul><p><img src="/./assets/image-20230724220753600.png" alt="image-20230724220753600"></p><h4 id="探测覆盖率"><a href="#探测覆盖率" class="headerlink" title="探测覆盖率"></a>探测覆盖率</h4><h5 id="线性探测法-1"><a href="#线性探测法-1" class="headerlink" title="线性探测法"></a>线性探测法</h5><ul><li>一定可以探测到散列表的每个位置</li><li>只要散列表中有空闲位置，就一定可以插入成功</li></ul><p><img src="/./assets/image-20230724220929567.png" alt="image-20230724220929567"></p><h5 id="平方探测"><a href="#平方探测" class="headerlink" title="平方探测"></a>平方探测</h5><ul><li>不能探测到所有位置，只可以探测到散列表中至少一半的位置</li><li>即使散列表中有空闲位置，也未必能插入成功</li><li>解决方法<ul><li>若散列表长度 m 是一个可以表示为 4j+3 的素数（如 7,11,19），平方探测法就能探测到所有位置</li></ul></li></ul><p><img src="/./assets/image-20230724221122254.png" alt="image-20230724221122254"></p><h5 id="双散列法-1"><a href="#双散列法-1" class="headerlink" title="双散列法"></a>双散列法</h5><ul><li>未必能探测到散列表的所有位置</li><li>覆盖率取决于第二个散列函数设计的是否合理</li><li>结局方法<ul><li>如果 hash2 计算得到的值与散列表表长 m 互质，就能保证双散列法可以探测到所有单元</li><li>令表长 m 本身就是质数，hash2(key)&#x3D;m-(key%m)</li></ul></li></ul><p><img src="/./assets/image-20230724221318939.png" alt="image-20230724221318939"></p><h5 id="伪随机序列"><a href="#伪随机序列" class="headerlink" title="伪随机序列"></a>伪随机序列</h5><ul><li>di 是一个伪随机序列，由程序员人为设计</li><li>采用伪随机序列法，是否能探测到散列表中全部位置，取决于伪随机序列的设计是否合理</li></ul><p><img src="/./assets/image-20230724221535492.png" alt="image-20230724221535492"></p><p><img src="/./assets/image-20230724221801664.png" alt="image-20230724221801664"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="1-若查找表是“动态查找表”，有没有更好的实现方式：链式存储"><a href="#1-若查找表是“动态查找表”，有没有更好的实现方式：链式存储" class="headerlink" title="1. 若查找表是“动态查找表”，有没有更好的实现方式：链式存储"></a>1. 若查找表是“动态查找表”，有没有更好的实现方式：链式存储</h4><p><img src="./assets/image-20230720193917761.png" alt="image-20230720193917761" style="zoom:33%;" /><img src="./assets/image-20230720194024307.png" alt="image-20230720194024307" style="zoom:33%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;&gt;&lt;/a&gt;考点总结&lt;/h</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="查找" scheme="https://sdumoist.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E5%9B%BE/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E5%9B%BE/</id>
    <published>2024-03-26T10:35:39.000Z</published>
    <updated>2024-03-26T12:40:25.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul><li><p><strong>有向无环图才存在拓扑排序</strong></p><ul><li>检验有向图是否有环<ul><li>深度优先遍历<ul><li>从有向图上的某个顶点 u 出发，在 DFS(u) 结束之前出现一条从顶点 v 到 u 的边，由于 v 在生成树上是 u 的子孙，则图中必定存在包含 u 和 v 的环</li></ul></li><li>拓扑序列<ul><li>存在无法找到下一个可以加入拓扑序列的顶点</li><li>一直存在有入度大于 0 的顶点</li></ul></li></ul></li><li><strong>在拓扑排序算法中为暂存入度为 0 的顶点，可以用栈，也可以用队列</strong><ul><li>若两个节点之间不存在祖先或子孙关系，则它们在拓扑序列中的关系是任意的（即前后关系任意），因此使用栈和队列都可以</li></ul></li></ul></li><li><p><strong>有向图中如果存在顶点数大于 1 的强连通分量，那么这意味着图中存在环。</strong></p><ul><li>强连通分量是指在有向图中，任意两个顶点之间都存在双向路径的一组顶点。</li><li>如果一个有向图中没有环，那么每个顶点都可以看作是一个独立的强连通分量，因为没有循环路径可以连接不同的顶点。</li></ul></li><li><p>最短路径</p><ul><li>BFS：无权图</li><li>Dijkstra：不含负权回路的有向图和无向图<ul><li>与有向无向无关</li><li>与有无环路无关</li></ul></li><li>Floyd 算法：不可以有负权的环路</li></ul></li></ul><h3 id="深度优先生成树和广度优先生成树"><a href="#深度优先生成树和广度优先生成树" class="headerlink" title="深度优先生成树和广度优先生成树"></a>深度优先生成树和广度优先生成树</h3><ul><li>结论<ul><li>深度优先生成树的高度大于等于广度优先生成树的高度</li></ul></li></ul><p><a href="http://data.biancheng.net/view/45.html">原文链接</a></p><p>本章的第一节中，介绍了有关生成树和生成森林的有关知识，本节来解决对于给定的无向图，如何构建它们相对应的生成树或者生成森林。</p><p>其实在对无向图进行遍历的时候，遍历过程中所经历过的图中的顶点和边的组合，就是图的生成树或者生成森林。</p><p><img src="/./assets/image-20230818141145777.png" alt="image-20230818141145777"></p><p>例如，图 1 中的无向图是由 V1～V7 的顶点和编号分别为 a～i 的边组成。当使用深度优先搜索 DFS算法时，假设 V1 作为遍历的起始点，涉及到的顶点和边的遍历顺序为（不唯一）：<br><img src="/./assets/2-1F912163444395.png" alt="img"></p><p><img src="/./assets/image-20230818140957690.png" alt="image-20230818140957690"></p><p>由深度优先搜索得到的树为深度优先生成树。同理，广度优先搜索 DFS生成的树为广度优先生成树，图 1 无向图以顶点 V1 为起始点进行广度优先搜索遍历得到的树，如图 3 所示：</p><p><img src="/./assets/image-20230818141122476.png" alt="image-20230818141122476"></p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/./assets/image-20230706150442768.png" alt="image-20230706150442768"></p><p><img src="/./assets/image-20230706154227052.png" alt="image-20230706154227052"></p><p><img src="/./assets/image-20230717194724763.png" alt="image-20230717194724763"></p><p><img src="/./assets/image-20230718000407288.png" alt="image-20230718000407288"></p><p><img src="/./assets/image-20230718011416173.png" alt="image-20230718011416173"></p><p><img src="/./assets/image-20230718124704785.png" alt="image-20230718124704785"></p><p><img src="/./assets/image-20230718151002528.png" alt="image-20230718151002528"></p><p><img src="/./assets/image-20230718164320442.png" alt="image-20230718164320442"></p><p><img src="/./assets/image-20230719010308328.png" alt="image-20230719010308328"></p><p><img src="/./assets/image-20230720144250289.png" alt="image-20230720144250289"></p><p><img src="/./assets/image-20230720144312170.png" alt="image-20230720144312170"></p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><ul><li><p>图G由<strong>顶点集V</strong>和<strong>边集E</strong>组成，记为G&#x3D;(V,E)</p></li><li><p>V(G)表示图G中顶点的有限非空集；</p></li><li><p>E(G)表示图G中顶点之间的关系（边）集合</p></li><li><p>若V&#x3D;{v1,v2…vn},则用|V|表示图G中顶点的个数，也称<strong>图G的阶</strong></p></li><li><p>E&#x3D;{(u,v)|u属于V,v属于V}</p></li><li><p>用**|E|<strong>表示图G中</strong>边的条数**</p></li></ul><blockquote><p>线性表可以是空表，树可以是空树，但图不可以是空图，即V一定是非空集，但是图的边集E可以是空集</p></blockquote><p><img src="/./assets/image-20230706114614606.png" alt="image-20230706114614606"></p><h3 id="逻辑结构的应用"><a href="#逻辑结构的应用" class="headerlink" title="逻辑结构的应用"></a>逻辑结构的应用</h3><ul><li>铁路网络：V 车站       E 铁路</li><li>公路交通：V 路口       E 道路</li><li>微信好友关系——边是没有方向的（好友关系是相互的）</li><li>微博粉丝关系——边是有方向的（关注是单向的）</li></ul><h3 id="无向图、有向图"><a href="#无向图、有向图" class="headerlink" title="无向图、有向图"></a>无向图、有向图</h3><ul><li>无向边：边 (v,w)&#x3D;(w,v): v和w是顶点</li><li>有向边：弧     &lt;v,w&gt;: v是弧尾，w是弧头，方向从v-&gt;w(弧尾指向弧头)</li></ul><p><img src="/./assets/image-20230706115317748.png" alt="image-20230706115317748"></p><h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/./assets/image-20230706115823764.png" alt="image-20230706115823764"></p><h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><ul><li>对于无向图：顶点v的度是指依附于该顶点的边的条数，记为TD(v)<ul><li>所有顶点的度之和 &#x3D; 2 * |E|（顶点数目的二倍）</li></ul></li><li>对于有向图<ul><li>入度：以顶点v为终点的有向边的数目，记为ID(v)    (进入)</li><li>出度：以顶点v为起点的有向边的数目，记为OD(v)  (发射)</li><li>顶点v的度等于其入度和出度之和，即TD(v)&#x3D;ID(v)+OD(v)</li><li>入度 &#x3D;&#x3D; 出度</li></ul></li></ul><p><img src="/./assets/image-20230706120450792.png" alt="image-20230706120450792"></p><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><ul><li><p>路径</p><ul><li>顶点Vp到Vq之间的一条路径是指顶点序列，Vp,V1,V2,…..,Vq</li><li>顶点之间可能不存在路径</li><li>有向图的路径也是有向的</li></ul></li><li><p>回路：第一个顶点和最后一个顶点相同的路径称为回路或环</p></li><li><p>简单路径：在路径序列中，顶点不重复出现的路径称为简单路径</p></li><li><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路</p></li><li><p>路径长度：路径上边的数目</p></li><li><p>点到点的距离</p><ul><li>从顶点u出发到顶点v的最短路径若存在，则<strong>此路径的长度为从u到v的距离</strong></li><li>若从u到v不存在路径，在记该距离为无穷</li></ul></li><li><p>无向图中，若从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的</p></li><li><p>有向图中</p><ul><li>若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<strong>强连通</strong>的</li></ul></li></ul><p><img src="/./assets/image-20230706121444298.png" alt="image-20230706121444298"></p><h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><ul><li>无向图：若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图<ul><li>对于n个顶点的无向图<ul><li>若G是连通图，则最少有n-1条边                          （一个顶点连接其余n-1个顶点）</li><li>若G是非连通图，则最多可能有C(2,n-1)条边        （一个顶点没有边，其余n-1个顶点两两相连）</li></ul></li></ul></li><li>有向图：若图中任何一对顶点都是强连通的，则称此图为强连通图<ul><li>对于n个顶点的有向图G<ul><li>若G是强连通图，则最少有n条边（形成回路）</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230706143401002.png" alt="image-20230706143401002"></p><h3 id="子图、生成子图"><a href="#子图、生成子图" class="headerlink" title="子图、生成子图"></a>子图、生成子图</h3><ul><li><p>设有两个图G&#x3D;(V,E)和G1&#x3D;(V1,E1),若V1是V的子集，且E1是E的子集，则称G1是G的子图</p><ul><li>并非任意挑几个点、几条边都能构成子图（首先要能是个图）</li></ul></li><li><p>若有满足V(G1)&#x3D;V(G)的子图G1，则称其为G的<strong>生成子图</strong>（点都有，可以去除几条边）</p></li></ul><p><img src="/./assets/image-20230706143820933.png" alt="image-20230706143820933"></p><h3 id="连通分量、强连通分量"><a href="#连通分量、强连通分量" class="headerlink" title="连通分量、强连通分量"></a>连通分量、强连通分量</h3><ul><li>无向图中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>（只要有能连通的点就要包含到里面）<ul><li>子图必须连通，且包含尽可能多的顶点和边</li></ul></li></ul><p><img src="/./assets/image-20230706144148600.png" alt="image-20230706144148600"></p><ul><li>有向图中的极大强连通子图称为有向图的强连通分量<ul><li>子图必须强连通，同时保留尽可能多的边</li></ul></li></ul><p><img src="/./assets/image-20230706144306901.png" alt="image-20230706144306901"></p><h3 id="生成树、生成森林（一种保持连通的临界）"><a href="#生成树、生成森林（一种保持连通的临界）" class="headerlink" title="生成树、生成森林（一种保持连通的临界）"></a>生成树、生成森林（一种保持连通的临界）</h3><ul><li><p>连通图的生成树是<strong>包含图中所有顶点的一个极小连通子图</strong></p><ul><li>连通图都是无向的</li><li>边尽可能少，但要保持连通</li><li>一个连通图可能有多个生成树</li></ul></li><li><p>若图中顶点数为n，则它的生成树含有n-1条边。</p><ul><li>对生成树而言，若砍去它的一条边，则会变成非连通图</li><li>若加上一条边则会形成一条回路</li></ul></li></ul><p><img src="/./assets/image-20230706144815318.png" alt="image-20230706144815318"></p><ul><li>在非连通图中，连通分量的生成树构成了非连通图的生成森林</li></ul><p><img src="/./assets/image-20230706144954104.png" alt="image-20230706144954104"></p><h3 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图&#x2F;网"></a>边的权、带权图&#x2F;网</h3><ul><li>边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值</li><li>带权图&#x2F;网——边上带有权值的图称为带权图，也称网</li><li>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</li></ul><p><img src="/./assets/image-20230706145438969.png" alt="image-20230706145438969"></p><h3 id="几种特殊状态的图"><a href="#几种特殊状态的图" class="headerlink" title="几种特殊状态的图"></a>几种特殊状态的图</h3><h4 id="无向完全图"><a href="#无向完全图" class="headerlink" title="无向完全图"></a>无向完全图</h4><ul><li>无向图中任意两个顶点之间都存在边</li><li>若无向图的顶点数|V|&#x3D;n，则|E|&#x3D;n(n-1)&#x2F;2</li></ul><h4 id="有向完全图"><a href="#有向完全图" class="headerlink" title="有向完全图"></a>有向完全图</h4><ul><li>有向图中任意两个顶点之间都存在方向相反的两条弧</li></ul><p><img src="/./assets/image-20230706145813009.png" alt="image-20230706145813009"></p><h4 id="稀疏图"><a href="#稀疏图" class="headerlink" title="稀疏图"></a>稀疏图</h4><ul><li>边数很少的图</li><li>只是相对来说，没有明确的界限，一般认为|E|&lt;|V|log|V|就是稀疏图</li></ul><h4 id="稠密图"><a href="#稠密图" class="headerlink" title="稠密图"></a>稠密图</h4><ul><li>边数很多的图</li></ul><p><img src="/./assets/image-20230706145910441.png" alt="image-20230706145910441"></p><h4 id="树、有向树"><a href="#树、有向树" class="headerlink" title="树、有向树"></a>树、有向树</h4><ul><li>连通图，各个点之间时连通的<ul><li>n个顶点的树，必有n-1条边</li><li>n个顶点的图，若|E|&gt;n-1，则一定有回路</li><li>若|E|&lt;n-1,则一定有孤零的顶点（森林）</li></ul></li><li>有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图，称为有向树<ul><li>有向树不是强连通图</li></ul></li></ul><p><img src="/./assets/image-20230706150357216.png" alt="image-20230706150357216"></p><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ul><li>数组实现的顺序存储，空间复杂度高，不适合存储稀疏图</li></ul><h4 id="存储无权图"><a href="#存储无权图" class="headerlink" title="存储无权图"></a>存储无权图</h4><ul><li>无向图：<ul><li>1: 有一条边，两顶点邻接                        0: 没有边，两个顶点不邻接</li><li>一条边对应两个1: (A,B)是1，(B,A)也是1</li></ul></li><li>有向图：<ul><li>1: 有一条行元素指向列元素的边0: 没有行元素指向列元素的边</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                    <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                 <span class="comment">//顶点表（存放顶点名称，这里是A B C...,可以换成更复杂的比如北京、上海...)</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];   <span class="comment">//邻接矩阵、边表(可以换成bool类型和枚举类型，int：4B, bool: 1B)</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                      <span class="comment">//图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGragh;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230706151618291.png" alt="image-20230706151618291"></p><p><img src="/./assets/image-20230706151758698.png" alt="image-20230706151758698"></p><ul><li>求顶点的度、出度、入度：<ul><li>无向图<ul><li>查找顶点所在的一行&#x2F;一列一共有几个1，度就是几</li><li>第i个顶点的度 &#x3D; 第i行（或第i列）的非零元素个数        O(n)</li></ul></li><li>有向图（1表示存在行元素指向列元素的边）：<ul><li>出度：第i行的非零元素个数                              O(n)</li><li>入度：第i列的非零元素个数                              O(n)</li></ul></li></ul></li></ul><h4 id="存储带权图（网）"><a href="#存储带权图（网）" class="headerlink" title="存储带权图（网）"></a>存储带权图（网）</h4><ul><li>如果邻接矩阵的值为0&#x2F;无穷，则说明两点之间没有边</li></ul><p><img src="/./assets/image-20230706153022014.png" alt="image-20230706153022014"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                    <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 2147483647                 <span class="comment">//最大的int值 (2^31)-1=2147483647</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;                    <span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;                       <span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵（有权图）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VertexType Vex[MaxVertexNum];           <span class="comment">//顶点</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">//边的权</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;                     <span class="comment">//图的当前顶点数、弧数</span></span><br><span class="line">&#125; MGragh;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230706153202614.png" alt="image-20230706153202614"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>空间复杂度，n个顶点<ul><li>存储顶点：O(n)</li><li>存储边：O(n^2)</li><li>总：O(|V|^2)       只和顶点数有关，和实际边数无关</li></ul></li><li>适合存储稠密图（边数较多的图）</li><li>无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区&#x2F;下三角区）</li></ul><h4 id="回顾：对称矩阵的压缩存储"><a href="#回顾：对称矩阵的压缩存储" class="headerlink" title="回顾：对称矩阵的压缩存储"></a>回顾：对称矩阵的压缩存储</h4><p><img src="/./assets/image-20230706153557402.png" alt="image-20230706153557402"></p><ul><li>邻接矩阵自乘n次—&gt;等于从顶点i到顶点j的长度为n的路径的数目</li></ul><p><img src="/./assets/image-20230706153809492.png" alt="image-20230706153809492"></p><p><img src="/./assets/image-20230706154051318.png" alt="image-20230706154051318"></p><p><img src="/./assets/image-20230706154107656.png" alt="image-20230706154107656"></p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul><li>顺序存储+链式存储</li></ul><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="/./assets/image-20230717192008898.png" alt="image-20230717192008898"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//“边/弧”</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;                             <span class="comment">//边/弧指向哪个节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *next;                   <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                        //边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;</span><br><span class="line">    VertexType data;                        <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                         <span class="comment">//第一条边/弧</span></span><br><span class="line">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGragh;</span><br></pre></td></tr></table></figure><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>有向图：O(V+2E)</li><li>无向图：O(V+E)</li></ul><p><img src="/./assets/image-20230717192221675.png" alt="image-20230717192221675"></p><h4 id="入度、出度、度"><a href="#入度、出度、度" class="headerlink" title="入度、出度、度"></a>入度、出度、度</h4><ul><li>无向图的度：节点连接的弧的数量</li><li>有向图<ul><li>入度：把所有点的边链表遍历一遍，找到其中指向该节点的边</li><li>出度：节点连接的弧的数量</li></ul></li></ul><h4 id="邻接表不唯一（边链表的顺序任意）"><a href="#邻接表不唯一（边链表的顺序任意）" class="headerlink" title="邻接表不唯一（边链表的顺序任意）"></a>邻接表不唯一（边链表的顺序任意）</h4><p><img src="/./assets/image-20230717192719492.png" alt="image-20230717192719492"></p><h3 id="邻接矩阵和邻接表的劣势"><a href="#邻接矩阵和邻接表的劣势" class="headerlink" title="邻接矩阵和邻接表的劣势"></a>邻接矩阵和邻接表的劣势</h3><ul><li>邻接矩阵：空间复杂度高</li><li>邻接表：找顶点的入度不方便（找到指向该节点的边不方便）</li></ul><p><img src="/./assets/image-20230715175549075.png" alt="image-20230715175549075"></p><h3 id="十字链表（只能存储有向图）"><a href="#十字链表（只能存储有向图）" class="headerlink" title="十字链表（只能存储有向图）"></a>十字链表（只能存储有向图）</h3><h4 id="弧节点（存储弧）"><a href="#弧节点（存储弧）" class="headerlink" title="弧节点（存储弧）"></a>弧节点（存储弧）</h4><ul><li>绿色tailvex：弧尾顶点编号，指示这条弧是由哪个节点出发的（弧尾）</li><li>橙色headvex：弧头顶点编号，指示这条弧是指向哪个节点的（弧头）</li><li>橙色hlink：弧头相同的下一条弧，可以找到所有指向该节点的弧</li><li>绿色tlink：弧尾相同的下一条弧，可以找到所有从该节点出发的弧</li><li>灰色info：权值，指示该条弧的weight</li></ul><p><img src="/./assets/image-20230715180410155.png" alt="image-20230715180410155"></p><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>空间复杂度：O(V+E)</li></ul><p><img src="/./assets/image-20230715181800049.png" alt="image-20230715181800049"></p><h3 id="邻接多重表（存储无向图）"><a href="#邻接多重表（存储无向图）" class="headerlink" title="邻接多重表（存储无向图）"></a>邻接多重表（存储无向图）</h3><h4 id="改进邻接表"><a href="#改进邻接表" class="headerlink" title="改进邻接表"></a>改进邻接表</h4><ul><li>邻接表的缺点<ul><li>每条边对应两份冗余信息</li><li>删除顶点、删除边等操作时间复杂度高</li></ul></li></ul><p><img src="/./assets/image-20230717193934926.png" alt="image-20230717193934926"></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>边节点<ul><li>i：其中一个顶点的编号</li><li>j：另一个顶点的编号</li><li>iLink：依附于顶点i的下一条边（寻找与i有关的边，从iLink寻找下一个）</li><li>jLink：依附于顶点j的下一条边（寻找与j有关的边，从jLink寻找下一个）</li><li>info：权值</li></ul></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>空间复杂度：O(V+E)  （每条边只对应一份数据）</li><li>删除边、删除节点等操作都很方便</li><li>只适用于存储无向图</li></ul><p><img src="/./assets/image-20230717220112624.png" alt="image-20230717220112624"></p><h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>Adjacent(G,x,y): 判断图G是否存在边&lt;x,y&gt;或(x,y)</li><li>Neighbors(G,x): 列出图G中与节点x邻接的边</li><li>InsertVertex(G,x): 在图G中插入顶点x</li><li>DeleteVertex(G,x): 从图G中删除顶点x</li><li>AddEdge(G,x,y): 若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边</li><li>RemoveEdge(G,x,y): 若无向边(x,y)或有向边&lt;x,y&gt;存在,则从图G中删除该边</li><li>FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点，或图中不存在x，则返回-1</li><li>NextNeighbor(G,x,y): 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li><li>Get_edge_value(G,x,y): 获取图G中边(x,y)或&lt;x,y&gt;对应的权值</li><li>Set_edge_value(G,x,y,v): 设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v</li></ul><p><img src="/./assets/image-20230717222335244.png" alt="image-20230717222335244"></p><h3 id="判断是否存在边或-x-y"><a href="#判断是否存在边或-x-y" class="headerlink" title="判断是否存在边&lt;x,y&gt;或(x,y)"></a>判断是否存在边&lt;x,y&gt;或(x,y)</h3><ul><li>有向图&#x2F;无向图<ul><li>邻接矩阵 O(1)</li><li>邻接表O(1)~O(V)</li></ul></li></ul><p><img src="/./assets/image-20230717222759777.png" alt="image-20230717222759777"></p><h3 id="列出与节点x邻接的边"><a href="#列出与节点x邻接的边" class="headerlink" title="列出与节点x邻接的边"></a>列出与节点x邻接的边</h3><p><img src="/./assets/image-20230717223003760.png" alt="image-20230717223003760"></p><p><img src="/./assets/image-20230717223054367.png" alt="image-20230717223054367"></p><h3 id="插入新顶点"><a href="#插入新顶点" class="headerlink" title="插入新顶点"></a>插入新顶点</h3><p><img src="/./assets/image-20230717224829999.png" alt="image-20230717224829999"></p><h3 id="删除顶点"><a href="#删除顶点" class="headerlink" title="删除顶点"></a>删除顶点</h3><p><img src="/./assets/image-20230717224946032.png" alt="image-20230717224946032"></p><p><img src="/./assets/image-20230717225047826.png" alt="image-20230717225047826"></p><h3 id="添加新边"><a href="#添加新边" class="headerlink" title="添加新边"></a>添加新边</h3><ul><li>邻接表可以采用头插法，减少时间复杂度</li></ul><p><img src="/./assets/image-20230717225158802.png" alt="image-20230717225158802"></p><h3 id="找到第一个邻接点（重点）"><a href="#找到第一个邻接点（重点）" class="headerlink" title="找到第一个邻接点（重点）"></a>找到第一个邻接点（重点）</h3><p><img src="/./assets/image-20230718000001514.png" alt="image-20230718000001514"></p><p><img src="/./assets/image-20230718000020682.png" alt="image-20230718000020682"></p><h3 id="找到除了邻接点y以外的下一个邻接点-重点"><a href="#找到除了邻接点y以外的下一个邻接点-重点" class="headerlink" title="找到除了邻接点y以外的下一个邻接点(重点)"></a>找到除了邻接点y以外的下一个邻接点(重点)</h3><p><img src="/./assets/image-20230718000150388.png" alt="image-20230718000150388"></p><h3 id="找边的权值-设置边的权值"><a href="#找边的权值-设置边的权值" class="headerlink" title="找边的权值&#x2F;设置边的权值"></a>找边的权值&#x2F;设置边的权值</h3><ul><li>核心在于找到边<ul><li>Adjacent(G,x,y)：判断图G中是否存在边&lt;x,y&gt;或(x,y)</li></ul></li></ul><p><img src="/./assets/image-20230718000322650.png" alt="image-20230718000322650"></p><h3 id="图的深度优先遍历（重点）（用栈实现）"><a href="#图的深度优先遍历（重点）（用栈实现）" class="headerlink" title="图的深度优先遍历（重点）（用栈实现）"></a>图的深度优先遍历（重点）（用栈实现）</h3><h4 id="树的深度优先遍历"><a href="#树的深度优先遍历" class="headerlink" title="树的深度优先遍历"></a>树的深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的先根遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (R!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">visit</span>(R);<span class="comment">//访问根节点</span></span><br><span class="line">    <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">      <span class="built_in">PreOrder</span>(T);<span class="comment">//先根遍历下一棵子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="comment">//图的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGragh G, <span class="type">int</span> v)</span></span>&#123;                  <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//设已访问标志</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;                    <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230718121855381.png" alt="image-20230718121855381"></p><h4 id="算法存在的问题"><a href="#算法存在的问题" class="headerlink" title="算法存在的问题"></a>算法存在的问题</h4><ul><li>如果是非连通图，无法遍历完所有节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(MGragh G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;                   <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(G,v);           <span class="comment">//从v=0开始遍历</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGragh G, <span class="type">int</span> v)</span></span>&#123;                  <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//设已访问标志</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;                    <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>空间复杂度<ul><li>最坏情况：O(V)</li><li>最好情况：O(1)</li></ul></li></ul><p><img src="/./assets/image-20230718122433238.png" alt="image-20230718122433238"></p><ul><li><p>时间复杂度 &#x3D; 访问各个顶点+探索各条边</p><ul><li>邻接矩阵<ul><li>访问V个顶点需要O(V)的时间</li><li>查找每个顶点的邻接点都需要O(V)的时间，总共有V个顶点</li><li>时间复杂度&#x3D;O(V^2)</li></ul></li><li>邻接表<ul><li>访问V个顶点需要O(V)的时间</li><li>查找各个顶点的邻接点总共需要O(E)的时间</li><li>时间复杂度&#x3D;O(V+E)</li></ul></li></ul><p><img src="/./assets/image-20230718123014506.png" alt="image-20230718123014506"></p><h4 id="深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）"><a href="#深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）" class="headerlink" title="深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）"></a>深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）</h4><h4 id="邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历"><a href="#邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历" class="headerlink" title="邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历"></a>邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历</h4><p><img src="/./assets/image-20230718123316421.png" alt="image-20230718123316421"></p></li></ul><h4 id="邻接表的遍历序列要看邻接表，不能直接从图中得出"><a href="#邻接表的遍历序列要看邻接表，不能直接从图中得出" class="headerlink" title="邻接表的遍历序列要看邻接表，不能直接从图中得出"></a>邻接表的遍历序列要看邻接表，不能直接从图中得出</h4><p><img src="/./assets/image-20230718123823625.png" alt="image-20230718123823625"></p><h4 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h4><ul><li>同一个图的邻接矩阵表达方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一</li><li>同一个图邻接表表达方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一</li></ul><p><img src="/./assets/image-20230718124045455.png" alt="image-20230718124045455"></p><p><img src="/./assets/image-20230718124111846.png" alt="image-20230718124111846"></p><h4 id="深度优先生成森林"><a href="#深度优先生成森林" class="headerlink" title="深度优先生成森林"></a>深度优先生成森林</h4><p><img src="/./assets/image-20230718124204653.png" alt="image-20230718124204653"></p><p><img src="/./assets/image-20230718124223134.png" alt="image-20230718124223134"></p><h4 id="图的遍历与图的连通性"><a href="#图的遍历与图的连通性" class="headerlink" title="图的遍历与图的连通性"></a>图的遍历与图的连通性</h4><ul><li>无向图<ul><li>进行BFS&#x2F;DFS遍历</li><li>调用BFS&#x2F;DFS函数的次数&#x3D;连通分量数</li><li>对于连通图，只需调用一次BFS&#x2F;DFS</li></ul></li></ul><p><img src="/./assets/image-20230718124615536.png" alt="image-20230718124615536"></p><ul><li><p>有向图</p><ul><li><p>进行BFS&#x2F;DFS遍历</p></li><li><p>调用BFS&#x2F;DFS函数的次数要具体问题具体分析</p></li><li><p>若起始顶点到其他各顶点都有路径，则只需调用一次BFS&#x2F;DFS函数</p></li><li><p>对于强连通图之需要调用一次BFS&#x2F;DFS函数</p></li></ul></li></ul><p><img src="/./assets/image-20230718124600462.png" alt="image-20230718124600462"></p><h3 id="图的广度优先遍历（重点）（用队列实现）"><a href="#图的广度优先遍历（重点）（用队列实现）" class="headerlink" title="图的广度优先遍历（重点）（用队列实现）"></a>图的广度优先遍历（重点）（用队列实现）</h3><h4 id="树的广度优先遍历-VS-图的广度优先遍历"><a href="#树的广度优先遍历-VS-图的广度优先遍历" class="headerlink" title="树的广度优先遍历 VS 图的广度优先遍历"></a>树的广度优先遍历 VS 图的广度优先遍历</h4><ul><li>树🌲：不存在“回路”，搜索相邻的节点时，不可能搜到已经访问过的节点<ul><li>若树非空，则根节点入队</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li><li>重复2直到队列为空</li></ul></li><li>图✍️：搜索相邻的节点时，有可能搜到已经访问过的节点<ul><li>找到与一个顶点相邻的所有顶点</li><li>标记哪些顶点被访问过</li><li>需要一个辅助队列<ul><li>FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号，若x没有邻接点或图中不存在x，则返回-1</li><li>NextNeighbor(G,x,y): 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li></ul></li></ul></li></ul><p><img src="/./assets/image-20230718001912351.png" alt="image-20230718001912351"></p><p><img src="/./assets/image-20230718002515580.png" alt="image-20230718002515580"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(MGragh G,<span class="type">int</span> v)</span></span>&#123;                   <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//对x做已访问标记</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);                           <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);                       <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">            <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);                   <span class="comment">//访问顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;   <span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230718004600437.png" alt="image-20230718004600437"></p><h4 id="手算"><a href="#手算" class="headerlink" title="手算"></a>手算</h4><p><img src="/./assets/image-20230718004856597.png" alt="image-20230718004856597"></p><h4 id="遍历序列可变（邻接链表存储先后）"><a href="#遍历序列可变（邻接链表存储先后）" class="headerlink" title="遍历序列可变（邻接链表存储先后）"></a>遍历序列可变（邻接链表存储先后）</h4><p><img src="/./assets/image-20230718005050465.png" alt="image-20230718005050465"></p><h4 id="算法存在的问题-1"><a href="#算法存在的问题-1" class="headerlink" title="算法存在的问题"></a>算法存在的问题</h4><ul><li>如果是非连通图，则无法遍历完所有代码</li></ul><p><img src="/./assets/image-20230718005144167.png" alt="image-20230718005144167"></p><ul><li>但是可以通过visited数组找到未遍历的顶点</li></ul><p><img src="/./assets/image-20230718005949817.png" alt="image-20230718005949817"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                    <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 2147483647                 <span class="comment">//最大的int值 (2^31)-1=2147483647</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MaxVertexNum];                 <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(MGragh G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;G.vexnum; ++i) visited[i]=<span class="literal">false</span>;  <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);                           <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum;++i)        <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) <span class="built_in">BFS</span>(G,i);           <span class="comment">//对每个连通分量调用一次BFS，vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(MGragh G,<span class="type">int</span> v)</span></span>&#123;                   <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//对x做已访问标记</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);                           <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);                       <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">            <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);                   <span class="comment">//访问顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;   <span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>最坏情况：辅助队列O(V)</li><li>所有其他节点都与1相邻</li></ul><p><img src="/./assets/image-20230718010216390.png" alt="image-20230718010216390"></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><p>邻接矩阵</p><ul><li><p>访问V个顶点需要O(V)的时间</p></li><li><p>查找每个顶点的邻接点都需要O(V)的时间，而总共有V个顶点</p></li><li><p>时间复杂度&#x3D;O(V^2)</p></li></ul></li><li><p>邻接表</p><ul><li>访问V个节点需要O(V)的时间</li><li>查找各个顶点的邻接点共需要O(E)的时间</li><li>时间复杂度&#x3D;O(V+E)</li></ul></li></ul><p><img src="/./assets/image-20230718010608710.png" alt="image-20230718010608710"></p><h4 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h4><ul><li>n个顶点，n-1条边</li><li>广度优先生成树由广度优先遍历过程确定。由于邻接表的表达方式不唯一，因此基于邻接表的广度优先生成树也不唯一</li></ul><p><img src="/./assets/image-20230718010903777.png" alt="image-20230718010903777"></p><p><img src="/./assets/image-20230718010939467.png" alt="image-20230718010939467"></p><p><img src="/./assets/image-20230718010957518.png" alt="image-20230718010957518"></p><h4 id="广度优先生成森林"><a href="#广度优先生成森林" class="headerlink" title="广度优先生成森林"></a>广度优先生成森林</h4><ul><li>对非连通图的广度优先遍历，可得到广度优先生成森林</li></ul><p><img src="/./assets/image-20230718011203751.png" alt="image-20230718011203751"></p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><ul><li>连通图的生成树是包含图中所有顶点的一个极小连通子图（边要尽可能小，但要保持连通）</li><li>若图中顶点数为n，则它的生成树含有n-1条边。</li><li>对于生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路</li></ul><p><img src="/./assets/image-20230718142718791.png" alt="image-20230718142718791"></p><h4 id="广度优先生成树-1"><a href="#广度优先生成树-1" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h4><p><img src="/./assets/image-20230718142810106.png" alt="image-20230718142810106"></p><h4 id="深度优先生成树-1"><a href="#深度优先生成树-1" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h4><p><img src="/./assets/image-20230718142829309.png" alt="image-20230718142829309"></p><h4 id="最小生成树（最小代价树）"><a href="#最小生成树（最小代价树）" class="headerlink" title="最小生成树（最小代价树）"></a>最小生成树（最小代价树）</h4><ul><li>对于一个<strong>带权连通无向图</strong>G&#x3D;(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同</li><li>设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树(Minimum-Spanning-Tree,MST)</li></ul><p><img src="/./assets/image-20230718143223844.png" alt="image-20230718143223844"></p><ul><li>不唯一<ul><li>可能有多个，但边的权值之和总是唯一且最小的</li></ul></li><li>最小生成树的边数 &#x3D; 顶点数 - 1<ul><li>砍掉一条则不连通，增加一条边则会出现回路</li></ul></li><li>如果连通图本身是一棵树，则其最小生成树就是它本身</li><li>只有连通图才有生成树，非连通图只有生成森林</li></ul><p><img src="/./assets/image-20230718143451611.png" alt="image-20230718143451611"></p><p><img src="/./assets/image-20230718144321711.png" alt="image-20230718144321711"></p><h4 id="Prim算法（普里姆）（点）"><a href="#Prim算法（普里姆）（点）" class="headerlink" title="Prim算法（普里姆）（点）"></a>Prim算法（普里姆）（点）</h4><ul><li><p>算法实现</p><ul><li><p>从某一个<strong>顶点</strong>开始构建生成树</p></li><li><p>每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止</p></li></ul></li><li><p>时间复杂度</p><ul><li>O(V^2)，适合用于边稠密图<ul><li>从V0开始，总共需要n-1轮处理</li><li>每一轮循环：循环遍历所有节点，找到lowCast最低的，且还没有加入树的节点</li><li>再次循环遍历，更新还没有加入各个节点的lowCast值</li></ul></li></ul></li><li><p>机器实现</p><ul><li>初始：从V0开始<ul><li>声明两个数组<ul><li>isJoin[]: 标记各节点是否已加入树</li><li>lowCost[]: 各节点加入树的最低代价</li></ul></li></ul></li><li>第一轮<ul><li>循环遍历所有的节点，找到lowCast最低的，且还没有加入树的节点</li><li>将该节点加入正在构建的树里，isJoin数组对应元素变为true</li><li>再次循环遍历。更新还没有加入各个顶点的lowCast值<ul><li>遍历刚加入节点的所有边，将这些边的权值与lowCast数组中的值进行比较，取其中较小的一个</li></ul></li></ul></li><li>循环以上操作，直到isJoin数组中不存在false（n-1轮）</li></ul></li></ul><p><img src="/./assets/image-20230718144504433.png" alt="image-20230718144504433"></p><p><img src="/./assets/image-20230718145024457.png" alt="image-20230718145024457"></p><h4 id="Kruskal算法（克鲁斯卡尔）（边）"><a href="#Kruskal算法（克鲁斯卡尔）（边）" class="headerlink" title="Kruskal算法（克鲁斯卡尔）（边）"></a>Kruskal算法（克鲁斯卡尔）（边）</h4><ul><li><p>算法实现</p><ul><li><p>每次选择一条权值最小的<strong>边</strong>，使这条边的两头连通（原本已经连通的就不选）</p></li><li><p>直到所有节点都连通</p></li></ul></li><li><p>时间复杂度</p><ul><li>O(Elog2E)，适合用于边稀疏图<ul><li>共执行e轮</li><li>每轮判断两个顶点是否属于同一个集合，需要O(log2e)</li></ul></li></ul></li><li><p>机器实现</p><ul><li>初始：<ul><li>将各条边按权值排序</li><li>三个属性<ul><li>Weight: 权值</li><li>Vertex1: 起始节点</li><li>Vertex2: 末尾节点</li></ul></li></ul></li><li>第一轮<ul><li>检查第一条边的两个顶点是否连通（是否属于同一个集合）（并查集）</li><li>如果不属于同一个集合，就将这条边选上，并将其两边的顶点放到同一个集合中</li><li>如果属于同一个集合，就直接跳过</li></ul></li><li>重复以上操作，直到所有顶点都属于一个集合（都连通）</li></ul></li></ul><p><img src="/./assets/image-20230718145822232.png" alt="image-20230718145822232"></p><h3 id="图的最短路径"><a href="#图的最短路径" class="headerlink" title="图的最短路径"></a>图的最短路径</h3><h4 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h4><ul><li>一个点到其他点的最短路径</li></ul><h4 id="多源最短路径"><a href="#多源最短路径" class="headerlink" title="多源最短路径"></a>多源最短路径</h4><ul><li>每对顶点间的最短路径</li></ul><p><img src="/./assets/image-20230718151235217.png" alt="image-20230718151235217"></p><h3 id="BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）"><a href="#BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）" class="headerlink" title="BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）"></a>BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）</h3><ul><li>无权图可以视为一种特殊的带权图，只是每条边的权值都为1</li><li>就是对BFS的一个小修改，在visit一个顶点时，修改其最短路径长度d[]并在path[]记录前驱节点</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(MGragh G,<span class="type">int</span> v)</span></span>&#123;                   <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//对x做已访问标记</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);                           <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);                       <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">            <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);                   <span class="comment">//访问顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;   <span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求顶点u到其他顶点到最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(MGragh G, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d[MaxVertexNum];                     <span class="comment">//d[i]表示u到i的节点的最短路径</span></span><br><span class="line">    <span class="type">int</span> path[MaxVertexNum];                  <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        d[i]=INFINITY;                       <span class="comment">//初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;                          <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=<span class="literal">true</span>;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;                  <span class="comment">//BFS算法主过程</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,u);                       <span class="comment">//队头元素u出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="built_in">FirstNeighbor</span>(G,u); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,u,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;                <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;                  <span class="comment">//最短路径应从u到w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//设已访问标志</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230718163858910.png" alt="image-20230718163858910"></p><h3 id="狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）"><a href="#狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）" class="headerlink" title="狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）"></a>狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）</h3><ul><li><p>Dijkstra</p></li><li><p>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p></li><li><p>算法实现</p><ul><li>初始<ul><li>从V0开始，初始化三个数组信息如下</li><li>Final[]: 标记各顶点是否已找到最短路径</li><li>Dist[]: 最短路径长度</li><li>Path[]: 路径上的前驱</li></ul></li><li>第一轮：<ul><li>循环遍历所有节点，找到还没确定最短路径，且dist最小的顶点Vi，令final[i]&#x3D;true</li><li>检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path信息</li><li>如果dist[]里面存储的值   小于   该点的最小距离+该点到另一点的距离，则更新dist和path</li></ul></li><li>重复以上步骤</li></ul></li></ul><p><img src="/./assets/image-20230718165636642.png" alt="image-20230718165636642"></p><p><img src="/./assets/image-20230718170122893.png" alt="image-20230718170122893"></p><p><img src="/./assets/image-20230718170232665.png" alt="image-20230718170232665"></p><p><img src="/./assets/image-20230718170606667.png" alt="image-20230718170606667"></p><p><img src="/./assets/image-20230718170533775.png" alt="image-20230718170533775"></p><ul><li>使用dist[]和path[]数组可以找到最短带权路径</li></ul><p><img src="/./assets/image-20230718170739493.png" alt="image-20230718170739493"></p><ul><li>时间复杂度<ul><li>O(V^2)</li><li>初始<ul><li>Arcs[i][j]表示Vi到Vj的弧的权值</li><li>若从V0开始，令final[0]&#x3D;true; dist[0]&#x3D;0; path[0]&#x3D;-1;</li><li>其余顶点final[k]&#x3D;false; dist[k]&#x3D;arcs[o][k]; path[k]&#x3D;(arcs[0][k]&#x3D;&#x3D;无穷大)? -1:0;</li></ul></li><li>第n-1轮处理<ul><li>循环遍历所有顶点，找到还确定最短路径，且dist最小的顶点Vi，令final[i]&#x3D;true</li><li>检查所有邻接自Vi的顶点，对于邻接自Vi的顶点Vj，若final[j]&#x3D;&#x3D;false且dist[i]+arcs[i][j]&lt;dist[j],则令dist[j]&#x3D;dist[i]+arcs[i][j]; path[j]&#x3D;i</li></ul></li></ul></li></ul><h4 id="算法缺点"><a href="#算法缺点" class="headerlink" title="算法缺点"></a>算法缺点</h4><ul><li>不适用于有负权值的带权图</li></ul><p><img src="/./assets/image-20230718172100109.png" alt="image-20230718172100109"></p><h3 id="Floyd算法（求各顶点间最短路径）（可以用于负权图）"><a href="#Floyd算法（求各顶点间最短路径）（可以用于负权图）" class="headerlink" title="Floyd算法（求各顶点间最短路径）（可以用于负权图）"></a>Floyd算法（求各顶点间最短路径）（可以用于负权图）</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li><p>求出每一对顶点之间的最短路径</p></li><li><p>使用<strong>动态规划</strong>思想，将问题的求解分为多个节点</p></li><li><p>对于n个顶点的图G，求任意一对顶点Vi-&gt;Vj之间的最短路径可分为如下几个阶段：</p><ul><li><p>#初始：不允许在其他顶点中转，最短路径是？</p></li><li><p>#0：若允许V0中转，最短路径是？</p></li><li><p>#1：若允许V0、V1中转，最短路径是？</p></li><li><p>#2：若允许V0、V1、V2中转，最短路径是？</p></li><li><p>…</p></li><li><p>#n-1：若允许V0、V1、V2……Vn-1中转，最短路径是？</p></li></ul></li></ul><p><img src="/./assets/image-20230719002515354.png" alt="image-20230719002515354"></p><p><img src="/./assets/image-20230719002636465.png" alt="image-20230719002636465"></p><p><img src="/./assets/image-20230719002812797.png" alt="image-20230719002812797"></p><p><img src="/./assets/image-20230719002926947.png" alt="image-20230719002926947"></p><p><img src="/./assets/image-20230719002901286.png" alt="image-20230719002901286"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Floyd算法，求每个顶点间距离的最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGragh G)</span></span>&#123;</span><br><span class="line">    <span class="comment">//准备工作，根据图的信息初始化矩阵A和path</span></span><br><span class="line">    <span class="type">int</span> A[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    <span class="type">int</span> path[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    <span class="type">int</span> n = G.vexnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++)&#123;                    <span class="comment">//考虑以vk作为中转点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n; i ++)&#123;                  <span class="comment">//遍历整个矩阵，i为行号，j为列号</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; n; j ++)&#123;              </span><br><span class="line">                <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[j][k])&#123;    <span class="comment">//以vk为中转点的路径更短</span></span><br><span class="line">                    A[i][j]=A[i][k]+A[j][k];        <span class="comment">//更新最短路径长度</span></span><br><span class="line">                    path[i][j]=k;                   <span class="comment">//中转点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230719004122837.png" alt="image-20230719004122837"></p><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><ul><li>时间复杂度：O(V^3)</li><li>空间复杂度：O(V^2)</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="/./assets/image-20230719004238079.png" alt="image-20230719004238079"></p><p><img src="/./assets/image-20230719004655886.png" alt="image-20230719004655886"></p><p><img src="/./assets/image-20230719005500094.png" alt="image-20230719005500094"></p><p><img src="/./assets/image-20230719005624147.png" alt="image-20230719005624147"></p><p><img src="/./assets/image-20230719005659212.png" alt="image-20230719005659212"></p><h4 id="寻找完整路径"><a href="#寻找完整路径" class="headerlink" title="寻找完整路径"></a>寻找完整路径</h4><ul><li>通过path矩阵递归地找到完整路径</li></ul><p><img src="/./assets/image-20230719005938122.png" alt="image-20230719005938122"></p><h4 id="算法存在问题"><a href="#算法存在问题" class="headerlink" title="算法存在问题"></a>算法存在问题</h4><ul><li>可以解决负权图的问题</li><li>但是不能解决带有“负权回路”的图（有负权值的边组成回路），这种图可能没有最短路径</li></ul><p><img src="/./assets/image-20230719010215338.png" alt="image-20230719010215338"></p><h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>若一个有向图中不存在环，则称为有向无环图，建成DAG图(Directed Acyclic Gragh)</li></ul><p><img src="/./assets/image-20230719010643791.png" alt="image-20230719010643791"></p><h3 id="有向无环图描述表达式（简化存储结构）（不唯一）"><a href="#有向无环图描述表达式（简化存储结构）（不唯一）" class="headerlink" title="有向无环图描述表达式（简化存储结构）（不唯一）"></a>有向无环图描述表达式（简化存储结构）（不唯一）</h3><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p><img src="/./assets/image-20230719011019240.png" alt="image-20230719011019240"></p><p><img src="/./assets/image-20230719011034513.png" alt="image-20230719011034513"></p><p><img src="/./assets/image-20230719011052975.png" alt="image-20230719011052975"></p><p><img src="/./assets/image-20230719011121655.png" alt="image-20230719011121655"></p><p><img src="/./assets/image-20230719011134744.png" alt="image-20230719011134744"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/./assets/image-20230719011228174.png" alt="image-20230719011228174"></p><p><img src="/./assets/image-20230719011258644.png" alt="image-20230719011258644"></p><p><img src="/./assets/image-20230719011309795.png" alt="image-20230719011309795"></p><h4 id="总结方法"><a href="#总结方法" class="headerlink" title="总结方法"></a>总结方法</h4><ul><li>思想：顶点中不可能出现重复的操作数</li><li>第一步<ul><li>把各个操作数不重复地排成一排</li></ul></li><li>第二步<ul><li>标出各个运算符的生效顺序（先后顺序无所谓）</li></ul></li><li>第三步<ul><li>按顺序加入运算符，注意分层</li></ul></li><li>第四步<ul><li><strong>自底向上</strong>逐层检查<strong>同层</strong>的运算符是否可以合体</li></ul></li></ul><p><img src="/./assets/image-20230719011351606.png" alt="image-20230719011351606"></p><p><img src="/./assets/image-20230719011623851.png" alt="image-20230719011623851"></p><p><img src="/./assets/image-20230719011800244.png" alt="image-20230719011800244"></p><p><img src="/./assets/image-20230719011906622.png" alt="image-20230719011906622"></p><p><img src="/./assets/image-20230719011926673.png" alt="image-20230719011926673"></p><p><img src="/./assets/image-20230719011949901.png" alt="image-20230719011949901"></p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul><li>可以用 DFS 实现拓扑排序</li></ul><h4 id="AOV网（用顶点表示活动）"><a href="#AOV网（用顶点表示活动）" class="headerlink" title="AOV网（用顶点表示活动）"></a>AOV网（用顶点表示活动）</h4><ul><li>AOV网(Activity on Vertex NetWork，用顶点表示活动的网)</li><li>用DAG图（有向无环图）表示一个工程。顶点表示活动，有向边&lt;Vi,Vj&gt;表示活动Vi必须先于活动Vj进行</li><li>有环路就不是AOV网</li></ul><p><img src="/./assets/image-20230719012714728.png" alt="image-20230719012714728"></p><h4 id="拓扑排序定义"><a href="#拓扑排序定义" class="headerlink" title="拓扑排序定义"></a>拓扑排序定义</h4><ul><li>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序<ul><li>每个顶点出现且只出现一次</li><li>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径</li></ul></li><li>或定义为<ul><li>拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在A的后面</li><li>每个AOV网都有一个或多个拓扑排序序列</li></ul></li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>先找到做事的先后顺序</li></ul><p><img src="/./assets/image-20230719013108763.png" alt="image-20230719013108763"></p><p><img src="/./assets/image-20230719013138338.png" alt="image-20230719013138338"></p><ul><li><p>机器实现</p><ul><li>从AOV网中选择一个没有前驱（入度为0）的顶点并输出</li><li>从网中删除该顶点和所有以它为起点的有向边</li><li>重复以上步骤知道当前的AOV网为空或当前网中不存在无前驱的顶点为止</li></ul></li><li><p>数据结构</p><ul><li>两个数组<ul><li>Indegree[]: 当前顶点的入度</li><li>Print[]: 记录拓扑序列</li></ul></li><li>栈&#x2F;队列<ul><li>S：保存度为0的顶点</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);                           <span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">Push</span>(S,i);                      <span class="comment">//将所有入度为0的顶点入栈</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;                            <span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;                     <span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">        <span class="built_in">Pop</span>(S,i);                           <span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++]= i;                  <span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            <span class="comment">//将所有i指向的顶点的入度-1，并且将入度减为0的顶点压入栈S</span></span><br><span class="line">            v=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v])) Push[S,v]; <span class="comment">//入度为0，则入栈</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;                       <span class="comment">//拓扑排序成功</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VertexType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;                     <span class="comment">//边表节点</span></span><br><span class="line">    <span class="type">int</span> adjvex;                             <span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;                <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                        //网的边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>                        <span class="comment">//顶点表节点</span></span><br><span class="line">&#123;</span><br><span class="line">    VertexType data;                        <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;                      <span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    AdjList vertices;                       <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;                     <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125; Graph;<span class="comment">//Graph是以邻接表存储的图类型</span></span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230719013657678.png" alt="image-20230719013657678"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="/./assets/image-20230719155110778.png" alt="image-20230719155110778"></p><p><img src="/./assets/image-20230719155314319.png" alt="image-20230719155314319"></p><p><img src="/./assets/image-20230719155421430.png" alt="image-20230719155421430"></p><p><img src="/./assets/image-20230719155408611.png" alt="image-20230719155408611"></p><p><img src="/./assets/image-20230719155604735.png" alt="image-20230719155604735"></p><p><img src="/./assets/image-20230719155630295.png" alt="image-20230719155630295"></p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>邻接表：O(V+E)</li><li>邻接矩阵：O(V^2)</li></ul><p><img src="/./assets/image-20230719155751183.png" alt="image-20230719155751183"></p><h4 id="无法进行拓扑排序：有回路的图"><a href="#无法进行拓扑排序：有回路的图" class="headerlink" title="无法进行拓扑排序：有回路的图"></a>无法进行拓扑排序：有回路的图</h4><p><img src="/./assets/image-20230719013605807.png" alt="image-20230719013605807"></p><ul><li>当前AOV图中每个节点的入度都&gt;0</li></ul><p><img src="/./assets/image-20230719013455492.png" alt="image-20230719013455492"></p><h3 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h3><ul><li>拓扑排序是删除入度&#x3D;0的点</li><li>逆拓扑排序是删除出度&#x3D;0的点</li></ul><p><img src="/./assets/image-20230719155859372.png" alt="image-20230719155859372"></p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="/./assets/image-20230719155923334.png" alt="image-20230719155923334"></p><p><img src="/./assets/image-20230719155938429.png" alt="image-20230719155938429"></p><h4 id="逆拓扑排序的实现"><a href="#逆拓扑排序的实现" class="headerlink" title="逆拓扑排序的实现"></a>逆拓扑排序的实现</h4><ul><li>邻接表<ul><li>保存的是从这个节点出去的边</li></ul></li><li>逆邻接表<ul><li>保存的是指向这个顶点的边</li></ul></li><li>邻接矩阵<ul><li>横行：从该节点出去的边</li><li>竖列：指向这个顶点的边</li></ul></li></ul><p><img src="/./assets/image-20230719160056829.png" alt="image-20230719160056829"></p><h4 id="DFS实现逆拓扑排序"><a href="#DFS实现逆拓扑排序" class="headerlink" title="DFS实现逆拓扑排序"></a>DFS实现逆拓扑排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆拓扑排序（DFS算法）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;                  <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;                   <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            <span class="built_in">DFS</span>(G,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS，从顶点v出发，深度优先遍历图G</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问顶点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;                    <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="built_in">print</span>(v);                               <span class="comment">//输出顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p><img src="/./assets/image-20230720001307281.png" alt="image-20230720001307281"></p><p><img src="/./assets/image-20230720001337456.png" alt="image-20230720001337456"></p><p><img src="/./assets/image-20230720001354364.png" alt="image-20230720001354364"></p><p><img src="/./assets/image-20230720001411582.png" alt="image-20230720001411582"></p><p><img src="/./assets/image-20230720001433264.png" alt="image-20230720001433264"></p><p><img src="/./assets/image-20230720001522660.png" alt="image-20230720001522660"></p><p><img src="/./assets/image-20230720001545539.png" alt="image-20230720001545539"></p><p><img src="/./assets/image-20230720001605059.png" alt="image-20230720001605059"></p><p><img src="/./assets/image-20230720001623820.png" alt="image-20230720001623820"></p><p><img src="/./assets/image-20230720001651750-9783412.png" alt="image-20230720001651750"></p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><h4 id="AOE网（用边表示活动）"><a href="#AOE网（用边表示活动）" class="headerlink" title="AOE网（用边表示活动）"></a>AOE网（用边表示活动）</h4><ul><li>在带权有向图中，以<strong>顶点</strong>表示事件，以<strong>有向边</strong>表示活动，以<strong>边上的权值</strong>表示完成该活动的开销（如完成活动所需时间），称之为用边表示活动的网络，简称AOE网（Activity On Edge Network）</li></ul><p><img src="/./assets/image-20230720002543969.png" alt="image-20230720002543969"></p><ul><li><p>AOV网的性质</p><ul><li><p>只有在某个顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</p></li><li><p>只有在进入某个顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生</p></li><li><p>另外，有些活动是可以并行进行的</p></li></ul></li><li><p>AOE网的组成</p><ul><li>在AOE网中仅有一个入度为0的顶点，称为<strong>开始顶点（源点）</strong>，表示整个工程的开始</li><li>仅有一个出度为0的点，称为<strong>结束顶点（汇点）</strong>，表示整个工程的结束</li><li>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong></li><li>完成整个工程的最短时间就是<strong>关键路径的长度</strong>，若关键路径不能按时完成，则整个工程完成时间就会延长</li></ul></li></ul><p><img src="/./assets/image-20230720003025269.png" alt="image-20230720003025269"></p><p><img src="/./assets/image-20230720003229716.png" alt="image-20230720003229716"></p><h4 id="关键路径（类似软件项目管理的里程碑）"><a href="#关键路径（类似软件项目管理的里程碑）" class="headerlink" title="关键路径（类似软件项目管理的里程碑）"></a>关键路径（类似软件项目管理的里程碑）</h4><ul><li>事件Vk的最早发生时间Ve(k)——决定了所有从Vk开始的活动能够开工的最早时间</li><li>活动ai的最早开始时间e(i)——指该活动弧的起点所表示的事件的最早发生时间</li></ul><p><img src="/./assets/image-20230720003544094.png" alt="image-20230720003544094"></p><ul><li>事件Vk的最早发生时间Vl(k)——指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间</li><li>活动ai的最早开始时间l(i)——指该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差</li></ul><p><img src="/./assets/image-20230720140959200.png" alt="image-20230720140959200"></p><ul><li>活动最早时间e(i) VS 活动最迟开始时间l(i)</li><li>活动ai的时间余量d(i)&#x3D;l(i)-e(i)<ul><li>表示在不增加完成整个工程所需总时间的情况下，活动ai可以拖延的时间</li><li>若一个活动的时间余量&#x3D;0，则说明该活动必须要如期完成，d(i)&#x3D;0即l(i)&#x3D;e(i)的活动ai是关键活动，由关键活动组成的路径就是关键路径</li></ul></li></ul><p><img src="/./assets/image-20230720141529642.png" alt="image-20230720141529642"></p><h4 id="求关键路径的步骤"><a href="#求关键路径的步骤" class="headerlink" title="求关键路径的步骤"></a>求关键路径的步骤</h4><ol><li>求所有事件的最早发生时间Ve()<ul><li>按<strong>拓扑排序</strong>序列，依次求各个顶点的Ve(k)</li><li>Ve(源点)&#x3D;0</li><li>Ve(k)&#x3D;Max{Ve(j) + Weight(Vj,Vk)}.  Vj为Vk的任意前驱（即找到前驱节点+事件时间最大的路径）</li></ul></li><li>求所有事件的最迟发生时间Vl()<ul><li>按逆拓扑排序序列，依次求各个顶点的Vl(k)</li><li>Vl(汇点)&#x3D;Ve(汇点)</li><li>Vl(k)&#x3D;Min{Vl(j)+Weight(Vk,Vj)}.     Vj为Vk的任意后继</li></ul></li><li>求所有活动的最早发生时间e()<ul><li>若边&lt;Vk,Vj&gt;表示活动ai，则有e(i)&#x3D;Ve(k)</li></ul></li><li>求所有活动的最迟发生时间l()<ul><li>若边&lt;Vk,Vj&gt;表示活动ai，则有l(i)&#x3D;Vl(j)-Weight(Vk,Vj)</li></ul></li><li>求所有活动的时间余量d()<ul><li>d(i)&#x3D;l(i)-e(i)</li></ul></li><li>求得关键活动、关键路径<ul><li>将d[i]&#x3D;0的路径连接成一条线</li></ul></li></ol><p><strong>d(i)&#x3D;0的活动就是关键活动，由关键活动可得关键路径</strong></p><p><img src="/./assets/image-20230720141956503.png" alt="image-20230720141956503"></p><ul><li>求所有事件的最早发生时间</li></ul><p><img src="/./assets/image-20230720142518121.png" alt="image-20230720142518121"></p><ul><li>求所有事件的最迟发生时间</li></ul><p><img src="/./assets/image-20230720142714515.png" alt="image-20230720142714515"></p><ul><li>求所有活动的最早发生时间</li></ul><p><img src="/./assets/image-20230720143204437.png" alt="image-20230720143204437"></p><ul><li>求所有活动的最迟发生时间</li></ul><p><img src="/./assets/image-20230720143240311.png" alt="image-20230720143240311"></p><ul><li>求所有活动的最迟发生时间</li></ul><p><img src="/./assets/image-20230720143420904.png" alt="image-20230720143420904"></p><ul><li>求所有活动的时间余量</li></ul><p><img src="/./assets/image-20230720143524191.png" alt="image-20230720143524191"></p><ul><li>求得关键活动、关键路径</li></ul><p><img src="/./assets/image-20230720143604260.png" alt="image-20230720143604260"></p><h4 id="关键活动、关键路径的特性"><a href="#关键活动、关键路径的特性" class="headerlink" title="关键活动、关键路径的特性"></a>关键活动、关键路径的特性</h4><ul><li>若关键活动耗时增加，则整个工程的工期将曾长</li><li>缩短关键活动的时间，可以缩短整个工程的工期</li><li>当缩短到一定程度时，关键活动可能会变成非关键活动（并不是只要压缩关键路径的时间，工期就可以提前）</li><li>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的（或者缩短每一条关键路径上的关键活动）</li></ul><p><img src="/./assets/image-20230720143931809.png" alt="image-20230720143931809"></p><p><img src="/./assets/image-20230720144157251.png" alt="image-20230720144157251"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1-练习：有向图的BFS过程"><a href="#1-练习：有向图的BFS过程" class="headerlink" title="1.练习：有向图的BFS过程"></a>1.练习：有向图的BFS过程</h3><p><img src="/./assets/image-20230718011319698.png" alt="image-20230718011319698"></p><h3 id="2-练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？"><a href="#2-练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？" class="headerlink" title="2.练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？"></a>2.练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？</h3><p><img src="/./assets/image-20230720001940125.png" alt="image-20230720001940125"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;&gt;&lt;/a&gt;考点总结&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="图" scheme="https://sdumoist.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>树与二叉树</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-03-26T10:34:39.000Z</published>
    <updated>2024-03-26T12:40:13.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="树为什么是一种递归定义的数据结构"><a href="#树为什么是一种递归定义的数据结构" class="headerlink" title="树为什么是一种递归定义的数据结构"></a>树为什么是一种递归定义的数据结构</h4><p>树是一种递归定义的数据结构，因为它的定义可以通过对自身的描述进行递归来完成。</p><p>树由节点组成，每个节点可以有零个或多个子节点。树的定义可以通过以下方式进行递归描述：</p><ol><li>树由一个根节点开始。根节点是树的顶层节点，没有父节点。</li><li>每个节点可以有零个或多个子节点。子节点是相对于父节点而言的。</li><li>每个子节点本身也可以是一个树，即子树。子树可以看作是原始树的一部分。</li></ol><p>这种递归定义的特点在于树的结构可以通过对子树的定义来描述。树的每个节点都可以作为一个根节点，它们可以包含更多的子节点，形成更深层次的结构。</p><p>递归定义使得树具有自相似的性质。树的整体结构与其子树的结构类似，这种递归性质使得树在许多算法和数据结构中具有广泛的应用，例如搜索、排序、存储和组织数据等。</p><p>通过递归定义，我们可以使用相同的规则来构建树的不同部分，从而形成复杂的树结构。这种递归性质使得树成为一种灵活而强大的数据结构。</p><h4 id="线索二叉树寻找前驱后继（先不前，后不继）"><a href="#线索二叉树寻找前驱后继（先不前，后不继）" class="headerlink" title="线索二叉树寻找前驱后继（先不前，后不继）"></a>线索二叉树寻找前驱后继（先不前，后不继）</h4><ul><li>先不前，后不继<ul><li>先序线索二叉树不能找先序前驱</li><li>后序线索二叉树不能找后序后继<ul><li>因为只有根能找到自己的左右子树，而且根没有自己的线索（都是左右孩子）</li><li>先序遍历的时候：根左右，根在最前面，所以找不到自己的前驱</li><li>后序遍历的时候：左右根，根在最后面，所以找不到自己的后继</li></ul></li></ul></li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/./assets/image-20230702130914954.png" alt="image-20230702130914954"></p><p><img src="/./assets/image-20230702131951970.png" alt="image-20230702131951970"></p><p><img src="/./assets/image-20230702134009965.png" alt="image-20230702134009965"></p><p><img src="/./assets/image-20230702161639310.png" alt="image-20230702161639310"></p><p><img src="/./assets/image-20230702173836143.png" alt="image-20230702173836143"></p><p><img src="/./assets/image-20230702173848860.png" alt="image-20230702173848860"></p><p><img src="/./assets/image-20230704214903786.png" alt="image-20230704214903786"></p><p><img src="/./assets/image-20230704215842806.png" alt="image-20230704215842806"></p><p><img src="/./assets/image-20230704224529787.png" alt="image-20230704224529787"></p><p><img src="/./assets/image-20230705155415191.png" alt="image-20230705155415191"></p><p><img src="/./assets/image-20230705165109906.png" alt="image-20230705165109906"></p><p><img src="/./assets/image-20230705190952703.png" alt="image-20230705190952703"></p><p><img src="/./assets/image-20230705191049589.png" alt="image-20230705191049589"></p><p><img src="/./assets/image-20230705200603558.png" alt="image-20230705200603558"></p><p><img src="/./assets/image-20230705203548373.png" alt="image-20230705203548373"></p><p><img src="/./assets/image-20230705213945765.png" alt="image-20230705213945765"></p><p><img src="/./assets/image-20230705223222668.png" alt="image-20230705223222668"></p><p><img src="/./assets/image-20230706105227305.png" alt="image-20230706105227305"></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>n(n&gt;&#x3D;0)个节点的有限集合，n&#x3D;0时，称为空树。</p><p>在任何一棵非空树中应满足：</p><ul><li>有且仅有一个特定的成为根的节点</li><li>当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集合T1,T2,…,Tm,其中每个集合本身又是一棵树，并且成为根节点的子树</li></ul><p><img src="/./assets/image-20230701165215387.png" alt="image-20230701165215387"></p><p><img src="/./assets/image-20230706111114375.png" alt="image-20230706111114375"></p><p><img src="/./assets/image-20230706112412312.png" alt="image-20230706112412312"></p><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><h4 id="空树"><a href="#空树" class="headerlink" title="空树"></a>空树</h4><p>节点数为0的树</p><h4 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h4><p>根节点（Root Node）：树的顶层节点，它是树的起点，没有父节点。树中只能有一个根节点。</p><h4 id="边"><a href="#边" class="headerlink" title="边"></a>边</h4><p>连接两个节点的线段，它表示节点之间的关联关系。在树中，边用于连接父节点与子节点。</p><h4 id="分支节点"><a href="#分支节点" class="headerlink" title="分支节点"></a>分支节点</h4><p>有后继的节点，也称为非终端节点，内部节点或非叶子节点，是除了根节点以外的其他节点。分支节点至少有一个子节点。</p><h4 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h4><p>没有后继的节点，也称为终端节点或叶节点，是没有子节点的节点。它们位于树的末端。</p><h4 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h4><p><strong>在树中，节点的前驱是指在树的某一种遍历顺序中，位于该节点之前的节点。</strong></p><p>除了根节点外，任何一个节点都有且仅有一个前驱（根节点没有前驱）</p><h4 id="后继"><a href="#后继" class="headerlink" title="后继"></a>后继</h4><p><strong>在树中，节点的后继是指在树的某一种遍历顺序中，位于该节点之后的节点。</strong></p><p>树中的叶子节点没有后继，因为它们没有子节点</p><h4 id="祖先节点"><a href="#祖先节点" class="headerlink" title="祖先节点"></a>祖先节点</h4><p>对于给定节点，在树中位于其上方的所有节点都是其祖先节点。祖先节点可以是父节点、父节点的父节点，以此类推，直到根节点为止。</p><h4 id="子孙节点"><a href="#子孙节点" class="headerlink" title="子孙节点"></a>子孙节点</h4><p>对于给定节点，在树中位于其下方的所有节点都是其子孙节点。子孙节点可以是子节点、子节点的子节点，以此类推，直到叶子节点为止。</p><h4 id="双亲节点"><a href="#双亲节点" class="headerlink" title="双亲节点"></a>双亲节点</h4><p>对于给定节点，它的直接上一级节点称为双亲节点或父节点。每个节点都只有一个父节点，除了根节点没有父节点。</p><h4 id="孩子节点"><a href="#孩子节点" class="headerlink" title="孩子节点"></a>孩子节点</h4><p>对于给定节点，它的直接下一级节点称为孩子节点或子节点。每个节点可以有零个或多个子节点。</p><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>对于给定节点，具有相同父节点的其他节点称为兄弟节点。兄弟节点之间是同级节点。</p><h4 id="堂兄弟节点"><a href="#堂兄弟节点" class="headerlink" title="堂兄弟节点"></a>堂兄弟节点</h4><p>给定节点，具有相同祖先节点但不是兄弟节点的节点称为堂兄弟节点。换句话说，堂兄弟节点是具有不同的双亲节点但共享同一级祖先的节点。</p><h4 id="两个节点之间的路径"><a href="#两个节点之间的路径" class="headerlink" title="两个节点之间的路径"></a>两个节点之间的路径</h4><p>在树中，两个节点之间的路径是指连接这两个节点的边的序列。路径由起始节点开始，沿着树的边连接到目标节点（只能从上到下）。</p><h4 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h4><p>路径长度是指路径上<strong>经过的边的数量</strong>。它表示从起始节点到目标节点之间的距离或步数。</p><p>树的路径长度是指树根到每个节点的路径长的总和</p><p>根到每个节点的路径长度的最大值应该是树的高度-1</p><p>注意与哈夫曼树的带权路径长度的区别</p><h4 id="节点的层次（深度）"><a href="#节点的层次（深度）" class="headerlink" title="节点的层次（深度）"></a>节点的层次（深度）</h4><p>（从上往下数）默认从1开始，要读题看看是不是第一层，有可能根节点是第0层</p><h4 id="节点的高度"><a href="#节点的高度" class="headerlink" title="节点的高度"></a>节点的高度</h4><p>（从下往上数）</p><h4 id="树的高度（深度）"><a href="#树的高度（深度）" class="headerlink" title="树的高度（深度）"></a>树的高度（深度）</h4><p>总共多少层（最多的）</p><h4 id="节点的度"><a href="#节点的度" class="headerlink" title="节点的度"></a>节点的度</h4><p>有几个孩子（分支）       非叶子节点的度&gt;0</p><h4 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h4><p><strong>各节点的度的最大值</strong></p><h4 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h4><p>有序树——逻辑上看，树中结点的各子树从左到右是有次序的，不能互换</p><p>无序树——逻辑上看，树中节点各子树从左到右是无次序的，可以互换</p><p>具体要看用树存什么，是否要用节点的左右位置反应某些逻辑关系</p><p><img src="/./assets/image-20230702130621646.png" alt="image-20230702130621646"></p><h4 id="树-和-森林"><a href="#树-和-森林" class="headerlink" title="树 和 森林"></a>树 和 森林</h4><p>森林是m(m&gt;&#x3D;0)棵互不相交的树的集合（可以有空森林）</p><p><img src="/./assets/image-20230702130848399.png" alt="image-20230702130848399"></p><h3 id="常考性质"><a href="#常考性质" class="headerlink" title="常考性质"></a>常考性质</h3><h4 id="节点数-总度数-1（根节点没有度数）"><a href="#节点数-总度数-1（根节点没有度数）" class="headerlink" title="节点数 &#x3D; 总度数 + 1（根节点没有度数）"></a>节点数 &#x3D; 总度数 + 1（根节点没有度数）</h4><h4 id="度为m的树、m叉树的区别"><a href="#度为m的树、m叉树的区别" class="headerlink" title="度为m的树、m叉树的区别"></a>度为m的树、m叉树的区别</h4><p>度为m的树要求比较严格，至少有一个节点的度为m，所以一定是非空树，至少m+1个节点</p><p>m叉树要求比较小，只要所以节点的度小于m就可以，可以是空树</p><p><img src="/./assets/image-20230702131209681.png" alt="image-20230702131209681"></p><h4 id="度为m的树第i层至多有m-i-1-个节点"><a href="#度为m的树第i层至多有m-i-1-个节点" class="headerlink" title="度为m的树第i层至多有m^(i-1)个节点"></a>度为m的树第i层至多有m^(i-1)个节点</h4><p><img src="/./assets/image-20230702131431524.png" alt="image-20230702131431524"></p><h4 id="高度为h的m叉树至多有-m-h-1-m-1-个节点"><a href="#高度为h的m叉树至多有-m-h-1-m-1-个节点" class="headerlink" title="高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个节点"></a>高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个节点</h4><p>等比数列求和公式：a + aq + aq^2 +……+aq^(n-1)&#x3D;a(1-q^n)&#x2F;(1-q)</p><p><img src="/./assets/image-20230702131624172.png" alt="image-20230702131624172"></p><h4 id="高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h-m-1个节点"><a href="#高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h-m-1个节点" class="headerlink" title="高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h+m-1个节点"></a>高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h+m-1个节点</h4><p><img src="/./assets/image-20230702131750880.png" alt="image-20230702131750880"></p><h4 id="有n个节点的m叉树的最小高度是logm-n-m-1-1-向下取整"><a href="#有n个节点的m叉树的最小高度是logm-n-m-1-1-向下取整" class="headerlink" title="有n个节点的m叉树的最小高度是logm(n(m-1)+1)向下取整"></a>有n个节点的m叉树的最小高度是logm(n(m-1)+1)向下取整</h4><p><img src="/./assets/image-20230702131931837.png" alt="image-20230702131931837"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>n(n&gt;&#x3D;0)个节点的有限集合</p><ul><li>或者为空二叉树，即n&#x3D;0</li><li>或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树右分别是一颗二叉树</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每个节点至多只有两颗子树</li><li>左右子树不能颠倒（二叉树是有序树）</li></ul><p><img src="/./assets/image-20230702132400074.png" alt="image-20230702132400074"></p><h4 id="二叉树的五种状态"><a href="#二叉树的五种状态" class="headerlink" title="二叉树的五种状态"></a>二叉树的五种状态</h4><ul><li>空二叉树</li><li>只有左子树</li><li>只有右子树</li><li>只有根节点</li><li>左右子树都有</li></ul><p><img src="/./assets/image-20230702132457500.png" alt="image-20230702132457500"></p><h4 id="几个特殊的二叉树"><a href="#几个特殊的二叉树" class="headerlink" title="几个特殊的二叉树"></a>几个特殊的二叉树</h4><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ul><li><p>一颗高度为h，且含有2^h-1个节点的二叉树</p></li><li><p>特点：</p><ul><li>只有最后一层有叶子节点</li><li>不存在度为1的节点</li><li>按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为i&#x2F;2向下取整（如果有的话）</li></ul></li></ul><p><img src="/./assets/image-20230702132912536.png" alt="image-20230702132912536"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ul><li><p>当且仅当其每个节点都与高度为h的满二叉树中编号为1～n的节点一一对应时，称为完全二叉树</p></li><li><p>特点</p><ul><li><p>只有最后两层可能有叶子节点</p></li><li><p>最多只有一个度为1的节点</p></li><li><p>按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为i&#x2F;2向下取整（如果有的话）</p></li><li><p>i&lt;&#x3D;n&#x2F;2（向上取整）为分支节点         i&gt;&#x3D;n&#x2F;2（向上取整）为叶子节点</p></li><li><p>如果一个节点只有一个孩子，那一定是左孩子，不是右孩子</p></li></ul></li></ul><p><img src="/./assets/image-20230702133421655.png" alt="image-20230702133421655"></p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><ul><li>空二叉树</li><li>具有如下性质的二叉树：<ul><li>左子树上所有节点的关键字均小于根节点的关键字</li><li>右子树上所有节点的关键字均大于根节点的关键字</li><li>左右子树又各是一棵二叉排序树</li></ul></li></ul><p><img src="/./assets/image-20230702133719969.png" alt="image-20230702133719969"></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><ul><li><p>树上任一节点的左子树和右子树的深度之差不超过1</p></li><li><p>平衡二叉树能有更高的搜索效率</p></li></ul><p><img src="/./assets/image-20230702133922676.png" alt="image-20230702133922676"></p><h4 id="二叉树基本常考性质"><a href="#二叉树基本常考性质" class="headerlink" title="二叉树基本常考性质"></a>二叉树基本常考性质</h4><h4 id="设非空二叉树中度为0、1、2的节点个数分别是n0-n1-n2，则n0-n2-1（叶子节点比二分支节点多一个）"><a href="#设非空二叉树中度为0、1、2的节点个数分别是n0-n1-n2，则n0-n2-1（叶子节点比二分支节点多一个）" class="headerlink" title="设非空二叉树中度为0、1、2的节点个数分别是n0,n1,n2，则n0&#x3D;n2+1（叶子节点比二分支节点多一个）"></a>设非空二叉树中度为0、1、2的节点个数分别是n0,n1,n2，则n0&#x3D;n2+1（叶子节点比二分支节点多一个）</h4><p>假设树中结点总数为n，则</p><ol><li>n&#x3D;n0+n1+n2</li><li>n&#x3D;n1+2n2+1   （树的节点树&#x3D;总度数+1）</li></ol><p><img src="/./assets/image-20230702160206974.png" alt="image-20230702160206974"></p><h4 id="二叉树第i层至多有2-i-1-个节点"><a href="#二叉树第i层至多有2-i-1-个节点" class="headerlink" title="二叉树第i层至多有2^(i-1)个节点"></a>二叉树第i层至多有2^(i-1)个节点</h4><p><img src="/./assets/image-20230702160304035.png" alt="image-20230702160304035"></p><h4 id="高度为h的二叉树最多有2-h-1个节点"><a href="#高度为h的二叉树最多有2-h-1个节点" class="headerlink" title="高度为h的二叉树最多有2*h-1个节点"></a>高度为h的二叉树最多有2*h-1个节点</h4><p><img src="/./assets/image-20230702160346024.png" alt="image-20230702160346024"></p><h4 id="完全二叉树常考性质"><a href="#完全二叉树常考性质" class="headerlink" title="完全二叉树常考性质"></a>完全二叉树常考性质</h4><h4 id="具有n个-n-0-节点的完全二叉树的高度为log2-n-1-向下取整或者log2n向上取整-1"><a href="#具有n个-n-0-节点的完全二叉树的高度为log2-n-1-向下取整或者log2n向上取整-1" class="headerlink" title="具有n个(n&gt;0)节点的完全二叉树的高度为log2(n+1)向下取整或者log2n向上取整+1"></a>具有n个(n&gt;0)节点的完全二叉树的高度为log2(n+1)向下取整或者log2n向上取整+1</h4><p>高为h的满二叉树共有2^h-1个节点</p><p><img src="/./assets/image-20230702160719524.png" alt="image-20230702160719524"></p><p><img src="/./assets/image-20230702160809404.png" alt="image-20230702160809404"></p><h4 id="对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2"><a href="#对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2" class="headerlink" title="对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2"></a>对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2</h4><p>完全二叉树最多只有一个度为1的节点，即</p><ul><li>n1&#x3D;0&#x2F;1</li><li>n0&#x3D;n2+1  —-&gt;  n0 + n2 一定是奇数</li></ul><p>若完全二叉树有2k个节点，则必有<strong>n1&#x3D;1,   n0&#x3D;k,   n2&#x3D;k-1</strong></p><p>若完全二叉树有2k-1个节点，则必有<strong>n1&#x3D;0,   n0&#x3D;k,   n2&#x3D;k-1</strong></p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h4 id="i的左孩子"><a href="#i的左孩子" class="headerlink" title="i的左孩子"></a>i的左孩子</h4><h4 id="i的右孩子"><a href="#i的右孩子" class="headerlink" title="i的右孩子"></a>i的右孩子</h4><h4 id="i的父亲节点"><a href="#i的父亲节点" class="headerlink" title="i的父亲节点"></a>i的父亲节点</h4><h4 id="i所在的层次"><a href="#i所在的层次" class="headerlink" title="i所在的层次"></a>i所在的层次</h4><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    二叉树的顺序存储</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    ElemType value; <span class="comment">//节点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;   <span class="comment">//节点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode t[Maxsize];    <span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下、从左到右的顺序依次存储完全二叉树中的各个节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitTree</span><span class="params">(TreeNode t[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i ++)&#123;</span><br><span class="line">        <span class="comment">//初始化时所有节点标记为空</span></span><br><span class="line">        t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230702162321119.png" alt="image-20230702162321119"></p><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li>i的左孩子：2i</li><li>i的右孩子：2i+1</li><li>i的父节点：i&#x2F;2向上取整</li><li>i所在的层次：log2(n+1)（向下取整）或log2n+1(向上取整)</li></ul><p>若完全二叉树中共有n个节点，则</p><ul><li>判断i是否有左孩子：2i&lt;&#x3D; n</li><li>判断i是否有右孩子：2i+1&lt;&#x3D;n</li><li>判断i是否时叶子&#x2F;分支节点：i&gt;n&#x2F;2（向上取整）</li></ul><p><img src="/./assets/image-20230702165242874.png" alt="image-20230702165242874"></p><p><img src="/./assets/image-20230702165355081.png" alt="image-20230702165355081"></p><p>非完全二叉树通过isEmpty(TreeNode T)来判断是否有左右孩子</p><blockquote><p>二叉树的顺序存储结构只适合存储完全二叉树</p></blockquote><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    二叉树的链式存储</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;                      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;    <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>n个节点的二叉链表共有n+1个空链域（可以用于构造线索二叉树）</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitTree</span><span class="params">(BiTree &amp;root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入根节点</span></span><br><span class="line">    root = (BiTree) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    root-&gt;data =&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">    root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入新节点，作为左孩子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertNewTNode</span><span class="params">(BiTree &amp;root, ElemType pData)</span></span>&#123;</span><br><span class="line">    BiTNode *p = (BiTNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    p-&gt;data=pData;</span><br><span class="line">    p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;lchild=p;     <span class="comment">//作为根节点的左孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种定义方法</p><ul><li>找到指定节点p的左&#x2F;右孩子超简单</li><li>找到指定节点p的父节点很难，只能从根节点开始遍历</li></ul><p><img src="/./assets/image-20230702173412228.png" alt="image-20230702173412228"></p><h4 id="改进——三叉链表"><a href="#改进——三叉链表" class="headerlink" title="改进——三叉链表"></a>改进——三叉链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三叉链表————方便找父节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;                      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;    <span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *parent;             <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h2 id="二叉树的先中后序遍历"><a href="#二叉树的先中后序遍历" class="headerlink" title="二叉树的先中后序遍历"></a>二叉树的先中后序遍历</h2><p><strong>先中后代表着根出现的顺序</strong></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li><p>按照某中次序把所有节点都访问一遍</p></li><li><p>线性结构很容易进行遍历</p></li><li><p>树可以层次遍历（基于树的层次特性确定的次序规则）也可以先中后序遍历（基于树的递归特性确定的次序规则）</p></li></ul><p><img src="/./assets/image-20230704211658740.png" alt="image-20230704211658740"></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="递归特性"><a href="#递归特性" class="headerlink" title="递归特性"></a>递归特性</h4><ol><li>要么是个空二叉树</li><li>要么就是由“根节点+左子树+右子树”组成的二叉树</li></ol><h4 id="手算口诀（默念）"><a href="#手算口诀（默念）" class="headerlink" title="手算口诀（默念）"></a>手算口诀（默念）</h4><p>先序遍历：根左右（NLR）</p><p>中序遍历：左根右（LNR）</p><p>后序遍历：左右根（LRN）</p><p><img src="/./assets/image-20230704212420320.png" alt="image-20230704212420320"></p><p><img src="/./assets/image-20230704212634674.png" alt="image-20230704212634674"></p><p><img src="/./assets/image-20230704212931789.png" alt="image-20230704212931789"></p><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>若二叉树为空，则什么也不做</li><li>若二叉树非空：<ol><li>访问根节点；</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230704214225071.png" alt="image-20230704214225071"></p><p><img src="/./assets/image-20230704214415005.png" alt="image-20230704214415005"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="操作过程-1"><a href="#操作过程-1" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>若二叉树为空，则什么也不做</li><li>若二叉树非空：<ol><li>先序遍历左子树；</li><li>访问根节点；</li><li>先序遍历右子树；</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230704214442776.png" alt="image-20230704214442776"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="操作过程-2"><a href="#操作过程-2" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>若二叉树为空，则什么也不做</li><li>若二叉树非空：<ol><li>先序遍历左子树；</li><li>先序遍历右子树；</li><li>访问根节点；</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230704214502599.png" alt="image-20230704214502599"></p><h3 id="求树的深度（应用）"><a href="#求树的深度（应用）" class="headerlink" title="求树的深度（应用）"></a>求树的深度（应用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">treeDepth</span>(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">treeDepth</span>(T -&gt; rchild);</span><br><span class="line">        <span class="comment">//树的深度=Max(左子树深度，右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>初始化一个辅助<strong>队列</strong></li><li>根节点入队</li><li>若队列非空，则队头节点入队，访问该节点，并将其左右孩子插入队尾（如果有的话）</li><li>重复3直至队列为空</li></ol><p><img src="/./assets/image-20230704215010029.png" alt="image-20230704215010029"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);       <span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,T);       <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123; <span class="comment">//队列不空则循环</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,p);   <span class="comment">//队头节点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);       <span class="comment">//访问出队节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(Q,p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(Q,p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><h3 id="不同二叉树的中序遍历序列"><a href="#不同二叉树的中序遍历序列" class="headerlink" title="不同二叉树的中序遍历序列"></a>不同二叉树的中序遍历序列</h3><p><img src="/./assets/image-20230704222841229.png" alt="image-20230704222841229"></p><h3 id="若只给出一棵二叉树的前-中-后-层序遍历序列的一种，不能唯一确定一棵二叉树"><a href="#若只给出一棵二叉树的前-中-后-层序遍历序列的一种，不能唯一确定一棵二叉树" class="headerlink" title="若只给出一棵二叉树的前&#x2F;中&#x2F;后&#x2F;层序遍历序列的一种，不能唯一确定一棵二叉树"></a>若只给出一棵二叉树的前&#x2F;中&#x2F;后&#x2F;层序遍历序列的一种，不能唯一确定一棵二叉树</h3><p>一定要有中序遍历序列才能确定一棵二叉树</p><p><img src="/./assets/image-20230704223001314.png" alt="image-20230704223001314"></p><h3 id="前序-中序遍历序列"><a href="#前序-中序遍历序列" class="headerlink" title="前序+中序遍历序列"></a>前序+中序遍历序列</h3><p><img src="/./assets/image-20230704223142717.png" alt="image-20230704223142717"></p><p><img src="/./assets/image-20230704223536041.png" alt="image-20230704223536041"></p><h3 id="后序-中序遍历序列"><a href="#后序-中序遍历序列" class="headerlink" title="后序+中序遍历序列"></a>后序+中序遍历序列</h3><p><img src="/./assets/image-20230704223909246.png" alt="image-20230704223909246"></p><h3 id="层序-中序遍历序列"><a href="#层序-中序遍历序列" class="headerlink" title="层序+中序遍历序列"></a>层序+中序遍历序列</h3><p> <img src="/./assets/image-20230704224354379.png" alt="image-20230704224354379"></p><p><img src="/./assets/image-20230704224307205.png" alt="image-20230704224307205"></p><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树的作用（更容易寻找遍历后的前驱和后继）"><a href="#线索二叉树的作用（更容易寻找遍历后的前驱和后继）" class="headerlink" title="线索二叉树的作用（更容易寻找遍历后的前驱和后继）"></a>线索二叉树的作用（更容易寻找遍历后的前驱和后继）</h3><h4 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h4><ul><li>遍历只能从根节点出发，不能从一个指定节点开始中序遍历</li><li>找到指定节点p在中序遍历中的前驱或者后继，需要从根节点出发重新进行一次中序遍历<ul><li>用一个指针q记录当前访问的节点，指针pre记录上一个被访问的节点。</li><li>当q&#x3D;&#x3D;p时，pre为前驱</li><li>当pre&#x3D;&#x3D;p时，q为后继</li></ul></li></ul><p><img src="/./assets/image-20230704225230624.png" alt="image-20230704225230624"></p><h4 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h4><p><img src="/./assets/image-20230704225516383.png" alt="image-20230704225516383"></p><h3 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;                      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;    <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;                     <span class="comment">//左右线索标志（tag=0，表示指针指向孩子；tag=1，表示指针是线索）</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p><img src="/./assets/image-20230705154700122.png" alt="image-20230705154700122"></p><h4 id="中序线索二叉树-1"><a href="#中序线索二叉树-1" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h4><p><img src="/./assets/image-20230705154812016.png" alt="image-20230705154812016"></p><h4 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h4><p><img src="/./assets/image-20230705154921007.png" alt="image-20230705154921007"></p><p><img src="/./assets/image-20230705155118817.png" alt="image-20230705155118817"></p><h4 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h4><p><img src="/./assets/image-20230705155222541.png" alt="image-20230705155222541"></p><p><img src="/./assets/image-20230705155239630.png" alt="image-20230705155239630"></p><h3 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h3><h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><blockquote><p>只有先序线索化的时候才会出现转圈死循环的状态</p><p>因为只有先序线索化是先visit，使得原本为NULL的lchild填充进前驱节点后，再进行PreThread(T-&gt;lchild)</p><p>而其他两种遍历都是先访问lchild再visit</p></blockquote><h4 id="用土方法找到中序前驱"><a href="#用土方法找到中序前驱" class="headerlink" title="用土方法找到中序前驱"></a>用土方法找到中序前驱</h4><p><img src="/./assets/image-20230705161227608.png" alt="image-20230705161227608"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找节点p的前驱</span></span><br><span class="line">BiTNode *p;                 <span class="comment">//p指向目标节点</span></span><br><span class="line">BiTNode *pre=<span class="literal">NULL</span>;          <span class="comment">//指向当前访问节点的前驱</span></span><br><span class="line">BiTNode *<span class="keyword">final</span>=<span class="literal">NULL</span>;        <span class="comment">//记录最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问节点q</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)                <span class="comment">//当前访问节点刚好是节点p</span></span><br><span class="line">        <span class="keyword">final</span> = pre;        <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> pre = q;           <span class="comment">//pre指向当前访问的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序线索化-1"><a href="#中序线索化-1" class="headerlink" title="中序线索化"></a>中序线索化</h4><p><img src="/./assets/image-20230705162744790.png" alt="image-20230705162744790"></p><p><img src="/./assets/image-20230705163128107.png" alt="image-20230705163128107"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre指向当前访问节点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;              <span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;                  <span class="comment">//建立前驱节点的后继节点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;<span class="comment">//对pre进行更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);            <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);                       <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);            <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                         <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!= <span class="literal">NULL</span>)&#123;                       <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T);                    <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)           </span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;                <span class="comment">//处理遍历的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>书上版本</strong></p><p><img src="/./assets/image-20230705163356997.png" alt="image-20230705163356997"></p><h4 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h4><p><img src="/./assets/image-20230705163552658.png" alt="image-20230705163552658"></p><blockquote><p>先序线索化容易出现死循环，所以必须对ltag进行判断</p></blockquote><p><img src="/./assets/image-20230705163706180.png" alt="image-20230705163706180"></p><ul><li><strong>视频版本</strong></li></ul><p><img src="/./assets/image-20230705163818823.png" alt="image-20230705163818823"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre指向当前访问节点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;              <span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;                  <span class="comment">//建立前驱节点的后继节点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;<span class="comment">//对pre进行更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">visit</span>(T);                        <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">if</span>(T-&gt;ltag==<span class="number">0</span>) <span class="comment">//lchild不是前驱线索</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;lchild);          <span class="comment">//中序遍历左子树</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild);            <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                         <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!= <span class="literal">NULL</span>)&#123;                       <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T);                    <span class="comment">//先序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)           </span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;                <span class="comment">//处理遍历的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>书上代码</strong></li></ul><p><img src="/./assets/image-20230705164330469.png" alt="image-20230705164330469"></p><h4 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h4><ul><li><strong>视频代码</strong></li></ul><p><img src="/./assets/image-20230705164703509.png" alt="image-20230705164703509"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre指向当前访问节点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;              <span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;                  <span class="comment">//建立前驱节点的后继节点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;<span class="comment">//对pre进行更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostThread</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);            <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);            <span class="comment">//中序遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);                         <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                         <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!= <span class="literal">NULL</span>)&#123;                       <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T);                    <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)           </span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;                <span class="comment">//处理遍历的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>书上代码</li></ul><p><img src="/./assets/image-20230705165000736.png" alt="image-20230705165000736"></p><h3 id="线索二叉树寻找前驱后继（先不前，后不继）-1"><a href="#线索二叉树寻找前驱后继（先不前，后不继）-1" class="headerlink" title="线索二叉树寻找前驱后继（先不前，后不继）"></a>线索二叉树寻找前驱后继（先不前，后不继）</h3><ul><li>先不前，后不继<ul><li>先序线索二叉树不能找先序前驱</li><li>后序线索二叉树不能找后序后继<ul><li>因为只有根能找到自己的左右子树</li><li>先序遍历的时候：根左右，根在最前面，所以找不到自己的前驱</li><li>后序遍历的时候：左右根，根在最后面，所以找不到自己的后继</li></ul></li></ul></li></ul><h4 id="中序线索二叉树找中序后继"><a href="#中序线索二叉树找中序后继" class="headerlink" title="中序线索二叉树找中序后继"></a>中序线索二叉树找中序后继</h4><ul><li>在中序线索二叉树中找到指定节点*p的中序后继next<ul><li>如果p-&gt;rtag&#x3D;&#x3D;1,则next&#x3D;p-&gt;rchild</li><li>如果p-&gt;rtag&#x3D;&#x3D;0,则next&#x3D;p的右子树中最左下节点</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以p为根的子树中，第一个被中序遍历的节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最左下节点(不一定是叶子节点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>) p=p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到节点p的后继节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//右子树中最左下节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Firstnode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;              <span class="comment">//rtag==1直接返回后序线索</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">Firstnode</span>(T); p!=<span class="literal">NULL</span>;p=<span class="built_in">Nextnode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230705172852595.png" alt="image-20230705172852595"></p><p><img src="/./assets/image-20230705173819863.png" alt="image-20230705173819863"></p><h4 id="中序线索二叉树找中序前驱"><a href="#中序线索二叉树找中序前驱" class="headerlink" title="中序线索二叉树找中序前驱"></a>中序线索二叉树找中序前驱</h4><ul><li>在中序线索二叉树中找到指定节点*p的中序前驱pre<ul><li>如果p-&gt;ltag&#x3D;&#x3D;1,则pre&#x3D;p-&gt;lchild</li><li>如果p-&gt;ltag&#x3D;&#x3D;0,则pre&#x3D;p的左子树中最右下节点</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    中序遍历找前驱</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Lastnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最右下节点（不一定是叶节点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag==<span class="number">0</span>) p=p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到节点p的前驱节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Prenode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//左子树中最右下节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Lastnode</span>(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;lchild;                      <span class="comment">//ltag==1直接返回前驱线索</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">Lastnode</span>(T); p!=<span class="literal">NULL</span>; p=<span class="built_in">Prenode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230705174105589.png" alt="image-20230705174105589"></p><p><img src="/./assets/image-20230705174837243.png" alt="image-20230705174837243"></p><h4 id="先序线索二叉树找先序后继"><a href="#先序线索二叉树找先序后继" class="headerlink" title="先序线索二叉树找先序后继"></a>先序线索二叉树找先序后继</h4><ul><li>在先序线索二叉树中找到指定节点*p的先序后继next<ul><li>若p-&gt;rtag&#x3D;&#x3D;1,则next&#x3D;p-&gt;rchild</li><li>若p-&gt;rtag&#x3D;&#x3D;0<ul><li>若p有左孩子则先序后继为左孩子</li><li>若p没有左孩子，则先序后继为右孩子</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705175024236</span>](./assets/image<span class="number">-20230705175024236.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 先序线索二叉树找先序前驱（不行）</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705175455248</span>](./assets/image<span class="number">-20230705175455248.</span>png)</span><br><span class="line"></span><br><span class="line">- 在先序线索二叉树中找到指定节点*p的先序前驱pre</span><br><span class="line"></span><br><span class="line">  - 若p-&gt;ltag==<span class="number">1</span>,则pre=p-&gt;lchild</span><br><span class="line"></span><br><span class="line">  - **若p-&gt;ltag==<span class="number">0</span>,则先序线索二叉树无法寻找到先序前驱，因为左右子树中的节点只可能是根的后继，不可能是前驱**</span><br><span class="line"></span><br><span class="line">    - 除非用土办法从头开始先序遍历</span><br><span class="line"></span><br><span class="line">    - 或者使用三叉链表（有一个指向父节点的指针）</span><br><span class="line"></span><br><span class="line">      - 如果能找到p的父节点，且**p是左孩子——p的父节点即为其前驱**</span><br><span class="line">      - 如果能找到p的父节点，且**p是右孩子，其左兄弟为空——p的父节点即为其前驱**</span><br><span class="line">      - 如果能找到p的父节点，且**p是右孩子，其左兄弟非空——p的前驱为左兄弟子树中最后一个被先序遍历的节点**</span><br><span class="line">        - 怎么找左兄弟子树中最后一个被先序遍历的节点？</span><br><span class="line">          - （自己的思路）优先寻找左兄弟子树中的右节点，如果没有右节点则寻找左节点，直到叶子节点</span><br><span class="line"></span><br><span class="line">      - p是根节点，则p没有前驱节点</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705175916064</span>](./assets/image<span class="number">-20230705175916064.</span>png)</span><br><span class="line"></span><br><span class="line">#### 后序线索二叉树找后序前驱</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705180603206</span>](./assets/image<span class="number">-20230705180603206.</span>png)</span><br><span class="line"></span><br><span class="line">- 在后序线索二叉树中找到指定节点*p的后序前驱pre</span><br><span class="line">  - 若p-&gt;ltag==<span class="number">1</span>,则pre=p-&gt;lchild</span><br><span class="line">  - 若p-&gt;ltag==<span class="number">0</span></span><br><span class="line">    - 若p有右孩子，则后序前驱为右孩子</span><br><span class="line">    - 若p没有右孩子，则后序前驱为左孩子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 后序线索二叉树找后序后继（不行）</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705181036104</span>](./assets/image<span class="number">-20230705181036104.</span>png)</span><br><span class="line"></span><br><span class="line">- 在后序线索二叉树中找到指定节点*p的后序后继next</span><br><span class="line">  - 若p-&gt;rtag==<span class="number">1</span>,则next=p-&gt;rchild</span><br><span class="line">  - 若p-&gt;rtag==<span class="number">0</span>,则后序线索二叉树无法寻找到后序后驱，因为**左右子树中的节点只可能是根的前驱，不可能是后继**</span><br><span class="line">    - 除非用土办法从头开始后序遍历</span><br><span class="line">    - 或者使用三叉链表（有一个指向父节点的指针）</span><br><span class="line">      - 如果能找到p的父节点，且**p是右孩子——p的父节点即为其后继**</span><br><span class="line">      - 如果能找到p的父节点，且**p是左孩子，其右兄弟为空**——**p的父节点即为其前驱**</span><br><span class="line">      - 如果能找到p的父节点，且**p是左孩子，其右兄弟非空**——**p的前驱为右兄弟子树中第一个被后序遍历的节点**</span><br><span class="line">        - 怎么找右兄弟子树中第一个被后序遍历的节点？</span><br><span class="line">          - （自己的思路）优先寻找右兄弟子树中的左节点，如果没有左节点则寻找右节点，直到叶子节点</span><br><span class="line">      - 如果p是根节点，则p没有后序后继</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 三种线索二叉树</span><br><span class="line"></span><br><span class="line">#### 三种线索二叉树的对比</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705155352784</span>](./assets/image<span class="number">-20230705155352784.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 树的存储结构</span><br><span class="line"></span><br><span class="line">### 树的逻辑结构</span><br><span class="line"></span><br><span class="line">- 树是<span class="built_in">n</span> (n&gt;=<span class="number">0</span>)个节点的有限集合，n=<span class="number">0</span>时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：</span><br><span class="line">  - 有且仅有一个特定的称为根的节点</span><br><span class="line">  - 当n&gt;<span class="number">1</span>时，其余节点可分为<span class="built_in">m</span> (m&gt;<span class="number">0</span>) 个互不相交的有限集合T1,T2,...,Tm,其中每个集合本身又是一棵树，并且称为根节点的子树</span><br><span class="line">- 树是一种递归定义的数据结构</span><br><span class="line">  - 二叉树：一个分支节点最多只能右两棵子树</span><br><span class="line">  - 树：一个分支节点可以有多棵子树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705191624631</span>](./assets/image<span class="number">-20230705191624631.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 回顾：二叉树的顺序存储</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705191727964</span>](./assets/image<span class="number">-20230705191727964.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 树的顺序存储</span><br><span class="line"></span><br><span class="line">- 树：一个分支节点可以有多棵子树</span><br><span class="line">- 只依靠数组下标无法反映节点之间的逻辑关系</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 树的存储<span class="number">1</span>:双亲表示法</span><br><span class="line"></span><br><span class="line">#### 思路</span><br><span class="line"></span><br><span class="line">- 用数组顺序存储各个节点。</span><br><span class="line">- **每个节点中保存数据元素、指向双亲节点（父节点）的指针**</span><br><span class="line">- 可以保存森林</span><br><span class="line"></span><br><span class="line">#### 优缺点</span><br><span class="line"></span><br><span class="line">- 优点：</span><br><span class="line">  - 找双亲（父节点）很方便</span><br><span class="line"></span><br><span class="line">- 缺点</span><br><span class="line">  - 找孩子节点很不方便，只能从头遍历整个数组</span><br><span class="line">- 比较适用于找父亲多，找孩子少的应用场景。如：并查集</span><br><span class="line"></span><br><span class="line">#### 代码实现</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    树的存储：双亲表示法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100     <span class="comment">//树中最多的节点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//树的节点定义</span></span><br><span class="line">    <span class="type">int</span> parent;                 <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                 <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;                      <span class="comment">//节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230705192015342.png" alt="image-20230705192015342"></p><p><img src="/./assets/image-20230705192413802.png" alt="image-20230705192413802"></p><h4 id="树的存储2-孩子表示法（链式存储-顺序存储）"><a href="#树的存储2-孩子表示法（链式存储-顺序存储）" class="headerlink" title="树的存储2:孩子表示法（链式存储+顺序存储）"></a>树的存储2:孩子表示法（链式存储+顺序存储）</h4><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>用数组顺序存储各个节点。</li><li>每个节点中保存数据元素、孩子链表头指针</li><li>也可以存储森林</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>找孩子很方便</li></ul></li><li>缺点<ul><li>找双亲（父节点）不方便，只能遍历每个链表</li></ul></li><li>适用于找孩子多，找父亲少的应用场景，如：服务流程树</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    树的存储：孩子表示法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> child;      <span class="comment">//孩子节点在数组中的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;  <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *firstChild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r;<span class="comment">//节点数和根的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230705192920354.png" alt="image-20230705192920354"></p><p><img src="/./assets/image-20230705193937268.png" alt="image-20230705193937268"></p><p><img src="/./assets/image-20230705194259393.png" alt="image-20230705194259393"></p><h4 id="树的存储3-孩子兄弟表示法（链式存储结构）"><a href="#树的存储3-孩子兄弟表示法（链式存储结构）" class="headerlink" title="树的存储3:孩子兄弟表示法（链式存储结构）"></a>树的存储3:孩子兄弟表示法（链式存储结构）</h4><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>与二叉树类似，采用二叉链表实现（左孩子右兄弟）</li><li>每个节点内保存数据元素和两个指针，但两个指针的含义与二叉树节点不同</li><li>也可以存储森林，将森林中每棵树的根节点视为平级的兄弟关系</li></ul><p><img src="/./assets/image-20230705195912056.png" alt="image-20230705195912056"></p><p><img src="/./assets/image-20230705200149154.png" alt="image-20230705200149154"></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h3><ul><li><strong>节点的权</strong>：有某种现实含义的数值（如：节点的重要性）</li><li><strong>节点的带权路径长度</strong>：从树的根到该节点的路径长度（经过的边数）与该节点上权值的乘积</li><li><strong>树的带权路径长度：</strong>树中所有叶子节点的带权路径长度之和（WPL，Weighted Path Length)</li></ul><p><img src="/./assets/image-20230705201213503.png" alt="image-20230705201213503"></p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>在含有n个带权叶子节点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树</p><p><img src="/./assets/image-20230705201331984.png" alt="image-20230705201331984"></p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul><li>给定n个权值分别为w1,w2,…,w3的节点，构造哈夫曼树的算法描述如下：<ol><li>将n个节点分别作为n棵仅含一个节点的二叉树，构成森林F</li><li>构造一个新节点，从F中选取两棵根节点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根节点的权值之和</li><li>从F中 删除刚才选出的两棵树，同时将新的到的树加入F中</li><li>重复步骤2和3，直至F中只剩下一棵树为止</li></ol></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>每个初始节点最终都成为叶节点，且权值越小的节点到根节点的路径越大</li><li>哈夫曼树的节点总数是2n-1</li><li>哈夫曼树中不存在度为1的点</li><li>哈夫曼树并不唯一，但WPL必然相等且为最优解</li></ul><p><img src="/./assets/image-20230705202000675.png" alt="image-20230705202000675"></p><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h4 id="固定长度编码"><a href="#固定长度编码" class="headerlink" title="固定长度编码"></a>固定长度编码</h4><ul><li>每个字符用相等长度的二进制位表示</li></ul><h4 id="可变长度编码"><a href="#可变长度编码" class="headerlink" title="可变长度编码"></a>可变长度编码</h4><ul><li>允许对不同字符用不等长的二进制位表示</li></ul><h4 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h4><ul><li>没有一个编码是另一个编码的前缀</li><li>前缀码解释无歧义</li></ul><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ul><li>用哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子节点，各个字符出现的频度作为节点的权值，根据之前的方法构造哈夫曼树</li><li>哈夫曼树不唯一，因此哈夫曼编码不唯一</li><li>哈夫曼编码可以用于数据的压缩</li></ul><p><img src="/./assets/image-20230705202705501.png" alt="image-20230705202705501"></p><p><img src="/./assets/image-20230705203033880.png" alt="image-20230705203033880"></p><p><img src="/./assets/image-20230705203455986.png" alt="image-20230705203455986"></p><h2 id="树、森林和二叉树的转换（孩子兄弟表示法）"><a href="#树、森林和二叉树的转换（孩子兄弟表示法）" class="headerlink" title="树、森林和二叉树的转换（孩子兄弟表示法）"></a>树、森林和二叉树的转换（孩子兄弟表示法）</h2><h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><h4 id="转换技巧"><a href="#转换技巧" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>现在二叉树中，画一个根节点</li><li>按“树的层序”依次处理每个节点</li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>如果当前处理的节点在树中有孩子，就<strong>把所有孩子节点“用右指针串成糖葫芦”</strong>，并在二叉树中把第一个孩子挂在当前节点的左指针下面</li></ul><p><img src="/./assets/image-20230705204752770.png" alt="image-20230705204752770"></p><p><img src="/./assets/image-20230705205010792.png" alt="image-20230705205010792"></p><h3 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>森林中各棵树的根节点视为平级的兄弟关系</li></ul><h4 id="转换技巧-1"><a href="#转换技巧-1" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>先把所有树的根节点画出来，在二叉树中用右指针串成糖葫芦</li><li>按<strong>森林的层序</strong>依次处理每个节点</li></ol><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li>如果当前处理的节点在树中有孩子，就把所有孩子节点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前节点的左指针下方</li></ul><p><img src="/./assets/image-20230705205544107.png" alt="image-20230705205544107"></p><p><img src="/./assets/image-20230705212821411.png" alt="image-20230705212821411"></p><h3 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h3><h4 id="转换技巧-2"><a href="#转换技巧-2" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>先画出树的根节点</li><li>从树的根节点开始，按照<strong>“树的层序”</strong>恢复每个节点的孩子</li></ol><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul><li>如何恢复一个节点的孩子：在二叉树中，如果当前处理的节点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前节点的下方</li></ul><p><img src="/./assets/image-20230705213239895.png" alt="image-20230705213239895"></p><p><img src="/./assets/image-20230705213402764.png" alt="image-20230705213402764"></p><h3 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h3><h4 id="转换技巧-3"><a href="#转换技巧-3" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>先把二叉树的根节点和“一整串右指针糖葫芦”拆下来，作为多棵树的根节点</li><li>按“森林的层序”恢复每个节点的孩子</li></ol><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul><li>在一个二叉树中，如果当前处理的节点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前节点的下方</li></ul><p><img src="/./assets/image-20230705213839951.png" alt="image-20230705213839951"></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="使用克鲁斯卡尔Kruskal算法求图的最小生成树"><a href="#使用克鲁斯卡尔Kruskal算法求图的最小生成树" class="headerlink" title="使用克鲁斯卡尔Kruskal算法求图的最小生成树"></a>使用克鲁斯卡尔Kruskal算法求图的最小生成树</h4><p><img src="/./assets/image-20230814204400581.png" alt="image-20230814204400581"></p><ul><li><strong>判断是否加入一条边</strong><ul><li>先查找这条边关联的两个顶点是否属于同一个集合<ul><li>即判断加入这条边之后是否形成回路</li></ul></li><li>若形成回路，则继续判断下一条边</li><li>若形不成回路，则将该边和边对应的顶点加入最小生成树 T，并继续判断下一条边</li><li>直到所有顶点都已经加入最小生成树 T</li></ul></li></ul><h4 id="判断无向图的连通性"><a href="#判断无向图的连通性" class="headerlink" title="判断无向图的连通性"></a>判断无向图的连通性</h4><p><img src="/./assets/image-20230814204606124.png" alt="image-20230814204606124"></p><ul><li>用并查集判断无向图连通性的方法<ul><li>遍历无向图的边，每遍历到一条边，就把这条边连接的两个顶点合并到同一个集合中</li><li>处理完所有边之后，只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中</li></ul></li></ul><p><img src="/./assets/image-20230705214230148.png" alt="image-20230705214230148"></p><h3 id="逻辑结构——集合"><a href="#逻辑结构——集合" class="headerlink" title="逻辑结构——集合"></a>逻辑结构——集合</h3><p>逻辑结构分为：线性结构、树形结构、图结构、集合</p><h4 id="全集S"><a href="#全集S" class="headerlink" title="全集S"></a>全集S</h4><ul><li>包含所有元素</li></ul><h4 id="子集S0，S1，S2…"><a href="#子集S0，S1，S2…" class="headerlink" title="子集S0，S1，S2…"></a>子集S0，S1，S2…</h4><ul><li>将各个元素划分为若干个<strong>互不相交</strong>的子集</li></ul><h4 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h4><ul><li>A和B属于同一个集合S0</li><li>A和H属于不同的集合</li></ul><p><img src="/./assets/image-20230705214456468.png" alt="image-20230705214456468"></p><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><ul><li>森林是m（m&gt;&#x3D;0)棵互不相交的树的集合</li><li>各个子集中的各个元素，可以组织成一棵树</li><li>三棵树可以组成森林</li></ul><h3 id="如何表示“集合关系”（并-AND-查）"><a href="#如何表示“集合关系”（并-AND-查）" class="headerlink" title="如何表示“集合关系”（并 AND 查）"></a>如何表示“集合关系”（并 AND 查）</h3><h4 id="用互不相交的树，表示多个“集合”"><a href="#用互不相交的树，表示多个“集合”" class="headerlink" title="用互不相交的树，表示多个“集合”"></a>用互不相交的树，表示多个“集合”</h4><h4 id="如何“查”到一个元素到底属于哪一个集合"><a href="#如何“查”到一个元素到底属于哪一个集合" class="headerlink" title="如何“查”到一个元素到底属于哪一个集合"></a>如何“<strong>查</strong>”到一个元素到底属于哪一个集合</h4><ul><li>从指定元素出发，一路向上，直到找到根节点</li></ul><h4 id="如何判断两个元素是否属于同一个集合？"><a href="#如何判断两个元素是否属于同一个集合？" class="headerlink" title="如何判断两个元素是否属于同一个集合？"></a>如何判断两个元素是否属于同一个集合？</h4><ul><li>分别查到两个元素的根，判断根节点是否相等即可</li></ul><h4 id="如何把两个集合“并”为一个集合？"><a href="#如何把两个集合“并”为一个集合？" class="headerlink" title="如何把两个集合“并”为一个集合？"></a>如何把两个集合“并”为一个集合？</h4><ul><li>让一棵树成为另一棵树的子树即可</li></ul><p><img src="/./assets/image-20230705215232833.png" alt="image-20230705215232833"></p><h3 id="并查集存储结构"><a href="#并查集存储结构" class="headerlink" title="并查集存储结构"></a>并查集存储结构</h3><h4 id="类比-树的存储——双亲表示法"><a href="#类比-树的存储——双亲表示法" class="headerlink" title="类比: 树的存储——双亲表示法"></a>类比: 树的存储——双亲表示法</h4><p><img src="/./assets/image-20230705215357726.png" alt="image-20230705215357726"></p><p><img src="/./assets/image-20230705215613856.png" alt="image-20230705215613856"></p><p><img src="/./assets/image-20230705215739328.png" alt="image-20230705215739328"></p><h3 id="“并查集”的代码实现"><a href="#“并查集”的代码实现" class="headerlink" title="“并查集”的代码实现"></a>“并查集”的代码实现</h3><ul><li>并 和 查</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作 找x所属集合（返回x所属根节点）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)              <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;                   <span class="comment">//根的S[]小于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作 将两个集合合并为一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//要求Root1和Root2是两个不同的集合</span></span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    并查集</span></span><br><span class="line"><span class="comment">    树的存储：双亲表示法</span></span><br><span class="line"><span class="comment">    通过int S[]这样一个数组来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100     <span class="comment">//树中最多的节点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];               <span class="comment">//集合元素数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//树的节点定义</span></span><br><span class="line">    <span class="type">int</span> parent;                 <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                 <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;                      <span class="comment">//节点数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find &quot;查&quot;操作 找x所属集合（返回x所属根节点）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)              <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;                   <span class="comment">//根的S[]小于0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作 将两个集合合并为一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//要求Root1和Root2是两个不同的集合</span></span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析-与并查集树的高度有关"><a href="#时间复杂度分析-与并查集树的高度有关" class="headerlink" title="时间复杂度分析(与并查集树的高度有关)"></a>时间复杂度分析(与并查集树的高度有关)</h4><p><img src="/./assets/image-20230814204810890.png" alt="image-20230814204810890"></p><ul><li>最好时间复杂度：O(1)</li><li>最坏时间复杂度：O(n)</li></ul><p><img src="/./assets/image-20230705221938113.png" alt="image-20230705221938113"></p><h3 id="”并查集“的优化"><a href="#”并查集“的优化" class="headerlink" title="”并查集“的优化"></a>”并查集“的优化</h3><ul><li>优化后find()最坏时间复杂度为log2(n)  树高不超过log2(n)+1</li></ul><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><ul><li>每次Union操作构建树的时候，尽可能让树不长高高<ul><li>用根节点的绝对值表示树的节点总数（-number）</li><li><strong>Union操作，让小树合并到大树</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union操作优化 “并”操作 小树合并到大树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[Root2]&gt;S[Root1])&#123;      <span class="comment">//Root2节点数更少</span></span><br><span class="line">        S[Root1] += S[Root2];   <span class="comment">//累加节点总数</span></span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        S[Root2]+=S[Root1];     <span class="comment">//累加节点总数</span></span><br><span class="line">        S[Root1]=Root2;         <span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230705222408759.png" alt="image-20230705222408759"></p><p><img src="/./assets/image-20230705223039955.png" alt="image-20230705223039955"></p><h3 id="并查集的终极优化"><a href="#并查集的终极优化" class="headerlink" title="并查集的终极优化"></a>并查集的终极优化</h3><h4 id="Find操作的优化（压缩路径）"><a href="#Find操作的优化（压缩路径）" class="headerlink" title="Find操作的优化（压缩路径）"></a>Find操作的优化（压缩路径）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find 查操作 找x所属集合（返回x所属根节点）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>) x=S[x];<span class="comment">//循环寻找x的根</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find 查操作优化 先找到根节点  再进行“压缩路径”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>) root=S[root];     <span class="comment">//循环找到根节点</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root)&#123;                     <span class="comment">//压缩路径</span></span><br><span class="line">        <span class="type">int</span> t=S[x];                     <span class="comment">//t指向x的父节点</span></span><br><span class="line">        S[x]=root;                      <span class="comment">//x直接挂到根节点下</span></span><br><span class="line">        x=t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;                        <span class="comment">//返回根节点的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>先找到根节点</li><li>再将查找路径上所有节点都挂到根节点下</li></ul><p><img src="/./assets/image-20230706110456300.png" alt="image-20230706110456300"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>每次Find操作，先找根，再“压缩路径”，可使树的高度不超过O(a(n)).</li><li>a(n)是一个增长很缓慢的函数，对于常见的n值（&lt;10000)，通常a(n)&lt;&#x3D;4,因此优化后并查集的Find、Union操作时间开销都很低</li></ul><p><img src="/./assets/image-20230706110840907.png" alt="image-20230706110840907"></p><h3 id="总结两次优化"><a href="#总结两次优化" class="headerlink" title="总结两次优化"></a>总结两次优化</h3><p><img src="/./assets/image-20230706110938473.png" alt="image-20230706110938473"></p><p><img src="/./assets/image-20230706111114375.png" alt="image-20230706111114375"></p><h2 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>树是一种递归定义的数据结构</p><h4 id="先根遍历（深度优先遍历，类似二叉树的先序遍历）"><a href="#先根遍历（深度优先遍历，类似二叉树的先序遍历）" class="headerlink" title="先根遍历（深度优先遍历，类似二叉树的先序遍历）"></a>先根遍历（深度优先遍历，类似二叉树的先序遍历）</h4><ul><li>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的先根遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(R);       <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            <span class="built_in">PreOrder</span>(T);    <span class="comment">//先根遍历下一棵子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230705225317743.png" alt="image-20230705225317743"></p><h4 id="后根遍历-深度优先遍历，类似二叉树的中序遍历"><a href="#后根遍历-深度优先遍历，类似二叉树的中序遍历" class="headerlink" title="后根遍历(深度优先遍历，类似二叉树的中序遍历)"></a>后根遍历(深度优先遍历，类似二叉树的中序遍历)</h4><ul><li>若树非空，先依次对每棵子树进行后根遍历，最后再访问根节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根的后根遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            <span class="built_in">PostOrder</span>(T);   <span class="comment">//后根遍历下一棵子树</span></span><br><span class="line">        <span class="built_in">visit</span>(R);           <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230705225849576.png" alt="image-20230705225849576"></p><h4 id="层序遍历（广度优先遍历）"><a href="#层序遍历（广度优先遍历）" class="headerlink" title="层序遍历（广度优先遍历）"></a>层序遍历（广度优先遍历）</h4><ul><li>用队列实现<ul><li>若树非空，则根节点入队</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li><li>重复2直到队列为空</li></ul></li></ul><p><img src="/./assets/image-20230706103738593.png" alt="image-20230706103738593"></p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><h4 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul><li>森林是m(m&gt;&#x3D;0)棵互不相交的树的集合。每棵树去掉根节点后，其各个子树又组成森林</li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li><p><strong>效果等同于依次对各个树进行先根遍历，对二叉树进行先序遍历</strong></p></li><li><p>若森林非空，则按如下规则进行遍历</p><ol><li>访问森林中第一棵树的根节点</li><li>先序遍历第一棵树中根节点的子树森林</li><li>先序遍历除去第一棵树之后剩余的树组成的森林</li></ol></li></ul><p><img src="/./assets/image-20230706104545434.png" alt="image-20230706104545434"></p><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><ul><li><p><strong>效果等同于依次对各个树进行后根遍历，对二叉树进行中序遍历</strong></p></li><li><p>若森林非空，则按一下规则进行遍历：</p><ol><li>中序遍历森林中第一棵树的根节点的子树森林</li><li>访问第一棵树的根节点</li><li>中序遍历除去第一棵树之后剩余的树构成的森林</li></ol></li></ul><p><img src="/./assets/image-20230706105316336.png" alt="image-20230706105316336"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树和二叉树&quot;&gt;&lt;a href=&quot;#树和二叉树&quot; class=&quot;headerlink&quot; title=&quot;树和二叉树&quot;&gt;&lt;/a&gt;树和二叉树&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树与二叉树" scheme="https://sdumoist.github.io/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2024-03-26T10:32:39.000Z</published>
    <updated>2024-03-26T12:42:48.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ul><li>栈的应用（先进后出）：括号匹配、表达式求值、中缀转后缀、中缀转前缀、递归、迷宫求解（深度优先算法）、进制转换</li><li>队列的应用（先进先出）：层次遍历（广度优先算法）、缓冲区、资源分配、矩阵压缩、页面替换算法</li><li>中缀转后缀表达式算法：栈中存储运算符</li><li>后缀表达式的计算：栈中存储操作数</li><li>递归求解</li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><h4 id="中缀转后缀的手算方法"><a href="#中缀转后缀的手算方法" class="headerlink" title="中缀转后缀的手算方法"></a>中缀转后缀的手算方法</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，就继续2</li></ol><h4 id="中缀表达式转后缀表达式（机算）"><a href="#中缀表达式转后缀表达式（机算）" class="headerlink" title="中缀表达式转后缀表达式（机算）"></a>中缀表达式转后缀表达式（机算）</h4><ul><li><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符</p></li><li><p>从左向右处理各个元素，直到末尾。</p></li><li><p>可能遇到三种情况：</p><ol><li><p>遇到操作数。直接加入后缀表达式</p></li><li><p>遇到界限符。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。注意：”(“不加入后缀表达式</p></li><li><p>遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再将当前运算符入栈。</p></li></ol></li><li><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p></li></ul><h4 id="后缀表达式的机算"><a href="#后缀表达式的机算" class="headerlink" title="后缀表达式的机算"></a>后缀表达式的机算</h4><p>用栈实现后缀表达式：</p><ol><li>从左往右扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则压入栈，并回到1；否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素（<strong>先出栈的是右操作数</strong>），执行相应运算，运算结果压回栈顶，回到1</li></ol><p><img src="/./assets/image-20230629103009744.png" alt="image-20230629103009744"></p><p><img src="/./assets/image-20230630170830221.png" alt="image-20230630170830221"></p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>数据结构三要素：逻辑结构、数据的运算、存储结构（物理结构）</p><p>![image-20230628203720101](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628203720101.png)</p><p>![image-20230628223246084](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628223246084.png)</p><p>![image-20230628223758471](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628223758471.png)</p><p><img src="/assets/image-20230629093704498.png" alt="image-20230629093704498"></p><p><img src="/assets/image-20230629102936204.png" alt="image-20230629102936204"></p><p><img src="/assets/image-20230629122344731.png" alt="image-20230629122344731"></p><p><img src="/assets/image-20230629193720289.png" alt="image-20230629193720289"></p><p><img src="/assets/image-20230629203040235.png" alt="image-20230629203040235"></p><p><img src="/assets/image-20230629214408162.png" alt="image-20230629214408162"></p><p><img src="/assets/image-20230629224617293.png" alt="image-20230629224617293"></p><p><img src="/./assets/image-20230630144103407.png" alt="image-20230630144103407"></p><p><img src="/./assets/image-20230630170813811.png" alt="image-20230630170813811"></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>线性表是具有相同数据类型的n（n&gt;&#x3D;0）个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表，若用L命名线性表，则其一般表示为L&#x3D;(a1,a2,a2……,an)</li><li>栈(Stack)是只允许一段进行插入或删除操作的<strong>线性表</strong></li></ul><h4 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h4><h4 id="栈顶"><a href="#栈顶" class="headerlink" title="栈顶"></a>栈顶</h4><p>允许进行插入和删除的一端</p><h4 id="栈底"><a href="#栈底" class="headerlink" title="栈底"></a>栈底</h4><p>不允许进行插入和删除的一端</p><h4 id="空栈"><a href="#空栈" class="headerlink" title="空栈"></a>空栈</h4><p>空表（没有元素）</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>后进先出（FILO）</p><p>![image-20230628202312363](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628202312363.png)</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h4><ol><li>初始化</li><li>销毁</li><li>插入</li><li>删除</li><li>按值查找</li><li>按位查找</li><li>求表长</li><li>输出</li><li>判空</li></ol><p>![image-20230628202547870](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628202547870.png)</p><h4 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h4><ol><li>InitStack(&amp;S): 初始化栈。创造一个空栈S，分配内存空间</li><li>DestroyStack(&amp;L): 销毁栈。销毁并释放栈S所占用的内存空间</li><li>Push(&amp;S, x): 进栈， 若栈S非满，则将x加入使之成为新栈顶</li><li>Pop(&amp;S, &amp;x): 出栈， 若栈S非空，则弹出栈顶元素，并用x返回              删除栈顶元素</li><li>GetTop(S, &amp;x): 读栈顶元素。若栈S非空，则用x返回栈顶元素               不删除栈顶元素</li><li>StackEmpty(S): 判断一个栈S是否为空，若S为空，则返回true，否则返回false</li></ol><p>![image-20230628203238863](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628203238863.png)</p><h3 id="栈的常考题型"><a href="#栈的常考题型" class="headerlink" title="栈的常考题型"></a>栈的常考题型</h3><p>进栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e</p><p>出栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e   e-&gt;d-&gt;c-&gt;b-&gt;a……..</p><h4 id="n个不同元素进栈，出栈元素的不同排列的个数有1-n-1-Cn-2n"><a href="#n个不同元素进栈，出栈元素的不同排列的个数有1-n-1-Cn-2n" class="headerlink" title="n个不同元素进栈，出栈元素的不同排列的个数有1&#x2F;n+1 * Cn 2n"></a>n个不同元素进栈，出栈元素的不同排列的个数有1&#x2F;n+1 * Cn 2n</h4><p>![image-20230628203530876](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628203530876.png)</p><h3 id="顺序栈（顺序存储方式的实现）"><a href="#顺序栈（顺序存储方式的实现）" class="headerlink" title="顺序栈（顺序存储方式的实现）"></a>顺序栈（顺序存储方式的实现）</h3><h4 id="顺序存储的定义"><a href="#顺序存储的定义" class="headerlink" title="顺序存储的定义"></a>顺序存储的定义</h4><p>缺点：栈的大小不可变</p><p>顺序存储：给各个数据元素分配连续的存储空间。 MaxSize*sizeof(ElemType)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struck&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br></pre></td></tr></table></figure><p>![image-20230628204412528](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230628204412528.png)</p><h4 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新元素入栈（Push）"><a href="#新元素入栈（Push）" class="headerlink" title="新元素入栈（Push）"></a>新元素入栈（Push）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈-Pop"><a href="#出栈-Pop" class="headerlink" title="出栈(Pop)"></a>出栈(Pop)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struck&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack s;</span><br><span class="line">    <span class="built_in">InitStack</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="共享栈-顺序栈的一种"><a href="#共享栈-顺序栈的一种" class="headerlink" title="共享栈(顺序栈的一种)"></a>共享栈(顺序栈的一种)</h3><h4 id="共享栈定义"><a href="#共享栈定义" class="headerlink" title="共享栈定义"></a>共享栈定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top0;</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br></pre></td></tr></table></figure><h4 id="初始化共享栈"><a href="#初始化共享栈" class="headerlink" title="初始化共享栈"></a>初始化共享栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈满"><a href="#判断栈满" class="headerlink" title="判断栈满"></a>判断栈满</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈满条件：top0 + 1 == top1;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(top0 +<span class="number">1</span> == top1);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="总代码-1"><a href="#总代码-1" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    共享栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top0;</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满条件：top0 + 1 == top1;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(top0 +<span class="number">1</span> == top1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ShStack s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况</p><h4 id="链栈结构定义"><a href="#链栈结构定义" class="headerlink" title="链栈结构定义"></a>链栈结构定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;      <span class="comment">//数据域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack2</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    S -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈空-1"><a href="#判断栈空-1" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty2</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进栈（Push）不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push2</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S -&gt; next;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S -&gt; next= p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈 (Pop) 不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop2</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    S -&gt; next = S -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取栈顶元素"><a href="#读取栈顶元素" class="headerlink" title="读取栈顶元素"></a>读取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem2</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总代码-2"><a href="#总代码-2" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    链栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;      <span class="comment">//数据域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack2</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    S -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty2</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push2</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S -&gt; next;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S -&gt; next= p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop2</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    S -&gt; next = S -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem2</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LiStack s;</span><br><span class="line">    <span class="built_in">InitStack</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The Stack is empty: %d\n&quot;</span>,<span class="built_in">StackEmpty</span>(s));</span><br><span class="line">    <span class="type">int</span> choise;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    <span class="keyword">while</span>(choise != <span class="number">0</span>)&#123;</span><br><span class="line">        ElemType x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter value: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;Successfully!!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Erorr!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">GetElem</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;The value is:%d &quot;</span>, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Erorr!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choise2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise2);</span><br><span class="line">    <span class="keyword">while</span>(choise2 != <span class="number">0</span>)&#123;</span><br><span class="line">        ElemType x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Pop</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>队列是只允许在一端进行插入，在另一端进行删除的线性表</p><h4 id="重要术语-1"><a href="#重要术语-1" class="headerlink" title="重要术语"></a>重要术语</h4><h4 id="队头"><a href="#队头" class="headerlink" title="队头"></a>队头</h4><p>允许删除的一端</p><h4 id="队尾"><a href="#队尾" class="headerlink" title="队尾"></a>队尾</h4><p>允许插入的一端</p><h4 id="空队列"><a href="#空队列" class="headerlink" title="空队列"></a>空队列</h4><p>没有元素的队列</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>先进先出（FIFO）</p><p><img src="/assets/image-20230629093336205.png" alt="image-20230629093336205"></p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><blockquote><p>创建 销毁 增删改查</p></blockquote><p><img src="/assets/image-20230629093630075.png" alt="image-20230629093630075"></p><ol><li>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q</li><li>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间</li><li>EnQueue(&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾</li><li>DeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回</li><li>GetHead(Q, &amp;x)：读队头元素，若队列非空，则将队头元素赋值给x</li><li>QueueEmpty(Q): 判断队列是否为空</li></ol><h3 id="顺序队列（队列的顺序实现）"><a href="#顺序队列（队列的顺序实现）" class="headerlink" title="顺序队列（队列的顺序实现）"></a>顺序队列（队列的顺序实现）</h3><h4 id="定义-浪费一个存储空间"><a href="#定义-浪费一个存储空间" class="headerlink" title="定义(浪费一个存储空间)"></a>定义(浪费一个存储空间)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;        <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p>连续的存储空间，大小：MaxSize*sizeof(ElemType);</p><p><img src="/assets/image-20230629094736245.png" alt="image-20230629094736245"></p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断队空"><a href="#判断队空" class="headerlink" title="判断队空"></a>判断队空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);<span class="comment">//队空条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>)%MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front=[Q.front+<span class="number">1</span>]%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取队列元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + MaxSize - Q.front) % MaxSize); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码-3"><a href="#总代码-3" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    队列的顺序实现(浪费空间)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;        <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);<span class="comment">//队空条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>)%MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front=[Q.front+<span class="number">1</span>]%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + MaxSize - Q.front) % MaxSize); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（不浪费存储空间的方法）"><a href="#（不浪费存储空间的方法）" class="headerlink" title="（不浪费存储空间的方法）"></a>（不浪费存储空间的方法）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个size进行判空和判满</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用tag来判空和判满</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230629102348180.png" alt="image-20230629102348180"></p><p><img src="/assets/image-20230629102511110.png" alt="image-20230629102511110"></p><h3 id="链队（队列的链式实现）"><a href="#链队（队列的链式实现）" class="headerlink" title="链队（队列的链式实现）"></a>链队（队列的链式实现）</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;     <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230629103917368.png" alt="image-20230629103917368"></p><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230629120620415.png" alt="image-20230629120620415"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20230629120711292.png" alt="image-20230629120711292"></p><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判空（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty2</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新节点赋值</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入其他元素</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear -&gt; next = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s -&gt; data = x;</span><br><span class="line">    s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">        Q.front == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空队列</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//返回值和修改</span></span><br><span class="line">    x = p -&gt; data;</span><br><span class="line">    Q.front -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="comment">//检验是否为最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码-4"><a href="#总代码-4" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    队列的链式实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;     <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue2</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty2</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新节点赋值</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入其他元素</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear -&gt; next = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s -&gt; data = x;</span><br><span class="line">    s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">        Q.front == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空队列</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//返回值和修改</span></span><br><span class="line">    x = p -&gt; data;</span><br><span class="line">    Q.front -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="comment">//检验是否为最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue q;        <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(q);       <span class="comment">//初始化队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>可以在两端进行输入和输出的队列</p><p><img src="/assets/image-20230629165606815.png" alt="image-20230629165606815"></p><p><img src="/assets/image-20230629165638917.png" alt="image-20230629165638917"> </p><h4 id="考点：判断输出序列合法性"><a href="#考点：判断输出序列合法性" class="headerlink" title="考点：判断输出序列合法性"></a>考点：判断输出序列合法性</h4><p>若数据元素输入序列为1，2，3，4，则哪些输出序列是合法的，哪些是非法的？</p><h4 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h4><p><img src="/assets/image-20230629165955894.png" alt="image-20230629165955894"></p><p><img src="/assets/image-20230629193200265.png" alt="image-20230629193200265"></p><p> <img src="/assets/image-20230629193540166.png" alt="image-20230629193540166"></p><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><h3 id="1-栈的第一个应用：括号匹配中的应用"><a href="#1-栈的第一个应用：括号匹配中的应用" class="headerlink" title="1.栈的第一个应用：括号匹配中的应用"></a>1.栈的第一个应用：括号匹配中的应用</h3><h4 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);   <span class="comment">//初始化一个栈 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length;i ++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">Push</span>(S, str[i]);   <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);    <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码（可运行）"><a href="#总代码（可运行）" class="headerlink" title="总代码（可运行）"></a>总代码（可运行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈在括号匹配中的应用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);   <span class="comment">//初始化一个栈 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length;i ++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">Push</span>(S, str[i]);   <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);    <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[]=<span class="string">&quot;&#123;&#125;[&#123;((()))&#125;]&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bracketCheck</span>(s,<span class="built_in">strlen</span>(s))) <span class="built_in">printf</span>(<span class="string">&quot;Right!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-栈的第二个应用：表达式的求值"><a href="#2-栈的第二个应用：表达式的求值" class="headerlink" title="2.栈的第二个应用：表达式的求值"></a>2.栈的第二个应用：表达式的求值</h3><h4 id="中缀、后缀、前缀表达式"><a href="#中缀、后缀、前缀表达式" class="headerlink" title="中缀、后缀、前缀表达式"></a>中缀、后缀、前缀表达式</h4><ul><li>中缀表达式：运算符在两个操作数中间</li><li>后缀表达式：运算符在两个操作数后面</li><li>前缀表达式：运算符在两个操作数前面</li></ul><p><img src="/assets/image-20230629205620005.png" alt="image-20230629205620005"></p><h4 id="中缀转后缀的手算方法-1"><a href="#中缀转后缀的手算方法-1" class="headerlink" title="中缀转后缀的手算方法"></a>中缀转后缀的手算方法</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，就继续2</li></ol><p><img src="/assets/image-20230629212626321.png" alt="image-20230629212626321"></p><p>运算顺序不唯一，因此对应的后缀表达式也不唯一</p><p>“左优先原则”，不要Freestyle，保证手算和机算结果相同：只要左边的运算符能先计算，就优先算左边（可保证表达式唯一）</p><h4 id="中缀表达式转后缀表达式（机算）-1"><a href="#中缀表达式转后缀表达式（机算）-1" class="headerlink" title="中缀表达式转后缀表达式（机算）"></a>中缀表达式转后缀表达式（机算）</h4><ul><li><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符</p></li><li><p>从左向右处理各个元素，直到末尾。</p></li><li><p>可能遇到三种情况：</p><ol><li><p>遇到操作数。直接加入后缀表达式</p></li><li><p>遇到界限符。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。注意：”(“不加入后缀表达式</p></li><li><p>遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再将当前运算符入栈。</p></li></ol></li><li><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 后缀表达式的机算</span><br><span class="line"></span><br><span class="line">用栈实现后缀表达式：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 从左往右扫描下一个元素，直到处理完所有元素</span><br><span class="line"><span class="number">2.</span> 若扫描到操作数则压入栈，并回到<span class="number">1</span>；否则执行<span class="number">3</span></span><br><span class="line"><span class="number">3.</span> 若扫描到运算符，则弹出两个栈顶元素（先出栈的是右操作数），执行相应运算，运算结果压回栈顶，回到<span class="number">1</span></span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629214241531</span>](assets/image<span class="number">-20230629214241531.</span>png)</span><br><span class="line"></span><br><span class="line">```C++</span><br></pre></td></tr></table></figure><h4 id="中缀转前缀的手算方法"><a href="#中缀转前缀的手算方法" class="headerlink" title="中缀转前缀的手算方法"></a>中缀转前缀的手算方法</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下个运算符，按照[运算符 左操作数 右操作数] 的方式组合成一个新的操作数</li><li>如果还有操作符没被处理，就继续2</li></ol><p>”右优先原则“：只要右边的运算符能先计算，就优先计算右边的</p><p><img src="/assets/image-20230629214225723.png" alt="image-20230629214225723"></p><h4 id="前缀表达式的机算"><a href="#前缀表达式的机算" class="headerlink" title="前缀表达式的机算"></a>前缀表达式的机算</h4><p>用栈实现前缀表达式的机算：</p><ol><li>从右往左扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则压入栈，并回到1；否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素（先出栈的元素是左操作数），执行相应运算，运算结果压回栈顶，回到1</li></ol><p><img src="/assets/image-20230629214129572.png" alt="image-20230629214129572"></p><h4 id="中缀表达式的机算（用栈实现）"><a href="#中缀表达式的机算（用栈实现）" class="headerlink" title="中缀表达式的机算（用栈实现）"></a>中缀表达式的机算（用栈实现）</h4><p>中缀转后缀 + 后缀表达式求值       两个算法结合</p><p>用栈实现中缀表达式的计算：</p><ol><li>初始化两个字栈：操作数栈和运算符栈</li><li>若扫描到操作数，压入操作数栈</li><li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈<strong>（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">3.</span>栈的第三个应用：递归</span><br><span class="line"></span><br><span class="line">函数调用背后的过程：</span><br><span class="line"></span><br><span class="line">#### 函数调用的特点：最后被调用的函数最先被执行结束（FILO）</span><br><span class="line"></span><br><span class="line">#### 函数调用的过程</span><br><span class="line"></span><br><span class="line">函数调用时，需要用一个栈存储：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 调用返回地址</span><br><span class="line"><span class="number">2.</span> 实参</span><br><span class="line"><span class="number">3.</span> 局部变量</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225015684</span>](assets/image<span class="number">-20230629225015684.</span>png)</span><br><span class="line"></span><br><span class="line">栈在递归中的应用：</span><br><span class="line"></span><br><span class="line">**适合用递归算法解决：可以把原始问题转换为属性相同，但规模更小的问题**</span><br><span class="line"></span><br><span class="line">#### 求阶乘和斐波那契数列的和</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225405960</span>](assets/image<span class="number">-20230629225405960.</span>png)</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225517294</span>](assets/image<span class="number">-20230629225517294.</span>png)</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230630143943097</span>](./assets/image<span class="number">-20230630143943097.</span>png)</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">/计算阶乘</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span> <span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Fib</span>(n<span class="number">-1</span>)+<span class="built_in">Fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;阶乘是：%d  ,斐波那契数列是：%d&quot;</span>, <span class="built_in">factorial</span>(num),<span class="built_in">Fib</span>(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈应用的缺点"><a href="#栈应用的缺点" class="headerlink" title="栈应用的缺点"></a>栈应用的缺点</h4><p>效率低，太多层递归可能会导致栈溢出；可能包含很多重复计算</p><h4 id="栈的改善方法"><a href="#栈的改善方法" class="headerlink" title="栈的改善方法"></a>栈的改善方法</h4><p>可以自定义栈将递归算法改造成非递归算法</p><h3 id="4-栈的第四个应用：进制转换"><a href="#4-栈的第四个应用：进制转换" class="headerlink" title="4.栈的第四个应用：进制转换"></a>4.栈的第四个应用：进制转换</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>使用stack<int>来存储每一位的数字。</li><li>在函数decimalToBase中，通过不断将十进制数除以目标进制数并取余数，将余数压入栈中。</li><li>将栈中的元素依次弹出，并将其转换为字符串类型，连接起来形成最终的转换结果。</li></ul><h4 id="总代码-5"><a href="#总代码-5" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈在进制转换中的应用</span></span><br><span class="line"><span class="comment">    使用stack&lt;int&gt;来存储每一位的数字。</span></span><br><span class="line"><span class="comment">    在函数decimalToBase中，通过不断将十进制数除以目标进制数并取余数，将余数压入栈中。</span></span><br><span class="line"><span class="comment">    将栈中的元素依次弹出，并将其转换为字符串类型，连接起来形成最终的转换结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制数转换为指定进制数</span></span><br><span class="line"><span class="function">string <span class="title">decimalToBase</span><span class="params">(<span class="type">int</span> number, <span class="type">int</span> base)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; digits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> remainder = number % base;</span><br><span class="line">        digits.<span class="built_in">push</span>(remainder);</span><br><span class="line">        number /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">while</span> (!digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> digit = digits.<span class="built_in">top</span>();</span><br><span class="line">        digits.<span class="built_in">pop</span>();</span><br><span class="line">        result += <span class="built_in">to_string</span>(digit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a decimal number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the base to convert to: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; base;</span><br><span class="line"></span><br><span class="line">    string result = <span class="built_in">decimalToBase</span>(number, base);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-栈的第五个应用：迷宫求解（深度优先算法）"><a href="#5-栈的第五个应用：迷宫求解（深度优先算法）" class="headerlink" title="5. 栈的第五个应用：迷宫求解（深度优先算法）"></a>5. 栈的第五个应用：迷宫求解（深度优先算法）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>栈在迷宫求解中有广泛的应用，主要用于实现<strong>深度优先搜索算法</strong>。下面是栈在迷宫求解中的具体应用：</p><ol><li><p>迷宫表示：首先，我们可以使用二维数组或者矩阵来表示迷宫。迷宫的每个位置可以用0表示可通行的路径，用1表示墙壁或障碍物。这样的表示方式可以方便我们在后续的求解过程中进行遍历和判断。</p></li><li><p>深度优先搜索：在迷宫求解过程中，我们通常采用深度优先搜索算法来寻找从入口到出口的路径。<strong>深度优先搜索算法的核心思想是沿着一个方向尽可能深入地探索迷宫，直到无法继续为止，然后回溯到上一个位置，选择其他的方向进行探索。</strong></p></li><li><p>栈的应用：为了实现深度优先搜索算法，我们可以借助栈来保存当前位置和搜索路径的信息。具体操作如下：</p><ul><li>将起始位置入栈。</li><li>不断出栈并探索当前位置的相邻可通行位置。</li><li>将可通行位置入栈，并标记为已访问。</li><li>重复上述步骤，直到找到出口或者栈为空。</li><li>如果找到出口，则可以通过栈中保存的路径信息来追踪整个路径。</li></ul></li></ol><p>通过使用栈，我们可以有效地管理搜索过程中的状态信息，避免了递归调用带来的函数调用开销，同时也方便了路径的回溯和记录。</p><p>总结起来，栈在迷宫求解中的应用主要体现在深度优先搜索算法的实现中，通过栈来管理搜索状态和路径信息，以便找到从入口到出口的路径。</p><h3 id="1-队列应用——树的层次遍历"><a href="#1-队列应用——树的层次遍历" class="headerlink" title="1.队列应用——树的层次遍历"></a>1.队列应用——树的层次遍历</h3><p><img src="/./assets/image-20230630145425126.png" alt="image-20230630145425126"></p><p><img src="/./assets/image-20230630145117386.png" alt="image-20230630145117386"></p><p><img src="/./assets/image-20230630145256711.png" alt="image-20230630145256711"></p><p><img src="/./assets/image-20230630145358106.png" alt="image-20230630145358106"></p><h3 id="2-队列的应用：页面替换算法"><a href="#2-队列的应用：页面替换算法" class="headerlink" title="2.队列的应用：页面替换算法"></a>2.队列的应用：页面替换算法</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><strong>页面替换算法是操作系统中用于管理虚拟内存的一种策略。在计算机系统中，虚拟内存是一种将主存（RAM）扩展到硬盘上的技术。由于硬盘的访问速度较慢，所以在内存空间不足时，操作系统需要根据一定的策略将部分主存中的页面（页框）置换到硬盘上，从而腾出空间供其他页面使用。</strong></p><p>页面替换算法的目标是使得整体的页面访问效率最大化，减少页面置换带来的性能损失。常见的页面替换算法有以下几种：</p><ol><li><p><strong>最佳(OPT)算法</strong>：选择将来最长时间内不再被访问的页面进行置换。该算法是一种理想化的算法，但实际上很难预测将来页面的访问模式。</p></li><li><p><strong>先进先出(FIFO)算法</strong>：选择最早进入内存的页面进行置换。该算法简单直观，但可能会导致”先进入”的页面在后续访问中仍然频繁使用，造成性能下降，即所谓的”Belady现象”。</p></li><li><p><strong>最近最少使用(LRU)算法</strong>：选择最近一段时间内最少被访问的页面进行置换。该算法基于局部性原理，认为最近被访问的页面可能在将来继续被访问，适应了大多数程序的访问模式。</p></li><li><p><strong>最不经常使用(LFU)算法</strong>：选择最近一段时间内访问次数最少的页面进行置换。该算法认为访问次数少的页面可能是不常用的页面，适用于具有较强访问模式的程序。</p></li><li><p><strong>时钟(Clock)算法</strong>：基于FIFO算法的基础上，使用一个”访问位”（也称为”引用位”）来判断页面是否被访问过，将未被访问的页面进行置换。</p></li></ol><p>不同的页面替换算法在不同的工作负载下表现不同，没有一种算法能够适用于所有情况。因此，在实际应用中，根据系统特点和工作负载的特点选择合适的页面替换算法。</p><h4 id="先进先出-FIFO-算法使用队列"><a href="#先进先出-FIFO-算法使用队列" class="headerlink" title="先进先出(FIFO)算法使用队列"></a><strong>先进先出(FIFO)算法</strong>使用队列</h4><h4 id="LRU（最近最少使用）算法也可以使用双端队列"><a href="#LRU（最近最少使用）算法也可以使用双端队列" class="headerlink" title="LRU（最近最少使用）算法也可以使用双端队列"></a>LRU（最近最少使用）算法也可以使用双端队列</h4><h3 id="3-队列的应用：缓冲区"><a href="#3-队列的应用：缓冲区" class="headerlink" title="3.队列的应用：缓冲区"></a>3.队列的应用：缓冲区</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>解决主机 与外部设备之间速度不匹配的问题</li><li>例如：主机输出数据给打印机打印，输出数据的速度比打印数据的速度快很多，由于速度不匹配，若直接把输出的数据给打印机打印显然是不行的。解决方法是设置一个<strong>打印数据缓冲区</strong>，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他事情。打印机就从缓冲区中按照<strong>先进先出</strong>的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求之后再向缓冲区写入打印数据。</li><li>这样做既保证了打印数据的正确，又使主机提高了效率。</li><li>打印数据缓冲区中所存储的数据就是一个队列</li></ul><h3 id="4-队列的应用：CPU资源分配"><a href="#4-队列的应用：CPU资源分配" class="headerlink" title="4. 队列的应用：CPU资源分配"></a>4. 队列的应用：CPU资源分配</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><ul><li>解决由多用户引起的资源竞争问题</li><li>在一个多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，分别通过各自的终端向操作系统提出占用CPU的请求，操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或者用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。</li><li>既能满足每个用户的请求，又使CPU能够正常运行</li></ul><h3 id="5-队列的应用：图的广度优先搜索"><a href="#5-队列的应用：图的广度优先搜索" class="headerlink" title="5.队列的应用：图的广度优先搜索"></a>5.队列的应用：图的广度优先搜索</h3><p>队列在图的广度优先搜索(BFS)中扮演了关键的角色，用于管理待访问的顶点和控制搜索的顺序。下面是队列在图的广度优先搜索中的具体应用：</p><ol><li><p>图的表示：首先，我们需要使用适当的数据结构来表示图。常见的表示方式有邻接矩阵和邻接表。邻接矩阵适用于稠密图，而邻接表适用于稀疏图。无论使用哪种表示方式，我们需要确保能够存储图中顶点之间的连接关系。</p></li><li><p>广度优先搜索：广度优先搜索是一种用于图的遍历的算法，它从图中的一个顶点开始，逐层地访问与该顶点相邻的顶点，直到达到目标顶点或者遍历完所有可达的顶点。这种搜索方式确保了先访问离起始顶点最近的顶点，然后再逐渐扩展到离起始顶点更远的顶点。</p></li><li><p>队列的应用：为了实现广度优先搜索算法，我们需要使用队列来管理待访问的顶点。具体操作如下：</p><ul><li>将起始顶点入队列。</li><li>从队列中取出一个顶点并标记为已访问。</li><li>遍历该顶点的所有相邻顶点，将未访问的顶点入队列。</li><li>重复上述步骤，直到队列为空或者找到目标顶点。</li><li>如果找到目标顶点，则可以通过记录顶点间的连接关系来追踪整个路径。</li></ul></li></ol><p>通过使用队列，我们能够按照广度优先的顺序逐层遍历图中的顶点，保证了离起始顶点近的顶点优先被访问。队列的先进先出(FIFO)特性确保了每个顶点在队列中只被访问一次。</p><p>综上所述，队列在图的广度优先搜索中的应用主要体现在管理待访问的顶点和控制搜索顺序方面，通过队列来按照广度优先的方式遍历图中的顶点，并追踪整个路径。</p><h3 id="6-队列的应用：特殊矩阵的压缩"><a href="#6-队列的应用：特殊矩阵的压缩" class="headerlink" title="6.队列的应用：特殊矩阵的压缩"></a>6.队列的应用：特殊矩阵的压缩</h3><h4 id="主要术语"><a href="#主要术语" class="headerlink" title="主要术语"></a>主要术语</h4><ul><li><strong>压缩存储</strong>：为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。目的是节省存储空间</li><li><strong>特殊矩阵</strong>：具有许多相同矩阵元素或零元素，这些相同的矩阵元素或零元素的分布有一定规律的矩阵。 常见有：对称矩阵、上（下）三角矩阵、对角矩阵</li><li><strong>特殊矩阵的压缩存储方法</strong>：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间</li></ul><h4 id="二维数组的存储结构"><a href="#二维数组的存储结构" class="headerlink" title="二维数组的存储结构"></a>二维数组的存储结构</h4><p><img src="/./assets/image-20230630151537264.png" alt="image-20230630151537264"></p><h4 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h4><p><img src="/./assets/image-20230630152013425.png" alt="image-20230630152013425"></p><p>矩阵下标  a(i,j)           一维数组下标B[k]</p><p>a(i,j)  (i &gt;&#x3D; j):  k &#x3D; i*(i-1)&#x2F;2+j-1;</p><p>a(i,j)  (i &lt; j):  k &#x3D; j*(j-1)&#x2F;2+i-1;</p><h4 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h4><p><img src="/./assets/image-20230630152935003.png" alt="image-20230630152935003"></p><p><img src="/./assets/image-20230630165439721.png" alt="image-20230630165439721"></p><h4 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h4><p><img src="/./assets/image-20230630165850992.png" alt="image-20230630165850992"></p><p><img src="/./assets/image-20230630170018814.png" alt="image-20230630170018814"></p><h4 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h4><p>非零元素远远少于矩阵元素的个数</p><h4 id="顺序存储——三元组"><a href="#顺序存储——三元组" class="headerlink" title="顺序存储——三元组&lt;行，列，值&gt;"></a>顺序存储——三元组&lt;行，列，值&gt;</h4><p><img src="/./assets/image-20230630170531882.png" alt="image-20230630170531882"></p><h4 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h4><ul><li><a href="https://blog.csdn.net/qq_42185999/article/details/105083274">十字链表法的实现</a></li></ul><p><img src="/./assets/image-20230630170726655.png" alt="image-20230630170726655"></p><p><strong>使用条件</strong>：当矩阵的非零元个数和位置在操作过程中变化较大时，就不宜采用顺序存储结构来表示三元组的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a>。对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。</p><p><strong>使用方法</strong>：在链表中，每个非零元可用一个含 5 个域的结点表示，其中 i , j , e 这 3 个域分别表示该非零元所在的行、列和非零元的值，向右域 right 用以链接同一行中下一个非零元，向下域 down 用以链接同一列中下一个非零元。</p><p>同一行的非零元通过 right 域链接成一个线性链表，同一列的非零元通过 down 域链接成一个线性链表，每个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表，故称这样的存储结构为十字链表。<br>可用两个分别存储行链表的头指针和列链表的头指针的一维数组表示之</p><p><img src="/./assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><em><strong>采用十字链表存储稀疏矩阵的示例：</strong></em></p><p> <img src="/./assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70-20230630181803252.png" alt="img"></p><blockquote><p>由于十字链表存储结构中的非零元素是按其所在行、列插入相应的链表的，所以，在创建稀疏矩阵输入非零元时，可以按<strong>任意顺序</strong>输入非零元素。每个非零元结点按升序被插入到两个没有头结点的单链表中：一个是所在行链表；另一个是所在列链表。当插入或删除结点时，只要修改相关的行、列链表即可，比较灵活。</p></blockquote><p>总代码（不知道能不能运行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean; <span class="comment">/* Boolean是布尔类型,其值是TRUE或FALSE */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span> <span class="comment">/* malloc()等 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* EOF(=^Z或F6),NULL */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;process.h&gt;</span> <span class="comment">/* exit() */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span> <span class="comment">/* 标准头文件，提供宏va_start，va_arg和va_end， */</span></span></span><br><span class="line"><span class="comment">/* 用于存取变长参数表 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数结果状态代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2 </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ---------------------------    稀疏矩阵的十字链表存储表示    ------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">OLNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j; <span class="comment">/* 该非零元的行和列下标 */</span></span><br><span class="line">ElemType e; <span class="comment">/* 非零元素值 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OLNode</span> *right, *down; <span class="comment">/* 该非零元所在行表和列表的后继链域 */</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">OLink *rhead, *chead; <span class="comment">/* 行和列链表头指针向量基址,由CreatSMatrix_OL()分配 */</span></span><br><span class="line"><span class="type">int</span> mu, nu, tu; <span class="comment">/* 稀疏矩阵的行数、列数和非零元个数 */</span></span><br><span class="line">&#125;CrossList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ---------------------------  稀疏矩阵的十字链表存储的基本操作(9个)  --------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitSMatrix</span><span class="params">(CrossList *M)</span> <span class="comment">/* 加 */</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始化M(CrossList类型的变量必须初始化,否则创建、复制矩阵将出错) */</span></span><br><span class="line">(*M).rhead = (*M).chead = <span class="literal">NULL</span>;</span><br><span class="line">(*M).mu = (*M).nu = (*M).tu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DestroySMatrix</span><span class="params">(CrossList *M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 销毁稀疏矩阵M */</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">OLNode *p, *q;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*M).mu; i++) <span class="comment">/* 按行释放结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = *((*M).rhead + i);</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>((*M).rhead);</span><br><span class="line"><span class="built_in">free</span>((*M).chead);</span><br><span class="line">(*M).rhead = (*M).chead = <span class="literal">NULL</span>;</span><br><span class="line">(*M).mu = (*M).nu = (*M).tu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateSMatrix</span><span class="params">(CrossList *M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 创建稀疏矩阵M,采用十字链表存储表示。算法5.4 */</span></span><br><span class="line"><span class="type">int</span> i, j, k, m, n, t;</span><br><span class="line">ElemType e;</span><br><span class="line">OLNode *p, *q;</span><br><span class="line"><span class="keyword">if</span> ((*M).rhead)</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(M);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入稀疏矩阵的行数 列数 非零元个数: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;t);</span><br><span class="line">(*M).mu = m;</span><br><span class="line">(*M).nu = n;</span><br><span class="line">(*M).tu = t;</span><br><span class="line">(*M).rhead = (OLink*)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*M).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*M).chead = (OLink*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*M).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= m; k++) <span class="comment">/* 初始化行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*M).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++) <span class="comment">/* 初始化列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*M).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请按任意次序输入%d个非零元的行 列 元素值:\n&quot;</span>, (*M).tu);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;i, &amp;j, &amp;e);</span><br><span class="line">p = (OLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode));</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;i = i; <span class="comment">/* 生成结点 */</span></span><br><span class="line">p-&gt;j = j;</span><br><span class="line">p-&gt;e = e;</span><br><span class="line"><span class="keyword">if</span> ((*M).rhead[i] == <span class="literal">NULL</span> || (*M).rhead[i]-&gt;j &gt; j) <span class="comment">/* p插在该行的第一个结点处 */</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;right = (*M).rhead[i];</span><br><span class="line">(*M).rhead[i] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 寻查在行表中的插入位置 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (q = (*M).rhead[i]; q-&gt;right&amp;&amp;q-&gt;right-&gt;j &lt; j; q = q-&gt;right);</span><br><span class="line">p-&gt;right = q-&gt;right; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">q-&gt;right = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*M).chead[j] == <span class="literal">NULL</span> || (*M).chead[j]-&gt;i &gt; i) <span class="comment">/* p插在该列的第一个结点处 */</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;down = (*M).chead[j];</span><br><span class="line">(*M).chead[j] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 寻查在列表中的插入位置 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (q = (*M).chead[j]; q-&gt;down&amp;&amp;q-&gt;down-&gt;i &lt; i; q = q-&gt;down);</span><br><span class="line">p-&gt;down = q-&gt;down; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">q-&gt;down = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">PrintSMatrix</span><span class="params">(CrossList M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 按行或按列输出稀疏矩阵M */</span></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">OLink p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d行%d列%d个非零元素\n&quot;</span>, M.mu, M.nu, M.tu);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入选择(1.按行输出 2.按列输出): &quot;</span>);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.mu; j++)</span><br><span class="line">&#123;</span><br><span class="line">p = M.rhead[j];</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d行%d列值为%d\n&quot;</span>, p-&gt;i, p-&gt;j, p-&gt;e);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.nu; j++)</span><br><span class="line">&#123;</span><br><span class="line">p = M.chead[j];</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d行%d列值为%d\n&quot;</span>, p-&gt;i, p-&gt;j, p-&gt;e);</span><br><span class="line">p = p-&gt;down;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSMatrix1</span><span class="params">(CrossList M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 按矩阵形式输出M</span></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">OLink p;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++)</span><br><span class="line">&#123; <span class="comment">// 从第1行到最后1行</span></span><br><span class="line">p = M.rhead[i]; <span class="comment">// p指向该行的第1个非零元素</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.nu; j++) <span class="comment">// 从第1列到最后1列</span></span><br><span class="line"><span class="keyword">if</span> (!p || p-&gt;j != j) <span class="comment">// 已到该行表尾或当前结点的列值不等于当前列值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, <span class="number">0</span>); <span class="comment">// 输出0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, p-&gt;e);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CopySMatrix</span><span class="params">(CrossList M, CrossList *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 由稀疏矩阵M复制得到T */</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">OLink p, q = <span class="literal">NULL</span>, q1 = <span class="literal">NULL</span>, q2;</span><br><span class="line"><span class="keyword">if</span> ((*T).rhead)</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(T);</span><br><span class="line">(*T).mu = M.mu;</span><br><span class="line">(*T).nu = M.nu;</span><br><span class="line">(*T).tu = M.tu;</span><br><span class="line">(*T).rhead = (OLink*)<span class="built_in">malloc</span>((M.mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*T).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*T).chead = (OLink*)<span class="built_in">malloc</span>((M.nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*T).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 初始化矩阵T的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*T).rhead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.nu; i++) <span class="comment">/* 初始化矩阵T的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*T).chead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行复制 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = M.rhead[i];</span><br><span class="line"><span class="keyword">while</span> (p) <span class="comment">/* 没到行尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">q = (OLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!q)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">q-&gt;i = p-&gt;i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">q-&gt;j = p-&gt;j;</span><br><span class="line">q-&gt;e = p-&gt;e;</span><br><span class="line"><span class="keyword">if</span> (!(*T).rhead[i]) <span class="comment">/* 插在行表头 */</span></span><br><span class="line">(*T).rhead[i] = q1 = q;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在行表尾 */</span></span><br><span class="line">q1 = q1-&gt;right = q;</span><br><span class="line"><span class="keyword">if</span> (!(*T).chead[q-&gt;j]) <span class="comment">/* 插在列表头 */</span></span><br><span class="line">&#123;</span><br><span class="line">(*T).chead[q-&gt;j] = q;</span><br><span class="line">q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在列表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">q2 = (*T).chead[q-&gt;j];</span><br><span class="line"><span class="keyword">while</span> (q2-&gt;down)</span><br><span class="line">q2 = q2-&gt;down;</span><br><span class="line">q2-&gt;down = q;</span><br><span class="line">q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">AddSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M与N的行数和列数对应相等。 */</span></span><br><span class="line">  <span class="comment">/* 操作结果: 求稀疏矩阵的和Q=M+N */</span></span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line">OLink p, pq = <span class="literal">NULL</span>, pm, pn;</span><br><span class="line">OLink *col;</span><br><span class="line"><span class="keyword">if</span> (M.mu != N.mu || M.nu != N.nu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;两个矩阵不是同类型的,不能相加\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">&#125;</span><br><span class="line">(*Q).mu = M.mu; <span class="comment">/* 初始化Q矩阵 */</span></span><br><span class="line">(*Q).nu = M.nu;</span><br><span class="line">(*Q).tu = <span class="number">0</span>; <span class="comment">/* 元素个数的初值 */</span></span><br><span class="line">(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).mu; k++) <span class="comment">/* 初始化Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*Q).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 初始化Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*Q).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line">col = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink)); <span class="comment">/* 生成指向列的最后结点的数组 */</span></span><br><span class="line"><span class="keyword">if</span> (!col)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 赋初值 */</span></span><br><span class="line">col[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行的顺序相加 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = M.rhead[i]; <span class="comment">/* pm指向矩阵M的第i行的第1个结点 */</span></span><br><span class="line">pn = N.rhead[i]; <span class="comment">/* pn指向矩阵N的第i行的第1个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (pm&amp;&amp;pn) <span class="comment">/* pm和pn均不空 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pm-&gt;j &lt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列小于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;j &gt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列大于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;e + pn-&gt;e) <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和不为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e + pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pm) <span class="comment">/* 将矩阵M该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pn) <span class="comment">/* 将矩阵N该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++)</span><br><span class="line"><span class="keyword">if</span> (col[k]) <span class="comment">/* k列有结点 */</span></span><br><span class="line">col[k]-&gt;down = <span class="literal">NULL</span>; <span class="comment">/*  令该列最后一个结点的down指针为空 */</span></span><br><span class="line"><span class="built_in">free</span>(col);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">SubtSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M与N的行数和列数对应相等。 */</span></span><br><span class="line">  <span class="comment">/* 操作结果: 求稀疏矩阵的差Q=M-N */</span></span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line">OLink p, pq = <span class="literal">NULL</span>, pm, pn;</span><br><span class="line">OLink *col;</span><br><span class="line"><span class="keyword">if</span> (M.mu != N.mu || M.nu != N.nu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;两个矩阵不是同类型的,不能相加\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">&#125;</span><br><span class="line">(*Q).mu = M.mu; <span class="comment">/* 初始化Q矩阵 */</span></span><br><span class="line">(*Q).nu = M.nu;</span><br><span class="line">(*Q).tu = <span class="number">0</span>; <span class="comment">/* 元素个数的初值 */</span></span><br><span class="line">(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).mu; k++) <span class="comment">/* 初始化Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*Q).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 初始化Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*Q).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line">col = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink)); <span class="comment">/* 生成指向列的最后结点的数组 */</span></span><br><span class="line"><span class="keyword">if</span> (!col)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 赋初值 */</span></span><br><span class="line">col[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行的顺序相减 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = M.rhead[i]; <span class="comment">/* pm指向矩阵M的第i行的第1个结点 */</span></span><br><span class="line">pn = N.rhead[i]; <span class="comment">/* pn指向矩阵N的第i行的第1个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (pm&amp;&amp;pn) <span class="comment">/* pm和pn均不空 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pm-&gt;j &lt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列小于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;j &gt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列大于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = -pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;e - pn-&gt;e) <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之差不为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e - pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之差为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pm) <span class="comment">/* 将矩阵M该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pn) <span class="comment">/* 将矩阵N该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = -pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++)</span><br><span class="line"><span class="keyword">if</span> (col[k]) <span class="comment">/* k列有结点 */</span></span><br><span class="line">col[k]-&gt;down = <span class="literal">NULL</span>; <span class="comment">/* 令该列最后一个结点的down指针为空 */</span></span><br><span class="line"><span class="built_in">free</span>(col);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">MultSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M的列数等于N的行数。操作结果: 求稀疏矩阵乘积Q=M*N */</span></span><br><span class="line"><span class="type">int</span> i, j, e;</span><br><span class="line">OLink q = <span class="literal">NULL</span>, p0, q0, q1 = <span class="literal">NULL</span>, q2;</span><br><span class="line"><span class="built_in">InitSMatrix</span>(Q);</span><br><span class="line">(*Q).mu = M.mu;</span><br><span class="line">(*Q).nu = N.nu;</span><br><span class="line">(*Q).tu = <span class="number">0</span>;</span><br><span class="line">(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).mu; i++) <span class="comment">/* 初始化矩阵Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*Q).rhead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).nu; i++) <span class="comment">/* 初始化矩阵Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*Q).chead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).mu; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= (*Q).nu; j++)</span><br><span class="line">&#123;</span><br><span class="line">p0 = M.rhead[i];</span><br><span class="line">q0 = N.chead[j];</span><br><span class="line">e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p0&amp;&amp;q0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q0-&gt;i &lt; p0-&gt;j)</span><br><span class="line">q0 = q0-&gt;down; <span class="comment">/* 列指针后移 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (q0-&gt;i &gt; p0-&gt;j)</span><br><span class="line">p0 = p0-&gt;right; <span class="comment">/* 行指针后移 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* q0-&gt;i==p0-&gt;j */</span></span><br><span class="line">&#123;</span><br><span class="line">e += p0-&gt;e*q0-&gt;e; <span class="comment">/* 乘积累加 */</span></span><br><span class="line">q0 = q0-&gt;down; <span class="comment">/* 行列指针均后移 */</span></span><br><span class="line">p0 = p0-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e) <span class="comment">/* 值不为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">q = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!q) <span class="comment">/* 生成结点失败 */</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">q-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">q-&gt;j = j;</span><br><span class="line">q-&gt;e = e;</span><br><span class="line">q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead[i]) <span class="comment">/* 行表空时插在行表头 */</span></span><br><span class="line">(*Q).rhead[i] = q1 = q;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 否则插在行表尾 */</span></span><br><span class="line">q1 = q1-&gt;right = q;</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead[j]) <span class="comment">/* 列表空时插在列表头 */</span></span><br><span class="line">(*Q).chead[j] = q;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 否则插在列表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">q2 = (*Q).chead[j]; <span class="comment">/* q2指向j行第1个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (q2-&gt;down)</span><br><span class="line">q2 = q2-&gt;down; <span class="comment">/* q2指向j行最后1个结点 */</span></span><br><span class="line">q2-&gt;down = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">TransposeSMatrix</span><span class="params">(CrossList M, CrossList *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 求稀疏矩阵M的转置矩阵T */</span></span><br><span class="line"><span class="type">int</span> u, i;</span><br><span class="line">OLink *head, p, q, r;</span><br><span class="line"><span class="keyword">if</span> ((*T).rhead)</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(T);</span><br><span class="line"><span class="built_in">CopySMatrix</span>(M, T); <span class="comment">/* T=M */</span></span><br><span class="line">u = (*T).mu; <span class="comment">/* 交换(*T).mu和(*T).nu */</span></span><br><span class="line">(*T).mu = (*T).nu;</span><br><span class="line">(*T).nu = u;</span><br><span class="line">head = (*T).rhead; <span class="comment">/* 交换(*T).rhead和(*T).chead */</span></span><br><span class="line">(*T).rhead = (*T).chead;</span><br><span class="line">(*T).chead = head;</span><br><span class="line"><span class="keyword">for</span> (u = <span class="number">1</span>; u &lt;= (*T).mu; u++) <span class="comment">/* 对T的每一行 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (*T).rhead[u]; <span class="comment">/* p为行表头 */</span></span><br><span class="line"><span class="keyword">while</span> (p) <span class="comment">/* 没到表尾,对T的每一结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;down; <span class="comment">/* q指向下一个结点 */</span></span><br><span class="line">i = p-&gt;i; <span class="comment">/* 交换.i和.j */</span></span><br><span class="line">p-&gt;i = p-&gt;j;</span><br><span class="line">p-&gt;j = i;</span><br><span class="line">r = p-&gt;down; <span class="comment">/* 交换.down.和right */</span></span><br><span class="line">p-&gt;down = p-&gt;right;</span><br><span class="line">p-&gt;right = r;</span><br><span class="line">p = q; <span class="comment">/* p指向下一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*  检验以上操作的主程序 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CrossList A, B, C;</span><br><span class="line"><span class="built_in">InitSMatrix</span>(&amp;A); <span class="comment">/* CrossList类型的变量在初次使用之前必须初始化 */</span></span><br><span class="line"><span class="built_in">InitSMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵A: &quot;</span>);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;由矩阵A复制矩阵B: &quot;</span>);</span><br><span class="line"><span class="built_in">CopySMatrix</span>(A, &amp;B);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;B); <span class="comment">/* CrossList类型的变量在再次使用之前必须先销毁 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁矩阵B后:\n&quot;</span>);</span><br><span class="line"><span class="built_in">PrintSMatrix</span>(B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵B2:(与矩阵A的行、列数相同，行、列分别为%d,%d)\n&quot;</span>, A.mu, A.nu);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C1(A+B): &quot;</span>);</span><br><span class="line"><span class="built_in">AddSMatrix</span>(A, B, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C2(A-B): &quot;</span>);</span><br><span class="line"><span class="built_in">SubtSMatrix</span>(A, B, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C3(A的转置): &quot;</span>);</span><br><span class="line"><span class="built_in">TransposeSMatrix</span>(A, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵A2: &quot;</span>);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵B3:(行数应与矩阵A2的列数相同=%d)\n&quot;</span>, A.nu);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C5(A*B): &quot;</span>);</span><br><span class="line"><span class="built_in">MultSMatrix</span>(A, B, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p><img src="/./assets/image-20230630183803349.png" alt="image-20230630183803349"></p><p>答：C</p><p>存储空间是数组A[21],说明空间大小是MaxSize &#x3D; 21；</p><p>rear指向队尾元素，front指向队头元素前一个位置 &#x3D;&#x3D;  rear指向队尾元素下一个的位置，front指向队头元素</p><p>所以 长度length &#x3D; rear + MaxSize - front</p><p><img src="/./assets/image-20230630184303469.png" alt="image-20230630184303469"></p><p><img src="/./assets/image-20230630184318704.png" alt="image-20230630184318704"></p><p>一般情况下队列不为空，删除操作只要修改头指针：head -&gt; next  &#x3D; head -&gt; next -&gt; next;</p><p>但是只有一个元素的时候，尾指针也要修改: head -&gt; next &#x3D; NULL; rear &#x3D; head;</p><p><img src="/./assets/image-20230630184604551.png" alt="image-20230630184604551"></p><p><img src="/./assets/image-20230630184548970.png" alt="image-20230630184548970"></p><p>读题要认真！！！！！！！做法要严谨！！！！！！ 在复习一遍：</p><p>入队操作有三步: rear -&gt; next &#x3D; x; x -&gt; next &#x3D; NULL; rear &#x3D; x;</p><p><img src="/./assets/image-20230630184752987.png" alt="image-20230630184752987"></p><p><img src="/./assets/image-20230630184808759.png" alt="image-20230630184808759"></p><p>进队操作在队尾！！！！！！出队操作在队头！！！！</p><p>出队是O(1), 入队是O(n)</p><p><img src="/./assets/image-20230630185223956.png" alt="image-20230630185223956"></p><p><img src="/./assets/image-20230630185318491.png" alt="image-20230630185318491"></p><p><img src="/./assets/image-20230630222455612.png" alt="image-20230630222455612"></p><p><img src="/./assets/image-20230630222439474.png" alt="image-20230630222439474"></p><p>答：A</p><p>若存放一个元素A[0]，end1为0，end2为1，所以没有元素（队空）的时候，end1&#x3D;&#x3D;end2</p><p>若队满，end1 &#x3D; 0，end2 &#x3D; m-1，所以条件为end1 &#x3D;&#x3D; (end2+1) mod M</p><p><img src="/./assets/image-20230703220139729.png" alt="image-20230703220139729"></p><p><img src="/./assets/image-20230703220200177.png" alt="image-20230703220200177"></p><p>答：A. ABCD- * -    B. AB-C * D-     C. ABC * -D-    D. AB-CD-*</p><p>将ABCD四个后缀表达式写出来，会发现只有B最多两个数存在栈里</p><p><img src="/./assets/image-20230703220611030.png" alt="image-20230703220611030"></p><p><img src="/./assets/image-20230703220531448.png" alt="image-20230703220531448"></p><p><img src="/./assets/image-20230703220549091.png" alt="image-20230703220549091"></p><p><img src="/./assets/image-20230703220640471.png" alt="image-20230703220640471"></p><p><img src="/./assets/image-20230703220704632.png" alt="image-20230703220704632"></p><p><img src="/./assets/image-20230703220816968.png" alt="image-20230703220816968"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h1&gt;&lt;h2 id=&quot;做题总结&quot;&gt;&lt;a href=&quot;#做题总结&quot; class=&quot;headerlink&quot; title=&quot;做题总结&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="https://sdumoist.github.io/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://sdumoist.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2024-03-26T10:31:39.000Z</published>
    <updated>2024-03-26T12:40:58.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li>一定要读完所有选项，考虑周全</li><li>每个选项加以验证，有些明显感觉错的选项可能是判断失误</li><li>……</li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ul><li>p、q所指指针：p、q是指针，其实就是所指的元素，不是指后继节点</li><li>数组排序的最好时间复杂度：O(nlog2n)      链表排序的最好时间复杂度：O(n2)</li><li>顺序存储结构同样适用于图和树</li><li>顺序表长度为n的意思应该是存了n个 不是数组长度为n       因为顺序表只能一个接一个的存取</li><li>取线性表第i个元素的时间与i的大小：顺序表    无关；链表    有关</li><li>在长度为n的有序单链表中插入一个新节点并且保持有序，时间复杂度是O(N)</li><li>长度为n的单链表接到长度为m的单链表后面，时间复杂度是O(M)</li><li>各种结构优点：<ul><li>顺序表：表长可估计，查询（搜索）操作较多（或者只删除、增加表尾元素）</li><li>单链表：表长难以预估，经常要增加&#x2F;删除元素</li><li>双链表：访问前后相邻节点更加灵活，方便插入和删除数据</li><li>循环单链表：带有尾指针的循环单链表访问头节点和尾节点很方便（可是删除最后一个元素不方便）</li><li>循环双链表：插入和删除最后一个元素很方便</li></ul></li><li>有时候会使用带有尾指针的循环单链表，这样访问头节点和尾节点就很方便</li><li><strong>带头节点的循环单链表</strong>当head-&gt;next-&gt;next &#x3D; head时，长度可能为0或1</li><li><strong>设有头指针和尾指针的单链表</strong>执行删除最后一个元素的操作与链表长度有关，因为要进行遍历寻找尾节点前一个节点</li><li><strong>带头节点的双循环链表</strong>在末尾插入和删除节点最方便</li><li><strong>只有头节点没有尾节点的循环双链表</strong>删除第一个元素，删除最后一个元素，在第一个元素前面插入新元素，在最后一个元素之后插入新元素最方便</li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/assets/image-20230628183838155.png" alt="image-20230628183838155"></p><p><img src="/./assets/image-20230626222106120.png" alt="3"></p><p><img src="/./assets/image-20230626225358258.png" alt="image-20230626225358258"></p><p><img src="/./assets/image-20230627114059329.png" alt="6"></p><p><img src="/assets/image-20230627185203205.png" alt="image-20230627185203205"></p><p><img src="/assets/image-20230627191832663.png" alt="image-20230627191832663"></p><p><img src="/assets/image-20230627195139625.png" alt="image-20230627195139625"></p><p><img src="/assets/image-20230627212920273.png" alt="image-20230627212920273"></p><p><img src="/assets/image-20230627225053385.png" alt="image-20230627225053385"></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p><img src="/./assets/image-20230626211955546.png" alt="1"></p><h3 id="静态实现"><a href="#静态实现" class="headerlink" title="静态实现"></a>静态实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i ++)</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList l;</span><br><span class="line">    <span class="built_in">InitList</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230626215744625.png" alt="2"></p><h3 id="动态实现"><a href="#动态实现" class="headerlink" title="动态实现"></a>动态实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//申请一片连续的存储空间</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加动态数组长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数据备份</span></span><br><span class="line">    <span class="type">int</span> *p=L.data;</span><br><span class="line">    <span class="comment">//空间申请</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">//数据复制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;L.length;i++)&#123;</span><br><span class="line">        L.data[i]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//长度增加</span></span><br><span class="line">    L.MaxSize=L.MaxSize+len;</span><br><span class="line">    <span class="comment">//空间释放</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqList l;</span><br><span class="line">    <span class="built_in">InitList</span>(l);</span><br><span class="line">    <span class="built_in">IncreaseSize</span>(l,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, l.MaxSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src="/./assets/image-20230627113912100.png" alt="5"></p><h3 id="单链表（带头节点和不带头节点）"><a href="#单链表（带头节点和不带头节点）" class="headerlink" title="单链表（带头节点和不带头节点）"></a>单链表（带头节点和不带头节点）</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化链表(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建链表传入值"><a href="#创建链表传入值" class="headerlink" title="创建链表传入值"></a>创建链表传入值</h4><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法可以实现链表逆置</span></span><br><span class="line"><span class="comment">//逆向建立单链表 头插法（带头节点）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt; data = x;</span><br><span class="line">        s -&gt;next = L -&gt;next;</span><br><span class="line">        L -&gt;next = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正向建立单链表 尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    ElemType x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立头节点</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//r为表尾节点</span></span><br><span class="line">    LNode *s, *r = L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="comment">//s为一个新申请的节点</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt;data = x;</span><br><span class="line">        r -&gt;next = s;</span><br><span class="line">        <span class="comment">//r指向新的表尾节点s</span></span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾节点指针后续</span></span><br><span class="line">    r -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否空表（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return (L == NULL);</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求表长度(有头节点)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p -&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len ++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h4 id="按值查询"><a href="#按值查询" class="headerlink" title="按值查询"></a>按值查询</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据==e的节点(有头节点)</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据==e的节点的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem2</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next, i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="built_in">Length2</span>(L)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找,返回第i个元素（带头节点）</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem2</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LNode *<span class="title">GetElem3</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt; next;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    s -&gt;data = p -&gt;data;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    p -&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存分配失败</span></span><br><span class="line"></span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在第i个位置插入"><a href="#在第i个位置插入" class="headerlink" title="在第i个位置插入"></a>在第i个位置插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断第一个节点单独操作</span></span><br><span class="line">    <span class="keyword">if</span>(i ==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        s -&gt; data = e;</span><br><span class="line">        s -&gt; next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索操作</span></span><br><span class="line">    <span class="comment">//指针p指向扫描的节点，j指向位序</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验第i-1个的节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s -&gt; next = p -&gt;next;</span><br><span class="line">    p -&gt; next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsertPlus2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索操作</span></span><br><span class="line">    LNode *p = <span class="built_in">GetElem2</span>(L, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InsertNextNode</span>(p,e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果p节点是最后一个节点，存在bug（空指针异常）</span></span><br><span class="line">    p -&gt; next = q -&gt; next;</span><br><span class="line">    p -&gt; data = q -&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找删除某个节点并返回值"><a href="#查找删除某个节点并返回值" class="headerlink" title="查找删除某个节点并返回值"></a>查找删除某个节点并返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第i个节点并返回数据（有头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //搜索操作</span></span><br><span class="line">    <span class="comment">// LNode *p = GetElem2(L, i-1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i <span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p -&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并且返回数据</span></span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line">    e = q -&gt;data;</span><br><span class="line">    p -&gt;next = q -&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码（可执行）"><a href="#总代码（可执行）" class="headerlink" title="总代码（可执行）"></a>总代码（可执行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    单链表的局限性：无法逆向检索，有时候不太方便</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长度(有头节点)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p -&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len ++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否空表（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return (L == NULL);</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据==e的节点</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据==e的节点的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem2</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next, i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="built_in">Length2</span>(L)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位查找,返回第i个元素（带头节点）</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem2</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LNode *<span class="title">GetElem3</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt; next;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    s -&gt;data = p -&gt;data;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    p -&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存分配失败</span></span><br><span class="line"></span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断第一个节点单独操作</span></span><br><span class="line">    <span class="keyword">if</span>(i ==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        s -&gt; data = e;</span><br><span class="line">        s -&gt; next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="comment">//return InsertNextNode(p,e);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //搜索操作</span></span><br><span class="line">    <span class="comment">// LNode *p = GetElem2(L, i-1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针p指向扫描的节点，j指向位序</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="comment">//return InsertNextNode(p,e); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验第i-1个的节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s -&gt; next = p -&gt;next;</span><br><span class="line">    p -&gt; next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsertPlus2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索操作</span></span><br><span class="line">    LNode *p = <span class="built_in">GetElem2</span>(L, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InsertNextNode</span>(p,e); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个节点并返回数据（有头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //搜索操作</span></span><br><span class="line">    <span class="comment">// LNode *p = GetElem2(L, i-1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i <span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p -&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并且返回数据</span></span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line">    e = q -&gt;data;</span><br><span class="line">    p -&gt;next = q -&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果p节点是最后一个节点，存在bug（空指针异常）</span></span><br><span class="line">    p -&gt; next = q -&gt; next;</span><br><span class="line">    p -&gt; data = q -&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正向建立单链表 尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    ElemType x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立头节点</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//r为表尾节点</span></span><br><span class="line">    LNode *s, *r = L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="comment">//s为一个新申请的节点</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt;data = x;</span><br><span class="line">        r -&gt;next = s;</span><br><span class="line">        <span class="comment">//r指向新的表尾节点s</span></span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾节点指针后续</span></span><br><span class="line">    r -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法可以实现链表逆置</span></span><br><span class="line"><span class="comment">//逆向建立单链表 头插法（带头节点）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt; data = x;</span><br><span class="line">        s -&gt;next = L -&gt;next;</span><br><span class="line">        L -&gt;next = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印整个链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">Empty</span>(p))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList l;</span><br><span class="line">    l = <span class="built_in">List_TailInsert2</span>(l);</span><br><span class="line">    <span class="built_in">PrintList</span>(l);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Select what you want: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    1.Search\n    2.Insert\n    3.Delete\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> choise;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    <span class="keyword">while</span>(choise != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(choise == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;        1.Search by value, please enter the value you want:\n        2. Search by location, please enter the location you want:\n&quot;</span>);</span><br><span class="line">            <span class="type">int</span> choise2, a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;choise2, &amp;a);</span><br><span class="line">            <span class="keyword">if</span>(choise2 == <span class="number">1</span>)&#123;</span><br><span class="line">                b = <span class="built_in">LocateElem2</span>(l,a);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The location is %d\n&quot;</span>, b);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(choise2 == <span class="number">2</span>)&#123;</span><br><span class="line">                b = <span class="built_in">GetElem2</span>(l, a) -&gt; data;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The value is %d\n&quot;</span>, b);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error enter!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(choise == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;        Please enter the loaction and the value you want to Insert\n&quot;</span>);</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListInsert2</span>(l, a, b)) <span class="built_in">printf</span>(<span class="string">&quot;Insert Successfull!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error Insert!!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(choise == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;        Please enter the loaction you want to delete:\n&quot;</span>);</span><br><span class="line">            <span class="type">int</span> loc, value;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;loc);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListDelete2</span>(l, loc, value)) <span class="built_in">printf</span>(<span class="string">&quot;The value deleted is %d, delete successfully!!\n&quot;</span>, value);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error delete!!!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PrintList</span>(l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Select what you want: \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    1.Search\n    2.Insert\n    3.Delete\n    0.exit\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior,*next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; prior = <span class="literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入 将p节点之后插入s节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) p-&gt;next-&gt;prior = s;</span><br><span class="line">    s -&gt;prior = p;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 删除p节点的后继节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q -&gt;next != <span class="literal">NULL</span>) q -&gt;next -&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据节点</span></span><br><span class="line">    <span class="keyword">while</span>(L -&gt;next != <span class="literal">NULL</span>) <span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/assets/image-20230627211604117.png" alt="image-20230627211604117"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p -&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历（跳过头节点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码（不可执行）"><a href="#总代码（不可执行）" class="headerlink" title="总代码（不可执行）"></a>总代码（不可执行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior,*next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; prior = <span class="literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入 将p节点之后插入s节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) p-&gt;next-&gt;prior = s;</span><br><span class="line">    s -&gt;prior = p;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 删除p节点的后继节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q -&gt;next != <span class="literal">NULL</span>) q -&gt;next -&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据节点</span></span><br><span class="line">    <span class="keyword">while</span>(L -&gt;next != <span class="literal">NULL</span>) <span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p -&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历（跳过头节点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DLinkList L;</span><br><span class="line">    <span class="built_in">InitDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环单链表：从一个节点出发可以找到其他任何一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头节点next指针指向头节点</span></span><br><span class="line">    L -&gt;next = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L-&gt;next == L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断节点p是否为循环单链表的表尾节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(LinkList L, LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p -&gt;next == L) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList l;</span><br><span class="line">    <span class="built_in">InitList</span>(l);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">Empty</span>(l));</span><br><span class="line"></span><br><span class="line">    LNode *p = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    p = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">isTail</span>(l,p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环单链表-1"><a href="#循环单链表-1" class="headerlink" title="循环单链表"></a>循环单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环双链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;</span><br><span class="line">&#125;DNode, DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt;prior = L;</span><br><span class="line">    L -&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L -&gt;next == L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是尾节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L, DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p -&gt; next == L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p节点之后插入s节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    s -&gt; prior = p;</span><br><span class="line">    p -&gt; next -&gt; prior = s;</span><br><span class="line">    p -&gt; next = s; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除p的后继节点q</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    DNode *q = p -&gt;next;</span><br><span class="line">    p-&gt;next = q -&gt;next;</span><br><span class="line">    q -&gt;next -&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DLinkList l;</span><br><span class="line">    <span class="built_in">InitDLinkList</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    静态链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SLinkList a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">typedef</span> Node&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> a[MaxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_32643313/article/details/105339069">【数据结构】C++实现之静态链表</a></p><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间”一对一”的逻辑关系通过一个整形变量（称为”游标”，和指针功能类似）维持（和链表类似）。</p><h4 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="type">int</span> cur;        <span class="comment">//代表游标，为0时无指向</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Component StaticLinkList[MAXSIZE];   <span class="comment">//结构体数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h4><p>数组中的第一个元素和最后一个元素作为特殊元素处理，不存放数据。通常把数组中未存放数据的元素称为备用链表。而数组的第一个元素，即下表为0的元素的cur存放备用链表的第一个结点的下标；数组中最后一个元素，即下标为（MAXSIZE － 1）的元素的cur存放第一个有数值的元素的下标，相当于单链表中头结点的作用。</p><p><img src="/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNjQzMzEz,size_16,color_FFFFFF,t_70-7923546-7923550.jpeg" alt="静态数组"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化数组线性表，也是将数组链接成备用链表，其中space[0].cur代表头指针*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList &amp;space)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">//目前静态链表为空，所以最后一元素的cur=0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、静态链表插入操作"><a href="#4、静态链表插入操作" class="headerlink" title="4、静态链表插入操作"></a><strong>4、静态链表插入操作</strong></h4><p>1）插入前我们需要考虑，由于要多存入一个元素，那么就要考虑分配空间问题。即从链表中备用空间里拿出一空间，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*静态链表返回空闲空间下标，也是进行插入元素的准备操作（类似动态链表的分配空间）*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Malloc_SL</span><span class="params">(StaticLinkList space)</span><span class="comment">//返回分配的结点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">//当前数组第一个元素的cur的值，该值代表备用链表起始位置</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">//由于要出空闲链表中拿一个空间出来，因此需要将它相邻的空间的下标给头节点的cur</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）插入新元素，具体我们这里举例将在“乙” “丁”中间插入“丙”</p><p><img src="/assets/20200406103034506.jpg" alt="静态数组2"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*静态链表的插入操作*/</span></span><br><span class="line"><span class="function">Status <span class="title">Listinsert</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*在L链表中第i个元素前面插入新的数据元素*/</span></span><br><span class="line"><span class="type">int</span> k, j;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;<span class="comment">//k为最后一个元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L) + <span class="number">1</span>)    <span class="comment">//插入位置错误，异常抛出</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">j = <span class="built_in">Malloc_SL</span>(L);</span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line">L[j].data = e;                      <span class="comment">//将新值放入刚刚知道的空闲下标的数组元素值中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表插入新值时，不会改变插入值在数组中的位置，只会跟新插入前后数据的游标cur值*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt;= i - <span class="number">1</span>; n++)<span class="comment">//此时k为第i元素之前的下标</span></span><br><span class="line">k = L[k].cur;                  </span><br><span class="line">L[j].cur = L[k].cur;<span class="comment">//把第i前元素的cur赋值给新元素的cur</span></span><br><span class="line">L[k].cur = j;<span class="comment">//再更新第i前元素的cur</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、静态链表删除操作"><a href="#5、静态链表删除操作" class="headerlink" title="5、静态链表删除操作"></a><strong>5、静态链表删除操作</strong></h4><p>1）删除时，需要考虑第一删除位置合不合理？<br>2）删除元素数据后，数据空间的回收问题，即怎么将它恢复到备用链表中？<br>3）删除元素的目标链表实际元素数据长度？多长问题<br>4）就是删除元素的前后元素游标怎么变化?下面以删除“甲”为例</p><p><img src="/assets/20200406103236983.jpg" alt="静态数组3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将删除节点空间进行回收，回收为备用链表中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Free_SL</span><span class="params">(StaticLinkList &amp;space, <span class="type">int</span> k)</span>  <span class="comment">//k表示删除元素再链表中的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*如何回收？即将该节点作为备用链表的第1节点*/</span></span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur;          <span class="comment">//将头节点中的指向备用链表的第一节点下标赋值为当前节点的游标值</span></span><br><span class="line">space[<span class="number">0</span>].cur = k;   <span class="comment">//更新头节点游标值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回静态链表中数据元素的个数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="type">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;   <span class="comment">//得到链表中第1有值元素的下标</span></span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">i = L[i].cur;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除L中第i元素的数据e*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)<span class="comment">//找到第i元素之前元素的下标</span></span><br><span class="line">k = L[k].cur;</span><br><span class="line">j = L[k].cur;                 <span class="comment">//第i元素之前元素的游标</span></span><br><span class="line">L[k].cur = L[j].cur;<span class="comment">//将第i元素之后的元素的下标 交给 第i前元素的游标</span></span><br><span class="line"><span class="built_in">Free_SL</span>(L, j);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-完整代码"><a href="#6-完整代码" class="headerlink" title="6.  完整代码"></a>6.  完整代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线性表的操作包括如下几种</span></span><br><span class="line"><span class="comment">（1） InitList(&amp;L)初始化，构造一个空的线性表</span></span><br><span class="line"><span class="comment">（2） ListEmpty(&amp;L)判断线性表是否为空,true or flase</span></span><br><span class="line"><span class="comment">（3） ClearList(&amp;L)清空线性表中的内容</span></span><br><span class="line"><span class="comment">（4） GetElem(&amp;L，i，e)返回线性表i位置上的元素值，通过e返回</span></span><br><span class="line"><span class="comment">（5） LocateElem(&amp;L,e)在线性表中找到与e相同的元素，成功则返回其序号，否则返回0表示失败</span></span><br><span class="line"><span class="comment">（9） Listinsert(&amp;L,i,e)如果线性表存在了，而且i符合条件，则在i位置插入一个元素e</span></span><br><span class="line"><span class="comment">（10）ListDelete(&amp;L,i,)删除i位置上的元素</span></span><br><span class="line"><span class="comment">（5） ListLength(L)返回线性表的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="type">int</span> cur;        <span class="comment">//代表游标，为0时无指向</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Component StaticLinkList[MAXSIZE];   <span class="comment">//typedef可以掩饰复合类型，如指针和数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化数组线性表，也是将数组链接成备用链表，其中space[0].cur代表头指针*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList &amp;space)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">//目前静态链表为空，所以最后一元素的cur=0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表返回空闲空间下标，也是进行插入元素的准备操作（类似动态链表的分配空间）*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Malloc_SL</span><span class="params">(StaticLinkList space)</span><span class="comment">//返回分配的结点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">//当前数组第一个元素的cur的值，该值代表备用链表起始位置</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">//由于要出空闲链表中拿一个空间出来，因此需要将它相邻的空间的下标给头节点的cur</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回静态链表中数据元素的个数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="type">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;   <span class="comment">//得到链表中第1有值元素的下标</span></span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">i = L[i].cur;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表的插入操作*/</span></span><br><span class="line"><span class="function">Status <span class="title">Listinsert</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*在L链表中第i个元素前面插入新的数据元素*/</span></span><br><span class="line"><span class="comment">/*注意：在开展插入操作时，静态链表不能为空链表,至少长度&gt;=1*/</span></span><br><span class="line"><span class="type">int</span> k, j;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;<span class="comment">//k为最后一个元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L) + <span class="number">1</span>)    <span class="comment">//插入位置错误，异常抛出</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">j = <span class="built_in">Malloc_SL</span>(L);</span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line">L[j].data = e;                      <span class="comment">//将新值放入刚刚知道的空闲下标的数组元素值中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表插入新值时，不会改变插入值在数组中的位置，只会跟新插入前后数据的游标cur值*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt;= i - <span class="number">1</span>; n++)<span class="comment">//此时k为第i元素之前的下标</span></span><br><span class="line">k = L[k].cur;                  </span><br><span class="line">L[j].cur = L[k].cur;<span class="comment">//把第i前元素的cur赋值给新元素的cur</span></span><br><span class="line">L[k].cur = j;<span class="comment">//再更新第i前元素的cur</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将删除节点空间进行回收，回收为备用链表中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Free_SL</span><span class="params">(StaticLinkList &amp;space, <span class="type">int</span> k)</span>  <span class="comment">//k表示删除元素再链表中的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*如何回收？即将该节点作为备用链表的第1节点*/</span></span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur;          <span class="comment">//将头节点中的指向备用链表的第一节点下标赋值为当前节点的游标值</span></span><br><span class="line">space[<span class="number">0</span>].cur = k;   <span class="comment">//更新头节点游标值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除L中第i元素的数据e*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)<span class="comment">//找到第i元素之前元素的下标</span></span><br><span class="line">k = L[k].cur;</span><br><span class="line">j = L[k].cur;                 <span class="comment">//第i元素之前元素的游标</span></span><br><span class="line">L[k].cur = L[j].cur;<span class="comment">//将第i元素之后的元素的下标 交给 第i前元素的游标</span></span><br><span class="line"><span class="built_in">Free_SL</span>(L, j);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StaticLinkList  mylist;</span><br><span class="line"><span class="built_in">InitList</span>(mylist); <span class="comment">//初始化静态链表，空闲链表此时，默认头节点为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h = <span class="built_in">Malloc_SL</span>(mylist);</span><br><span class="line">mylist[h].cur = <span class="number">0</span>; <span class="comment">//初始链表元素存储头节点h=1,</span></span><br><span class="line">mylist[h].data = <span class="number">50</span>;</span><br><span class="line">mylist[<span class="number">999</span>].cur = h;<span class="comment">//更新数组最后元素的指向的第1元素下标，cur=1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Listinsert</span>(mylist,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Listinsert</span>(mylist, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">Listinsert</span>(mylist, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历并输出该链表上的所有数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;遍历并输出该链表上的所有数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i = mylist[<span class="number">999</span>].cur;</span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; mylist[i].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">i = mylist[i].cur;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;please hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ListDelete</span>(mylist, <span class="number">2</span>);         <span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">//遍历并输出该链表上的所有数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;遍历并输出该链表上的所有数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">i = mylist[<span class="number">999</span>].cur;</span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; mylist[i].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">i = mylist[i].cur;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><p>都属于线性表，都是线性结构</p><p><img src="/assets/image-20230628120312484.png" alt="image-20230628120312484"></p><h3 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2.存储结构"></a>2.存储结构</h3><ul><li><p>顺序表：<strong>（顺序存储结构）</strong></p></li><li><p>优点：支持随机存取，存储密度高</p></li><li><p>缺点：大片连续空间分配不方便，改变容量不方便</p></li><li><p>链表：**(链式存储结构)**</p></li><li><p>优点：离散的小空间分配方便，改变容量方便</p></li><li><p>缺点：不可随机存取，存储密度低</p></li></ul><p><img src="/assets/image-20230628120429304.png" alt="image-20230628120429304"></p><h3 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3.基本操作"></a>3.基本操作</h3><blockquote><p>创建 销毁 增删改查</p></blockquote><p><img src="/assets/image-20230628120449816.png" alt="image-20230628120449816"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>顺序表（静态分配：静态数组   动态分配：动态数组）</p></li><li><p>需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源</p></li><li><p>链表</p></li><li><p>只需分配一个头节点（也可以不要头节点，只声明一个头指针）之后方便拓展</p></li></ul><p><img src="/assets/image-20230628120607282.png" alt="image-20230628120607282"></p><h4 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h4><ul><li><p>顺序表（静态分配：静态数组   动态分配：动态数组）</p></li><li><p>静态分配：静态数组             系统自动回收空间</p></li><li><p>动态分配：动态数组             需要手动free</p></li><li><p>链表</p></li><li><p>依次删除各个节点（free）</p></li></ul><p><img src="/assets/image-20230628121809812.png" alt="image-20230628121809812"></p><h4 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h4><ul><li><p>顺序表（顺序存储）</p></li><li><p>插入&#x2F;删除元素要将后续元素都后移&#x2F;前移</p></li><li><p>时间复杂度O(n)时间开销主要来自移动元素（若数据元素很大，则移动的时间代价很高）</p></li><li><p>链表（链式存储）</p></li><li><p>插入&#x2F;删除元素只需修改指针即可</p></li><li><p>时间复杂度O(n)，时间开销主要来自查找目标元素（查找元素的时间代价低）</p></li></ul><p><img src="/assets/image-20230628121945141.png" alt="image-20230628121945141"></p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><ul><li><p>顺序表（顺序存储）</p></li><li><p>按位查找 O(1)</p></li><li><p>按值查找 O(n) 若表内元素有序，可以在O(log2n)时间内找到</p></li><li><p>链表</p></li><li><p>按位查找：O(n)</p></li><li><p>按值查找：O(n)</p></li></ul><p><img src="/assets/image-20230628122016514.png" alt="image-20230628122016514"></p><h4 id="用顺序表还是链表？"><a href="#用顺序表还是链表？" class="headerlink" title="用顺序表还是链表？"></a>用顺序表还是链表？</h4><ul><li><p>查：顺序表表长可估计，查询（搜索）操作较多（或者只删除、增加表尾元素）</p></li><li><p>创建、增、删：链表             表长难以预估，经常要增加&#x2F;删除元素</p></li></ul><p><img src="/assets/image-20230628122047901.png" alt="image-20230628122047901"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p><img src="/assets/image-20230628174331911.png" alt="image-20230628174331911"></p><p>答：A</p><p>​顺序存取结构即顺序表，该题考查顺序表和链表的不同。顺序表不像链表那样，要在节点中存放指针域，因此存储密度更大。</p><p><img src="/assets/image-20230628174603606.png" alt="image-20230628174603606"></p><p>答：A</p><p>​存取方式是指读写方式，顺序表是一种支持随机存取的存储结构，根据起始地址加上元素序号，可以很方便地访问任意一个元素，这就是随机存取的概念。</p><p><a href="https://blog.csdn.net/wq6ylg08/article/details/103358596">数据结构考研:随机存取、顺序存取、随机存储和顺序存储的区别&#x2F;详细解释(计算机&#x2F;软件工程&#x2F;王道论坛)</a></p><h4 id="1-存取结构-随机存取和顺序存取"><a href="#1-存取结构-随机存取和顺序存取" class="headerlink" title="**1.存取结构:随机存取和顺序存取 **"></a>**1.存取结构:随机存取和顺序存取 **</h4><h4 id="1-1随机存取"><a href="#1-1随机存取" class="headerlink" title="1.1随机存取"></a><strong>1.1随机存取</strong></h4><p>随机存取（直接存取,Random Access）指的是当存储器中的数据被读取或写入时，<strong>所需要的时间与该数据所在的物理地址无关</strong>。</p><p><strong>随机存取的微观现实例子就是编程语言中的数组。</strong><br>随机存取的宏观现实例子就是我们的随机存取存储器(RAM:Random Access Memory)，通俗的说也就是我们电脑的内存条。因为RAM利用电容存储电荷的原理保存信息，所以RAM可以高速存取，且与物理地址无关。</p><h4 id="1-2顺序存取"><a href="#1-2顺序存取" class="headerlink" title="1.2顺序存取"></a><strong>1.2顺序存取</strong></h4><p>顺序存取(Sequential Access)是一种按记录的逻辑顺序进行读、写操作的存取方法，<strong>所需要的时间与该数据所在的物理地址有关</strong>。顺序存取表现为:<strong>在存取第N个数据时，必须先访问前（N-1）个数据</strong>。<br><strong>顺序存取的微观现实例子就是数据结构中的链表</strong>。<br>顺序存取的现实例子就是我们的录音磁带、光盘、机械硬盘里面的磁盘。磁带、光盘、磁盘上的数据分别存储在不同扇区、不同磁道上，磁盘的读写磁头通过切换不同扇区和磁道来读取物理地址不连续的数据时，该过程中要经过不同扇区和不同磁道上的无关数据，磁盘的读写磁头在切换不同扇区和磁道所需时间也不同，故为顺序存取。</p><p><img src="/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxNnlsZzA4,size_16,color_FFFFFF,t_70.png" alt="随机存取和链式存取"></p><h4 id="2-存储结构-顺序存储、随机存储"><a href="#2-存储结构-顺序存储、随机存储" class="headerlink" title="2.存储结构:顺序存储、随机存储"></a>2.存储结构:顺序存储、随机存储</h4><p>存储结构是数据元素三大组成要素之一，下图是博主对数据元素三要素所画的思维导图。</p><p><img src="/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxNnlsZzA4,size_16,color_FFFFFF,t_70-20230628181201363.png" alt="思维导图"></p><h4 id="2-1顺序存储"><a href="#2-1顺序存储" class="headerlink" title="2.1顺序存储"></a>2.1顺序存储</h4><ul><li><p><strong>顺序存储是把逻辑上相邻的数据元素存储在物理位置上相邻的存储单元中，数据元素之间的逻辑关系由存储单元的邻接关系来体现。</strong></p></li><li><p>顺序存储的主要优点：</p><ul><li>节省存储空间。因为分配给数据的存储单元全用存放数据元素（不考虑c&#x2F;c++语言中数组需指定大小的情况），数据元素之间的逻辑关系没有占用额外的存储空间。</li><li>可实现对数据元素的随机存取(直接存取)。即每一个数据元素对应一个元素下标，由该元素下标可以直接计算出来数据元素的物理存储地址。</li></ul></li><li><p>顺序存储的主要缺点：</p><ul><li>不便于数据修改。对数据元素的插入、删除运算时，可能要移动一系列的数据元素。</li><li>产生磁盘碎片。因为顺序存储只能使用相邻的一整块存储单元，因此会产生较多的磁盘碎片</li></ul></li></ul><p>顺序存储的典型实例就是编程语言中的<code>数组</code>。例如，使用<a href="https://so.csdn.net/so/search?q=%E9%A1%BA%E5%BA%8F%E8%A1%A8&spm=1001.2101.3001.7020">顺序表</a>存储集合 {1,2,3,4,5}，数据最终的存储状态如下图所示：</p><p><img src="/assets/20191203201006798.png" alt="数组顺序存储"></p><p>数组中的所有元素存储在一个连续性的内存块中，并通过数组的首地址和元素下标来访问。因此一个数组就是由1个数组首地址和N个数组元素构成，数组不需要像链表一样，链表的每个节点必须存储下一个结点的物理地址，在存储同样多的数据下，数组比链表节省空间。</p><p>数组可通过数组的首地址和元素下标来直接存取数组中的没每一个元素，而不需要像链表一样，在存取第N个链表结点的数据时，必须先访问前（N-1）个链表结点。</p><p>但对数组的数据元素的插入、删除运算时，可能要移动一系列的数据元素，特别的麻烦，因此顺序存储结构的数组不便于修改。</p><h4 id="2-2随机存储"><a href="#2-2随机存储" class="headerlink" title="2.2随机存储"></a>2.2随机存储</h4><p><strong>在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。</strong></p><p><strong>它不要求逻辑上相邻的元素在物理位置上也相邻，而是借助指示元素存储地址的指针来表示元素之间的逻辑关系。</strong></p><ul><li><p>顺序存储的主要优点：</p><ul><li><p>不会产生磁盘碎片。因为随机存储不要求逻辑上相邻的元素在物理位置上也相邻，而是借助指示元素存储地址的指针来表示元素之间的逻辑关系，因此不会产生磁盘碎片。</p></li><li><p>数据修改方便。对数据元素的插入、删除运算时，随机存储不必移动结点，只要改变结点中的指针。</p></li></ul></li><li><p>顺序存储的主要缺点：</p><ul><li>占用空间大。随机存储的每个结点都由数据域和指针域组成，所以相同空间内假设全存满，顺序存储比随机存储可存更多数据。</li><li>查找结点时链式存储要比顺序存储慢，且只能实现顺序存取。</li></ul></li></ul><p><strong>2.2.1 随机存储——链式存储</strong></p><p>链式存储是随机存储最典型的代表，因此链式存储的定义、优点和缺点就是2.2随机存储中的定义、优点和缺点。</p><p><strong>2.2.2 随机存储——索引存储</strong><br>除建立存储结点信息外，还建立附加的索引表来标识结点的地址，索引表由若干索引项组成，索引项的一般形式是(关键字，地址)。</p><p>索引存储的主要优点：检索速度快。<br>索引存储的主要缺点：增加了附加的索引表,会占用较多的存储空间。</p><p><strong>2.2.3 随机存储——散列存储</strong><br>散列存储，又称Hash存储，是一种将数据元素的存储位置与关键码之间建立确定对应关系的查找技术，即根据元素的关键字直接计算出该元素的存储地址。</p><ul><li><p>散列存储的主要优点：检索、增加和删除节点的操作更快。</p></li><li><p>散列存储的主要缺点：若散列函数不好，则可能出现元素存储单元的冲突。</p></li><li><p>散列法存储的基本思想是：由节点的关键码值决定节点的存储地址。散列技术除了可以用于查找外，还可以用于存储。</p></li></ul><p>特点：</p><p>散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的，而不像在数组中的遍历过程，采用存储数组中内容的部分元素作为映射函数的输入，映射函数的输出就是存储数据的位置，这样的访问速度就省去了遍历数组的实现，因此时间复杂度可以认为为O(1)，而数组遍历的时间复杂度为O(n)。</p><p><img src="/assets/image-20230628181044838.png" alt="image-20230628181044838"></p><p><img src="/assets/image-20230628181110567.png" alt="image-20230628181110567"></p><p>答案： B</p><p>线性表元素的序号是从1开始，而在第n+1个位置插入，相当于在表尾追加</p><p>长度为n的意思应该是存了n个 不是数组长度为n（呜呜呜呜呜呜）</p><h4 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h4><p><strong>前驱结点是指在链表或树等数据结构中，某个节点的前面一个节点。具体来说：</strong></p><ol><li>在链表中，每个节点通常包含一个数据元素和一个指向下一个节点的指针。前驱结点是指在链表中，某个节点的前一个节点，即指向该节点的指针指向的节点。</li><li>在树的二叉搜索树（Binary Search Tree）中，前驱结点是指中序遍历顺序中，某个节点的前面一个节点。在中序遍历中，节点按照从小到大的顺序进行访问，前驱结点即是在这个顺序中的前一个节点。</li></ol><p>前驱结点的概念主要用于确定节点在某种特定顺序中的前一个节点，可以在某些操作中起到辅助作用。在链表和树等数据结构中，我们可以通过相应的指针或遍历方式来找到节点的前驱结点</p><p><img src="/assets/image-20230628192706921.png" alt="image-20230628192706921"></p><p>答案：D</p><p>​          顺序存储结构同样适用于图和树</p><p><img src="/assets/image-20230628192636888.png" alt="image-20230628192636888"></p><p>答：D</p><p>​       若先建立链表，然后依次插入建立有序表，则每插入一个元素就需要遍历链表寻找插入位置，即直接插入排序，时间复杂度O(N2)</p><p>​       若先讲数组进行排序，然后建立链表，建立链表的时间复杂度是O(N)，数组排序的最好时间复杂度是O(Nlog2N)，总时间复杂度是O(Nlog2N)</p><p><img src="/assets/image-20230628193300102.png" alt="image-20230628193300102"></p><p>答：C</p><p>​需要先遍历找到长度为m的单链表的尾节点，然后将其next域指向另一个单链表的首节点</p><p><img src="/assets/image-20230628193540185.png" alt="image-20230628193540185"></p><p>答：C</p><p>​<strong>设有头指针和尾指针的单链表执行删除最后一个元素的操作与链表长度有 关，因为要进行遍历寻找尾节点前一个节点</strong></p><p>​D选项没有考虑顺序表，数组存放的元素存取与i无关</p><p><img src="/assets/image-20230628200207710.png" alt="image-20230628200207710"></p><p><img src="/assets/image-20230628200146372.png" alt="image-20230628200146372"></p><h3 id="论述题"><a href="#论述题" class="headerlink" title="论述题"></a>论述题</h3><p><img src="/assets/image-20230628122125234.png" alt="image-20230628122125234"></p><h4 id="顺序表-VS-链表"><a href="#顺序表-VS-链表" class="headerlink" title="顺序表 VS 链表"></a>顺序表 VS 链表</h4><h4 id="顺序表动态数组实现-VS-静态数组实现"><a href="#顺序表动态数组实现-VS-静态数组实现" class="headerlink" title="顺序表动态数组实现 VS 静态数组实现"></a>顺序表动态数组实现 VS 静态数组实现</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h1&gt;&lt;h2 id=&quot;做题总结&quot;&gt;&lt;a href=&quot;#做题总结&quot; class=&quot;headerlink&quot; title=&quot;做题总结&quot;&gt;&lt;/a&gt;做题总</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="线性表" scheme="https://sdumoist.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E4%B8%B2/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E4%B8%B2/</id>
    <published>2024-03-26T10:30:39.000Z</published>
    <updated>2024-03-26T12:38:37.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>![image-20230701101054536](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230701101054536.png)</p><p><img src="/./assets/image-20230701125323097.png" alt="image-20230701125323097"></p><p><img src="/./assets/image-20230701132729113.png" alt="image-20230701132729113"></p><p><img src="/./assets/image-20230701141636054.png" alt="image-20230701141636054"></p><p><img src="/./assets/image-20230701143309420.png" alt="![image-20230701155518622](./assets/image-20230701155518622.png)"></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由零个或多个字符组成的有限序列。一般记为S&#x3D;’a1,a2,a3…an’(n&gt;&#x3D; 0)</p><p>其中，S是<strong>串名</strong>，单引号括起来的字符序列是串的值；ai可以是数字、字母或者其他字符；串中字符的个数n称为<strong>串的长度</strong>。n&#x3D;0时的串称为<strong>空串</strong></p><p>例如：S&#x3D;”HelloWorld!”  T&#x3D;’iPhone 11 pro max?’</p><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>串中任意个连续的字符组成的子序列</p><p>例如：‘iPhone’ ‘Pro M’就是串T的子串</p><h4 id="主串"><a href="#主串" class="headerlink" title="主串"></a>主串</h4><p>包含子串的串    </p><p>例如：T是子串’iPhone’的主串</p><h4 id="字符在主串中的位置"><a href="#字符在主串中的位置" class="headerlink" title="字符在主串中的位置"></a>字符在主串中的位置</h4><p>字符在串中的序号</p><p>例如：’1’在T中的位置是8（第一次出现）</p><h4 id="子串在主串中的位置"><a href="#子串在主串中的位置" class="headerlink" title="子串在主串中的位置"></a>子串在主串中的位置</h4><p>子串的第一个字符在主串中的位置</p><p>例如：’11 Pro’在T中的位置是8</p><h4 id="空串-VS-空格串"><a href="#空串-VS-空格串" class="headerlink" title="空串 VS 空格串"></a>空串 VS 空格串</h4><p>M &#x3D; ‘’    M是空串</p><p>N &#x3D; ‘   ‘  N是由三个空格字符组成的空格串，每个空格字符占1B</p><h4 id="串-VS-线性表"><a href="#串-VS-线性表" class="headerlink" title="串 VS 线性表"></a>串 VS 线性表</h4><p>串是一种特殊的线性表，数据元素之间呈线性关系</p><p>![image-20230630224417486](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230630224417486.png)</p><p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符）</p><p>串的基本操作，如增删改查等<strong>通常以子串为操作对象</strong></p><h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><p>![image-20230630225329884](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230630225329884.png)</p><ul><li>StrAssigh(&amp;T,chars):  赋值操作。把串赋值为chars</li><li>StrCopy(&amp;T, S): 复制操作。由串S复制得到串T</li><li>StrEmpty(S): 判空操作。若S为空串，则返回TRUE，否则返回FALSE</li><li>StrLength(S): 求串长。返回串S的元素个数</li><li>ClearString(&amp;S): 清空操作。将S清为空串</li><li>DestroyString(&amp;S): 销毁串。将串S销毁（回收存储空间）</li><li>Concat(&amp;T,S1,S2): 串联接。用T返回由S1和S2连接形成的新串</li><li>SubString(&amp;Sub,S,pos,len): 求子串。用sub返回串S的第pos个字符起长度为len的子串</li><li>Index(S,T): 定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</li><li>StrCompare(S,T):比较操作。若S&gt;T,则返回值&gt;0; 若S&#x3D;T，则返回值&#x3D;0；若S&lt;T,则返回值&lt;0.</li></ul><p>![image-20230630225930754](&#x2F;Users&#x2F;moist&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230630225930754.png)</p><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子串。用sub返回串S的第pos个字符起长度为len的子串</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos + len - <span class="number">1</span> &gt; S.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; pos + len; i ++) Sub.ch[i-pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">    Sub.length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较操作，若S&gt;T,则返回值&gt;0；若S&lt;T,则返回值&lt;0；若S=T，则返回值=0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S.length &amp;&amp; i &lt;= T.length; i ++)</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i]) <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, n = <span class="built_in">StrLength</span>(S), m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">SubString</span>(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(sub,T)!=<span class="number">0</span>) ++i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><p>任何数据存到计算机中一定是二进制数。需要确定一个字符和二进制数的对应规则，这就是编码</p><p>“字符集”：英文字符——ASCII字符集；中英文——Unicode字符集</p><ul><li>基于同一个字符集，可以有多种编码方案，如UTF-8，UTF-16</li><li>采用不同编码方式，每个字符所占空间不同，考研只需默认每个字符占1B即可</li></ul><h3 id="拓展：编码问题"><a href="#拓展：编码问题" class="headerlink" title="拓展：编码问题"></a>拓展：编码问题</h3><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的静态结构定义"><a href="#串的静态结构定义" class="headerlink" title="串的静态结构定义"></a>串的静态结构定义</h3><h4 id="静态数组实现"><a href="#静态数组实现" class="headerlink" title="静态数组实现"></a>静态数组实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串:静态数组实现（定长顺序存储）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLen 255  <span class="comment">//预定义最大串长</span></span></span><br><span class="line"></span><br><span class="line">type <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MaxLen];    <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态数组实现"><a href="#动态数组实现" class="headerlink" title="动态数组实现"></a>动态数组实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串：动态数组实现（堆分配存储）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLen 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MaxLen * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">//用完需要手动free</span></span><br><span class="line">S.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230701105048267.png" alt="image-20230701105048267"></p><ul><li><p>方案一：</p></li><li><p>方案二：ch[0]充当Length，最多0-255 存储256个字符</p></li><li><p>方案三：需要遍历才可以知道长度，经常需要长度不建议这样使用</p></li><li><p><strong>方案四：舍弃第一个位序不用，在末尾加一个length变量</strong></p></li></ul><h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    串的链式存储</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储密度低，每个字符1B，每个指针4B</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StringNode</span>&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">StringNode</span> *String;</span><br><span class="line">&#125;StringNode, *String;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储密度提高</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StringNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StringNode</span> *next;</span><br><span class="line"></span><br><span class="line">&#125;StringNode, *String;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230701114244242.png" alt="image-20230701114244242"></p><p><img src="/./assets/image-20230701114324847.png" alt="image-20230701114324847"></p><blockquote><p>32位操作系统中，指针内存占用4B；4 * 8 &#x3D; 32，指向地址</p><p>64位操作系统中，指针内存占用8B。8 * 8 &#x3D; 64</p></blockquote><h3 id="字符串的模式匹配"><a href="#字符串的模式匹配" class="headerlink" title="字符串的模式匹配"></a>字符串的模式匹配</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>在主串中找到与模式串相同的子串，并且返回其所在位置</p><h4 id="重要术语-1"><a href="#重要术语-1" class="headerlink" title="重要术语"></a>重要术语</h4><ul><li>模式串：不一定能在主串中找到</li><li>子串：主串的一部分，一定存在</li></ul><p><img src="/./assets/image-20230701125652455.png" alt="image-20230701125652455"></p><h4 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h4><ul><li><p>主串长度为n，模式串长度为m</p></li><li><p>朴素模式匹配算法：将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止</p></li><li><p>最多对比n-m+1个子串</p></li></ul><h4 id="使用字符串的基本操作实现"><a href="#使用字符串的基本操作实现" class="headerlink" title="使用字符串的基本操作实现"></a>使用字符串的基本操作实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, n = <span class="built_in">StrLength</span>(S), m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">SubString</span>(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(sub,T)!=<span class="number">0</span>) ++i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用两个指针实现"><a href="#使用两个指针实现" class="headerlink" title="使用两个指针实现"></a>使用两个指针实现</h4><p>当发生失配时，应该令i &#x3D; i - j + 2, j &#x3D; 1</p><p><strong>模式串不动，移动主串</strong></p><p><img src="/./assets/image-20230701131546260.png" alt="image-20230701131546260"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串的朴素模式匹配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i; ++j;   <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i -j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;      <span class="comment">//指针后退重新匹配</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设主串长度为n，模式串长度为m，则最坏时间复杂度&#x3D;O(nm)</p><p><img src="/./assets/image-20230701132709173.png" alt="image-20230701132709173"></p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>有点类似具体问题具体分析</p><p>核心思想是当发生失配的时候，前面的适配的元素都是已知并且跟模式串一致的，所以可以根据失配元素的位置具体枚举分析</p><p>所以可以从最后一个元素匹配失败依次向前进行分析<strong>（主串不动，移动模式串）</strong> </p><p><img src="/./assets/image-20230701134407954.png" alt="image-20230701134407954"></p><p>next数组表明了当发生失配的时候，j的值应该指向多少 </p><p><img src="/./assets/image-20230701135524778.png" alt="image-20230701135524778"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;                <span class="comment">//继续比较后继指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];       <span class="comment">//模式串向右移动</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230701141611134.png" alt="image-20230701141611134"></p><blockquote><p><strong>只需要掌握手动求next[]数组</strong></p></blockquote><h4 id="求模式串next数组的手算练习"><a href="#求模式串next数组的手算练习" class="headerlink" title="求模式串next数组的手算练习"></a>求模式串next数组的手算练习</h4><ul><li>next[1]始终为0；next[2]始终为1</li><li>当i&gt;2，在不匹配的位置前面，划一根分界线，模式串一步一步向前走，直到分界线之前的元素都能对上或者模式串完全跨过分界线为止。此时线后面的j指向哪，next数组就是多少</li></ul><h4 id="求模式串next数组的机算和优化-可运行"><a href="#求模式串next数组的机算和优化-可运行" class="headerlink" title="求模式串next数组的机算和优化(可运行)"></a>求模式串next数组的机算和优化(可运行)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    KMP算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLen 255  <span class="comment">//预定义最大串长</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MaxLen];    <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            next[i]=j;          <span class="comment">//若pi = pj, 则next[j+1]=next[j]+1</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];       <span class="comment">//否则令j=next[j],循环继续</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己写的）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Next_KMP</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = T.length;</span><br><span class="line">    next = (<span class="type">int</span> *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1  &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>, t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; i<span class="number">-1</span>; j ++)&#123;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(T.ch[t] == T.ch[t + j] &amp;&amp; (t &lt; i-j))&#123;</span><br><span class="line">                t ++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(t &gt;= i - j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;t = %d, j = %d\n&quot;, t, j);</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        next[i] = t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Nextval_KMP</span><span class="params">(SString T, <span class="type">int</span> next[], <span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    nextval[<span class="number">1</span>]= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= T.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])</span><br><span class="line">            nextval[j] = nextval[next[j]];</span><br><span class="line">        <span class="keyword">else</span> nextval[j]=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;                <span class="comment">//继续比较后继指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];       <span class="comment">//模式串向右移动</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SString S, T;</span><br><span class="line">    S.ch[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">3</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">4</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">5</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">6</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.length = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> *next, *next1;</span><br><span class="line">    <span class="built_in">get_next</span>(S,next1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Next_KMP</span>(S,next)) <span class="built_in">printf</span>(<span class="string">&quot;Successfully!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习1"><a href="#练习1" class="headerlink" title="练习1:"></a>练习1:</h5><p><img src="/./assets/image-20230701142153257.png" alt="image-20230701142153257"></p><p><img src="/./assets/image-20230701143412813.png" alt="image-20230701143412813"></p><h5 id="练习2"><a href="#练习2" class="headerlink" title="练习2:"></a>练习2:</h5><p><img src="/./assets/image-20230701143043130.png" alt="image-20230701143043130"></p><h4 id="next数组的优化"><a href="#next数组的优化" class="headerlink" title="next数组的优化"></a>next数组的优化</h4><p>根据指向的字符与原本失配的字符是否相等,求nextval[]数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Nextval_KMP</span><span class="params">(SString T, <span class="type">int</span> next[], <span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    nextval[<span class="number">1</span>]= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= T.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])</span><br><span class="line">            nextval[j] = nextval[next[j]];</span><br><span class="line">        <span class="keyword">else</span> nextval[j]=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./assets/image-20230701155518622.png" alt="image-20230701155518622"></p><h5 id="练习一："><a href="#练习一：" class="headerlink" title="练习一："></a>练习一：</h5><p><img src="/./assets/image-20230701160047594.png" alt="image-20230701160047594"></p><h5 id="练习二"><a href="#练习二" class="headerlink" title="练习二:"></a>练习二:</h5><p><img src="/./assets/image-20230701160201715.png" alt="image-20230701160201715"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;串&quot;&gt;&lt;a href=&quot;#串&quot; class=&quot;headerlink&quot; title=&quot;串&quot;&gt;&lt;/a&gt;串&lt;/h1&gt;&lt;h2 id=&quot;做题总结&quot;&gt;&lt;a href=&quot;#做题总结&quot; class=&quot;headerlink&quot; title=&quot;做题总结&quot;&gt;&lt;/a&gt;做题总结&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="字符串" scheme="https://sdumoist.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基本概念</title>
    <link href="https://sdumoist.github.io/2024/03/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://sdumoist.github.io/2024/03/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2024-03-26T10:29:39.000Z</published>
    <updated>2024-03-26T12:40:00.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构基础概念"><a href="#数据结构基础概念" class="headerlink" title="数据结构基础概念"></a>数据结构基础概念</h1><h2 id="一、基本概念和术语"><a href="#一、基本概念和术语" class="headerlink" title="一、基本概念和术语"></a>一、基本概念和术语</h2><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h3><p>数据是描述客观事物的符号，是计算机可以操作的对象，是能被计算机识别，并输入到计算机处理的符号集合。</p><p>（数据不仅仅包括整型、实型等数值型，还有字符、声音、图像、视频等非数值类型）</p><h3 id="2-数据元素"><a href="#2-数据元素" class="headerlink" title="2.数据元素"></a>2.数据元素</h3><p>数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也称为记录（元组、结点、顶点）。</p><h3 id="3-数据项（属性、字段）"><a href="#3-数据项（属性、字段）" class="headerlink" title="3.数据项（属性、字段）"></a>3.数据项（属性、字段）</h3><ul><li>一个数据元素可以由若干个数据项组成。</li><li>数据项是数据不可分割的最小单位。</li></ul><h3 id="4-数据对象"><a href="#4-数据对象" class="headerlink" title="4.数据对象"></a>4.数据对象</h3><p>数据对象是性质相同的数据元素的集合，是数据的子集。</p><h3 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5.数据结构"></a>5.数据结构</h3><ul><li>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，这些关系称为结构。</li><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</li><li><strong>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算</strong>。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</li></ul><h2 id="二、逻辑结构和物理结构（存储结构）"><a href="#二、逻辑结构和物理结构（存储结构）" class="headerlink" title="二、逻辑结构和物理结构（存储结构）"></a>二、逻辑结构和物理结构（存储结构）</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>逻辑结构是指数据对象中数据元素之间相互关系（逻辑关系），即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机存储器的。</p><h4 id="2）分类（线性结构和非线性结构）"><a href="#2）分类（线性结构和非线性结构）" class="headerlink" title="2）分类（线性结构和非线性结构）"></a>2）分类（线性结构和非线性结构）</h4><p>根据数据元素之间关系的不同特征，通常有下列4类基本结构，复杂程度依次递进。</p><p>①集合：结构中的数据元素之间除了同属于一个集合外，没有其他的关系。</p><p>②线性结构：线性结构中的数据元素之间是一对一的关系。</p><p>③树形结构：树形结构中的数据元素之间是一对多的关系。</p><p>④图状结构或网状结构：结构中的元素之间是多对多的关系。</p><h3 id="2-物理结构（存储结构）"><a href="#2-物理结构（存储结构）" class="headerlink" title="2.物理结构（存储结构）"></a>2.物理结构（存储结构）</h3><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li><p>数据的物理结构是指数据的逻辑结构在计算机中的存储方式。又称存储结构。</p></li><li><p>它研究的是<strong>数据结构在计算机中的实现方法，包括数据元素的表示和元素之间的关系。</strong></p></li><li><p>数据元素的存储结构形式主要有两种：顺序存储和链式存储</p></li></ul><h4 id="2）顺序存储和链式存储"><a href="#2）顺序存储和链式存储" class="headerlink" title="2）顺序存储和链式存储"></a>2）顺序存储和链式存储</h4><p>①顺序存储结构</p><p>是利用数据元素在存储器中的相对位置来表示数据元素之间的逻辑顺序。<br>顺序存储结构是把数据元素放在地址连续的存储单元中，程序设计中使用数组类型来实现。（逻辑相邻物理相邻）</p><p>②链式存储结构</p><p>利用结点中指针来表示数据元素之间的关系。<br>把数据元素存储在任意的存储单元里，这组存储单元可以是连续的，也可以是连续的，程序设计中使用指针类型来实现。（逻辑相邻物理不一定相邻）</p><h4 id="3）其他存储方式"><a href="#3）其他存储方式" class="headerlink" title="3）其他存储方式"></a>3）其他存储方式</h4><p>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。</p><p>散列存储：通过关键字直接计算出元素的物理地址。</p><p><a href="https://blog.csdn.net/Jacky_Feng/article/details/108538689">逻辑结构和存储结构</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构基础概念&quot;&gt;&lt;a href=&quot;#数据结构基础概念&quot; class=&quot;headerlink&quot; title=&quot;数据结构基础概念&quot;&gt;&lt;/a&gt;数据结构基础概念&lt;/h1&gt;&lt;h2 id=&quot;一、基本概念和术语&quot;&gt;&lt;a href=&quot;#一、基本概念和术语&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="基本概念" scheme="https://sdumoist.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>2642. 设计可以求最短路径的图类</title>
    <link href="https://sdumoist.github.io/2024/03/26/2642-%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%B1%BB/"/>
    <id>https://sdumoist.github.io/2024/03/26/2642-%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%B1%BB/</id>
    <published>2024-03-26T08:36:39.000Z</published>
    <updated>2024-03-26T11:18:41.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2642-设计可以求最短路径的图类"><a href="#2642-设计可以求最短路径的图类" class="headerlink" title="2642. 设计可以求最短路径的图类"></a>2642. 设计可以求最短路径的图类</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个有 <code>n</code> 个节点的 <strong>有向带权</strong> 图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。图中的初始边用数组 <code>edges</code> 表示，其中 <code>edges[i] = [fromi, toi, edgeCosti]</code> 表示从 <code>fromi</code> 到 <code>toi</code> 有一条代价为 <code>edgeCosti</code> 的边。</p><p>请你实现一个 <code>Graph</code> 类：</p><ul><li><code>Graph(int n, int[][] edges)</code> 初始化图有 <code>n</code> 个节点，并输入初始边。</li><li><code>addEdge(int[] edge)</code> 向边集中添加一条边，其中 <code>edge = [from, to, edgeCost]</code> 。数据保证添加这条边之前对应的两个节点之间没有有向边。</li><li><code>int shortestPath(int node1, int node2)</code> 返回从节点 <code>node1</code> 到 <code>node2</code> 的路径 <strong>最小</strong> 代价。如果路径不存在，返回 <code>-1</code> 。一条路径的代价是路径中所有边代价之和。</li></ul><p><strong>示例 1：</strong></p><p><img src="/../image/leetcode/graph3drawio-2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Graph&quot;, &quot;shortestPath&quot;, &quot;shortestPath&quot;, &quot;addEdge&quot;, &quot;shortestPath&quot;]</span><br><span class="line">[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]</span><br><span class="line">输出：</span><br><span class="line">[null, 6, -1, null, 6]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);</span><br><span class="line">g.shortestPath(3, 2); // 返回 6 。从 3 到 2 的最短路径如第一幅图所示：3 -&gt; 0 -&gt; 1 -&gt; 2 ，总代价为 3 + 2 + 1 = 6 。</span><br><span class="line">g.shortestPath(0, 3); // 返回 -1 。没有从 0 到 3 的路径。</span><br><span class="line">g.addEdge([1, 3, 4]); // 添加一条节点 1 到节点 3 的边，得到第二幅图。</span><br><span class="line">g.shortestPath(0, 3); // 返回 6 。从 0 到 3 的最短路径为 0 -&gt; 1 -&gt; 3 ，总代价为 2 + 4 = 6 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li><li><code>edges[i].length == edge.length == 3</code></li><li><code>0 &lt;= fromi, toi, from, to, node1, node2 &lt;= n - 1</code></li><li><code>1 &lt;= edgeCosti, edgeCost &lt;= 106</code></li><li>图中任何时候都不会有重边和自环。</li><li>调用 <code>addEdge</code> 至多 <code>100</code> 次。</li><li>调用 <code>shortestPath</code> 至多 <code>100</code> 次。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目要求实现 Graph 类，一共有三个类方法，一个构造方法，一个添加边的方法，一个求最短路径的方法。前两个属于简单问题，没有什么难度，重点在于求有向加权图的最短路径的那一个方法。</p><p>之前数据结构课设中，我选择的课设题目便是解决有向加权图的最短路径的求取方法，所以刚好用上了。</p><p>数据结构课设链接：<a href="https://github.com/sdumoist/DataStruct/tree/main/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1">https://github.com/sdumoist/DataStruct/tree/main/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1</a></p><p>有个讲 Floyd 和 Dijkstra 算法不错的文章：<a href="https://blog.csdn.net/weixin_43872728/article/details/100662957">https://blog.csdn.net/weixin_43872728/article/details/100662957</a></p><ul><li>Floyd算法<ul><li><p>算法思想：是一种基于动态规划的多源最短路算法。</p></li><li><p>优点：代码非常容易理解，而且很优美。是一种在具有正或负（但没有负环）加权图中找到最短路径的算法，容易理解，可以算出任意两个节点之间的最短距离，代码编写简单</p></li><li><p>缺点：时间复杂度比较高，不适合计算大量数据    时间复杂度:O(n^3)； </p></li><li><p>代码实现</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">              <span class="keyword">if</span>(minEdges[i][k] != Integer.MAX_VALUE)</span><br><span class="line">                  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                      <span class="keyword">if</span>(minEdges[k][j] != Integer.MAX_VALUE &amp;&amp; </span><br><span class="line">                         minEdges[i][j] &gt; minEdges[i][k] + minEdges[k][j])</span><br><span class="line">                          minEdges[i][j] = minEdges[i][k] + minEdges[k][j];</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Bellman-Ford算法<ul><li>算法思想：Bellman-Ford算法基于动态规划，反复利用已有的边来更新最短距离。核心思想是松弛。如果dist[u]和dist[v]满足dist[v]&lt;&#x3D;dist[u]+map[u][v]，dist[v]就应该被更新为dist[u]+map[u][v]反复地利用上式对dist数组进行松弛，如果没有负权回路的话，应当会在n-1次松弛之后结束。</li><li>时间复杂度O(nm),空间复杂度O(m)</li><li>代码实现</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bellman_ford</span><span class="params">()</span> &#123;</span><br><span class="line">      Arrays.fill(dist, INF);</span><br><span class="line">      dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">          <span class="comment">//备份dist数组</span></span><br><span class="line">          backup = Arrays.copyOf(dist, n + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">              <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> list[j];</span><br><span class="line">              <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> node.x;</span><br><span class="line">              <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> node.y;</span><br><span class="line">              <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> node.z;</span><br><span class="line">              dist[y] = Math.min(dist[y], backup[x] + z);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (dist[n] &gt; INF / <span class="number">2</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(dist[n]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>SPFA算法</p><ul><li><p>算法介绍</p><ul><li>最短路径快速算法（Shortest Path Faster Algorithm (SPFA)），一般认为是队列优化的Bellman-Ford 算法，是一个用于求解有向带权图单源最短路径的算法。</li><li>这一算法被认为在随机的稀疏图上表现出色，并且适用于带有负边权的图对于无向图，可通过将每个无向边视作两条有向边以采用 SPFA 算法。</li><li>SPFA的复杂度大约是O(kE),k是每个点的平均进队次数(一般的，k是一个常数，在稀疏图中小于2)</li><li>其优于狄杰斯特拉算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。</li></ul></li><li><p>算法思想</p><ul><li>用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。</li><li>采取动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。</li><li>这样不断从队列中取出结点来进行松弛操作，直至队列空为止</li></ul></li><li><p>代码实现</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">spfa</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Arrays.fill(dist, INF);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue.offer(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">// 从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[t]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) &#123;<span class="comment">// 当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                    queue.offer(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Dijkstra算法</p><ul><li><p>采用的是贪心算法的策略，时间复杂度（N^2）</p></li><li><p>算法思想</p><ul><li>将所有顶点分为两部分：已知最短路程的顶点集合P和未知最短路程的顶点集合Q。用vis[i]表示，如果vis[i]&#x3D;1则表示这个顶点在集合P中，反之顶点在集合Q中。</li><li>设置源点s到自己的最短路径为0。其余按照实际情况进行设置。</li><li>在集合Q的所有定点中选择一个离源点s最近的顶点加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。</li><li>重复第三步，如果集合Q为空，算法结束。最终dis数组中的值就是源点到所有顶点的最短路径。</li></ul></li><li><p>代码实现</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dijkstra最短路径。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * vs -- 起始顶点(start vertex) 即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> vs)</span> &#123;</span><br><span class="line">    <span class="comment">// flag[i]=true表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取</span></span><br><span class="line">    <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexes.length];</span><br><span class="line">    <span class="comment">// U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)，与 flag配合使用,flag[i] == true 表示U中i顶点已被移除</span></span><br><span class="line">    <span class="type">int</span>[] U = <span class="keyword">new</span> <span class="title class_">int</span>[vertexes.length];</span><br><span class="line">    <span class="comment">// 前驱顶点数组,即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。</span></span><br><span class="line">    <span class="type">int</span>[] prev = <span class="keyword">new</span> <span class="title class_">int</span>[vertexes.length];</span><br><span class="line">    <span class="comment">// S的作用是记录已求出最短路径的顶点</span></span><br><span class="line">    String[] S = <span class="keyword">new</span> <span class="title class_">String</span>[vertexes.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：初始时，S中只有起点vs；U中是除vs之外的顶点，并且U中顶点的路径是&quot;起点vs到该顶点的路径&quot;。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line">        flag[i] = <span class="literal">false</span>; <span class="comment">// 顶点i的最短路径还没获取到。</span></span><br><span class="line">        U[i] = matrix[vs][i]; <span class="comment">// 顶点i与顶点vs的初始距离为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。也就是邻接矩阵vs行的数据。</span></span><br><span class="line"></span><br><span class="line">        prev[i] = <span class="number">0</span>; <span class="comment">// 顶点i的前驱顶点为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将vs从U中“移除”（U与flag配合使用）</span></span><br><span class="line">    flag[vs] = <span class="literal">true</span>;</span><br><span class="line">    U[vs] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将vs顶点加入S</span></span><br><span class="line">    S[<span class="number">0</span>] = vertexes[vs];</span><br><span class="line">    <span class="comment">// 步骤一结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤四：重复步骤二三，直到遍历完所有顶点。</span></span><br><span class="line">    <span class="comment">// 遍历vertexes.length-1次；每次找出一个顶点的最短路径。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 步骤二：从U中找出路径最短的顶点，并将其加入到S中（如果vs顶点到x顶点还有更短的路径的话，那么</span></span><br><span class="line">        <span class="comment">// 必然会有一个y顶点到vs顶点的路径比前者更短且没有加入S中</span></span><br><span class="line">        <span class="comment">// 所以，U中路径最短顶点的路径就是该顶点的最短路径）</span></span><br><span class="line">        <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> MAX_WEIGHT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexes.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="literal">false</span> &amp;&amp; U[j] &lt; min) &#123;</span><br><span class="line">                min = U[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将k放入S中</span></span><br><span class="line">        S[i] = vertexes[k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤二结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤三：更新U中的顶点和顶点对应的路径</span></span><br><span class="line">        <span class="comment">// 标记&quot;顶点k&quot;为已经获取到最短路径（更新U中的顶点，即将k顶点对应的flag标记为true）</span></span><br><span class="line">        flag[k] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修正当前最短路径和前驱顶点（更新U中剩余顶点对应的路径）</span></span><br><span class="line">        <span class="comment">// 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexes.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 以k顶点所在位置连线其他顶点，判断其他顶点经过最短路径顶点k到达vs顶点是否小于目前的最短路径，是，更新入U，不是，不做处理</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (matrix[k][j] == MAX_WEIGHT ? MAX_WEIGHT : (min + matrix[k][j]));</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="literal">false</span> &amp;&amp; (tmp &lt; U[j])) &#123;</span><br><span class="line">                U[j] = tmp;</span><br><span class="line">                <span class="comment">// 更新 j顶点的最短路径前驱顶点为k</span></span><br><span class="line">                prev[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 步骤三结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤四结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;起始顶点：&quot;</span> + vertexes[vs]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;最短路径（&quot;</span> + vertexes[vs] + <span class="string">&quot;,&quot;</span> + vertexes[i] + <span class="string">&quot;):&quot;</span> + U[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            path.add(vertexes[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            j = prev[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path.size() - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(path.get(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(path.get(x) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;顶点放入S中的顺序：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.print(S[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != vertexes.length - <span class="number">1</span>)</span><br><span class="line">            System.out.print(<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ul><li>感觉如果是 <strong>查询最短路径</strong> 比较多的情况下，Floyd会优于Dijkstra</li><li>官方版本的 Floyd 优化了很多</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] minEdges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">change</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="built_in">this</span>.edges[edges[i][<span class="number">0</span>]][edges[i][<span class="number">1</span>]] = edges[i][<span class="number">2</span>];</span><br><span class="line">        change = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span>[] edge)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.edges[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        change = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(change == <span class="literal">true</span>) shortestEdges();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minEdges[node1][node2] != Integer.MAX_VALUE) <span class="keyword">return</span> minEdges[node1][node2];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shortestEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        minEdges = edges;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(minEdges[i][j] == <span class="number">0</span>) minEdges[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span>(i == j) minEdges[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">                <span class="keyword">if</span>(minEdges[i][k] != Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        <span class="keyword">if</span>(minEdges[k][j] != Integer.MAX_VALUE &amp;&amp; minEdges[i][j] &gt; minEdges[i][k] + minEdges[k][j])</span><br><span class="line">                            minEdges[i][j] = minEdges[i][k] + minEdges[k][j];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Graph object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Graph obj = new Graph(n, edges);</span></span><br><span class="line"><span class="comment"> * obj.addEdge(edge);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.shortestPath(node1,node2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>官方题解</strong></p><ul><li>Floyed 版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        dist = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dist[i], Integer.MAX_VALUE);</span><br><span class="line">            dist[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            dist[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] != Integer.MAX_VALUE &amp;&amp; dist[k][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span>[] edge)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>], y = edge[<span class="number">1</span>], cost = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (cost &gt;= dist[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dist.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][x] != Integer.MAX_VALUE &amp;&amp; dist[y][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][x] + cost + dist[y][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dist[node1][node2];</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dijkstra版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt;[] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">            graph[x].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;y, cost&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span>[] edge)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">        graph[x].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;y, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[node1] = <span class="number">0</span>;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, node1&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> arr[<span class="number">0</span>], cur = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == node2) &#123;</span><br><span class="line">                <span class="keyword">return</span> cost;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] nextArr : graph[cur]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> nextArr[<span class="number">0</span>], ncost = nextArr[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (dist[next] &gt; cost + ncost) &#123;</span><br><span class="line">                    dist[next] = cost + ncost;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cost + ncost, next&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solutions/2701377/she-ji-ke-yi-qiu-zui-duan-lu-jing-de-tu-hj8e9/">https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solutions/2701377/she-ji-ke-yi-qiu-zui-duan-lu-jing-de-tu-hj8e9/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2642-设计可以求最短路径的图类&quot;&gt;&lt;a href=&quot;#2642-设计可以求最短路径的图类&quot; class=&quot;headerlink&quot; title=&quot;2642. 设计可以求最短路径的图类&quot;&gt;&lt;/a&gt;2642. 设计可以求最短路径的图类&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://sdumoist.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="困难" scheme="https://sdumoist.github.io/tags/%E5%9B%B0%E9%9A%BE/"/>
    
    <category term="有向图最短路径" scheme="https://sdumoist.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sdumoist.github.io/2024/03/25/hello-world/"/>
    <id>https://sdumoist.github.io/2024/03/25/hello-world/</id>
    <published>2024-03-25T10:50:58.339Z</published>
    <updated>2024-03-26T12:08:18.698Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
