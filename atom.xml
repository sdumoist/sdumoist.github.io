<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moist</title>
  
  
  <link href="https://sdumoist.github.io/atom.xml" rel="self"/>
  
  <link href="https://sdumoist.github.io/"/>
  <updated>2024-03-30T19:23:54.874Z</updated>
  <id>https://sdumoist.github.io/</id>
  
  <author>
    <name>SDUMoist</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2952. 需要添加的硬币的最小数量</title>
    <link href="https://sdumoist.github.io/2024/03/31/2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/"/>
    <id>https://sdumoist.github.io/2024/03/31/2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/</id>
    <published>2024-03-30T17:46:49.000Z</published>
    <updated>2024-03-30T19:23:54.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2952-需要添加的硬币的最小数量"><a href="#2952-需要添加的硬币的最小数量" class="headerlink" title="2952. 需要添加的硬币的最小数量"></a>2952. 需要添加的硬币的最小数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>coins</code>，表示可用的硬币的面值，以及一个整数 <code>target</code> 。</p><p>如果存在某个 <code>coins</code> 的子序列总和为 <code>x</code>，那么整数 <code>x</code> 就是一个 <strong>可取得的金额</strong> 。</p><p>返回需要添加到数组中的 <strong>任意面值</strong> 硬币的 <strong>最小数量</strong> ，使范围 <code>[1, target]</code> 内的每个整数都属于 <strong>可取得的金额</strong> 。</p><p>数组的 <strong>子序列</strong> 是通过删除原始数组的一些（<strong>可能不删除</strong>）元素而形成的新的 <strong>非空</strong> 数组，删除过程不会改变剩余元素的相对位置。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,4,10], target = 19</span><br><span class="line">输出：2</span><br><span class="line">解释：需要添加面值为 2 和 8 的硬币各一枚，得到硬币数组 [1,2,4,8,10] 。</span><br><span class="line">可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,4,10,5,7,19], target = 19</span><br><span class="line">输出：1</span><br><span class="line">解释：只需要添加一枚面值为 2 的硬币，得到硬币数组 [1,2,4,5,7,10,19] 。</span><br><span class="line">可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 1 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,1,1], target = 20</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">需要添加面值为 4 、8 和 16 的硬币各一枚，得到硬币数组 [1,1,1,4,8,16] 。 </span><br><span class="line">可以证明从 1 到 20 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 105</code></li><li><code>1 &lt;= coins.length &lt;= 105</code></li><li><code>1 &lt;= coins[i] &lt;= target</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一眼看上去这道题像是动态规划，从 1 开始到 target，判断是否可以被 coins 中的硬币相加得到，得不到的最小值就是需要加入的硬币值</p><p>但是 emmmm，解决不了，时间和空间复杂度都过于高了一点</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumAddedCoins</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">      <span class="comment">//数组排序，并且写入动态数组中，方便往数组中增加值</span></span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) nums.add(coins[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//进行第一轮求所有组合的和并且将其变为 true</span></span><br><span class="line">        List&lt;Integer&gt; values = combinationSum(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> values.size();</span><br><span class="line">        <span class="type">boolean</span>[] res = <span class="keyword">new</span> <span class="title class_">boolean</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">            <span class="keyword">if</span>(values.get(i) &lt; target)</span><br><span class="line">                res[values.get(i)]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; target+<span class="number">1</span>; i++)&#123;</span><br><span class="line">          <span class="comment">//从 1 开始遍历，当发现 false 的时候进行硬币加入，并且更新组合数</span></span><br><span class="line">            <span class="keyword">if</span>(res[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                res[i] = <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; values.size(); j++) values.add(values.get(j)+i);</span><br><span class="line">                values.add(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; values.size(); j++) </span><br><span class="line">                    <span class="keyword">if</span>(values.get(j) &lt; target)</span><br><span class="line">                        res[values.get(j)]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算 nums 数组中元素的 n(n-1)/2 种组合的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">combinationSum</span><span class="params">(List&lt;Integer&gt; nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(nums, <span class="number">0</span>, <span class="number">0</span>, values);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> start, <span class="type">int</span> sum, List&lt;Integer&gt; values)</span> &#123;</span><br><span class="line">        values.add(sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>, sum + nums.get(i), values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很遗憾，这样内存和时间都会超出限制</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><h4 id="自己做的"><a href="#自己做的" class="headerlink" title="自己做的"></a>自己做的</h4><p>自己没做出来 orz</p><h4 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h4><p><img src="/../image/assets/image-20240331032259583.png" alt="image-20240331032259583"></p><p><img src="/../image/assets/image-20240331032321841.png" alt="image-20240331032321841"></p><p><img src="/../image/assets/image-20240331032333977.png" alt="image-20240331032333977"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumAddedCoins</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> coins.length, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; length &amp;&amp; coins[index] &lt;= x) &#123;</span><br><span class="line">                x += coins[index];</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x *= <span class="number">2</span>;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/submissions/518472998/">https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/submissions/518472998/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2952-需要添加的硬币的最小数量&quot;&gt;&lt;a href=&quot;#2952-需要添加的硬币的最小数量&quot; class=&quot;headerlink&quot; title=&quot;2952. 需要添加的硬币的最小数量&quot;&gt;&lt;/a&gt;2952. 需要添加的硬币的最小数量&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心" scheme="https://sdumoist.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="中等" scheme="https://sdumoist.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="每日一题" scheme="https://sdumoist.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>5. 最长回文子串</title>
    <link href="https://sdumoist.github.io/2024/03/30/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://sdumoist.github.io/2024/03/30/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2024-03-29T17:53:06.000Z</published>
    <updated>2024-03-29T18:08:47.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>一个字符串要想是回文字符串只有两种方式：</p><ul><li>aba 这种类型，即中间一个不相同的，两侧都是相同的</li><li>abba 这种，即中间两个相同，两侧也相同</li></ul><p>所以可以从中间字母入手，开始从 0~len-1 遍历以该字母为中心两种方式的最长回文字符串</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="自己写的"><a href="#自己写的" class="headerlink" title="自己写的"></a>自己写的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> longOfPalindrome(s, i, i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> longOfPalindrome(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1.length();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> s2.length();</span><br><span class="line">            <span class="keyword">if</span>(Math.max(len1, len2) &gt; max)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">                    maxString = s1;</span><br><span class="line">                    max = len1;</span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    maxString = s2;</span><br><span class="line">                    max = len2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxString;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">longOfPalindrome</span><span class="params">(String s, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a &gt;= <span class="number">0</span> &amp;&amp; b &lt; s.length() &amp;&amp; s.charAt(a) == s.charAt(b))&#123;</span><br><span class="line">            a--;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> s.substring(<span class="number">0</span>, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b &gt;= s.length()) <span class="keyword">return</span> s.substring(a+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> s.substring(a+<span class="number">1</span>, b);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h4><p><img src="/../image/assets/image-20240330020120150.png" alt="image-20240330020120150"></p><p><img src="/../image/assets/image-20240330020455476.png" alt="image-20240330020455476"></p><p><img src="/../image/assets/image-20240330020531275.png" alt="image-20240330020531275"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">       <span class="comment">//  ans[i][j]：表示从s[i...j]是否为回文串</span></span><br><span class="line">       <span class="type">boolean</span>[][] ans = <span class="keyword">new</span> <span class="title class_">boolean</span>[length][length];</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  所有自己到自己都是回文串</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">           ans[i][i] = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; L &lt;= length; L++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; length; left++) &#123;</span><br><span class="line">               <span class="comment">//  right - left + 1 = L</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + L - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (right &gt;= length)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//  先判断头尾字符是否相等</span></span><br><span class="line">               <span class="keyword">if</span> (s.charAt(left) != s.charAt(right))&#123;</span><br><span class="line">                   ans[left][right] = <span class="literal">false</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//  如果右边界 - 左边界少于3，那么该字符串为回文字符串</span></span><br><span class="line">                   <span class="comment">//  因为右边界 - 左边界少于3代表着这段字符串长度为2或者3，首尾相同，剩下字符数量为0或者1，不影响</span></span><br><span class="line">                   <span class="keyword">if</span> (right - left &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                       ans[left][right] = <span class="literal">true</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                       ans[left][right] = ans[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//  选择到一个回文串，然后再判断该长度是否大于最大长度，如果是，则赋值，并且记录起始和结束位置</span></span><br><span class="line">               <span class="keyword">if</span> (ans[left][right] &amp;&amp; right -left + <span class="number">1</span> &gt; maxLength)&#123;</span><br><span class="line">                   maxLength = right - left + <span class="number">1</span>;</span><br><span class="line">                   begin = left;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//  分割右边界 = 起始 + 最大长度</span></span><br><span class="line">       <span class="keyword">return</span> s.substring(begin, begin + maxLength);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20240330020549182.png" alt="image-20240330020549182"></p><p><img src="/../image/assets/image-20240330020619288.png" alt="image-20240330020619288"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> expandAroundCenter(s, i, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expandAroundCenter</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20240330020640141.png" alt="image-20240330020640141"></p><p><img src="/../image/assets/image-20240330020653200.png" alt="image-20240330020653200"></p><p><img src="/../image/assets/image-20240330020727350.png" alt="image-20240330020727350"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            t.append(s.charAt(i));</span><br><span class="line">            t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        t.append(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        s = t.toString();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; arm_len = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> -<span class="number">1</span>, j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur_arm_len;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i_sym</span> <span class="operator">=</span> j * <span class="number">2</span> - i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min_arm_len</span> <span class="operator">=</span> Math.min(arm_len.get(i_sym), right - i);</span><br><span class="line">                cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur_arm_len = expand(s, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">            arm_len.add(cur_arm_len);</span><br><span class="line">            <span class="keyword">if</span> (i + cur_arm_len &gt; right) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                right = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur_arm_len * <span class="number">2</span> + <span class="number">1</span> &gt; end - start) &#123;</span><br><span class="line">                start = i - cur_arm_len;</span><br><span class="line">                end = i + cur_arm_len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ans.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expand</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/longest-palindromic-substring/solutions/255195/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">https://leetcode.cn/problems/longest-palindromic-substring/solutions/255195/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;5-最长回文子串&quot;&gt;&lt;a href=&quot;#5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;5. 最长回文子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-palindromic-sub</summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://sdumoist.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="中等" scheme="https://sdumoist.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="字符串" scheme="https://sdumoist.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>2908. 元素和最小的山形三元组 I</title>
    <link href="https://sdumoist.github.io/2024/03/29/2908-%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%BD%A2%E4%B8%89%E5%85%83%E7%BB%84-I/"/>
    <id>https://sdumoist.github.io/2024/03/29/2908-%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E5%B1%B1%E5%BD%A2%E4%B8%89%E5%85%83%E7%BB%84-I/</id>
    <published>2024-03-29T10:31:26.000Z</published>
    <updated>2024-03-29T10:48:01.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2908-元素和最小的山形三元组-I"><a href="#2908-元素和最小的山形三元组-I" class="headerlink" title="2908. 元素和最小的山形三元组 I"></a>2908. 元素和最小的山形三元组 I</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>如果下标三元组 <code>(i, j, k)</code> 满足下述全部条件，则认为它是一个 <strong>山形三元组</strong> ：</p><ul><li><code>i &lt; j &lt; k</code></li><li><code>nums[i] &lt; nums[j]</code> 且 <code>nums[k] &lt; nums[j]</code></li></ul><p>请你找出 <code>nums</code> 中 <strong>元素和最小</strong> 的山形三元组，并返回其 <strong>元素和</strong> 。如果不存在满足条件的三元组，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [8,6,1,5,3]</span><br><span class="line">输出：9</span><br><span class="line">解释：三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为： </span><br><span class="line">- 2 &lt; 3 &lt; 4</span><br><span class="line">- nums[2] &lt; nums[3] 且 nums[4] &lt; nums[3]</span><br><span class="line">这个三元组的元素和等于 nums[2] + nums[3] + nums[4] = 9 。可以证明不存在元素和小于 9 的山形三元组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,8,7,10,2]</span><br><span class="line">输出：13</span><br><span class="line">解释：三元组 (1, 3, 5) 是一个元素和等于 13 的山形三元组，因为： </span><br><span class="line">- 1 &lt; 3 &lt; 5 </span><br><span class="line">- nums[1] &lt; nums[3] 且 nums[5] &lt; nums[3]</span><br><span class="line">这个三元组的元素和等于 nums[1] + nums[3] + nums[5] = 13 。可以证明不存在元素和小于 13 的山形三元组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [6,5,4,3,4,5]</span><br><span class="line">输出：-1</span><br><span class="line">解释：可以证明 nums 中不存在山形三元组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 50</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>开始把这一问题想的过于复杂：最小值是一定要出现的，然后剩下两个要么是都在最小值左边，要么都在右边……</p><p>但是这明显不是简单题的风格</p><p>所以直接暴力循环求最小值</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><h4 id="自己做的"><a href="#自己做的" class="headerlink" title="自己做的"></a>自己做的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">151</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len-<span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len-<span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j+<span class="number">1</span>; k &lt; len; k++)</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] &lt; nums[j] &amp;&amp; nums[j] &gt; nums[k])</span><br><span class="line">                        min = Math.min(min, nums[i] + nums[j] + nums[k]);</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">if</span>(min == <span class="number">151</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a>官方答案</h4><p>我们从左到右遍历，来求出前缀数组中的最小值，用 left[i] 来表示前 i 个数字的最小值。</p><p>然后我们从右到左遍历，用 right来表示当前数字右边的最小值。<br>如果一个数比左右两边最小值大时，说明找到一个山形三元组，并更新当前山形三元组的最小元素和。</p><p>最后我们返回最小元素和即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, res = <span class="number">1000</span>, mn = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left[i] = mn = Math.min(nums[i - <span class="number">1</span>], mn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &lt; nums[i] &amp;&amp; nums[i] &gt; right) &#123;</span><br><span class="line">                res = Math.min(res, left[i] + nums[i] + right);</span><br><span class="line">            &#125;</span><br><span class="line">            right = Math.min(right, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res &lt; <span class="number">1000</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solutions/2708392/yuan-su-he-zui-xiao-de-shan-xing-san-yua-82ab/">https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solutions/2708392/yuan-su-he-zui-xiao-de-shan-xing-san-yua-82ab/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2908-元素和最小的山形三元组-I&quot;&gt;&lt;a href=&quot;#2908-元素和最小的山形三元组-I&quot; class=&quot;headerlink&quot; title=&quot;2908. 元素和最小的山形三元组 I&quot;&gt;&lt;/a&gt;2908. 元素和最小的山形三元组 I&lt;/h2&gt;&lt;h3 id=</summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="简单" scheme="https://sdumoist.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="数组" scheme="https://sdumoist.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="每日一题" scheme="https://sdumoist.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>1997. 访问完所有房间的第一天</title>
    <link href="https://sdumoist.github.io/2024/03/29/1997-%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://sdumoist.github.io/2024/03/29/1997-%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</id>
    <published>2024-03-28T18:27:49.000Z</published>
    <updated>2024-03-28T18:44:00.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1997-访问完所有房间的第一天"><a href="#1997-访问完所有房间的第一天" class="headerlink" title="1997. 访问完所有房间的第一天"></a>1997. 访问完所有房间的第一天</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你需要访问 <code>n</code> 个房间，房间从 <code>0</code> 到 <code>n - 1</code> 编号。同时，每一天都有一个日期编号，从 <code>0</code> 开始，依天数递增。你每天都会访问一个房间。</p><p>最开始的第 <code>0</code> 天，你访问 <code>0</code> 号房间。给你一个长度为 <code>n</code> 且 <strong>下标从 0 开始</strong> 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 <strong>次序</strong> 将根据下面的 <strong>规则</strong> 决定：</p><ul><li>假设某一天，你访问 <code>i</code> 号房间。</li><li>如果算上本次访问，访问 <code>i</code> 号房间的次数为 <strong>奇数</strong> ，那么 <strong>第二天</strong> 需要访问 <code>nextVisit[i]</code> 所指定的房间，其中 <code>0 &lt;= nextVisit[i] &lt;= i</code> 。</li><li>如果算上本次访问，访问 <code>i</code> 号房间的次数为 <strong>偶数</strong> ，那么 <strong>第二天</strong> 需要访问 <code>(i + 1) mod n</code> 号房间。</li></ul><p>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>109 + 7</code> 取余后的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [0,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。</span><br><span class="line">  下一天你需要访问房间的编号是 nextVisit[0] = 0</span><br><span class="line">- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。</span><br><span class="line">  下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1</span><br><span class="line">- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [0,0,2]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。</span><br><span class="line">第 6 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [0,1,2,0]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。</span><br><span class="line">第 6 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nextVisit.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= nextVisit[i] &lt;= i</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很经典的一道动态规划题目，唯一需要的注意的是更新数组时注意求 mod 时会出现负数</p><p>由于规定了<code>0 &lt;= nextVisit[i] &lt;= i</code> 所以每次更新下一个数据只需要</p><ul><li>+2 : 从 res[i] 到 res[i+1] 需要两步</li><li>+res[i] : 需要先到 i 才能到 i+1 (因为只有 <strong>访问 <code>i</code> 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间</strong> 时，才能往后走一步)</li><li>+res[i]-res[nextVisit[i]] : 每次重新走的时候，不需要走 nextVisit[i] 之前的路了</li></ul><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><h4 id="自己答案"><a href="#自己答案" class="headerlink" title="自己答案"></a>自己答案</h4><p>自己一开始的，未考虑负数， 所以出错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstDayBeenInAllRooms</span><span class="params">(<span class="type">int</span>[] nextVisit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nextVisit.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == nextVisit[i]) res[i+<span class="number">1</span>] = res[i]+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                res[i+<span class="number">1</span>] += <span class="number">2</span>*res[i];</span><br><span class="line">                <span class="keyword">if</span>(nextVisit[i] != <span class="number">0</span>) res[i+<span class="number">1</span>] = (res[i+<span class="number">1</span>] - res[nextVisit[i]] + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑负数之后，但是运行很慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstDayBeenInAllRooms</span><span class="params">(<span class="type">int</span>[] nextVisit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nextVisit.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == nextVisit[i]) res[i+<span class="number">1</span>] = res[i]+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                res[i+<span class="number">1</span>] += (<span class="number">2</span>*res[i])%mod;</span><br><span class="line">                res[i+<span class="number">1</span>] = (res[i+<span class="number">1</span>] - res[nextVisit[i]] + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看别人做法之后，进行优化，只需要检验一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstDayBeenInAllRooms</span><span class="params">(<span class="type">int</span>[] nextVisit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nextVisit.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == nextVisit[i]) res[i+<span class="number">1</span>] = res[i]+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i+<span class="number">1</span>] = (<span class="number">2</span> + <span class="number">2</span> * res[i]- res[nextVisit[i]]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(res[i+<span class="number">1</span>] &lt; <span class="number">0</span>) res[i+<span class="number">1</span>] += mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="官方答案"><a href="#官方答案" class="headerlink" title="官方答案"></a>官方答案</h4><p><strong>思路</strong></p><p><img src="/../image/assets/WechatIMG7351.png" alt="思路"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstDayBeenInAllRooms</span><span class="params">(<span class="type">int</span>[] nextVisit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nextVisit.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">//初始化原地待一天 + 访问下一个房间一天</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> nextVisit[i];</span><br><span class="line">            dp[i] = <span class="number">2</span> + dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (to != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = (dp[i] - dp[to - <span class="number">1</span>] + mod) % mod; <span class="comment">//避免负数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp[i] = (dp[i] + dp[i - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">2</span>]; <span class="comment">//题目保证n &gt;= 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solutions/2710218/fang-wen-wan-suo-you-fang-jian-de-di-yi-p7fc2/">https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solutions/2710218/fang-wen-wan-suo-you-fang-jian-de-di-yi-p7fc2/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1997-访问完所有房间的第一天&quot;&gt;&lt;a href=&quot;#1997-访问完所有房间的第一天&quot; class=&quot;headerlink&quot; title=&quot;1997. 访问完所有房间的第一天&quot;&gt;&lt;/a&gt;1997. 访问完所有房间的第一天&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://sdumoist.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="中等" scheme="https://sdumoist.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
    <category term="数组" scheme="https://sdumoist.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <link href="https://sdumoist.github.io/2024/03/26/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://sdumoist.github.io/2024/03/26/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2024-03-26T12:09:11.000Z</published>
    <updated>2024-03-26T12:30:26.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为没有系统的总结过解题的方法，所以一般遇到问题习惯于暴力解题</p><p>很不巧，这个题暴力会直接超时</p><p>最一开始，直接暴力遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, len = prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                max = Math.max(prices[i] - prices[j], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后稍微优化还是不行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length, max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len -<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i -<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; prices[j]) min = prices[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; prices[i]-min) max = prices[i]-min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然想到其实可以只遍历一次，毕竟只有数组右边的减去左边的才是有效的，所以采用双指针，慢指针记录数组最小值，快指针负责遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length, max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fastIndex &lt; len)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> prices[fastIndex] -prices[slowIndex];</span><br><span class="line">            <span class="keyword">if</span>(money &gt; max) max = money;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(money &lt; <span class="number">0</span>) slowIndex = fastIndex;</span><br><span class="line"></span><br><span class="line">            fastIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后查看题解，嗯比我想的还要简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minPrice=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            minPrice=Math.min(minPrice, prices[i]);</span><br><span class="line">            ans=Math.max(ans, prices[i]-minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些补充知识"><a href="#一些补充知识" class="headerlink" title="一些补充知识"></a>一些补充知识</h3><p>一开始想着要不要先排序再查找，但是数组号和值的对应是个问题，补充一下二分查找和排序的知识吧</p><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArraySort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//升序</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">      Arrays.sort(arr1);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> values : arr1) &#123;</span><br><span class="line">            System.out.print(values + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="comment">// 1, 2, 5, 8, 10,</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//部分升序</span></span><br><span class="line">      <span class="comment">//Arrays.sort(int[] a, int fromIndex, int toIndex)</span></span><br><span class="line"><span class="comment">//这种形式是对数组部分排序，也就是对数组a的下标从fromIndex到toIndex-1的元素排序</span></span><br><span class="line">      <span class="comment">//注意：下标为toIndex的元素不参与排序哦！</span></span><br><span class="line">      <span class="type">int</span>[] a = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(a, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i ++) &#123;</span><br><span class="line">        System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="comment">//7 8 9 2 3 4 1 0 6 5</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//降序</span></span><br><span class="line">      <span class="comment">//数组必须是对象数组(Integer)才可以使用上述的逆序排列，原始数组(int)则不能 / 只有泛型数组能传比较器，换句话说必须是Object</span></span><br><span class="line">        Integer[] arr2 = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        Arrays.sort(arr2, Collections.reverseOrder());</span><br><span class="line">      </span><br><span class="line">      Arrays.sort(arr, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="comment">//返回值&gt;0交换</span></span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">       Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">//重写compare方法，最好加注解，不加也没事</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">              <span class="comment">//返回值&gt;0交换</span></span><br><span class="line">                <span class="keyword">return</span> b-a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> values : arr2) &#123;</span><br><span class="line">            System.out.print(values + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="comment">// 10, 8, 5, 2, 1,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数组中查找目标元素的下标。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  被查找的数组（这个必须已经排序的）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> -1 表示该元素不存在，其他表示返回目标元素的下标。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    <span class="comment">// 开始下标。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结束下标.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始元素下标只要在结束元素下标的左边，就有机会继续循环。</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        <span class="comment">// 中间元素下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == dest) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; dest) &#123;</span><br><span class="line">            <span class="comment">// 目标在“中间“的右边。</span></span><br><span class="line">            <span class="comment">// 开始元素下标需要发生变化（开始元素的下标需要重新赋值）。</span></span><br><span class="line">            begin = mid + <span class="number">1</span>; <span class="comment">// 一直增。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// arr[mid] &gt; dest</span></span><br><span class="line">            <span class="comment">// 目标元素在”中间“左边</span></span><br><span class="line">            <span class="comment">// 修改结束元素下标</span></span><br><span class="line">            end = mid - <span class="number">1</span>; <span class="comment">// 一直减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;121. 买卖股票的最佳时机&quot;&gt;&lt;/a&gt;121. 买卖股票的最佳时机&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; c</summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心" scheme="https://sdumoist.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="简单" scheme="https://sdumoist.github.io/tags/%E7%AE%80%E5%8D%95/"/>
    
    <category term="双指针" scheme="https://sdumoist.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>2642. 设计可以求最短路径的图类</title>
    <link href="https://sdumoist.github.io/2024/03/26/2642-%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%B1%BB/"/>
    <id>https://sdumoist.github.io/2024/03/26/2642-%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%B1%BB/</id>
    <published>2024-03-26T08:36:39.000Z</published>
    <updated>2024-03-26T11:18:41.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2642-设计可以求最短路径的图类"><a href="#2642-设计可以求最短路径的图类" class="headerlink" title="2642. 设计可以求最短路径的图类"></a>2642. 设计可以求最短路径的图类</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个有 <code>n</code> 个节点的 <strong>有向带权</strong> 图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。图中的初始边用数组 <code>edges</code> 表示，其中 <code>edges[i] = [fromi, toi, edgeCosti]</code> 表示从 <code>fromi</code> 到 <code>toi</code> 有一条代价为 <code>edgeCosti</code> 的边。</p><p>请你实现一个 <code>Graph</code> 类：</p><ul><li><code>Graph(int n, int[][] edges)</code> 初始化图有 <code>n</code> 个节点，并输入初始边。</li><li><code>addEdge(int[] edge)</code> 向边集中添加一条边，其中 <code>edge = [from, to, edgeCost]</code> 。数据保证添加这条边之前对应的两个节点之间没有有向边。</li><li><code>int shortestPath(int node1, int node2)</code> 返回从节点 <code>node1</code> 到 <code>node2</code> 的路径 <strong>最小</strong> 代价。如果路径不存在，返回 <code>-1</code> 。一条路径的代价是路径中所有边代价之和。</li></ul><p><strong>示例 1：</strong></p><p><img src="/../image/leetcode/graph3drawio-2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Graph&quot;, &quot;shortestPath&quot;, &quot;shortestPath&quot;, &quot;addEdge&quot;, &quot;shortestPath&quot;]</span><br><span class="line">[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]</span><br><span class="line">输出：</span><br><span class="line">[null, 6, -1, null, 6]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);</span><br><span class="line">g.shortestPath(3, 2); // 返回 6 。从 3 到 2 的最短路径如第一幅图所示：3 -&gt; 0 -&gt; 1 -&gt; 2 ，总代价为 3 + 2 + 1 = 6 。</span><br><span class="line">g.shortestPath(0, 3); // 返回 -1 。没有从 0 到 3 的路径。</span><br><span class="line">g.addEdge([1, 3, 4]); // 添加一条节点 1 到节点 3 的边，得到第二幅图。</span><br><span class="line">g.shortestPath(0, 3); // 返回 6 。从 0 到 3 的最短路径为 0 -&gt; 1 -&gt; 3 ，总代价为 2 + 4 = 6 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li><li><code>edges[i].length == edge.length == 3</code></li><li><code>0 &lt;= fromi, toi, from, to, node1, node2 &lt;= n - 1</code></li><li><code>1 &lt;= edgeCosti, edgeCost &lt;= 106</code></li><li>图中任何时候都不会有重边和自环。</li><li>调用 <code>addEdge</code> 至多 <code>100</code> 次。</li><li>调用 <code>shortestPath</code> 至多 <code>100</code> 次。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目要求实现 Graph 类，一共有三个类方法，一个构造方法，一个添加边的方法，一个求最短路径的方法。前两个属于简单问题，没有什么难度，重点在于求有向加权图的最短路径的那一个方法。</p><p>之前数据结构课设中，我选择的课设题目便是解决有向加权图的最短路径的求取方法，所以刚好用上了。</p><p>数据结构课设链接：<a href="https://github.com/sdumoist/DataStruct/tree/main/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1">https://github.com/sdumoist/DataStruct/tree/main/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1</a></p><p>有个讲 Floyd 和 Dijkstra 算法不错的文章：<a href="https://blog.csdn.net/weixin_43872728/article/details/100662957">https://blog.csdn.net/weixin_43872728/article/details/100662957</a></p><ul><li>Floyd算法<ul><li><p>算法思想：是一种基于动态规划的多源最短路算法。</p></li><li><p>优点：代码非常容易理解，而且很优美。是一种在具有正或负（但没有负环）加权图中找到最短路径的算法，容易理解，可以算出任意两个节点之间的最短距离，代码编写简单</p></li><li><p>缺点：时间复杂度比较高，不适合计算大量数据    时间复杂度:O(n^3)； </p></li><li><p>代码实现</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">              <span class="keyword">if</span>(minEdges[i][k] != Integer.MAX_VALUE)</span><br><span class="line">                  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                      <span class="keyword">if</span>(minEdges[k][j] != Integer.MAX_VALUE &amp;&amp; </span><br><span class="line">                         minEdges[i][j] &gt; minEdges[i][k] + minEdges[k][j])</span><br><span class="line">                          minEdges[i][j] = minEdges[i][k] + minEdges[k][j];</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Bellman-Ford算法<ul><li>算法思想：Bellman-Ford算法基于动态规划，反复利用已有的边来更新最短距离。核心思想是松弛。如果dist[u]和dist[v]满足dist[v]&lt;&#x3D;dist[u]+map[u][v]，dist[v]就应该被更新为dist[u]+map[u][v]反复地利用上式对dist数组进行松弛，如果没有负权回路的话，应当会在n-1次松弛之后结束。</li><li>时间复杂度O(nm),空间复杂度O(m)</li><li>代码实现</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bellman_ford</span><span class="params">()</span> &#123;</span><br><span class="line">      Arrays.fill(dist, INF);</span><br><span class="line">      dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">          <span class="comment">//备份dist数组</span></span><br><span class="line">          backup = Arrays.copyOf(dist, n + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">              <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> list[j];</span><br><span class="line">              <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> node.x;</span><br><span class="line">              <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> node.y;</span><br><span class="line">              <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> node.z;</span><br><span class="line">              dist[y] = Math.min(dist[y], backup[x] + z);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (dist[n] &gt; INF / <span class="number">2</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(dist[n]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>SPFA算法</p><ul><li><p>算法介绍</p><ul><li>最短路径快速算法（Shortest Path Faster Algorithm (SPFA)），一般认为是队列优化的Bellman-Ford 算法，是一个用于求解有向带权图单源最短路径的算法。</li><li>这一算法被认为在随机的稀疏图上表现出色，并且适用于带有负边权的图对于无向图，可通过将每个无向边视作两条有向边以采用 SPFA 算法。</li><li>SPFA的复杂度大约是O(kE),k是每个点的平均进队次数(一般的，k是一个常数，在稀疏图中小于2)</li><li>其优于狄杰斯特拉算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达 O(VE)。</li></ul></li><li><p>算法思想</p><ul><li>用数组dis记录每个结点的最短路径估计值，用邻接表或邻接矩阵来存储图G。</li><li>采取动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。</li><li>这样不断从队列中取出结点来进行松弛操作，直至队列空为止</li></ul></li><li><p>代码实现</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">spfa</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Arrays.fill(dist, INF);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue.offer(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">// 从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[t]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) &#123;<span class="comment">// 当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                    queue.offer(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Dijkstra算法</p><ul><li><p>采用的是贪心算法的策略，时间复杂度（N^2）</p></li><li><p>算法思想</p><ul><li>将所有顶点分为两部分：已知最短路程的顶点集合P和未知最短路程的顶点集合Q。用vis[i]表示，如果vis[i]&#x3D;1则表示这个顶点在集合P中，反之顶点在集合Q中。</li><li>设置源点s到自己的最短路径为0。其余按照实际情况进行设置。</li><li>在集合Q的所有定点中选择一个离源点s最近的顶点加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。</li><li>重复第三步，如果集合Q为空，算法结束。最终dis数组中的值就是源点到所有顶点的最短路径。</li></ul></li><li><p>代码实现</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dijkstra最短路径。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * vs -- 起始顶点(start vertex) 即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> vs)</span> &#123;</span><br><span class="line">    <span class="comment">// flag[i]=true表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取</span></span><br><span class="line">    <span class="type">boolean</span>[] flag = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexes.length];</span><br><span class="line">    <span class="comment">// U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)，与 flag配合使用,flag[i] == true 表示U中i顶点已被移除</span></span><br><span class="line">    <span class="type">int</span>[] U = <span class="keyword">new</span> <span class="title class_">int</span>[vertexes.length];</span><br><span class="line">    <span class="comment">// 前驱顶点数组,即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。</span></span><br><span class="line">    <span class="type">int</span>[] prev = <span class="keyword">new</span> <span class="title class_">int</span>[vertexes.length];</span><br><span class="line">    <span class="comment">// S的作用是记录已求出最短路径的顶点</span></span><br><span class="line">    String[] S = <span class="keyword">new</span> <span class="title class_">String</span>[vertexes.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：初始时，S中只有起点vs；U中是除vs之外的顶点，并且U中顶点的路径是&quot;起点vs到该顶点的路径&quot;。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line">        flag[i] = <span class="literal">false</span>; <span class="comment">// 顶点i的最短路径还没获取到。</span></span><br><span class="line">        U[i] = matrix[vs][i]; <span class="comment">// 顶点i与顶点vs的初始距离为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。也就是邻接矩阵vs行的数据。</span></span><br><span class="line"></span><br><span class="line">        prev[i] = <span class="number">0</span>; <span class="comment">// 顶点i的前驱顶点为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将vs从U中“移除”（U与flag配合使用）</span></span><br><span class="line">    flag[vs] = <span class="literal">true</span>;</span><br><span class="line">    U[vs] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将vs顶点加入S</span></span><br><span class="line">    S[<span class="number">0</span>] = vertexes[vs];</span><br><span class="line">    <span class="comment">// 步骤一结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤四：重复步骤二三，直到遍历完所有顶点。</span></span><br><span class="line">    <span class="comment">// 遍历vertexes.length-1次；每次找出一个顶点的最短路径。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 步骤二：从U中找出路径最短的顶点，并将其加入到S中（如果vs顶点到x顶点还有更短的路径的话，那么</span></span><br><span class="line">        <span class="comment">// 必然会有一个y顶点到vs顶点的路径比前者更短且没有加入S中</span></span><br><span class="line">        <span class="comment">// 所以，U中路径最短顶点的路径就是该顶点的最短路径）</span></span><br><span class="line">        <span class="comment">// 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> MAX_WEIGHT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexes.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="literal">false</span> &amp;&amp; U[j] &lt; min) &#123;</span><br><span class="line">                min = U[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将k放入S中</span></span><br><span class="line">        S[i] = vertexes[k];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤二结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤三：更新U中的顶点和顶点对应的路径</span></span><br><span class="line">        <span class="comment">// 标记&quot;顶点k&quot;为已经获取到最短路径（更新U中的顶点，即将k顶点对应的flag标记为true）</span></span><br><span class="line">        flag[k] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修正当前最短路径和前驱顶点（更新U中剩余顶点对应的路径）</span></span><br><span class="line">        <span class="comment">// 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexes.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 以k顶点所在位置连线其他顶点，判断其他顶点经过最短路径顶点k到达vs顶点是否小于目前的最短路径，是，更新入U，不是，不做处理</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> (matrix[k][j] == MAX_WEIGHT ? MAX_WEIGHT : (min + matrix[k][j]));</span><br><span class="line">            <span class="keyword">if</span> (flag[j] == <span class="literal">false</span> &amp;&amp; (tmp &lt; U[j])) &#123;</span><br><span class="line">                U[j] = tmp;</span><br><span class="line">                <span class="comment">// 更新 j顶点的最短路径前驱顶点为k</span></span><br><span class="line">                prev[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 步骤三结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤四结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印dijkstra最短路径的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;起始顶点：&quot;</span> + vertexes[vs]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;最短路径（&quot;</span> + vertexes[vs] + <span class="string">&quot;,&quot;</span> + vertexes[i] + <span class="string">&quot;):&quot;</span> + U[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            path.add(vertexes[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            j = prev[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> path.size() - <span class="number">1</span>; x &gt;= <span class="number">0</span>; x--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(path.get(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(path.get(x) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;顶点放入S中的顺序：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexes.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.print(S[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != vertexes.length - <span class="number">1</span>)</span><br><span class="line">            System.out.print(<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><ul><li>感觉如果是 <strong>查询最短路径</strong> 比较多的情况下，Floyd会优于Dijkstra</li><li>官方版本的 Floyd 优化了很多</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] minEdges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">change</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="built_in">this</span>.edges[edges[i][<span class="number">0</span>]][edges[i][<span class="number">1</span>]] = edges[i][<span class="number">2</span>];</span><br><span class="line">        change = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span>[] edge)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.edges[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        change = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(change == <span class="literal">true</span>) shortestEdges();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minEdges[node1][node2] != Integer.MAX_VALUE) <span class="keyword">return</span> minEdges[node1][node2];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shortestEdges</span><span class="params">()</span>&#123;</span><br><span class="line">        minEdges = edges;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(minEdges[i][j] == <span class="number">0</span>) minEdges[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span>(i == j) minEdges[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">                <span class="keyword">if</span>(minEdges[i][k] != Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        <span class="keyword">if</span>(minEdges[k][j] != Integer.MAX_VALUE &amp;&amp; minEdges[i][j] &gt; minEdges[i][k] + minEdges[k][j])</span><br><span class="line">                            minEdges[i][j] = minEdges[i][k] + minEdges[k][j];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Graph object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Graph obj = new Graph(n, edges);</span></span><br><span class="line"><span class="comment"> * obj.addEdge(edge);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.shortestPath(node1,node2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>官方题解</strong></p><ul><li>Floyed 版</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        dist = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dist[i], Integer.MAX_VALUE);</span><br><span class="line">            dist[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            dist[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] != Integer.MAX_VALUE &amp;&amp; dist[k][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span>[] edge)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>], y = edge[<span class="number">1</span>], cost = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (cost &gt;= dist[x][y]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dist.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][x] != Integer.MAX_VALUE &amp;&amp; dist[y][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][x] + cost + dist[y][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dist[node1][node2];</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dijkstra版本</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt;[] graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        graph = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">            graph[x].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;y, cost&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span>[] edge)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">        graph[x].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;y, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[node1] = <span class="number">0</span>;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, node1&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> arr[<span class="number">0</span>], cur = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur == node2) &#123;</span><br><span class="line">                <span class="keyword">return</span> cost;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] nextArr : graph[cur]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> nextArr[<span class="number">0</span>], ncost = nextArr[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (dist[next] &gt; cost + ncost) &#123;</span><br><span class="line">                    dist[next] = cost + ncost;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;cost + ncost, next&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solutions/2701377/she-ji-ke-yi-qiu-zui-duan-lu-jing-de-tu-hj8e9/">https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solutions/2701377/she-ji-ke-yi-qiu-zui-duan-lu-jing-de-tu-hj8e9/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2642-设计可以求最短路径的图类&quot;&gt;&lt;a href=&quot;#2642-设计可以求最短路径的图类&quot; class=&quot;headerlink&quot; title=&quot;2642. 设计可以求最短路径的图类&quot;&gt;&lt;/a&gt;2642. 设计可以求最短路径的图类&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://sdumoist.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="每日一题" scheme="https://sdumoist.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="困难" scheme="https://sdumoist.github.io/tags/%E5%9B%B0%E9%9A%BE/"/>
    
    <category term="有向图最短路径" scheme="https://sdumoist.github.io/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sdumoist.github.io/2024/03/25/hello-world/"/>
    <id>https://sdumoist.github.io/2024/03/25/hello-world/</id>
    <published>2024-03-25T10:50:58.339Z</published>
    <updated>2024-03-26T12:08:18.698Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>输入输出 I/O 管理</title>
    <link href="https://sdumoist.github.io/2023/08/07/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%20IO%20%E7%AE%A1%E7%90%86/"/>
    <id>https://sdumoist.github.io/2023/08/07/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%20IO%20%E7%AE%A1%E7%90%86/</id>
    <published>2023-08-07T05:56:57.467Z</published>
    <updated>2024-03-30T19:31:52.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入输出-I-O-管理"><a href="#输入输出-I-O-管理" class="headerlink" title="输入输出 I&#x2F;O 管理"></a>输入输出 I&#x2F;O 管理</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230807135701484.png" alt="image-20230807135701484"></p><p><img src="/../image/assets/image-20230807150425263.png" alt="image-20230807150425263"></p><p><img src="/../image/assets/image-20230807161922196.png" alt="image-20230807161922196"></p><p><img src="/../image/assets/image-20230807195420647.png" alt="image-20230807195420647"></p><p><img src="/../image/assets/image-20230807210104325.png" alt="image-20230807210104325"></p><p><img src="/../image/assets/image-20230807220713940.png" alt="image-20230807220713940"></p><p><img src="/../image/assets/image-20230808221356475.png" alt="image-20230808221356475"></p><h2 id="I-O设备的基本概念和分类"><a href="#I-O设备的基本概念和分类" class="headerlink" title="I&#x2F;O设备的基本概念和分类"></a>I&#x2F;O设备的基本概念和分类</h2><p><img src="/../image/assets/image-20230807125642802.png" alt="image-20230807125642802"></p><h3 id="什么是-I-O-设备？"><a href="#什么是-I-O-设备？" class="headerlink" title="什么是 I&#x2F;O 设备？"></a>什么是 I&#x2F;O 设备？</h3><p><img src="/../image/assets/image-20230807134849171.png" alt="image-20230807134849171"><br><img src="/../image/assets/image-20230807135015086.png" alt="image-20230807135015086"></p><ul><li>I&#x2F;O 设备<ul><li>输入&#x2F;输出</li><li>I&#x2F;O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备</li><li>属于计算机中的硬件部件</li></ul></li><li>Unix 系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作<ul><li>write 操作<ul><li>向外部设备写出数据</li></ul></li><li>read 操作<ul><li>从外部设备读入数据</li></ul></li></ul></li><li>设备<ul><li>鼠标、键盘——典型的输入型设备</li><li>显示器——输出型设备</li><li>移动硬盘——可输入可输出型设备</li></ul></li></ul><h3 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h3><p><img src="/../image/assets/image-20230807135054110.png" alt="image-20230807135054110"></p><ul><li>按使用特性分类<ul><li>人机交互类设备——鼠标、键盘、打印机<ul><li>数据传输速度慢</li></ul></li><li>存储设备——移动硬盘、光盘<ul><li>数据传输速度快</li></ul></li><li>网络通信设备——调制解调器<ul><li>数据传输速度介于上述二者之间</li></ul></li></ul></li></ul><h3 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h3><p><img src="/../image/assets/image-20230807135253380.png" alt="image-20230807135253380"></p><ul><li>按传输速率分类<ul><li>低速设备——鼠标、键盘<ul><li>传输速率为每秒几个到几百字节</li></ul></li><li>中速设备——激光打印机<ul><li>传输速率为每秒数千至上万个字节</li></ul></li><li>告诉设备——磁盘<ul><li>每秒数千字节至千兆字节</li></ul></li></ul></li></ul><h3 id="按信息交换的单位分类"><a href="#按信息交换的单位分类" class="headerlink" title="按信息交换的单位分类"></a>按信息交换的单位分类</h3><p><img src="/../image/assets/image-20230807135447368.png" alt="image-20230807135447368"></p><ul><li>按信息交换的单位分类<ul><li>块设备——磁盘<ul><li>数据传输的基本单位是“块”</li><li>传输速率较高，可寻址，即对它可以随机的读&#x2F;写任一块</li></ul></li><li>字符设备——鼠标、键盘<ul><li>数据传输的基本单位是字符</li><li>传输速率较慢，不可寻址，在输入&#x2F;输出时常采用中断驱动方式</li></ul></li></ul></li></ul><h2 id="I-O-控制器"><a href="#I-O-控制器" class="headerlink" title="I&#x2F;O 控制器"></a>I&#x2F;O 控制器</h2><p><img src="/../image/assets/image-20230807135814437.png" alt="image-20230807135814437"></p><h3 id="机械部件"><a href="#机械部件" class="headerlink" title="机械部件"></a>机械部件</h3><p><img src="/../image/assets/image-20230807135849181.png" alt="image-20230807135849181"></p><ul><li>I&#x2F;O 设备的机械部件主要用来执行具体 I&#x2F;O操作<ul><li>如我们看得见摸得着的鼠标&#x2F;键盘的按钮；显示器的 LED 屏；移动硬盘的磁臂、磁盘盘面</li></ul></li></ul><h3 id="电子部件（I-O控制器、设备控制器）"><a href="#电子部件（I-O控制器、设备控制器）" class="headerlink" title="电子部件（I&#x2F;O控制器、设备控制器）"></a>电子部件（I&#x2F;O控制器、设备控制器）</h3><ul><li><strong>I&#x2F;O 设备的电子部件通常是一块插入主板扩充槽的印刷电路</strong></li></ul><p><img src="/../image/assets/image-20230807140106370.png" alt="image-20230807140106370"></p><ul><li>电子部件（I&#x2F;O控制器）<ul><li>CPU 无法直接控制 I&#x2F;O 设备的机械部件，因此 I&#x2F;O 设备还要有一个电子部件作为 CPU 和 I&#x2F;O 设备机械部件之间的“中介”，用于实现 CPU 对设备的控制</li><li>这个电子部件就是 I&#x2F;O控制器，又称设备控制器<ul><li>CPU 可以控制 I&#x2F;O控制器，又由 I&#x2F;O控制器来控制设备的机械部件</li></ul></li><li>I&#x2F;O控制器的功能<ul><li>接收和识别CPU 发出的命令<ul><li>如 CPU 发来的 read&#x2F;write命令，I&#x2F;O控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数</li></ul></li><li>向 CPU 报告设备的状态<ul><li>I&#x2F;O控制器中会有相应的<strong>状态寄存器</strong>，用于记录 I&#x2F;O设备的当前状态<ul><li>1 表示空闲，0 表示忙碌</li></ul></li></ul></li><li>数据交换<ul><li>I&#x2F;O控制器中会设置相应的<strong>数据寄存器</strong></li><li>输出时，数据寄存器用于暂存 CPU 发来的数据，之后再由控制器传送设备</li><li>输入时，数据寄存器用于暂存设备发来的数据，之后 CPU 从数据寄存器中取走数据</li></ul></li><li>地址识别<ul><li>类似于内存的地址。为了区分设备控制器中的各个寄存器，也许要给各个寄存器设置一个特定的“地址”</li><li>I&#x2F;O控制器通过 CPU 提供的“地址”来判断 CPU 要读写的是哪个寄存器</li></ul></li></ul></li></ul></li></ul><h3 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I&#x2F;O控制器的组成"></a>I&#x2F;O控制器的组成</h3><p><img src="/../image/assets/image-20230807141417433.png" alt="image-20230807141417433"></p><ul><li><ul><li><p>I&#x2F;O 逻辑</p><ul><li><p>负责接收和识别 CPU 的各种命令</p><ul><li>如地址译码</li></ul><p>负责对设备发出命令</p></li></ul></li><li><p>CPU 与控制器的接口</p><ul><li>用于实现 CPU 与控制器之间的通信</li><li>CPU 通过控制线发出命令</li><li>通过地址线指明要操作的设备</li><li>通过数据线来取出（输入）数据，或放入（输出）数据</li></ul></li><li><p>控制器与设备的接口 </p><ul><li>用于实现控制器与设备之间的通信</li><li>数据线<ul><li>传送输入&#x2F;输出的数据</li></ul></li><li>状态线<ul><li>设备要反馈状态（忙碌&#x2F;空闲）</li></ul></li><li>控制线<ul><li>控制器向设备发出控制信号</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807150012038.png" alt="image-20230807150012038"></p><ul><li>注意<ul><li>一个 I&#x2F;O控制器可能会对应多个设备</li><li>数据寄存器、控制寄存器、控制寄存器可能会有多个，且这些寄存器都要有相应的地址，才能方便 CPU 操作<ul><li>每个控制&#x2F;状态寄存器对应一个具体的设备</li></ul></li><li>有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像；另一些计算机则采用 I&#x2F;O专用地址，即寄存器独立编址</li></ul></li></ul><h4 id="内存映像-I-O-VS-寄存器独立编址"><a href="#内存映像-I-O-VS-寄存器独立编址" class="headerlink" title="内存映像 I&#x2F;O VS 寄存器独立编址"></a>内存映像 I&#x2F;O VS 寄存器独立编址</h4><p><img src="/../image/assets/image-20230807150059752.png" alt="image-20230807150059752"></p><ul><li>内存映像 I&#x2F;O<ul><li>控制器中的寄存器与内存地址统一编址</li><li>优点<ul><li>简化了指令。可以采用对内存进行操作的指令来对控制器进行操作</li></ul></li></ul></li><li>寄存器独立编址<ul><li>控制器中的寄存器使用单独的地址</li><li>缺点<ul><li>需要设置专门的指令来实现对控制器的操作</li><li>不仅要指明寄存器的地址，还要指明控制器的编号</li></ul></li></ul></li></ul><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><p><img src="/../image/assets/image-20230807151047826.png" alt="image-20230807151047826"></p><ul><li>I&#x2F;O 控制方式<ul><li>即用什么样的方式来控制 I&#x2F;O 设备的数据读&#x2F;写</li><li>需要注意的问题<ul><li>完成一次读&#x2F;写的流程</li><li>CPU 干预的频率</li><li>数据传送的单位</li><li>数据的流向</li><li>主要缺点和主要优点</li></ul></li></ul></li></ul><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><ul><li>自己理解<ul><li>CPU 很专一，给 I&#x2F;O控制器发出命令之后，就一直询问他：好了吗，好了吗，好了吗；直到 I&#x2F;O控制器告诉他好了好了，终于好了</li></ul></li></ul><p><img src="/../image/assets/image-20230807151534548.png" alt="image-20230807151534548"></p><ul><li>key word：轮询<ul><li>完成一次读&#x2F;写操作的流程（以读操作为例）</li><li>流程<ul><li>CPU 向控制器发出读指令，于是设备启动，并且状态寄存器设为 1（未就绪）</li><li>轮询检查控制器状态<ul><li>其实就是在不断地执行程序的循环，若状态位一直是 1，说明设备还没准备好要输入的数据，于是 CPU 会不断地轮询</li></ul></li><li>输入设备准备好数据后将数据传给控制器，并报告自身状态</li><li>控制器将输入的数据放到数据寄存器中，并将状态改为 0（已就绪）</li><li>CPU 发现设备已就绪，即可将数据寄存器中的内容读入 CPU 的寄存器，再把 CPU 寄存器中的内容放入内存</li><li>若还要继续读入数据，则 CPU 继续发出读指令</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807152125708.png" alt="image-20230807152125708"></p><ul><li>程序直接控制方式<ul><li>流程<ul><li>CPU—&gt;I&#x2F;O<ul><li>给 I&#x2F;O 模块发出读指令</li><li>CPU 向控制器发出命令</li></ul></li><li>I&#x2F;O —&gt; CPU<ul><li>读 I&#x2F;O模块的状态</li><li>将 I&#x2F;O状态信息读入 CPU 寄存器</li></ul></li><li>检查错误条件<ul><li>检查状态</li><li>设备可能会出现错误</li></ul></li><li>I&#x2F;O —&gt; CPU<ul><li>从I&#x2F;O模块中读取字</li><li>将数据寄存器中的内容读入 CPU 寄存器</li></ul></li><li>CPU —&gt; 存储器<ul><li>往存储器中写入字</li><li>将 CPU 寄存器中的内容写到内存中</li></ul></li><li>检查是否继续</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807152608743.png" alt="image-20230807152608743"></p><ul><li>程序直接控制方式<ul><li>完成一次读&#x2F;写操作的流程</li><li>CPU 干预的频率<ul><li>很频繁，I&#x2F;O 操作开始之前、完成之后需要 CPU 介入，并且<strong>在等待 I&#x2F;O完成的过程中需要不断地轮询检查</strong></li></ul></li><li>数据传送的单位<ul><li><strong>每次读&#x2F;写一个字</strong></li></ul></li><li>数据的流向<ul><li>读操作（数据输入）<ul><li>I&#x2F;O 设备—&gt; CPU —&gt;内存</li></ul></li><li>写操作（数据输出）<ul><li>内存—&gt;CPU—&gt;I&#x2F;O设备</li></ul></li><li>每个字的读&#x2F;写都需要 CPU的帮助</li></ul></li><li>主要优点<ul><li>实现简单</li><li>在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）</li></ul></li><li>主要缺点<ul><li><strong>CPU 和 I&#x2F;O 设备只能串行工作，CPU 需要一直轮询检查，长期处于“忙等”状态，CPU 利用率低</strong></li></ul></li></ul></li></ul><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><ul><li>自己理解<ul><li>CPU 布置任务，输入一个字之后再来叫我，我先去做其他事</li></ul></li></ul><p><img src="/../image/assets/image-20230807153138382.png" alt="image-20230807153138382"></p><ul><li>中断驱动方式<ul><li>实现<ul><li>引入中断机制</li><li>由于 I&#x2F;O 设备速度很慢，因此在 CPU 发出读&#x2F;写命令后，可<strong>将等待 I&#x2F;O 的进程阻塞</strong>，先切换到别的进程（B）执行</li><li>当 I&#x2F;O 完成后，控制器会向 CPU 发出一个中断信号，<strong>CPU 监测到中断信号后，</strong>会保存当前进程（B）的运行环境信息，转去执行中断处理程序处理该中断</li><li>处理中断的过程中，CPU 从 I&#x2F;O 控制器读一个字的数据传送到 CPU 寄存器，再写入主存</li><li><strong>CPU 恢复等待 I&#x2F;O 的进程（或其他进程）的运行环境，然后继续执行</strong></li></ul></li><li>流程<ul><li>CPU—&gt;I&#x2F;O<ul><li>给 I&#x2F;O 模块发出读指令</li><li>CPU 向控制器发出命令</li><li><strong>然后 CPU 将该进程阻塞，去做其他事情</strong></li></ul></li><li>I&#x2F;O —&gt; CPU<ul><li>I&#x2F;O 完成后，控制器会向 CPU 发出一个中断信号，CPU 检测到中断信号后，会保存当前进程的运行环境信息，执行中断处理程序处理该中断</li><li>读 I&#x2F;O模块的状态</li><li>将 I&#x2F;O状态信息读入 CPU 寄存器</li></ul></li><li>检查错误条件<ul><li>检查状态</li><li>设备可能会出现错误</li></ul></li><li>I&#x2F;O —&gt; CPU<ul><li>从I&#x2F;O模块中读取字</li><li>将数据寄存器中的内容读入 CPU 寄存器</li></ul></li><li>CPU —&gt; 存储器<ul><li>往存储器中写入字</li><li>将 CPU 寄存器中的内容写到内存中</li></ul></li><li>检查是否继续</li></ul></li><li>注意<ul><li>CPU 会在每个指令周期的末尾检查中断</li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。<ul><li>如果中断发生的频率太高，也会降低系统性能</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807154128175.png" alt="image-20230807154128175"></p><ul><li>中断驱动方式<ul><li>完成一次读&#x2F;写操作的流程（key word：中断）</li><li>CPU 干预的频率<ul><li>每次 I&#x2F;O操作开始之前、完成之后需要 CPU 介入</li><li>等待 I&#x2F;O完成的过程中，CPU可以切换到别的进程执行</li></ul></li><li>数据传送的单位<ul><li>每次读&#x2F;写一个字</li></ul></li><li>数据的流向<ul><li>读操作（数据输入）<ul><li>I&#x2F;O 设备—&gt;CPU—&gt;内存</li></ul></li><li>写操作（数据输出）<ul><li>内存—&gt;CPU—&gt;I&#x2F;O设备</li></ul></li></ul></li><li>主要优点<ul><li>与程序直接控制方式相比，在中断驱动方式中，I&#x2F;O控制器会通过中断信号主动报告 I&#x2F;O 已完成，CPU 不再需要不停地轮询</li><li><strong>CPU 和 I&#x2F;O设备可以并行工作，CPU 利用率得到明显提升</strong></li></ul></li><li>主要缺点<ul><li>每个字在 I&#x2F;O设备与内存之间的传输，都需要经过 CPU</li><li><strong>频繁的中断处理会消耗较多的 CPU 时间</strong></li></ul></li></ul></li></ul><h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><p>自己理解</p><ul><li>CPU 布置任务，告诉你要读多少数据，读进来要存放到内存的什么位置，存放到外存的什么位置，都完成之后再来叫我，我先去做其他事</li></ul><p><img src="/../image/assets/image-20230807154639385.png" alt="image-20230807154639385"></p><ul><li>DMA（Direct Memory Access）<ul><li><strong>直接存储器存取</strong>，主要用于块设备的 I&#x2F;O控制</li><li>相比于“中断驱动方式”的改进<ul><li><strong>数据的传送单位是“块”</strong>，不再是一个字、一个字的传送</li><li>数据的流向是从设备直接放入内存，或者从内存直接到设备。<ul><li>不再需要 CPU 作为“快递小哥”</li></ul></li><li>仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预</li></ul></li><li>流程<ul><li>CPU—&gt;DMA<ul><li>做其他事情</li><li>CPU 指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：磁盘上的地址）</li></ul></li><li>DMA—&gt;CPU<ul><li>中断</li><li>读 DMA 模块的状态</li><li>控制器会根据 CPU 提出的要求完成数据的读&#x2F;写工作，整块数据的传输完成后，才向 CPU 发出中断信号</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807155518820.png" alt="image-20230807155518820"></p><ul><li>DMA 控制器<ul><li>DR（Data Register，数据寄存器）<ul><li>暂存从设备到内存，或者从内存到设备的数据</li></ul></li><li>MAR（Memory Address Register，内存地址寄存器）<ul><li>输入时，MAR 表示数据应放到内存中的什么位置；</li><li>输出时，MAR 表示输出的数据放在内存中的什么位置</li></ul></li><li>DC（Data Counter，数据计数器）<ul><li>表示剩余要读&#x2F;写的字节数</li></ul></li><li>CR（Command Register，命令&#x2F;状态寄存器）<ul><li>用于存放 CPU 发来的 I&#x2F;O 命令，或设备的状态信息</li></ul></li></ul></li><li>DMA 也是从磁盘中一个字一个字的读入，放入到 DR 中，直到DC&#x3D;0，将 DR 中所有的数据放到 MAR 存放的地址中</li></ul><p><img src="/../image/assets/image-20230807160036399.png" alt="image-20230807160036399"></p><ul><li>DMA方式<ul><li>完成一次读&#x2F;写操作的流程</li><li>CPU 干预的频率<ul><li>仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预</li></ul></li><li>数据传送的单位<ul><li>每次读&#x2F;写一个或多个块<ul><li>每次读写只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的</li></ul></li></ul></li><li>数据的流向（不再需要经过 CPU）<ul><li>读操作（数据输入）<ul><li>I&#x2F;O 设备—&gt;内存</li></ul></li><li>写操作（数据输出）<ul><li>内存—&gt;I&#x2F;O设备</li></ul></li></ul></li><li>主要优点<ul><li>数据传输以“块”为单位，CPU 介入频率进一步降低</li><li>数据的传输不再需要先经过 CPU 在写入内存，数据传输效率进一步增加</li><li>CPU 和 I&#x2F;O设备的并行性得到提升</li></ul></li><li>主要缺点<ul><li>CPU 每发出一条 I&#x2F;O指令<strong>，只能读&#x2F;写一个或多个连续的数据块</strong></li><li>如果要读&#x2F;写多个离散存储的数据库，或者要将数据分别写到不同的内存区域时，CPU 要分别发出多条 I&#x2F;O 指令，进行多次中断处理才能完成</li></ul></li></ul></li></ul><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><ul><li>自己理解<ul><li>CPU 发出命令，告诉通道执行哪个通道程序（任务清单）和操作哪个 I&#x2F;O 设备就可以做其他事情了，其余事情由通道自己完成</li></ul></li></ul><p><img src="/../image/assets/image-20230807160740311.png" alt="image-20230807160740311"></p><ul><li>通道控制方式<ul><li>通道<ul><li><strong>一种硬件</strong>，可以理解为是“弱鸡版的 CPU”</li><li><strong>通道可以识别并执行一系列通道指令</strong></li><li><strong>与 CPU 相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与 CPU 共享内存</strong></li></ul></li><li>通道程序<ul><li>任务清单</li><li>本质上是一系列通道指令的集合（跟之前的批操作指令一样）</li></ul></li><li>流程<ul><li>CPU 向通道发出 I&#x2F;O指令<ul><li>指明通道程序在内存中的位置，并指明要操作的是哪个 I&#x2F;O 设备</li><li>之后 CPU 就切换到其他进程执行了</li></ul></li><li>通道执行内存中的通道程序<ul><li>其中指明了要读入&#x2F;写出多少数据</li><li>读&#x2F;写的数据应该放在内存的什么位置等信息</li></ul></li><li>通道执行完规定的任务后，向CPU 发出中断信号，之后 CPU 对中断进行处理</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807161416155.png" alt="image-20230807161416155"></p><ul><li>通道控制方式<ul><li>完成一次读&#x2F;写操作的流程<ul><li>CPU 给通道发出指令<ul><li>CPU 做其他事情</li></ul></li></ul></li><li>CPU 干预的频率<ul><li>极低，通道会根据 CPU 的指示执行对应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求 CPU 干预</li></ul></li><li>数据传送的单位<ul><li><strong>每次读&#x2F;写一组数据块</strong></li></ul></li><li>数据的流向（在通道的控制下进行）<ul><li>读操作（数据流入）：I&#x2F;O设备—&gt;内存</li><li>写操作（数据输出）：内存—&gt;I&#x2F;O设备</li></ul></li><li>主要缺点<ul><li>实现复杂，需要专门的通道硬件支持</li></ul></li><li>主要优点<ul><li>CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807161922196.png" alt="image-20230807161922196"></p><h2 id="I-O-软件层次结构"><a href="#I-O-软件层次结构" class="headerlink" title="I&#x2F;O 软件层次结构"></a>I&#x2F;O 软件层次结构</h2><p><img src="/../image/assets/image-20230807173239433.png" alt="image-20230807173239433"></p><ul><li><p>I&#x2F;O 软件层次结构</p><ul><li>用户层软件<ul><li>越上面的层次越接近用户</li></ul></li><li>设备独立性软件<ul><li>每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供服务（“封装思想”）</li></ul></li><li>设备驱动程序</li><li>中断处理程序<ul><li>越下面的层次越接近硬件</li></ul></li><li>硬件</li></ul></li><li><p>中间三层：设备独立性软件、设备驱动程序、中断处理程序</p><ul><li>属于操作系统的内核部分，即 I&#x2F;O 系统或称 I&#x2F;O核心子系统</li></ul></li></ul><h3 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h3><p><img src="/../image/assets/image-20230807173703872.png" alt="image-20230807173703872"></p><ul><li><p>用户层软件</p><ul><li><p>“系统调用处理层”</p></li><li><p>实现了与用户交互的接口</p></li><li><p>用户可直接使用该层提供的、与 I&#x2F;O 操作相关的库函数对设备进行操作</p><ul><li>EG：printf(“Hello World!”);</li></ul></li><li><p>将用户请求翻译成格式化的 I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p><ul><li>EG：printf(“Hello World!”); 会被翻译成等价的 write 系统调用，当然用户层软件也会在系统调用时填入相应参数</li></ul></li></ul></li><li><p>Windows 操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用（Windows API）</p></li></ul><h3 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h3><ul><li>自己理解<ul><li>将下层设备编号，形成逻辑设备表<ul><li>逻辑设备名、物理设备名、驱动程序入口地址</li></ul></li><li>给上层提供服务:系统调用接口</li></ul></li></ul><p><img src="/../image/assets/image-20230807174243765.png" alt="image-20230807174243765"><br><img src="/../image/assets/image-20230807174355088.png" alt="image-20230807174355088"><br><img src="/../image/assets/image-20230807174511142.png" alt="image-20230807174511142"><br><img src="/../image/assets/image-20230807175227799.png" alt="image-20230807175227799"><br><img src="/../image/assets/image-20230807175238653.png" alt="image-20230807175238653"><br><img src="/../image/assets/image-20230807175249432.png" alt="image-20230807175249432"></p><ul><li>设备独立性软件<ul><li>设备无关性软件</li><li>与设备的硬件特性无关的功能几乎都在这一层实现</li><li>功能<ul><li>向上层提供统一的调用接口（如 read&#x2F;write 系统调用）</li><li>设备的保护<ul><li>原理类似于文件保护</li><li>设备被看做是一种特殊的文件，不同用户对各个文件的访问权限时不一样的，同理对设备的访问权限也不一样</li></ul></li><li>差错处理<ul><li>设备独立性软件需要对一些设备的错误进行处理</li></ul></li><li>设备的分配与回收</li><li>数据缓冲区管理<ul><li>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li></ul></li><li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序<ul><li>用户或用户层软件发出 I&#x2F;O操作相关系统调用的系统调用时，需要指明此次要操作的 I&#x2F;O设备的逻辑设备名<ul><li>eg：去学校打印店打印时，需要选择打印机 1&#x2F;打印机 2&#x2F;打印机 3，其实这些都是逻辑设备名</li></ul></li><li>设备独立性软件需要通过“逻辑设备表（LUT，Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807175301352.png" alt="image-20230807175301352"></p><ul><li>逻辑设备表<ul><li>逻辑设备名<ul><li>I&#x2F;O设备被当做一种特殊的文件</li></ul></li><li>物理设备名</li><li>驱动程序入口地址<ul><li>不同类型的 I&#x2F;O 设备需要有不同的驱动程序处理</li></ul></li></ul></li><li>操作系统可以用两种方式管理逻辑设备表（LUT）<ul><li><strong>整个系统只设置一张 LUT，这就意味着所有用户不能使用相同的逻辑设备名</strong><ul><li>只适用于单用户操作系统</li></ul></li><li><strong>为每个用户设置一张 LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统</strong><ul><li>系统会在用户登录时为其建立一个用户管理进程，而 LUT 就存放在用户管理进程的 PCB 中</li></ul></li></ul></li></ul><h3 id="设备驱动软件"><a href="#设备驱动软件" class="headerlink" title="设备驱动软件"></a>设备驱动软件</h3><ul><li>让设备听得懂 CPU 的指令</li></ul><p><img src="/../image/assets/image-20230807175626075.png" alt="image-20230807175626075"></p><ul><li>为何不同的设备需要不同的设备驱动程序？<ul><li>不同设备的内部硬件特性不同，这些特性只有厂家才知道</li><li>因此厂家必须提供与设备对应的驱动程序，CPU 执行驱动程序的指令序列，来完成设置设备寄存器、检查设备状态等工作</li></ul></li></ul><p><img src="/../image/assets/image-20230807175957607.png" alt="image-20230807175957607"></p><ul><li>设备驱动程序<ul><li>主要负责对硬件设备的具体控制，将上一层发出的一系列命令（如 read&#x2F;write）转化成特定设备“能听得懂的”一系列操作<ul><li>包括设置设备寄存器；检查设备状态</li></ul></li><li>不同的 I&#x2F;O 设备有不同的硬件特性，具体细节只有设备的厂家才知道<ul><li>厂家需要根据设备的硬件特性设计并提供相应的驱动程序</li></ul></li></ul></li><li>驱动程序一般会以一个独立进程的方式存在</li></ul><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p><img src="/../image/assets/image-20230807180440380.png" alt="image-20230807180440380"></p><ul><li>中断处理程序<ul><li><strong>当 I&#x2F;O 任务完成时，I&#x2F;O 控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行</strong></li><li>流程<ul><li>从控制器读出设备状态</li><li>判断 I&#x2F;O 是否是正常结束<ul><li>否：根据异常原因做相应处理</li><li>是：从设备中读入一个字的数据并经由 CPU 放到内存缓冲区</li></ul></li></ul></li><li>中断处理程序也会和硬件直接打交道</li></ul></li></ul><p><img src="/../image/assets/image-20230807180909187.png" alt="image-20230807180909187"></p><p><img src="/../image/assets/image-20230807180926054.png" alt="image-20230807180926054"></p><h2 id="输入输出应用程序接口-设备驱动程序接口"><a href="#输入输出应用程序接口-设备驱动程序接口" class="headerlink" title="输入输出应用程序接口 &amp; 设备驱动程序接口"></a>输入输出应用程序接口 &amp; 设备驱动程序接口</h2><p><img src="/../image/assets/image-20230807185950152.png" alt="image-20230807185950152"></p><h3 id="输入-输出应用程序接口"><a href="#输入-输出应用程序接口" class="headerlink" title="输入&#x2F;输出应用程序接口"></a>输入&#x2F;输出应用程序接口</h3><p><img src="/../image/assets/image-20230807190104232.png" alt="image-20230807190104232"></p><ul><li>I&#x2F;O 设备（硬件）<ul><li>字符设备<ul><li>如：键盘、打印机，<strong>不可“寻址”，每次读一个字符</strong></li></ul></li><li>块设备<ul><li>如：磁盘，<strong>可“寻址”，每次读&#x2F;写一个块</strong></li></ul></li><li>网络设备<ul><li>如：网络控制器（网卡），数据该给谁？</li></ul></li></ul></li><li>用户层的应用程序无法用一个统一的系统调用接口来完成所有类型设备的 I&#x2F;O</li></ul><h4 id="字符设备接口"><a href="#字符设备接口" class="headerlink" title="字符设备接口"></a>字符设备接口</h4><p><img src="/../image/assets/image-20230807190454376.png" alt="image-20230807190454376"></p><ul><li>字符设备接口<ul><li>get&#x2F;put 系统调用<ul><li>向字符设备读&#x2F;写一个字符</li></ul></li></ul></li></ul><h4 id="块设备接口"><a href="#块设备接口" class="headerlink" title="块设备接口"></a>块设备接口</h4><p><img src="/../image/assets/image-20230807190521590.png" alt="image-20230807190521590"></p><ul><li>块设备接口<ul><li>read&#x2F;write 系统调用<ul><li>向块设备的读写指针位置读&#x2F;写多个字符</li></ul></li><li>seek 系统调用<ul><li>修改读写指针位置</li></ul></li></ul></li></ul><h4 id="网络设备接口"><a href="#网络设备接口" class="headerlink" title="网络设备接口"></a>网络设备接口</h4><p><img src="/../image/assets/image-20230807190607907.png" alt="image-20230807190607907"></p><ul><li>网络设备接口<ul><li>又称网络套接字（socket）接口</li><li>socket 系统调用<ul><li>创建一个网络套接字，需要指明网络协议（TCP?UDP?）</li></ul></li><li>bind 系统调用<ul><li>将套接字绑定到某个本地“端口”</li></ul></li><li>connect 系统调用<ul><li>将套接字连接到远程地址</li></ul></li><li>read&#x2F;write 系统调用<ul><li>从套接字读&#x2F;写数据</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807191018118.png" alt="image-20230807191018118"></p><p><img src="/../image/assets/image-20230807191111050.png" alt="image-20230807191111050"></p><p><img src="/../image/assets/image-20230807191125317.png" alt="image-20230807191125317"></p><p><img src="/../image/assets/image-20230807191138048.png" alt="image-20230807191138048"></p><p><img src="/../image/assets/image-20230807191150719.png" alt="image-20230807191150719"></p><p><img src="/../image/assets/image-20230807191203926.png" alt="image-20230807191203926"></p><p><img src="/../image/assets/image-20230807191226707.png" alt="image-20230807191226707"></p><p><img src="/../image/assets/image-20230807191242691.png" alt="image-20230807191242691"></p><p><img src="/../image/assets/image-20230807191254741.png" alt="image-20230807191254741"></p><ul><li><h2 id="网络数据传输流程"><a href="#网络数据传输流程" class="headerlink" title="网络数据传输流程"></a>网络数据传输流程</h2></li></ul><h4 id="什么是阻塞-非阻塞-IO"><a href="#什么是阻塞-非阻塞-IO" class="headerlink" title="什么是阻塞&#x2F;非阻塞 IO"></a>什么是阻塞&#x2F;非阻塞 IO</h4><p><img src="/../image/assets/image-20230807191306381.png" alt="image-20230807191306381"></p><ul><li>阻塞 I&#x2F;O<ul><li>应用程序发出 I&#x2F;O 系统调用，进程需要转为阻塞态等待 I&#x2F;O的完成</li><li>eg：字符设备接口——从键盘读一个字符 get</li></ul></li><li>非阻塞 I&#x2F;O<ul><li>应用程序发出 I&#x2F;O 系统调用，系统调用可迅速返回，进程无需阻塞等待</li><li>eg：块设备接口——往磁盘写数据 write<ul><li>就算是磁盘被占用忙碌，内存中用户空间的进程也可以将数据复制到内核区域，等待磁盘空闲立即写入</li></ul></li></ul></li></ul><h3 id="设备驱动程序接口"><a href="#设备驱动程序接口" class="headerlink" title="设备驱动程序接口"></a>设备驱动程序接口</h3><p><img src="/../image/assets/image-20230807191317835.png" alt="image-20230807191317835"></p><p><img src="/../image/assets/image-20230807191339976.png" alt="image-20230807191339976"></p><ul><li>设备驱动程序接口<ul><li>若各公司开发的设备驱动程序接口不统一，则操作系统很难调用设备驱动程序</li></ul></li><li>统一标准的设备驱动程序接口<ul><li>操作系统规定好设备驱动程序的接口标准，各个厂商必须按要求开发设备驱动程序</li></ul></li></ul><p><img src="/../image/assets/image-20230807191425994.png" alt="image-20230807191425994"></p><ul><li>不同的操作系统，对设备驱动程序接口的标准各不相同</li><li>设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用</li></ul><h2 id="I-O-核心子系统"><a href="#I-O-核心子系统" class="headerlink" title="I&#x2F;O 核心子系统"></a>I&#x2F;O 核心子系统</h2><p><img src="/../image/assets/image-20230807193900926.png" alt="image-20230807193900926"></p><ul><li>I&#x2F;O 软件的层次<ul><li>属于操作系统的内核部分，即 I&#x2F;O 系统或称“I&#x2F;O 核心子系统”<ul><li>设备独立性软件、设备驱动程序、中断处理程序</li></ul></li><li>I&#x2F;O 核心子系统要实现的功能其实就是中间三层要实现的程序</li><li>要重点理解和掌握的功能是：I&#x2F;O 调度、设备保护、假脱机技术（SPOOLing 技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存）</li></ul></li></ul><p><img src="/../image/assets/image-20230807194231024.png" alt="image-20230807194231024"></p><h3 id="假脱机技术（SPOOLing-技术）"><a href="#假脱机技术（SPOOLing-技术）" class="headerlink" title="假脱机技术（SPOOLing 技术）"></a>假脱机技术（SPOOLing 技术）</h3><ul><li>假脱机技术（SPOOLing 技术）需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的</li></ul><p><img src="/../image/assets/image-20230807195500527.png" alt="image-20230807195500527"></p><h4 id="什么是假脱机技术？可以解决什么问题？"><a href="#什么是假脱机技术？可以解决什么问题？" class="headerlink" title="什么是假脱机技术？可以解决什么问题？"></a>什么是假脱机技术？可以解决什么问题？</h4><h5 id="脱机技术"><a href="#脱机技术" class="headerlink" title="脱机技术"></a>脱机技术</h5><p><img src="/../image/assets/image-20230807195628468.png" alt="image-20230807195628468"><br><img src="/../image/assets/image-20230807195814450.png" alt="image-20230807195814450">】</p><ul><li>什么是脱机技术？<ul><li>手工操作阶段<ul><li>主机直接从 I&#x2F;O 设备获得数据，由于设备速度慢，主机速度很快</li><li>人机矛盾明显，主机要浪费很多时间来等待设备</li></ul></li><li>批处理阶段<ul><li>引入了脱机输入&#x2F;脱机输出技术（用磁带完成）<ul><li>引入脱机技术后，缓解了 CPU 与慢速 I&#x2F;O 设备的速度矛盾</li><li>另一方面，即使 CPU 在忙碌，也可以提前将数据输入到磁带</li><li>即使慢速的输出设备在忙碌，也可以提前将数据输出到磁带</li></ul></li><li>在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上，之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾</li><li>为什么叫脱机？<ul><li>脱离主机的控制进行的输入&#x2F;输出操作</li></ul></li></ul></li></ul></li></ul><h5 id="假脱机技术——输入井和输出井-缓冲区-进程"><a href="#假脱机技术——输入井和输出井-缓冲区-进程" class="headerlink" title="假脱机技术——输入井和输出井&#x2F; 缓冲区&#x2F; 进程"></a>假脱机技术——输入井和输出井&#x2F; 缓冲区&#x2F; 进程</h5><p><img src="/../image/assets/image-20230807200316831.png" alt="image-20230807200316831"><br><img src="/../image/assets/image-20230807200859721.png" alt="image-20230807200859721"></p><ul><li>假脱机技术<ul><li>又称“SPOOLing技术”</li><li>用软件的方式模拟脱机技术</li><li>从磁盘上开辟出两个存储区域——“输入井”和“输出井”</li><li>组成<ul><li><strong>输入井</strong><ul><li>模拟脱机输入时的磁带，用于收容 I&#x2F;O 设备输入的数据</li></ul></li><li><strong>输出井</strong><ul><li>模拟脱机输出时的磁带，用于收容用户进程输出的数据</li></ul></li><li><strong>输入进程</strong><ul><li>模拟脱机输入时的外围控制机</li><li><strong>输入缓冲区</strong></li></ul></li><li><strong>输出进程</strong><ul><li>模拟脱机输出时的外围控制机</li><li><strong>输出缓冲区</strong></li></ul></li><li><strong>输入设备</strong></li><li><strong>输出设备</strong></li></ul></li><li>要<strong>实现 SPOOLing 技术，必须要有多道程序技术的支持</strong>，系统会建立“输入进程”和“输出进程”</li></ul></li></ul><p><img src="/../image/assets/image-20230807200840098.png" alt="image-20230807200840098"></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="/../image/assets/image-20230807200954738.png" alt="image-20230807200954738"></p><p><img src="/../image/assets/image-20230807200859721.png" alt="image-20230807200859721"></p><p><img src="/../image/assets/image-20230807201023074.png" alt="image-20230807201023074"></p><ul><li>输入输出进程<ul><li>输入进程<ul><li>模拟脱机输入时的外围控制机</li><li>在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后在转存到输入井中</li></ul></li><li>输出进程<ul><li>模拟脱机输出时的外围控制机</li><li>在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后在传送到输出设备上</li></ul></li><li>注意<ul><li>输入缓冲区和输出缓冲区是在内存中的缓冲区</li></ul></li></ul></li></ul><h4 id="共享打印机原理分析"><a href="#共享打印机原理分析" class="headerlink" title="共享打印机原理分析"></a>共享打印机原理分析</h4><p><img src="/../image/assets/image-20230807201534478.png" alt="image-20230807201534478"></p><p><img src="/../image/assets/image-20230807201850659.png" alt="image-20230807201850659"></p><ul><li><p>独占式设备</p><ul><li>只允许多个进程串行使用的设备</li><li>一段时间内只能满足一个进程的请求</li><li>例子<ul><li>若进程 1 正在使用打印机，则进程 2 请求使用打印机时必然阻塞等待</li></ul></li></ul></li><li><p>共享设备</p><ul><li>允许多个进程同时使用的设备<ul><li>宏观上同时使用，微观上可能是交替使用</li></ul></li><li>可以同时满足多个进程的使用请求</li></ul></li><li><p>打印机</p><ul><li>打印机是种独占式设备，但是可以用 SPOOLing 技术改造成“共享设备”</li><li>假脱机文件队列<ul><li>打印任务队列</li></ul></li><li>原理分析（假脱机管理进程）<ul><li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由<strong>假脱机管理进程</strong>为每个进程做两件事<ul><li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上<ul><li>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可以一次处理完全部的打印任务</li></ul></li></ul></li></ul></li><li>过程<ul><li>进程提出打印请求</li><li>在磁盘（输出井）中新建空闲缓冲区</li><li>将用户进程中要打印的数据放到缓冲区中</li><li>为用户进程申请一张空白的打印请求表（说明书）</li><li>把表挂到假脱机文件队列（打印任务队列）</li></ul></li><li>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享</li><li><strong>SPOOLing 技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备</strong></li></ul></li></ul><p><img src="/../image/assets/image-20230807205516345.png" alt="image-20230807205516345"></p><h3 id="I-O-调度"><a href="#I-O-调度" class="headerlink" title="I&#x2F;O 调度"></a>I&#x2F;O 调度</h3><p><img src="/../image/assets/image-20230807194416312.png" alt="image-20230807194416312"></p><ul><li>I&#x2F;O 调度<ul><li><strong>用某种算法确定一个好的顺序来处理各个 I&#x2F;O 请求</strong><ul><li>如：磁盘调度：当多个磁盘 I&#x2F;O 请求到来时，用某种调度算法确定满足I&#x2F;O请求的顺序<ul><li>先来先服务</li><li>最短寻道优先算法</li><li>SCAN 算法</li><li>C-SCAN算法</li><li>LOOK 算法</li><li>C-LOOK算法</li></ul></li><li>打印机等设备也可以使用上述算法来确定 I&#x2F;O 调度顺序</li></ul></li></ul></li></ul><h3 id="设备保护"><a href="#设备保护" class="headerlink" title="设备保护"></a>设备保护</h3><p><img src="/../image/assets/image-20230807195145780.png" alt="image-20230807195145780"></p><ul><li><strong>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限</strong><ul><li>只读、读和写</li><li>在 UNIX 系统中，<strong>设备被看做是一种特殊的文件</strong>，每个设备也会有对应的 FCB</li><li>当用户请求访问某个设备时，系统根据 FCB 中记录的信息来判断该用户是否有相应的访问权限，以此来实现“设备保护”的功能</li></ul></li></ul><h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="/../image/assets/image-20230807210149591.png" alt="image-20230807210149591"></p><h3 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h3><p><img src="/../image/assets/image-20230807210250114.png" alt="image-20230807210250114"></p><h4 id="设备的固有属性"><a href="#设备的固有属性" class="headerlink" title="设备的固有属性"></a>设备的固有属性</h4><ul><li>设备的固有属性三种<ul><li>独占设备<ul><li>一个时段只能分配给一个进程（如打印机）</li></ul></li><li>共享设备<ul><li>可同时分配给多个进程使用（如磁盘）</li><li>各个进程往往是宏观上同时共享使用设备，而微观上交替使用</li></ul></li><li>虚拟设备<ul><li>采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可以同时分配给多个额进程使用<ul><li>如采用 SPOOLing 技术实现的共享打印机</li></ul></li></ul></li></ul></li></ul><h4 id="设备的分配算法"><a href="#设备的分配算法" class="headerlink" title="设备的分配算法"></a>设备的分配算法</h4><p><img src="/../image/assets/image-20230807210604150.png" alt="image-20230807210604150"></p><ul><li>设备的分配算法<ul><li>先来先服务</li><li>优先级高者优先</li><li>短任务优先</li></ul></li></ul><h4 id="设备分配中的安全性"><a href="#设备分配中的安全性" class="headerlink" title="设备分配中的安全性"></a>设备分配中的安全性</h4><p><img src="/../image/assets/image-20230807210710798.png" alt="image-20230807210710798"></p><ul><li>从进程运行的安全性上考虑，设备分配有两种方式<ul><li>安全分配方式<ul><li>为进程分配一个设备后就将进程阻塞，本次 I&#x2F;O 完成后才将进程唤醒<ul><li>eg：考虑进程请求打印机打印输出的例子</li></ul></li><li>一个时间段内每个进程只能是由一个设备</li><li>优点<ul><li>破坏了“请求和保持”条件，不会死锁</li></ul></li><li>缺点<ul><li>对于一个进程来说，CPU 和 I&#x2F;O设备只能串行工作</li></ul></li></ul></li><li>不安全的分配方式<ul><li>进程发出 I&#x2F;O 请求后，系统为其分配 I&#x2F;O 设备，进程可继续执行，之后还可以发出新的 I&#x2F;O 请求</li><li>只有某个 I&#x2F;O 请求得不到满足时才将进程阻塞</li><li>一个进程可以同时使用多个设备</li><li>优点<ul><li>进程的计算任务和 I&#x2F;O 任务可以并行处理，使进程迅速推进</li></ul></li><li>缺点<ul><li>有可能发生死锁（死锁避免、死锁的检测和解除）</li></ul></li></ul></li></ul></li></ul><h3 id="静态分配与动态分配"><a href="#静态分配与动态分配" class="headerlink" title="静态分配与动态分配"></a>静态分配与动态分配</h3><p><img src="/../image/assets/image-20230807211138402.png" alt="image-20230807211138402"></p><ul><li>静态分配<ul><li>进程运行前为其分配全部所需资源，运行结束后归还资源</li></ul></li><li>动态资源<ul><li>进程运行过程中动态申请设备资源</li></ul></li></ul><h3 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h3><p><img src="/../image/assets/image-20230807211225664.png" alt="image-20230807211225664"></p><ul><li>设备分配管理中的数据结构<ul><li>设备、控制器、通道之间的关系<ul><li>一个通道可以控制多个设备控制器</li><li>每个设备控制器可以控制多个设备</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807211319922.png" alt="image-20230807211319922"></p><ul><li>设备控制表<ul><li>系统为每个设备配置一张 DCT，用于记录设备情况</li><li>组成<ul><li>设备类型<ul><li>如：打印机、扫描仪、键盘</li></ul></li><li>设备标识符<ul><li>物理设备名，系统中的每个设备的物理设备名唯一</li></ul></li><li>设备状态<ul><li>忙碌、空闲、故障</li></ul></li><li>指向控制器表的指针<ul><li>每个设备由一个控制器控制，该指针可找到相应控制器的信息</li></ul></li><li>重复执行次数或时间<ul><li>当重复执行多次 I&#x2F;O 操作后仍不成功，才认为此次 I&#x2F;O 失败</li></ul></li><li>设备队列的队首指针<ul><li>指向正在等待该设备的进程队列（由进程 PCB 组成队列）</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807211622624.png" alt="image-20230807211622624"></p><ul><li><p>控制器控制表（COCT）</p><ul><li><p>每个设备控制器都会对应一张 COCT，操作系统根据 COCT 的信息对控制器进行操作和管理</p></li><li><p>组成</p><ul><li><p>控制器标识符</p><ul><li>各个控制器的唯一 ID</li></ul></li></ul></li><li><p>控制器状态</p><ul><li>忙碌&#x2F;空闲&#x2F;故障</li></ul></li><li><p>指向通道表的指针</p></li><li><p>每个控制器由一个通道控制，该指针可以找到相应通道的信息</p></li><li><p>控制器队列的队首指针</p></li><li><p>控制器队列的队尾指针</p></li><li><p>指向正在等待该控制器的进程队列（由进程 PCB 组成队列）</p></li></ul></li></ul><p><img src="/../image/assets/image-20230807211931915.png" alt="image-20230807211931915"></p><ul><li>通道控制表（CHCT）<ul><li>每个通道都会对应一张 CHCT，操作系统根据 CHCT 的信息对通道进行操作和管理</li><li>组成<ul><li>通道标识符<ul><li>各个通道的唯一 ID</li></ul></li><li>通道状态<ul><li>忙碌&#x2F;空闲&#x2F;故障</li></ul></li><li>与通道链接的控制器表首址<ul><li>可通过该指针找到该通道管理的所有控制器相关信息（COCT）</li></ul></li><li>通道队列的对手指针</li><li>通道队列的队尾指针<ul><li>指向正在等待该通道的进程队列（由进程 PCB 组成队列）</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807215542236.png" alt="image-20230807215542236"></p><ul><li>系统设备表（SDT）<ul><li>记录了系统中全部设备的情况，每个设备对应一个表目</li><li>组成<ul><li>表目 1</li><li>表目 2</li><li>表目 i<ul><li>设备类型<ul><li>如：打印机、扫描仪、键盘</li></ul></li><li>设备标识符<ul><li>物理设备名</li></ul></li><li>DCT（设备控制表）</li><li>驱动程序入口</li></ul></li></ul></li></ul></li></ul><h3 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h3><p><img src="/../image/assets/image-20230807215926429.png" alt="image-20230807215926429"><br><img src="/../image/assets/image-20230807215941955.png" alt="image-20230807215941955"><br><img src="/../image/assets/image-20230807220002642.png" alt="image-20230807220002642"><br><img src="/../image/assets/image-20230807220024567.png" alt="image-20230807220024567"></p><ul><li><p>设备分配的步骤</p><ul><li><p>根据进程请求的物理设备名查找 SDT（系统设备表）</p><ul><li>物理设备名是进程请求分配设备时提供的参数</li></ul></li><li><p>根据 SDT 找到 DCT，若设备忙碌则将进程 PCB 挂到设备等待队列，不忙碌则将设备分配给进程</p></li><li><p>根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程</p></li><li><p>根据 COCT 找到 CHCT，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进程</p></li></ul></li><li><p>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动 I&#x2F;O 设备进行数据传送</p></li></ul><h3 id="设备分配步骤的改进方法"><a href="#设备分配步骤的改进方法" class="headerlink" title="设备分配步骤的改进方法"></a>设备分配步骤的改进方法</h3><p><img src="/../image/assets/image-20230807220447563.png" alt="image-20230807220447563"></p><ul><li><p>设备分配步骤的改进</p><ul><li>缺点<ul><li>用户编程时必须使用物理设备名，底层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，则程序无法进行</li><li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li></ul></li><li>改进方法<ul><li>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807220645315.png" alt="image-20230807220645315"></p><ul><li>改进后过程<ul><li>根据进程请求的逻辑设备名查找 SDT<ul><li><strong>用户编程时提供的逻辑设备名其实就是设备类型</strong></li></ul></li><li>查找 SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程<ul><li><strong>操作系统在逻辑设备表（LUT）中新增一个表项</strong></li></ul></li><li>根据 DCT 找到 COCT<ul><li>若控制器忙碌则将进程 PCB 挂到控制器等待队列中</li><li>不忙碌则将控制器分配给进程</li></ul></li><li>根据 COCT 找到 CHCT<ul><li>若通道忙碌则将进程 PCB 挂到通道等待队列中</li><li>不忙碌则将通道分配给进程</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230807220656756.png" alt="image-20230807220656756"></p><ul><li><p>逻辑设备表（LUT）</p><ul><li>建立了逻辑设备名与物理设备名之间的映射关系</li><li>第一次<ul><li>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在 LUT 中增加相应表项</li></ul></li><li>非第一次<ul><li><strong>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过 LUT 表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址</strong></li></ul></li></ul></li><li><p>设置问题</p><ul><li>整个系统只有一张 LUT<ul><li>各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li></ul></li><li>每个用户一张 LUT<ul><li>不同用户的逻辑设备名可重复，适用于多用户操作系统</li></ul></li></ul></li></ul><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><img src="/../image/assets/image-20230808193409907.png" alt="image-20230808193409907"></p><h3 id="什么是缓冲区？有什么作业？"><a href="#什么是缓冲区？有什么作业？" class="headerlink" title="什么是缓冲区？有什么作业？"></a>什么是缓冲区？有什么作业？</h3><p><img src="/../image/assets/image-20230808193453420.png" alt="image-20230808193453420"></p><ul><li>缓冲区<ul><li>定义<ul><li>是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</li></ul></li><li>使用硬件作为缓冲区<ul><li>成本较高，容量也较小</li><li>一般仅用在对速度要求非常高的场合<ul><li>如存储器管理中所用的联想寄存器（快表），由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230808213459434.png" alt="image-20230808213459434"></p><ul><li>缓冲区的作用<ul><li>缓和 CPU 与 I&#x2F;O设备之间速度不匹配的矛盾<ul><li>如果是字符型设备，就需要每输出完一个字符就要向 CPU 发送一次中断信号</li></ul></li><li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制</li><li>解决数据粒度不匹配的问题<ul><li>如：输出进程每次可以生成一块数据，但 I&#x2F;O 设备每次只能输出一个字符</li></ul></li><li>提高 CPU 与I&#x2F;O 设备之间的并行性<ul><li>CPU 可以把要输出的数据快速地放入缓冲区，之后就可以做别的事情了</li><li>慢速的 I&#x2F;O 设备可以慢慢从缓冲区取走数据</li><li>数据输入时类似</li></ul></li></ul></li></ul><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p><img src="/../image/assets/image-20230808213727768.png" alt="image-20230808213727768"></p><ul><li>单缓冲<ul><li>假设某用户进程请求某种块设备读入若干块的数据</li><li>若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区<ul><li>若题目中没有特别说明，一个缓冲区的大小就是一个块</li><li>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；</li><li>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</li></ul></li><li>用户进程在内存空间中，会分出一片工作区接受输入&#x2F;输出数据<ul><li>一般默认工作区大小与缓冲区相同</li></ul></li><li>常考题型<ul><li>计算每处理一块数据平均需要多久？<ul><li>技巧：嘉定一个厨师状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间</li></ul></li><li>在单缓冲题型中，可以假设厨师状态为工作区慢，缓冲区空</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230808214824813.png" alt="image-20230808214824813"></p><ul><li>T&gt; C<ul><li>初始状态：工作区满，缓冲区空<ul><li>处理一块数据的平均用时 &#x3D; T + M</li></ul></li><li>因为 T&gt;C，因此 CPU 处理完数据后暂时不能将下一块数据传送到工作区，必须等待缓冲区中充满数据</li></ul></li></ul><p><img src="/../image/assets/image-20230808215009815.png" alt="image-20230808215009815"></p><ul><li><p>T &lt; C</p><ul><li><p>初始状态：工作区满，缓冲区空</p><ul><li>处理一块数据的平均用时 &#x3D; C + M</li></ul></li><li><p>因为 T&lt;C，因此 缓冲区中充满数据后暂时不能继续冲入下一块数据，必须等待 CPU 处理结束后，将缓冲区传送到工作区</p></li></ul></li></ul><p><img src="/../image/assets/image-20230808215152281.png" alt="image-20230808215152281"></p><ul><li>结论<ul><li>采用单缓冲策略，处理一块数据平均耗时 Max(C,T)+M</li></ul></li></ul><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p><img src="/../image/assets/image-20230808215234823.png" alt="image-20230808215234823"></p><ul><li>双缓冲<ul><li>假设某用户进程请求某种块设备读入若干块数据</li><li>若采用双缓冲策略，操作系统会在主存中为其分配两个缓冲区<ul><li>一个缓冲区大小就是一个块</li></ul></li><li>题目<ul><li>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</li><li>假设 T&gt;C+M<ul><li>处理一块数据的平均用时 &#x3D; T</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230808215704700.png" alt="image-20230808215704700"></p><ul><li>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</li><li>假设 T&lt;C+M，2T&lt;2M+C<ul><li>I&#x2F;O 设备将缓冲区！充满时，缓冲区 2 的数据尚未取空，因此 I&#x2F;O设备暂时不能冲入数据</li><li>T&lt;C+M意味着设备输入数据块的速度要比处理机处理数据块的速度更快</li><li>没处理一个数据块平均耗时 C+M</li></ul></li></ul><p><img src="/../image/assets/image-20230808215943093.png" alt="image-20230808215943093"></p><ul><li>结论<ul><li>采用双缓冲策略，处理一个数据库的平均耗时为 Max(T,C+M)</li></ul></li></ul><h3 id="使用单-双缓冲区在通信时的区别"><a href="#使用单-双缓冲区在通信时的区别" class="headerlink" title="使用单&#x2F;双缓冲区在通信时的区别"></a>使用单&#x2F;双缓冲区在通信时的区别</h3><p><img src="/../image/assets/image-20230808220157208.png" alt="image-20230808220157208"></p><p><img src="/../image/assets/image-20230808220348548.png" alt="image-20230808220348548"></p><ul><li>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受<ul><li>两台机器配置单缓冲区<ul><li>A机要发送的数据要先放入 A 机缓冲区中，等缓冲区满的时候将数据发出</li><li>B 机的缓冲区用于接收数据</li><li>B 机将缓冲区中的数据全部取走后，才能向 A 机发送数据<ul><li>显然两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输</li></ul></li></ul></li><li>两台机器配置双缓冲区<ul><li>A\B机都有接受缓冲区和发送缓冲区<ul><li>若两个相互通信的机器设置双缓冲区，在同一时刻可以实现双向的数据传输</li></ul></li></ul></li></ul></li></ul><h3 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h3><p><img src="/../image/assets/image-20230808220508735.png" alt="image-20230808220508735"></p><ul><li>循环缓冲区<ul><li>将多个大小相等的缓冲区连接成一个循环队列<ul><li>in 指针<ul><li>指向下一个可以冲入数据的空缓冲区</li></ul></li><li>out 指针<ul><li>指向下一个可以取出数据的满缓冲区</li></ul></li></ul></li></ul></li></ul><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p><img src="/../image/assets/image-20230808220756178.png" alt="image-20230808220756178"></p><ul><li>缓冲池<ul><li>由系统中共用的缓冲区组成</li><li>这些缓冲区按使用状况可以分为<ul><li>空缓冲队列</li><li>装满输入数据的缓冲队列（输入队列）</li><li>装满输出数据的缓冲队列（输出队列）</li></ul></li><li>根据一个缓冲区在实际算法中扮演的功能不同，设置了四种工作缓冲区<ul><li>用于收容输入数据的工作缓冲区（hin）</li><li>用于提取输入数据的工作缓冲区（sin）</li><li>用于收容输出数据的工作缓冲区（hout）</li><li>用于提取输出数据的工作缓冲区（sout）</li></ul></li><li>过程<ul><li>输入进程请求输入数据</li><li>计算进程想要取得一块输入数据</li><li>计算进程想要将准备好的数据冲入缓冲区</li><li>输出进程请求输出数据</li></ul></li><li>从输出队列中取得一块充满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”<ul><li>缓冲区读空后挂到空缓冲区队列</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;输入输出-I-O-管理&quot;&gt;&lt;a href=&quot;#输入输出-I-O-管理&quot; class=&quot;headerlink&quot; title=&quot;输入输出 I&amp;#x2F;O 管理&quot;&gt;&lt;/a&gt;输入输出 I&amp;#x2F;O 管理&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总</summary>
      
    
    
    
    <category term="操作系统" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/408/"/>
    
    
    <category term="输入" scheme="https://sdumoist.github.io/tags/%E8%BE%93%E5%85%A5/"/>
    
    <category term="输出" scheme="https://sdumoist.github.io/tags/%E8%BE%93%E5%87%BA/"/>
    
    <category term="I/O" scheme="https://sdumoist.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>文件管理</title>
    <link href="https://sdumoist.github.io/2023/08/04/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://sdumoist.github.io/2023/08/04/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2023-08-04T07:54:44.738Z</published>
    <updated>2024-03-30T19:41:56.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul><li>考试中遇到未指明隐式链接&#x2F;显式链接的链接分配，默认是指隐式链接的链接分配</li></ul><p><img src="/../image/assets/image-20230804213017334.png" alt="image-20230804213017334"></p><p><img src="/../image/assets/image-20230805171059528.png" alt="image-20230805171059528"></p><ul><li>超级超级超级超级重要的考点<ul><li>要会根据多层索引、混合索引的结构计算出文件的最大长度<ul><li>各级索引表最大不能超过一个块</li></ul></li><li>要能自己分析访问某个数据块所需要的读磁盘次数<ul><li>FCB 中会存有指向顶级索引块的指针，因此可以根据 FCB 读入顶级索引块</li><li>每次读入下一级的索引块都需要一次读磁盘奥做</li><li>注意题目条件——顶级索引块是否已经调入内存</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230805223521435.png" alt="image-20230805223521435"></p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230804165258406.png" alt="image-20230804165258406"></p><p><img src="/../image/assets/image-20230804191118114.png" alt="image-20230804191118114"></p><p><img src="/../image/assets/image-20230804191131262.png" alt="image-20230804191131262"></p><p><img src="/../image/assets/image-20230804203456033.png" alt="image-20230804203456033"></p><p><img src="/../image/assets/image-20230805171106463.png" alt="image-20230805171106463"></p><p><img src="/../image/assets/image-20230805171117595.png" alt="image-20230805171117595"></p><p><img src="/../image/assets/image-20230805181129352.png" alt="image-20230805181129352"></p><p><img src="/../image/assets/image-20230806154533972.png" alt="image-20230806154533972"></p><p><img src="/../image/assets/image-20230806163744579.png" alt="image-20230806163744579"></p><p><img src="/../image/assets/image-20230806172532725.png" alt="image-20230806172532725"></p><p><img src="/../image/assets/image-20230806175015900.png" alt="image-20230806175015900"></p><p><img src="/../image/assets/image-20230806180552701.png" alt="image-20230806180552701"></p><p><img src="/../image/assets/image-20230806202816195.png" alt="image-20230806202816195"></p><p><img src="/../image/assets/image-20230806211538991.png" alt="image-20230806211538991"></p><p><img src="/../image/assets/image-20230806213056289.png" alt="image-20230806213056289"></p><p><img src="/../image/assets/image-20230806215057163.png" alt="image-20230806215057163"></p><p><img src="/../image/assets/image-20230806215257865.png" alt="image-20230806215257865"></p><h2 id="文件管理概论"><a href="#文件管理概论" class="headerlink" title="文件管理概论"></a>文件管理概论</h2><p><img src="/../image/assets/image-20230804152522324.png" alt="image-20230804152522324"></p><ul><li>文件<ul><li>一组有意义的信息&#x2F;数据集合</li></ul></li><li>问题<ul><li>计算机中存放了各种各样的文件，一个文件有哪些属性？</li><li>文件内部的数据应该怎样组织起来？</li><li>文件之间又应该怎么组织起来？</li><li>从下往上看。OS 应提供哪些功能才能方便用户、应用程序使用文件？</li><li>从上向下看，文件数据应该怎么存放在外存（磁盘）上？</li></ul></li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p><img src="/../image/assets/image-20230804152816936.png" alt="image-20230804152816936"></p><ul><li>一个文件有哪些属性？<ul><li>文件名<ul><li>由创建文件的用户决定文件名，主要是为了方便用户找到文件</li><li>同一目录下不允许有重名文件</li></ul></li><li>标识符<ul><li>一个系统内的各文件标识符唯一，对用户毫无可读性</li><li>只是操作系统用于区分各个文件的一种内部名称</li></ul></li><li>类型<ul><li>指明文件的类型</li></ul></li><li>位置<ul><li>文件存放的路径<ul><li>让用户使用</li></ul></li><li>在外存中的地址<ul><li>操作系统使用，对用户不可见</li></ul></li></ul></li><li>大小<ul><li>指明文件大小</li></ul></li><li>创建时间、上次修改时间</li><li>文件所有者信息</li><li>保护信息<ul><li>对文件进行保护的访问控制信息</li></ul></li></ul></li></ul><h3 id="组织内部数据"><a href="#组织内部数据" class="headerlink" title="组织内部数据"></a>组织内部数据</h3><p><img src="/../image/assets/image-20230804153236967.png" alt="image-20230804153236967"></p><ul><li>无结构文件<ul><li>又称流式文件，如文本文件txt</li><li>由一些二进制或字符流组成</li><li>没有明显的结构特性</li></ul></li><li>有结构文件<ul><li>又称“记录式文件”</li><li>由一组<strong>相似的记录</strong>组成</li><li>数据项是文件系统中最基本的数据单位</li><li>记录是一组相关数据项的集合</li></ul></li></ul><h3 id="如何组织文件的内部数据"><a href="#如何组织文件的内部数据" class="headerlink" title="如何组织文件的内部数据"></a>如何组织文件的内部数据</h3><p><img src="/../image/assets/image-20230804155234582.png" alt="image-20230804155234582"></p><ul><li>有结构文件中，各个记录间应该如何组织的问题<ul><li>应该顺序存放？</li><li>用索引表表示记录间的顺序？<ul><li>这是文件的逻辑结构重点讨论的问题</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230804160606101.png" alt="image-20230804160606101"></p><ul><li>目录就是文件夹</li><li>用户可以自己创建一层一层的目录，各层目录中存放相应的文件<ul><li>系统中的各个文件就通过一层一层的目录合理有序的组织起来</li></ul></li><li>目录其实也是一种特殊的有结构文件<ul><li>由记录组成</li><li>重点：如何实现目录</li></ul></li></ul><h3 id="操作系统向上提供的功能"><a href="#操作系统向上提供的功能" class="headerlink" title="操作系统向上提供的功能"></a>操作系统向上提供的功能</h3><p><img src="/../image/assets/image-20230804160825437.png" alt="image-20230804160825437"></p><ul><li>创建文件<ul><li>点击新建后，图形化交互进程在背后调用了 create 系统调用</li></ul></li><li>读文件<ul><li>将文件数据读入内存，才能让 CPU 处理</li><li>双击之后，记事本应用程序通过操作系统提供的读文件功能，即 read 系统调用，将文件数据从外存读入内存，并显示在屏幕上</li></ul></li><li>写文件<ul><li>将更改过的文件数据写回外存</li><li>在记事本应用程序中编辑文件内容，点击保存后，记事本应用程序通过操作系统提供的写文件功能，即 write 系统调用，将文件数据从内存写回外存</li></ul></li><li>删除文件<ul><li>点击删除之后，图形化交互进程通过操作系统提供的删除文件功能，即 delete 系统调用，将文件数据从外存中删除</li></ul></li><li>打开文件<ul><li>open 系统调用</li><li>读写文件之前，需要打开文件</li></ul></li><li>关闭文件<ul><li>close 系统调用</li><li>读写文件结束之后，需要关闭文件</li></ul></li></ul><p><img src="/../image/assets/image-20230804164032052.png" alt="image-20230804164032052"></p><ul><li>可以用几个基本操作完成更复杂的操作<ul><li>复制文件<ul><li>先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</li></ul></li></ul></li></ul><h3 id="文件如何放到外存"><a href="#文件如何放到外存" class="headerlink" title="文件如何放到外存"></a>文件如何放到外存</h3><p><img src="/../image/assets/image-20230804164352285.png" alt="image-20230804164352285"></p><ul><li>与内存一样，外存也是由一个个存储单元组成的<ul><li>每个存储单元可以存储一定量的数据（如 1B）</li><li>每个存储单元对应一个物理地址</li></ul></li><li>类似于内存分为一个个内存块，外存也会分为一个个“块&#x2F;磁盘块&#x2F;物理块”<ul><li>每个磁盘块的大小是相等的，每块一般包含 2 的整数幂个地址<ul><li>本例中，一块包含 2^10个地址，即 1KB</li></ul></li><li>文件的逻辑地址也可以分为（逻辑块号，块内地址）</li><li>操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式</li><li>块内地址的位数取决于磁盘块的大小</li></ul></li><li>操作系统以块为单位为文件分配存储空间。<ul><li>即使一个文件大小只有 10B，但依然需要占用 1KB 的磁盘块。</li><li>外存中的数据读入内存时同样以块为单位</li></ul></li></ul><p><img src="/../image/assets/image-20230804165033686.png" alt="image-20230804165033686"></p><ul><li>连续存放<ul><li>文件数据放在连续的几个磁盘块中</li></ul></li><li>离散存放<ul><li>文件数据放在离散的几个磁盘块中<ul><li>如何记录各个磁盘块之间的先后顺序？</li><li>操作系统又应该怎么管理空闲磁盘块？</li></ul></li></ul></li></ul><h3 id="文件共享和文件保护"><a href="#文件共享和文件保护" class="headerlink" title="文件共享和文件保护"></a>文件共享和文件保护</h3><ul><li>文件共享：使多个用户可以共享使用一个文件</li><li>文件保护：如何保证不同的用户对文件有不同的操作权限</li></ul><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p><img src="/../image/assets/image-20230804165451105.png" alt="image-20230804165451105"></p><ul><li>逻辑结构<ul><li>在用户看来，文件内部的数据应该是如何组织起来的</li></ul></li><li>物理结构<ul><li>在操作系统看来，文件的数据时如何存放在外存中的</li></ul></li><li>类似于数据结构的逻辑结构和物理结构<ul><li>线性表就是一种逻辑结构</li><li>在用户角度<ul><li>线性表就是一组有先后关系的元素序列，如 a,b,c,d,e…..</li></ul></li><li>线性表可以用不同的物理结构实现<ul><li>顺序表和链表</li><li>顺序表的各个元素在逻辑上相邻，在物理上也相邻</li><li>链表的各个元素在物理上可以是不相邻的<ul><li>顺序表可以实现随机访问，链表无法实现随机访问</li></ul></li></ul></li><li>算法的实现与逻辑结构、物理结构都有关</li><li>文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关</li></ul></li></ul><h3 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h3><p><img src="/../image/assets/image-20230804165948942.png" alt="image-20230804165948942"></p><ul><li>无结构文件<ul><li>文件内部的数据就是一系列二进制流或字符流组成，没有明显的 结构特性</li><li>又称流式文件，如 txt 文件</li></ul></li></ul><h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><p><img src="/../image/assets/image-20230804170416051.png" alt="image-20230804170416051"></p><ul><li>有结构文件<ul><li>又称记录式文件</li><li>由一组相似的记录组成，每个记录由若干个数据项组成</li><li>如数据库表文件</li><li>每条记录都有一个数据项可以作为<strong>关键字</strong>。</li><li>根据各条记录的长度（占用存储空间）是否相等，分为定长记录和可变长记录</li></ul></li></ul><p><img src="/../image/assets/image-20230804170433047.png" alt="image-20230804170433047"></p><ul><li>定长记录<ul><li>每条记录的长度都相同（供 128B）</li><li>各个数据项都处在记录中相同的位置，具有相同的顺序和长度<ul><li>前 32B 一定是学号，之后 32B 一定是姓名</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230804170606124.png" alt="image-20230804170606124"></p><ul><li>可变长记录<ul><li>数据项的长度不确定，记录各条记录的长度也不确定</li></ul></li></ul><p><img src="/../image/assets/image-20230804170658965.png" alt="image-20230804170658965"></p><ul><li>根据有结构文件中的各条记录在逻辑上如何组织，可分为三类</li></ul><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p><img src="/../image/assets/image-20230804170812151.png" alt="image-20230804170812151"></p><ul><li><p>顺序存储</p><ul><li>逻辑上相邻的记录物理上也相邻</li><li>类似于顺序表</li></ul></li><li><p>链式存储</p><ul><li>逻辑上相邻的记录物理上不一定相邻</li><li>类似于链表</li></ul></li><li><p>顺序文件</p><ul><li><p>串结构</p><ul><li>记录之间的顺序与关键字无关</li></ul></li><li><p>顺序结构</p><ul><li>记录之间的顺序按关键字顺序排列</li></ul></li><li><p>通常按照记录存入的事件决定记录的顺序</p></li></ul></li><li><p>问题</p><ul><li>假设已经知道了文件的起始地址（第一个记录存放的位置）</li><li>能否快速找到第 i 个记录对应的地址？<ul><li>能否实现随机存取？</li></ul></li><li>能否快速找到某个关键字对应的记录存放的位置？</li></ul></li></ul><p><img src="/../image/assets/image-20230804175059650.png" alt="image-20230804175059650"></p><ul><li>定长记录的顺序文件<ul><li>若物理上采用顺序存储，则可实现随机存取</li><li>若能再保证记录的顺序结构，则可实现快速检索<ul><li>根据关键字快速找到对应记录</li></ul></li></ul></li><li>顺序文件<ul><li>一般指的是物理上顺序存储的顺序文件</li></ul></li><li>缺点<ul><li>增加、删除一个记录比较困难（如果是串结构则相对简单）</li></ul></li></ul><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p><img src="/../image/assets/image-20230804175637751.png" alt="image-20230804175637751"></p><ul><li>对于可变长记录文件，要找到第 i 个记录，就必须先顺序查找前 i-1 个记录<ul><li>但是很多应用场景中，又必须使用可变长记录</li></ul></li><li>如何解决？<ul><li>建立一张索引表来加快文件检索速度<ul><li>每条记录对应一个索引项</li><li>索引表对应的逻辑文件中的记录在物理上可以离散的存放</li></ul></li><li>索引表<ul><li>定长记录的顺序文件</li><li>可以快速找到第 i 个记录对应的索引表</li><li>可将关键字作为索引号内容，若按关键字顺序排列，还可以支持按照关键字折半查找</li><li>索引文件具有较快的检索速度，<strong>主要用于对信息处理的及时性要求比较高的场合</strong></li></ul></li><li>每当要增加&#x2F;删除一个记录<ul><li>需要对索引表进行修改</li></ul></li><li>可以用不同的数据项建立多个索引表<ul><li>学生信息表中<ul><li>可以用“学号”建立一张索引表</li><li>也可用用“姓名”建立一张索引表</li></ul></li><li>SQL 就支持根据某个数据项建立索引的功能</li></ul></li></ul></li></ul><h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p><img src="/../image/assets/image-20230804180417651.png" alt="image-20230804180417651"></p><ul><li>索引文件<ul><li>缺点<ul><li>每个记录对应一个索引表项，因此索引表可能会很大<ul><li>假设文件的每个记录平均只占 8B，而每个索引表项占 32 个字节</li><li>索引表本身都要比文件内容大 4 倍，对存储空间的利用率太低</li></ul></li></ul></li></ul></li><li>索引顺序文件<ul><li>索引文件额顺序文件思想的结合<ul><li>索引顺序文件中，同样会为文件建立一张索引表</li><li>但并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项</li></ul></li><li><strong>索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入</strong></li></ul></li><li>在例子中<ul><li>学生记录按照学生姓名的开头字母进行分组</li><li>每个分组就是一个顺序文件</li><li>分组内的记录不需要按关键字排序</li></ul></li></ul><p><img src="/../image/assets/image-20230804190725964.png" alt="image-20230804190725964"></p><ul><li><p>若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构 的顺序文件），平均须查找 5000 个记录。</p></li><li><p>若采用索引顺序文件结构，可把 10000 个记录分为 √10000 &#x3D; 100 组，每组 100 个记录。则需要先顺序查找 索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中顺序查找记录（每个分组100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，平均查找次数减少为 50+50 &#x3D; 100 次。</p></li><li><p>同理，若文件共有 106个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录平均需要查找 500+500 &#x3D; 1000 次。这个查找次数依然很多，如何解决呢？</p></li></ul><p><img src="/../image/assets/image-20230804190844853.png" alt="image-20230804190844853"></p><ul><li><p>多级索引顺序文件</p><ul><li>Tips: 要为 N 个记录的文件建立 K 级索引，则最优的分组是每组 N1&#x2F;(K+1)个记录。</li><li>检索一个记录的平均查找 次数是 ((N1&#x2F;(K+1) )&#x2F;2) * (K+1)</li><li>如：本例中，建立 2级索 引，则最优分组为每组100000^1&#x2F;3 &#x3D; 100 个记录，平均查找次数是 (100&#x2F;2) * 3 &#x3D; 150 次</li></ul></li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul><li>文件控制块和目录都是操作系统内核空间中用于管理文件和文件系统的重要数据结构。<ul><li><strong>它们加载到内存，便一直存放在操作系统内核空间里面的</strong></li></ul></li><li>内存中并不总是包含所有的目录项，尤其是当目录项的数量非常多时，无法一次性全部加载到内存中。在某些情况下，操作系统需要从磁盘中读取目录项到内存中，以便进行文件的查找、打开、读写等操作。这个过程涉及到磁盘 I&#x2F;O 操作，也就是从磁盘读取数据到内存的操作，以满足程序或用户的需求。</li></ul><p><img src="/../image/assets/image-20230804191438964.png" alt="image-20230804191438964"></p><ul><li><p>这种目录结构对于用户来说有什么好处？</p><ul><li>文件之间的组织结构清晰，易于查找</li></ul></li><li><p>编程时也可以很方便的使用文件路径找到一个文件</p><ul><li>FILE *fp; fp &#x3D; fopen(“F:\data\myfile.dat”)</li><li>用户可以轻松实现按名存取</li></ul></li><li><p>从操作系统的角度来看，这些目录结构应该是如何实现的？</p></li></ul><p><img src="/../image/assets/image-20230804191722783.png" alt="image-20230804191722783"></p><h3 id="文件控制块（实现文件目录的关键数据结构）"><a href="#文件控制块（实现文件目录的关键数据结构）" class="headerlink" title="文件控制块（实现文件目录的关键数据结构）"></a>文件控制块（实现文件目录的关键数据结构）</h3><p><img src="/../image/assets/image-20230804192045226.png" alt="image-20230804192045226"></p><ul><li>目录本身就是一种有结构文件，由一条条记录组成</li><li>每条记录对应一个在该目录下的文件</li><li>当我们双击“照片”后<ul><li>操作系统会在这个目录表中找到关键字“照片”对应的目录项（也就是记录）</li><li>然后从外存中将“照片”目录的信息读入内存</li><li>于是，照片目录中的内容就可以显示出来了</li></ul></li></ul><p><img src="/../image/assets/image-20230804192509991.png" alt="image-20230804192509991"></p><ul><li><p>照片目录对应的目录文件</p><ul><li>目录文件中的一条记录就是一个文件控制块（FCB）</li></ul></li><li><p>FCB 的有序集合称为文件目录</p><ul><li>一个 FCB 就是一个文件目录项</li><li>FCB 中包含了<ul><li>文件的基本信息（文件名、物理地址、逻辑地址、物理结构等）</li><li>存取控制信息（是否可读&#x2F;可写，禁止访问的用户名单等）</li><li>使用信息（文件创建时间、修改时间）</li></ul></li><li><strong>最重要、最基本的是文件名、文件存放的物理地址</strong><ul><li>FCB 实现了文件名与文件之间的映射。使用户（用户程序）可以实现“按名存取”</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230804192953712.png" alt="image-20230804192953712"></p><ul><li>对目录进行的操作<ul><li>搜索<ul><li>当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li></ul></li><li>创建文件<ul><li>创建一个新文件时，需要在其所属的目录中增加一个目录项</li></ul></li><li>删除文件<ul><li>当删除一个文件时，需要在目录中删除对应的目录项</li></ul></li><li>显示目录<ul><li>用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li></ul></li><li>修改目录<ul><li>某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项</li><li>如文件重命名</li></ul></li></ul></li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p><img src="/../image/assets/image-20230804193433448.png" alt="image-20230804193433448"></p><ul><li>单级目录结构<ul><li>早期操作系统并不支持多级目录，<strong>整个系统只建立一张目录表</strong>，每个文件占一个目录表</li><li>单级目录实现了“按名存取”，但是<strong>不允许文件重名</strong></li><li>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中</li><li>显然，单级目录结构不适用于多用户操作系统</li></ul></li></ul><h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p><img src="/../image/assets/image-20230804193731147.png" alt="image-20230804193731147"></p><ul><li>两级目录结构<ul><li>早期的多用户操作系统，采用两级目录结构<ul><li>主文件目录<ul><li>记录用户名及相应用户文件目录的存放位置</li></ul></li><li>用户文件目录<ul><li>由该用户的文件的 FCB 组成</li></ul></li></ul></li><li>两级目录结构允许不同用户的文件重名，也可以在目录上实现访问限制（检查此时登录的用户名是否匹配）</li><li>缺点<ul><li>缺乏灵活性</li><li>用户不能对自己的文件进行分类</li></ul></li></ul></li></ul><h4 id="多级目录结构（树形目录结构）"><a href="#多级目录结构（树形目录结构）" class="headerlink" title="多级目录结构（树形目录结构）"></a>多级目录结构（树形目录结构）</h4><p><img src="/../image/assets/image-20230804194907551.png" alt="image-20230804194907551"><br><img src="/../image/assets/image-20230804194935511.png" alt="image-20230804194935511"><br><img src="/../image/assets/image-20230804195001076.png" alt="image-20230804195001076"></p><ul><li><p>绝对路径</p><ul><li>用户（或用户进程）想要访问某个文件时要用文件路径名标识文件</li><li>文件路径名是个字符串，<strong>各级目录之间用“&#x2F;”隔开，从根目录出发的路径称为绝对路径</strong><ul><li>如：自拍.jpg的绝对路径是“&#x2F;照片&#x2F;2015-08&#x2F;自拍.jpg”</li></ul></li><li>查找过程<ul><li>系统根据绝对路径一层一层的找到下一级目录</li><li>刚开始从外存读入根目录的目录表；找到照片目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应的目录表；最后才找到文件“自拍.jpg”的存放位置</li><li>整个过程需要 3 次读磁盘 I&#x2F;O操作</li></ul></li></ul></li><li><p>相对位置</p><ul><li><p>很多时候用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）</p><ul><li><p>每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”</p></li><li><p>例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已经调入内存，那么可以把它设置为“当前目录”。</p></li><li><p>当用户想要访问某个文件时，可以<strong>使用从当前目录出发的相对路径</strong></p></li><li><p>在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则“自拍.jpg”的相对路径是“.&#x2F;2015-08&#x2F;自拍.jpg”</p></li><li><p>从当前路径出发，只需要查询内存中的“照片”目录表，即可知道“2015-08”目录表的存放位置，从外存调入该目录，即可知道”自拍.jpg”存放的位置</p></li></ul></li><li><p>引入<strong>“当前目录”和“相对路径”</strong>后，磁盘 I&#x2F;O的次数减少了，这就提升了访问文件的效率</p></li></ul></li><li><p>优点</p><ul><li>树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够更有效的进行文件的管理和保护</li></ul></li><li><p>缺点</p><ul><li><strong>树形结构不便于实现文件共享，为此提出了无换图目录结构</strong></li></ul></li></ul><h4 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h4><p><img src="/../image/assets/image-20230804200249674.png" alt="image-20230804200249674"></p><ul><li>无环图目录结构<ul><li>实现方式<ul><li>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）</li></ul></li><li>删除操作<ul><li>需要为每个共享节点设置一个共享计数器，用于记录此时有多少个地方在共享该节点</li><li>用户提出删除节点的请求时，只是删除该用户的FCB，并使共享计数器减 1，并不会直接删除共享节点</li><li>只有共享计数器减为 0 时，才删除节点</li></ul></li><li>注意<ul><li>共享文件不同于复制文件</li><li>在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</li></ul></li></ul></li></ul><h3 id="索引节点（对文件控制块的优化）"><a href="#索引节点（对文件控制块的优化）" class="headerlink" title="索引节点（对文件控制块的优化）"></a>索引节点（对文件控制块的优化）</h3><p><img src="/../image/assets/image-20230804201126714.png" alt="image-20230804201126714"></p><p><img src="/../image/assets/image-20230804201231362.png" alt="image-20230804201231362"></p><ul><li><p>索引节点</p><ul><li><strong>在查找各级目录的过程中只需要用到“文件名”这个信息</strong></li><li>只有文件名匹配时，才需要读出文件的其他信息</li><li>因此可以考虑让目录表“瘦身”来提升效率</li></ul></li><li><p>思考</p><ul><li><p>假设一个FCB是64B，磁盘块的大 小为1KB，则每个盘块中只能存放16个FCB。</p><ul><li><p>若一个文件目录中共有640个目录项，则共需要占用640&#x2F;16 &#x3D; 40 个盘块。因此按照某文件名检索该目录，平均需要查询320 个目录项，平均需要启动磁盘20次（每次磁盘I&#x2F;O读入一块）</p><ul><li><p>内存中并不总是包含所有的目录项，尤其是当目录项的数量非常多时，无法一次性全部加载到内存中。在某些情况下，操作系统需要从磁盘中读取目录项到内存中，以便进行文件的查找、打开、读写等操作。这个过程涉及到磁盘 I&#x2F;O 操作，也就是从磁盘读取数据到内存的操作，以满足程序或用户的需求。</p><p>在你的理解中，当操作系统需要查找某个文件时，它首先会查看内存中的目录结构。如果所需的目录项已经在内存中，那么就可以直接在内存中找到文件信息。但如果目录项不在内存中，操作系统就需要通过磁盘 I&#x2F;O 操作，从磁盘中读取相应的目录块（包含目录项）到内存中，然后再在内存中进行查找，最终找到所需的文件信息。</p><p>总之，内存中的目录结构可以看作是一个缓存，用于加速文件的查找和访问。但由于内存有限，无法容纳所有的目录项，因此有时候仍然需要从磁盘中读取数据到内存，以满足操作系统和应用程序的需要。</p></li></ul></li><li><p>若使用索引结点机制，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入 320&#x2F;64 &#x3D; 5 个磁盘块。显然，这将大大提升文件检索速度。</p><ul><li>当找到文件名对应的目录项的时候，才需要将索引节点调入内存，索引节点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件</li><li><strong>存放在外存中的索引节点称为“磁盘索引节点”，当索引节点放入内存后称为“内存索引节点”</strong></li><li>相比之下内存索引节点中需要增加一些信息<ul><li>文件是否被修改、此时有几个进程正在访问该文件</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="文件的物理结构（文件分配方式）"><a href="#文件的物理结构（文件分配方式）" class="headerlink" title="文件的物理结构（文件分配方式）"></a>文件的物理结构（文件分配方式）</h2><p><img src="/../image/assets/image-20230804204441644.png" alt="image-20230804204441644"></p><ul><li>对非空闲磁盘块的管理（存放量文件数据的磁盘块）<ul><li>文件的物理结构&#x2F;文件分配方式要探讨的问题</li><li>文件数据应该怎样存放在外存中</li></ul></li><li>对空闲磁盘块的管理<ul><li>“文件存储空间管理”要探讨的内容</li></ul></li></ul><p><img src="/../image/assets/image-20230804204919793.png" alt="image-20230804204919793"></p><h3 id="复习：文件块、磁盘块"><a href="#复习：文件块、磁盘块" class="headerlink" title="复习：文件块、磁盘块"></a>复习：文件块、磁盘块</h3><p><img src="/../image/assets/image-20230804204954625.png" alt="image-20230804204954625"></p><ul><li>类似于内存分页，磁盘中的存储单元也会被分为一个个“块&#x2F;磁盘块&#x2F;物理块”<ul><li>很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong></li></ul></li><li>内存与磁盘之间的数据交换（读写操作、磁盘 I&#x2F;O）<ul><li>读写操作、磁盘 I&#x2F;O都是以块为单位进行的</li><li>每次读入一块，或者写出一块</li></ul></li></ul><p><img src="/../image/assets/image-20230804205313994.png" alt="image-20230804205313994"></p><ul><li>在内存管理中，进程的逻辑地址空间被分为一个一个页面<ul><li>若块的大小是 1KB，则 1MB 大小的文件可以分为 1K 个块</li></ul></li><li>在外存管理中，为了方便对文件数据的管理，<strong>文件的逻辑地址空间也被分为了一个一个的文件块</strong><ul><li>文件的逻辑地址也可以表示位（逻辑块号，块内地址）的形式</li></ul></li><li>操作系统为文件分配存储空间都是以块为单位<ul><li>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射</li></ul></li></ul><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p><img src="/../image/assets/image-20230804205708213.png" alt="image-20230804205708213"></p><ul><li><strong>连续分配方式要求每个文件在磁盘上占有一组连续的块</strong><ul><li>用户通过逻辑地址来操作自己的文件，操作系统如何实现从偶记地址到物理地址的映射？<ul><li>（逻辑块号，块内地址）—&gt; （物理块号，块内地址）</li><li>只需要转换块号就可以，块内地址保持不变</li></ul></li><li>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB）<ul><li>物理块号 &#x3D; 起始块号 + 逻辑块号</li></ul></li><li>需要检查用户提供的逻辑块号是否合法<ul><li>逻辑块号 &gt;&#x3D; 长度就不合法</li></ul></li><li>可以直接算出逻辑块号对应的物理块号，因此<strong>连续分配支持顺序访问和直接访问（即随机访问）</strong><ul><li>顺序访问：访问 2 要先访问 0 和 1</li><li>直接访问：可以直接访问 2</li></ul></li></ul></li><li><strong>文件目录中记录存放的起始块号和长度（总共占用几个块）</strong></li></ul><p><img src="/../image/assets/image-20230804210323928.png" alt="image-20230804210323928"></p><ul><li>读取某个磁盘块时，需要移动磁头<ul><li>访问的两个磁盘块相隔越远，移动磁头所需时间就越长</li><li>结论<ul><li><strong>连续分配的文件在顺序读&#x2F;写时速度最快</strong></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230804210507007.png" alt="image-20230804210507007"></p><p><img src="/../image/assets/image-20230804210606061.png" alt="image-20230804210606061"></p><p><img src="/../image/assets/image-20230804210745730.png" alt="image-20230804210745730"></p><ul><li>缺点<ul><li>不方便拓展</li><li>存储空间利用率低，会产生难以利用的磁盘碎片<ul><li>可以用紧凑来处理碎片，但是需要耗费很大的事件代价</li></ul></li></ul></li><li>优点<ul><li>支持顺序访问和随机访问</li><li>连续分配的文件在顺序访问时速度最快</li></ul></li></ul><h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p><img src="/../image/assets/image-20230804211136162.png" alt="image-20230804211136162"></p><ul><li>采取离散分配的方式，可以为文件分配离散的磁盘块</li></ul><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p><img src="/../image/assets/image-20230804211207715.png" alt="image-20230804211207715"><br><img src="/../image/assets/image-20230804211548593.png" alt="image-20230804211548593"><br><img src="/../image/assets/image-20230804211600036.png" alt="image-20230804211600036"></p><ul><li>隐式链接<ul><li>目录<ul><li>记录了文件存放的<strong>起始块号和结束块号</strong></li><li>可以增加一个字段来表示文件的<strong>长度</strong></li><li>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的</li></ul></li><li>如何实现文件的逻辑块号到物理块号的转换？<ul><li>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）</li><li>从目录项中找到起始块号（即 0 号块），将 0 号逻辑块读入内存，由此知道 1 号逻辑块存放的物理块号，于是读入 1 号逻辑块，再找到 2 号逻辑块的存放位置…..以此类推</li><li>读入 i 号逻辑块，总共需要 i+1 次磁盘 I&#x2F;O</li></ul></li><li>采用链式分配（隐式链接）方式的文件<ul><li>优点<ul><li>很方便文件拓展，不会有碎片问题，外存利用率高</li></ul></li><li>缺点<ul><li>只支持顺序访问，不支持随机访问</li><li>查找效率低</li><li>指向下一个盘块的指针也需要耗费少量的存储空间</li></ul></li></ul></li></ul></li></ul><h4 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h4><p><img src="/../image/assets/image-20230804211723355.png" alt="image-20230804211723355"><br><img src="/../image/assets/image-20230804212229258.png" alt="image-20230804212229258"><br><img src="/../image/assets/image-20230804212320153.png" alt="image-20230804212320153"></p><ul><li><p>考试中遇到未指明隐式链接&#x2F;显式链接的链接分配，默认是指隐式链接的链接分配</p></li><li><p>显式链接</p><ul><li><p>目录</p><ul><li>只需记录文件的起始块号</li></ul></li><li><p>文件分配表</p><ul><li>把用于链接文件各物理块的指针显式的存放在一张表中</li><li><strong>一个磁盘仅设置一张 FAT。开机时，将 FAT 读入内存，并常驻内存</strong></li><li>FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的</li></ul></li><li><p>如何实现文件的逻辑块号到物理块号的转变？</p><ul><li>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）</li><li>从目录项中找到起始块号，若 i&gt;0，则查询内存中的文件分配表 FAT，往后找到 i 号逻辑块对应的物理块号<ul><li>逻辑块号转换成物理块号的过程不需要读磁盘操作</li></ul></li></ul></li><li><p>优点</p><ul><li>很方便文件拓展，不会有碎片问题，外存利用率高</li><li>支持顺序访问，也支持随机访问<ul><li>想访问 i 号逻辑块时，不需要一次访问之前的 0~i-1号逻辑块</li></ul></li><li>相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高</li></ul></li><li><p>缺点</p><ul><li>文件分配表需要占用一定的存储空间</li></ul></li></ul></li></ul><h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p><img src="/../image/assets/image-20230804213755082.png" alt="image-20230804213755082"></p><p><img src="/../image/assets/image-20230804215126243.png" alt="image-20230804215126243"></p><ul><li>索引分配<ul><li>目录<ul><li>需要记录文件的索引块是几号磁盘块</li></ul></li><li>实现<ul><li>允许文件离散地分配在各个磁盘块中</li><li>系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块<ul><li>索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系</li></ul></li><li>索引表存放的磁盘块称为索引块</li><li>文件数据存放的磁盘块称为数据块</li></ul></li><li>过程<ul><li>假设某个新创建的文件“aaa”的数据以此存放在磁盘块 2—&gt;5—&gt;13—&gt;9</li><li>7 号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容</li></ul></li><li>区别<ul><li>在显式链接的链式分配方式中，文件分配表 FAT 是一个磁盘对应一张</li><li>而<strong>索引分配方式中，索引表是一个文件对应一张</strong></li></ul></li><li>可以用固定的长度表示物理块号<ul><li>假设磁盘总容量是 1TB&#x3D;2^40B，磁盘块大小为 1KB，则总共有 2^30个磁盘块，则可用 4B 表示磁盘块号<ul><li>因此，索引表中的“逻辑块号”可以是隐含的</li></ul></li></ul></li><li>如何实现文件的逻辑块号到物理块号的转换？<ul><li>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）</li><li>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可知道 i 号逻辑块在外存中的存放位置</li></ul></li><li>优点<ul><li>可以支持随机访问</li><li>文件拓展也很容易实现<ul><li>只需要给文件分配一个空闲块，并且增加一个索引表项就可以</li></ul></li></ul></li><li>缺点<ul><li>索引表需要占用一定的存储空间</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230805145357861.png" alt="image-20230805145357861"></p><ul><li>若每个磁盘块 1KB，一个索引表项 4B，则一个磁盘块只能存放 256 个索引项<ul><li>如果一个文件的大小超过了 256 块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？<ul><li>链接方案</li><li>多层索引</li><li>混合索引</li></ul></li></ul></li></ul><h4 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h4><p><img src="/../image/assets/image-20230805145930763.png" alt="image-20230805145930763"></p><ul><li>链接方案<ul><li>如果索引表太大，一个索引表放不下，那么可以<strong>将多个索引表链接起来存放</strong><ul><li>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。</li><li>若一个文件大小为 256*256KB &#x3D;65,536 KB &#x3D; 64MB该文件共有 256*256 个块，也就对应256*256个索引项，也就需要 256 个索引块来存储，这些索引块用链接方案连起来。</li><li>若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第256个索引块），而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前 255 个索引块。</li></ul></li><li>缺点<ul><li>若文件很大，索引表很长，就需要将很多个索引块链接起来。</li><li>想要找到第 i 号索引块，就必须先依次读入 0~i-1 号索引块，这就导致磁盘 I&#x2F;O次数过多，查找效率低下</li></ul></li></ul></li></ul><h4 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h4><p><img src="/../image/assets/image-20230805150232371.png" alt="image-20230805150232371"></p><ul><li><p>多层索引</p><ul><li><p>建立多层索引（类似于多级页表）</p></li><li><p>使第一层索引块指向第二层索引块，还可以根据文件大小的要求再建立第三层、第四层索引块</p></li><li><p>若采用多级索引，则各层索引表大小不能超过一个磁盘块</p></li><li><p>采用二层索引，文件的最大长度 256*256*1KB &#x3D; 64MB</p></li><li><p>采用三层索引，文件的 最大长度 256*256*256*1KB &#x3D; 16GB</p></li><li><p>采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K + 1 次读磁盘操作</p><ul><li>可根据逻辑块号算出应该查找索引表中的哪个表项。</li><li>如：要访问 1026 号逻辑块，则1026&#x2F;256 &#x3D; 4，1026%256 &#x3D; 2</li><li>因此可以先将<strong>一级索引表</strong>调入内存，查询 4 号表项，将其对应的<strong>二级索引表</strong>调入内存，再查询二级索引表 的2号表项即可知道 <strong>1026 号逻辑块存放的磁盘块号</strong>了。</li><li><strong>访问目标数据块，需要3次磁盘I&#x2F;O</strong></li></ul></li></ul></li><li><p>缺点</p><ul><li>即使是小文件，访问一个数据块依然需要 K+1 次读磁盘</li></ul></li></ul><h4 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h4><p><img src="/../image/assets/image-20230805165526605.png" alt="image-20230805165526605"></p><ul><li><p>混合索引</p><ul><li><strong>多种索引分配方式的结合</strong>，上图结构的索引支持最大文件长度为 65800KB</li><li>例如：一个文件的顶级索引表包含<ul><li>直接地址索引（直接指向数据块）：8 个</li><li>一级间接索引（指向单层索引表）：1 个</li><li>两级间接索引（指向两层索引表）：1 个</li></ul></li><li>若顶级索引表还没有读入内存<ul><li>访问 0~7号逻辑块：两次读磁盘</li><li>访问 8~263 号逻辑块：三次读磁盘</li><li>访问 264~65799 号逻辑块：四次读磁盘</li></ul></li><li>对于小文件只需较少的读磁盘次数就可以访问目标数据块（一般来说计算机中小文件更多）</li></ul></li><li><p>优点</p><ul><li>对于小文件来说，访问一个数据块所需的读磁盘次数更少</li></ul></li></ul><p><img src="/../image/assets/image-20230805170745485.png" alt="image-20230805170745485"></p><ul><li>超级超级超级超级重要的考点<ul><li>要会根据多层索引、混合索引的结构计算出文件的最大长度<ul><li>各级索引表最大不能超过一个块</li></ul></li><li>要能自己分析访问某个数据块所需要的读磁盘次数<ul><li>FCB 中会存有指向顶级索引块的指针，因此可以根据 FCB 读入顶级索引块</li><li>每次读入下一级的索引块都需要一次读磁盘奥做</li><li>注意题目条件——顶级索引块是否已经调入内存</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230805171234545.png" alt="image-20230805171234545"></p><h2 id="逻辑结构-VS-物理结构"><a href="#逻辑结构-VS-物理结构" class="headerlink" title="逻辑结构 VS 物理结构"></a>逻辑结构 VS 物理结构</h2><p><img src="/../image/assets/image-20230805171404756.png" alt="image-20230805171404756"></p><p><img src="/../image/assets/image-20230805171413328.png" alt="image-20230805171413328"></p><h3 id="逻辑结构（从用户视角看）"><a href="#逻辑结构（从用户视角看）" class="headerlink" title="逻辑结构（从用户视角看）"></a>逻辑结构（从用户视角看）</h3><h4 id="无结构文件-1"><a href="#无结构文件-1" class="headerlink" title="无结构文件"></a>无结构文件</h4><p><img src="/../image/assets/image-20230805172951441.png" alt="image-20230805172951441"></p><p><img src="/../image/assets/image-20230805173004870.png" alt="image-20230805173004870"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写操作</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt;<span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;cylhbb!!&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    FILE *fp2 = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Fail to open file!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fseek</span>(fp2,<span class="number">16</span>,SEEK_SET);             <span class="comment">//读写指针指向 16</span></span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">fgetc</span>(fp2);                <span class="comment">//从读写指针所指位置读出一个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符：%c&quot;</span>, c);              <span class="comment">//打印从文件读出的字符</span></span><br><span class="line">    <span class="built_in">fclose</span>(fp2);</span><br></pre></td></tr></table></figure><h4 id="有结构文件-1"><a href="#有结构文件-1" class="headerlink" title="有结构文件"></a>有结构文件</h4><p><img src="/../image/assets/image-20230805174310539.png" alt="image-20230805174310539"></p><ul><li>用户角度<ul><li>每个学生记录占 64B   sizeof(Student_info)</li><li>用逻辑地址访问文件</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="type">char</span> major[<span class="number">30</span>];</span><br><span class="line">&#125; Student_info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//以写的方式打开文件</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;Student_info&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Student_info student[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        student[i].number = i;</span><br><span class="line">        student[i].name[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        student[i].major[<span class="number">0</span>]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fwrite</span>(student,<span class="built_in">sizeof</span>(Student_info), N, fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以读的方式打开文件</span></span><br><span class="line">    FILE *fp2 = <span class="built_in">fopen</span>(<span class="string">&quot;Student_info&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件读写指针指向编号为 5 的学生记录</span></span><br><span class="line">    Student_info stu;</span><br><span class="line">    <span class="built_in">fseek</span>(fp2, <span class="number">10</span>*<span class="built_in">sizeof</span>(Student_info), SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从文件读出 1 条记录，记录大小为 sizeof(Student_info)</span></span><br><span class="line">    <span class="built_in">fread</span>(&amp;stu, <span class="built_in">sizeof</span>(Student_info), <span class="number">1</span>, fp2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生编号：%d&quot;</span>, stu.number);</span><br><span class="line">    <span class="built_in">fclose</span>(fp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="物理结构（从操作系统视角看）"><a href="#物理结构（从操作系统视角看）" class="headerlink" title="物理结构（从操作系统视角看）"></a>物理结构（从操作系统视角看）</h3><h4 id="无结构文件-2"><a href="#无结构文件-2" class="headerlink" title="无结构文件"></a>无结构文件</h4><p><img src="/../image/assets/image-20230805173156391.png" alt="image-20230805173156391"></p><p><img src="/../image/assets/image-20230805174052895.png" alt="image-20230805174052895"></p><p><img src="/../image/assets/image-20230805174132943.png" alt="image-20230805174132943"></p><ul><li>操作系统视角<ul><li>一堆二进制数据</li><li>每个磁盘块可以存储 1KB，拆开存储</li><li>文件数据被操作系统拆分成若干个块，逻辑块号相邻</li></ul></li><li>用户<ul><li>使用 C 语言库函数 fseek，将文件读写指针指向位置 n（指明逻辑地址）</li><li>使用 C语言库函数 fgetc，从读写指针所指位置读出 1B 内容<ul><li>fgetc 底层使用了Read 系统调用，操作系统将（逻辑块号，块内偏移量）转换为（物理块号，块内偏移量）</li></ul></li></ul></li><li>连续分配：逻辑上相邻的块物理上也相邻</li><li>链接分配：逻辑上相邻的块在物理上用链接指针表示先后顺序</li><li>索引分配：操作系统为每个文件维护一张索引表，其中记录了逻辑块号—&gt;物理块号的映射关系</li></ul><h4 id="有结构文件-2"><a href="#有结构文件-2" class="headerlink" title="有结构文件"></a>有结构文件</h4><p><img src="/../image/assets/image-20230805175644794.png" alt="image-20230805175644794"></p><ul><li>操作系统<ul><li>反正就是一堆二进制数据，每个磁盘块可以存储 1KB，拆开存储就完事了</li></ul></li></ul><h3 id="存储-VS-分配"><a href="#存储-VS-分配" class="headerlink" title="存储  VS  分配"></a>存储  VS  分配</h3><p><img src="/../image/assets/image-20230805175709475.png" alt="image-20230805175709475"></p><ul><li><p>顺序文件采用顺序存储&#x2F;链式存储（用户自己规定的）</p><ul><li><p>顺序存储</p><ul><li><p>每条记录相邻着存放</p></li><li><p>支持随机访问：可以直接确定第 i 条记录的逻辑地址</p></li><li><pre><code class="C++">typedef struct&#123;    int number;    char name[30];    char major[30];&#125; Student_info;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 链式存储</span><br><span class="line"></span><br><span class="line">  - 各条记录离散着存放，用指针表示先后顺序</span><br><span class="line"></span><br><span class="line">  - ```C++</span><br><span class="line">    typedef struct&#123;</span><br><span class="line">        int number;</span><br><span class="line">        char name[30];</span><br><span class="line">        char major[30];</span><br><span class="line">      int next; //下一个学生记录的存放位置</span><br><span class="line">    &#125; Student_info;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230805180102118.png" alt="image-20230805180102118"></p><p><img src="/../image/assets/image-20230805180202955.png" alt="image-20230805180202955"></p><ul><li>文件内部各条记录如何存储由创建文件的用户自己设计<ul><li>顺序文件存储<ul><li>顺序存储：数组</li><li>链式存储：链表</li></ul></li></ul></li><li>文件整体存储用什么分配由操作系统决定<ul><li>顺序文件存储分配<ul><li>连续分配：逻辑上相邻的块物理上也相邻</li></ul></li><li>顺序文件链接分配<ul><li>链接分配：各条记录离散存放，指针表示先后关系</li></ul></li></ul></li></ul><h3 id="逻辑结构：索引文件"><a href="#逻辑结构：索引文件" class="headerlink" title="逻辑结构：索引文件"></a>逻辑结构：索引文件</h3><p><img src="/../image/assets/image-20230805180712594.png" alt="image-20230805180712594"></p><ul><li>索引文件<ul><li>从用户视角来看，整个文件依然是连续存放的</li><li>如：前 1MB 存放索引项，后续部分存放记录</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> number;<span class="comment">//学号</span></span><br><span class="line">  <span class="type">int</span> addr;<span class="comment">//学生记录的逻辑地址</span></span><br><span class="line">&#125; IndexTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">30</span>];<span class="comment">//姓名</span></span><br><span class="line">  <span class="type">char</span> major[<span class="number">30</span>];<span class="comment">//专业</span></span><br><span class="line">&#125; Student_info;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230805181000370.png" alt="image-20230805181000370"></p><ul><li>索引文件的索引表<ul><li>用户自己建立的</li><li>映射<ul><li>关键字—&gt;记录存放的逻辑地址</li></ul></li></ul></li><li>索引分配的索引表<ul><li>操作系统建立的</li><li>映射<ul><li>逻辑块号—&gt;物理块号</li></ul></li></ul></li></ul><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><h3 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h3><p><img src="/../image/assets/image-20230805181408087.png" alt="image-20230805181408087"></p><ul><li>从三个方面理解<ul><li>用什么方式记录、组织空闲块</li><li>如何分配磁盘块</li><li>如何回收磁盘块</li></ul></li></ul><h4 id="文件卷（逻辑卷）的概念"><a href="#文件卷（逻辑卷）的概念" class="headerlink" title="文件卷（逻辑卷）的概念"></a>文件卷（逻辑卷）的概念</h4><p><img src="/../image/assets/image-20230805184254627.png" alt="image-20230805184254627"></p><ul><li>安装 Windows 操作系统的时候，一个必经的步骤就是——为磁盘分区（C、D、E 盘等）<ul><li>存储空间的划分——将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）</li><li>有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷</li></ul></li></ul><h4 id="目录区与文件区"><a href="#目录区与文件区" class="headerlink" title="目录区与文件区"></a>目录区与文件区</h4><ul><li>目录区<ul><li>主要存放文件目录信息 FCB</li><li>用于磁盘存储空间管理的信息</li></ul></li><li>文件区<ul><li>用于存放文件数据</li></ul></li><li>存储空间的初始化<ul><li>将各个文件卷划分为目录区、文件区</li></ul></li></ul><h3 id="管理方法"><a href="#管理方法" class="headerlink" title="管理方法"></a>管理方法</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><p><img src="/../image/assets/image-20230805184546096.png" alt="image-20230805184546096"></p><p><img src="/../image/assets/image-20230805184859144.png" alt="image-20230805184859144"></p><ul><li>空闲表法<ul><li>适用于连续分配方法</li><li>组成<ul><li>第一个空闲盘块号</li><li>空闲盘块数</li></ul></li><li>如何分配磁盘块<ul><li>与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间</li><li>可以采用<strong>首次适应、最佳适应、最坏适应</strong>算法来决定要为文件分配哪个区间</li><li>例子：新创建的文件请求 3 个块，采用最佳适应算法</li></ul></li><li>如何回收磁盘块<ul><li>与内存管理中的动态分区分配很类似，当回收某个存储区时有四种情况<ul><li>回收区前后都没有相邻空闲区</li><li>回收区前后都是空闲区</li><li>回收区前面是空闲区</li><li>回收区后面是空闲区</li></ul></li><li>回收时需要注意表项的合并问题</li></ul></li></ul></li></ul><h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><p><img src="/../image/assets/image-20230805222403797.png" alt="image-20230805222403797"></p><h5 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h5><ul><li>空闲盘块链<ul><li><strong>以空闲的块为单位</strong></li><li>空闲盘块中存储着下一个空闲盘块的指针</li></ul></li></ul><h5 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h5><ul><li>空闲盘区链<ul><li><strong>以连续的空闲盘块组成的空闲盘区为单位</strong></li><li>空闲盘区中的第一个盘块内记录了<strong>盘区的长度</strong>、<strong>下一个盘区的指针</strong></li></ul></li></ul><p><img src="/../image/assets/image-20230805222635146.png" alt="image-20230805222635146"></p><ul><li>结构<ul><li><strong>操作系统保存着链头、链尾指针</strong></li></ul></li><li>如何分配<ul><li>若某文件申请 k 个盘块，则从链头开始依次摘下 k 个盘块分配，并修改空闲链的链头指针</li></ul></li><li>如何回收<ul><li>回收的盘块依次挂到链尾，并修改空闲链的链尾指针<ul><li>适用于离散分配的物理结构</li><li>为文件分配多个盘块时可能要重复多次操作</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230805223001005.png" alt="image-20230805223001005"></p><ul><li>结构<ul><li>操作系统保存着链头、链尾指针</li><li>空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针</li><li>连续的空闲盘块组成一个空闲盘区</li></ul></li><li>如何分配<ul><li>若某文件申请 k 个盘块，则可以采用首次使用、最佳使用等算法，从链头开始检索</li><li>按照算法规则找到一个大小符合要求的空闲盘区，分配给文件</li><li>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件</li><li>注意分配后可能要修改相应的链指针、盘区大小等数据</li></ul></li><li>如何回收<ul><li>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中</li><li>若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</li></ul></li><li>离散分配、连续分配都适用</li><li>为一个文件分配多个盘块时效率更高</li></ul><h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p><img src="/../image/assets/image-20230805223430332.png" alt="image-20230805223430332"></p><ul><li>位示图<ul><li>每个二进制位对应一个盘块</li><li>0 代表盘块空闲；1 代表盘块已分配</li><li>位示图一般用<strong>连续的字</strong>来表示<ul><li>如本例中一个字的字长是 16 位，字中的每一位对应一个盘块</li><li>因此可以用（字号，位号）对应一个盘块号。或者是（行号，列号）</li></ul></li><li>最最最最重要<ul><li><strong>能自己推出盘块号与（字号，位号）相互转换的公式</strong></li><li>注意题目条件<ul><li><strong>盘块号、字号、位号到底是从 0 开始还是从 1 开始</strong></li><li>如本例中盘块号、字号、位号从 0 开始</li><li>若 n 表示字长，则</li><li>（字号，位号）&#x3D;（i,j）的二进制位对应的盘块号 b&#x3D;ni+j</li><li><strong>b号盘块对应的字号 i&#x3D;b&#x2F;n，位号j&#x3D;b%n</strong></li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806152108917.png" alt="image-20230806152108917"></p><ul><li><p>位示图法</p><ul><li>连续分配、离散分配都适用</li><li>如何分配<ul><li>若文件需要 k 个块<ul><li>顺序扫描位示图，找到 k 个相邻或不相邻的“0”</li><li>根据字号、位号算出对应的盘块号，将对应盘块分配给文件</li><li>将对应位设置为 1</li></ul></li></ul></li><li>如何回收<ul><li>根据回收的盘块号计算出对应的字号、位号</li><li>将相应二进制位设为“0”</li></ul></li></ul></li></ul><h4 id="成组链接法（理解）"><a href="#成组链接法（理解）" class="headerlink" title="成组链接法（理解）"></a>成组链接法（理解）</h4><p><img src="/../image/assets/image-20230806152641171.png" alt="image-20230806152641171"></p><p><img src="/../image/assets/image-20230806152923376.png" alt="image-20230806152923376"></p><ul><li>成组链接法<ul><li>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大</li><li>UNIX 系统中采用了成组链接法对磁盘空闲块进行管理</li><li>文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级块读入内存，并且要保证内存与外存中的超级块数据一致</li></ul></li><li>组成<ul><li>第一个数据：下一组空闲盘块的数量</li><li>第二个数据：空闲块号</li></ul></li><li>注意<ul><li>若<strong>已经没有下一组空闲块（此时为倒数第二个盘块）</strong>，此时该将块数设为特殊值，如-1</li><li>一个分组中的块号不需要连续</li></ul></li></ul><p><img src="/../image/assets/image-20230806153723990.png" alt="image-20230806153723990"></p><ul><li>如何分配<ul><li>例如需要 100 个空闲块<ul><li>检查第一个分组的块数是否足够 100&#x3D;100 是足够的</li><li>分配第一个分组中的 100 个空闲块<ul><li>由于 300 号块内存放了再下一组的信息，因此 300 号块的数据需要复制到超级块中</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806154022483.png" alt="image-20230806154022483"></p><ul><li>如何回收<ul><li>假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块<ul><li>直接将新回收的块插入到第一个分组的最后的位置</li></ul></li><li>假设每个分组最多为 100 个空闲块，此时第一个分组已经有 100 个块，还要再回收一块<ul><li>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组<ul><li>懂了，因为新回收的块都是空的，所以可以把原来的内容都复制到这个块里面，让这个满的块称为超级块的第一个分组</li></ul></li></ul></li></ul></li></ul><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p><img src="/../image/assets/image-20230806155210055.png" alt="image-20230806155210055"></p><ul><li>向上提供的几个最基本功能<ul><li>创建文件<ul><li>create 系统调用</li></ul></li><li>删除文件<ul><li>delete 系统调用</li></ul></li><li>读文件<ul><li>read 系统调用</li></ul></li><li>写文件<ul><li>write 系统调用</li></ul></li><li>打开文件<ul><li>open 系统调用</li></ul></li><li>关闭文件<ul><li>close 系统调用</li></ul></li></ul></li></ul><h3 id="创建文件（create）"><a href="#创建文件（create）" class="headerlink" title="创建文件（create）"></a>创建文件（create）</h3><p><img src="/../image/assets/image-20230806155326830.png" alt="image-20230806155326830"></p><ul><li>进行Create 系统调用时，需要提供几个主要参数<ul><li>所需的外存空间大小（如：一个盘块，即 1KB）</li><li>文件存放路径（“D:&#x2F;Demo”）</li><li>文件名（默认为“新建文本文件.txt”）</li></ul></li><li>操作系统在处理 Create 系统调用时，主要做了两件事<ul><li><strong>在外存中找到文件所需的空间</strong><ul><li>可以使用空闲链表法、位示图、成组链接法等管理策略，找到空闲空间</li></ul></li><li>根据文件存放路径的信息找到该目录对应的目录文件（“D:&#x2F;Demo目录”），<strong>在目录中创建该文件对应的目录项</strong><ul><li>目录项中包含了文件名、文件在外存中存放位置等信息</li></ul></li></ul></li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><img src="/../image/assets/image-20230806155821181.png" alt="image-20230806155821181"></p><ul><li>删除文件<ul><li>进行 Delete 系统调用时，需要提供几个主要参数<ul><li>文件存放路径（“D:&#x2F;Demo”）</li><li>文件名（“test.txt”）</li></ul></li><li>操作系统在处理 Delete 系统调用时，主要做了几件事<ul><li>根据文件存放路径找到相应的目录文件，从目录中<strong>找到文件名对应的目录项</strong></li><li>根据该目录项的文件在外存的存放位置、文件大小等信息，<strong>回收文件占用的磁盘块</strong><ul><li>回收磁盘块时，根据空闲表法、空闲链表法、位示图等管理策略的不同，需要做不同的处理</li></ul></li><li>从目录表中<strong>删除文件对应的目录项</strong></li></ul></li></ul></li></ul><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p><img src="/../image/assets/image-20230806161541869.png" alt="image-20230806161541869"></p><ul><li>读文件<ul><li>将文件数据读入内存，才能让 CPU 处理（双击后，“记事本”应用程序通过操作系统提供的“读文件”功能，即 read 系统调用，将文件数据从外存读入内存，并显示在屏幕上）</li><li>读操作<ul><li>需要指明时哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可）</li><li>要读入多少数据（如读入 1KB）</li><li>读入的数据要放在内存中的什么位置</li></ul></li><li>操作系统在处理 read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域</li></ul></li></ul><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p><img src="/../image/assets/image-20230806162420020.png" alt="image-20230806162420020"></p><ul><li><p>写文件</p><ul><li><p>将更改过的文件数据写回外存</p><ul><li>在“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“写文件”功能，即 write 系统调用将文件数据从内存写回外存</li></ul></li><li><p>写操作</p><ul><li><p>需要指明是哪个文件</p><ul><li>在支持打开文件操作的系统中，只需要提供文件在打开文件表中的索引号即可</li></ul></li><li><p>写出多少数据（如写出 1KB）</p></li><li><p>写回外存的数据放在内存中的什么位置</p></li></ul></li><li><p>在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</p></li></ul></li></ul><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><img src="/../image/assets/image-20230806160140745.png" alt="image-20230806160140745"></p><ul><li>打开文件<ul><li>用户进程 A 的打开文件表<ul><li>之后用户进程 A 再操作文件就不需要每次都重新查目录了，这样可以加快文件的访问速度</li></ul></li><li>在很多操作系统中，在对文件进行操作之前，要求用户提供的几个主要参数，才能使用 open 系统调用“打开文件”<ul><li>文件存放路径（“D:&#x2F;Demo”）</li><li>文件名（“test.txt”）</li><li>要对文件的操作类型（r 只读；rw 读写）</li></ul></li><li>操作系统在处理 open 系统调用时，主要做了几件事<ul><li><strong>根据文件存放路径找到相应的目录文件</strong>，从目录中<strong>找到文件名对应的目录项</strong>，并检查该用户是否有指定的操作权限</li><li><strong>将目录项复制到内存中的“打开文件表”中，之后用户使用打开文件表的编号来指明要操作的文件</strong></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806160832032.png" alt="image-20230806160832032"></p><ul><li>用户进程的打开文件表<ul><li>编号</li><li>文件名</li><li>读&#x2F;写指针<ul><li>记录了该进程对文件的读&#x2F;写操作进行到的位置</li></ul></li><li>访问权限<ul><li>如果打开文件时声明的是只读，则该进程不能对文件进行写操作</li></ul></li><li>系统表索引号</li></ul></li><li>系统的打开文件表（整个系统只有一张）：会记录所有进程打开的文件<ul><li>编号</li><li>文件名</li><li>外存地址</li><li><strong>打开计数器</strong><ul><li>记录此时有多少个进程打开了此文件</li></ul></li><li>此表的作用<ul><li>可以方便实现某些文件管理的功能<ul><li>例如：在 windows 系统中，我们尝试删除某个 txt 文件，如果此时该文件已经被某个“记事本”进程打开，则系统会提示我们“暂时无法删除该文件”。其实系统在背后做的事情就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件</li></ul></li></ul></li></ul></li></ul><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p><img src="/../image/assets/image-20230806161349188.png" alt="image-20230806161349188"></p><ul><li>关闭文件<ul><li>进程使用完文件</li><li>操作系统在处理 Close 系统调用时，主要做了几件事<ul><li>将<strong>进程的打开文件表</strong>相应表项删除</li><li><strong>回收分配给该文件的内存空间</strong>等资源</li><li>系统打开文件表的打开计数器 count–，若 count&#x3D;&#x3D;0，则删除对应表项</li></ul></li></ul></li></ul><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="/../image/assets/image-20230806163903608.png" alt="image-20230806163903608"></p><ul><li>文件共享<ul><li>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</li><li>共享<ul><li>多个用户共享同一个文件，意味着系统中只有“一份”文件数据</li><li>并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化</li></ul></li><li>复制<ul><li>多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据</li><li>其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响</li></ul></li></ul></li></ul><h3 id="基于索引节点的共享方式（硬链接）"><a href="#基于索引节点的共享方式（硬链接）" class="headerlink" title="基于索引节点的共享方式（硬链接）"></a>基于索引节点的共享方式（硬链接）</h3><p><img src="/../image/assets/image-20230806165959892.png" alt="image-20230806165959892"></p><ul><li>索引节点<ul><li>是一种文件目录瘦身策略</li><li>检索文件时只需要用到文件名，因此可以将除了文件名之外的其他信息放到索引节点中。</li><li>这样目录项就只需要包含文件名、索引节点指针</li></ul></li><li>索引节点中设置一个链接计数变量 count，用于表示链接到本索引节点上的用户目录项数<ul><li>若 count&#x3D;2，说明此时有两个用户目录项链接到该索引节点上，或者说有两个用户在共享此文件</li><li>若某个用户决定删除该文件，则只需要把用户目录中与该文件对应的目录项删除，且索引节点的 count –</li><li>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空</li><li>当 count&#x3D;0，系统负责删除文件</li></ul></li></ul><h3 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h3><p><img src="/../image/assets/image-20230806171934811.png" alt="image-20230806171934811"></p><ul><li>当 User3 访问“ccc”时，操作系统判断文件“ccc”属于 Link 类型文件，于是会根据其中记录的路径层层查找目录，最终找到 User1 的目录表中的“aaa”表项，于是就找到了文件 1 的索引节点</li><li>Link 类型的文件，记录了文件 1 的存放路径“C:&#x2F;&#x2F;User1&#x2F;aaa”<ul><li>Link 类型的文件名可以不同</li><li>类似于 Windows 操作系统的“快捷访问”</li></ul></li><li>如果文件 1 已删除，但是文件 2 依然存在，只是通过“C:&#x2F;User1&#x2F;aaa”这个路径已经找不到文件 1 了<ul><li>此时软链接的“ccc”文件也就相应的失效了</li></ul></li><li>双击打开的时候，操作系统会判断这个文件是 Link 类型的“快捷方式”文件，于是会根据其中记录的“路径信息”检索目录，最终找到</li></ul><p><img src="/../image/assets/image-20230806171947105.png" alt="image-20230806171947105"></p><p><img src="/../image/assets/image-20230806172005012.png" alt="image-20230806172005012"></p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="/../image/assets/image-20230806172759760.png" alt="image-20230806172759760"></p><ul><li>保护文件数据的安全</li></ul><h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p><img src="/../image/assets/image-20230806172921233.png" alt="image-20230806172921233"></p><ul><li>口令保护<ul><li>方式<ul><li>为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”<ul><li>口令一般存放在文件对应的 FCB 或索引节点中</li><li>用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与 FCB 中存储的口令进行对比</li><li>如果正确，则允许该用户访问文件</li></ul></li></ul></li><li>优点<ul><li>保存口令的空间开销不多，验证口令的时间开销也很小</li></ul></li><li>缺点<ul><li>正确的“口令”存放在系统内部，不够安全</li></ul></li></ul></li></ul><h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3><p><img src="/../image/assets/image-20230806173207878.png" alt="image-20230806173207878"></p><ul><li>加密保护<ul><li>方式<ul><li>使用某个密码对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密</li></ul></li><li>EG：一个最简单的加密算法——异或加密<ul><li>假设用于加密解密的密码为“01001”</li><li>文件的原始数据</li><li>加密密码</li><li>加密结果</li><li>解密密码</li><li>解密结果</li></ul></li><li>加密和解密使用的密码相同，则最终得到的加密结果和解密结果相同</li><li>优点<ul><li>保密性强，不需要系统中存储“密码”</li></ul></li><li>缺点<ul><li>编码译码，或者加密解密要花费一定时间</li></ul></li></ul></li></ul><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p><img src="/../image/assets/image-20230806173825616.png" alt="image-20230806173825616"></p><ul><li><p>访问控制</p><ul><li><p>在每个文件的 FCB（或索引节点）中增加一个<strong>访问控制列表</strong>（ACL, Access-Control List），该表中记录了各个用户可以对该文件执行哪些操作</p></li><li><p>如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制</p></li><li><p>访问类型</p><ul><li>读：从文件中读数据</li><li>写：向文件中写数据</li><li>执行：将文件装入内存并执行</li><li>添加：将新信息添加到文件结尾部分</li><li>删除：删除文件，释放空间</li><li>列表清单：列出文件名和文件属性</li></ul></li><li><p>有的计算机可能有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题</p></li></ul></li></ul><p><img src="/../image/assets/image-20230806174222185.png" alt="image-20230806174222185"></p><ul><li>精简的访问列表<ul><li><strong>以组为单位，标记各组用户可以对文件执行哪些操作</strong><ul><li>如分为 系统管理员、文件主、文件主的伙伴、其他用户 几个分组</li></ul></li><li>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限<ul><li>系统需要管理分组的信息</li><li>若想要让某个用户能够读取文件，只需要把该用户放入“文件主的伙伴”这个分组即可</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806174821586.png" alt="image-20230806174821586"></p><ul><li>Windows 的访问控制<ul><li>每当用户想要访问某个文件夹</li><li>操作系统会先寻找这个文件夹的 FCB，然后根据 FCB 中记录的访问权限相关的记录信息来判断该用户是否有权限访问这个文件夹</li></ul></li></ul><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p><img src="/../image/assets/image-20230806175223373.png" alt="image-20230806175223373"></p><p><img src="/../image/assets/image-20230806175802451.png" alt="image-20230806175802451"></p><ul><li>文件系统的层次结构<ul><li>用户&#x2F;应用软件</li><li>用户接口<ul><li>文件系统需要向上层的用户提供一些简单易用的功能接口</li><li>这层就是用于处理用户发出的系统调用请求（Read、Write、Open、Close 系统调用）</li></ul></li><li>文件目录系统<ul><li>用户是通过文件路径来访问文件的</li><li>这一层需要根据用户给出的文件路径找到对应的 FCB 或索引节点</li><li>所有和目录、目录项相关的管理工作都在本层完成</li><li>如：管理活跃的文件目录表、管理打开文件表等</li></ul></li><li>存取控制模块<ul><li>为了保证文件数据的安全，还需要验证用户是否有访问权限</li><li>这一层主要完成了文件保护相关功能</li></ul></li><li>逻辑文件系统与文件信息缓冲区<ul><li>用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址</li><li>对索引地址进行向下查询</li></ul></li><li>物理文件系统<ul><li>这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址</li></ul></li><li>辅助分配模块<ul><li>负责文件存储空间的管理，即负责分配和回收存储空间</li></ul></li><li>设备管理模块<ul><li><strong>直接与硬件交互，负责和硬件直接相关的一些管理工作，与硬件连接最紧密</strong></li><li>如：分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806180600203.png" alt="image-20230806180600203"></p><ul><li>用一个例子辅助记忆文件系统的层次结构<ul><li>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xlsx”的最后 100 条记录<ul><li>用户需要通过操作系统提供的接口发出上述请求——<strong>用户接口</strong></li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层的查找目录，找到对应的目录项——<strong>文件目录系统</strong></li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——辅助分配模块</li></ul></li></ul></li></ul><h2 id="文件系统的全局结构（布局）"><a href="#文件系统的全局结构（布局）" class="headerlink" title="文件系统的全局结构（布局）"></a>文件系统的全局结构（布局）</h2><h3 id="文件系统在外存中的结构"><a href="#文件系统在外存中的结构" class="headerlink" title="文件系统在外存中的结构"></a>文件系统在外存中的结构</h3><h4 id="原始磁盘"><a href="#原始磁盘" class="headerlink" title="原始磁盘"></a>原始磁盘</h4><p><img src="/../image/assets/image-20230806181838651.png" alt="image-20230806181838651"></p><h4 id="物理格式化后（低级格式化）"><a href="#物理格式化后（低级格式化）" class="headerlink" title="物理格式化后（低级格式化）"></a>物理格式化后（低级格式化）</h4><p><img src="/../image/assets/image-20230806181911219.png" alt="image-20230806181911219"></p><ul><li>物理格式化<ul><li>划分扇区，检测坏扇区，并用备用扇区替换坏扇区</li></ul></li></ul><h4 id="磁盘分区后"><a href="#磁盘分区后" class="headerlink" title="磁盘分区后"></a>磁盘分区后</h4><p><img src="/../image/assets/image-20230806182020245.png" alt="image-20230806182020245"></p><h4 id="逻辑格式化后"><a href="#逻辑格式化后" class="headerlink" title="逻辑格式化后"></a>逻辑格式化后</h4><p><img src="/../image/assets/image-20230806182035384.png" alt="image-20230806182035384"><br><img src="/../image/assets/image-20230806182746391.png" alt="image-20230806182746391"></p><ul><li><p>逻辑格式化</p><ul><li>磁盘分区（分卷 Volume）后，对各分区进行逻辑格式化，完成文件系统初始化</li><li>逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据</li></ul></li><li><p>结构</p><ul><li><p>磁盘</p><ul><li><p>主引导记录（MBR）</p><ul><li>磁盘引导程序和分区表</li></ul></li><li><p>C盘</p><ul><li><p>引导块</p><ul><li>负责开机时初始化操作系统</li></ul></li><li><p>超级块</p><ul><li>找到很多空闲的磁盘块进行分配</li></ul></li><li><p>空闲空间管理</p><ul><li>位示图</li></ul></li><li><p>i 节点区</p><ul><li>索引节点（超大数组，数组元素就是一个个索引节点）</li></ul></li><li><p>根目录</p></li><li><p>其他文件、目录</p></li></ul></li><li><p>D 盘</p></li><li><p>E 盘</p></li></ul></li></ul></li></ul><h3 id="文件系统在内存中的结构"><a href="#文件系统在内存中的结构" class="headerlink" title="文件系统在内存中的结构"></a>文件系统在内存中的结构</h3><p><img src="/../image/assets/image-20230806182805793.png" alt="image-20230806182805793"></p><ul><li>文件系统在内存中的结构<ul><li>目录的缓存<ul><li>近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度</li></ul></li><li>系统打开文件表<ul><li>一个系统只有一张</li></ul></li><li>进程（用户）打开文件表<ul><li>每个进程都有一张</li><li>包含在进程的 PCB 中</li></ul></li></ul></li></ul><h3 id="open-系统调用打开文件的背后过程"><a href="#open-系统调用打开文件的背后过程" class="headerlink" title="open 系统调用打开文件的背后过程"></a>open 系统调用打开文件的背后过程</h3><p><img src="/../image/assets/image-20230806183218667.png" alt="image-20230806183218667"></p><ul><li>open(……&#x2F;M&#x2F;A，只读)根据路径一级一级读入目录<ul><li>规定对文件的权限控制：只读</li></ul></li><li>找到目标文件的 FCB，复制到系统打开文件表<ul><li>将 count 设置为 1</li><li>目录项 FCB_A指向文件 A</li></ul></li><li>在进程打开文件表中新建一个条目，并返回文件描述符（指向进程打开文件项）<ul><li>系统打开文件表索引：指向文件实际存放位置</li><li>打开方式：只读（与上面保持一致）</li></ul></li><li>给用户返回一个文件描述符&#x2F;文件句柄 fd<ul><li>对打开的文件进行相应操作<ul><li>read(fd, xxx, xxx)</li><li>从文件描述符 fd 出发，先找到进程打开文件表的索引</li><li>再找到系统打开文件表索引</li><li>根据索引找到目录项 FCB_A，找到它存储的逻辑位置</li><li>根据逻辑位置转化为物理位置，找到文件 A 并进行读取操作</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806183723287.png" alt="image-20230806183723287"></p><h2 id="虚拟文件系统-文件系统挂载（安装）"><a href="#虚拟文件系统-文件系统挂载（安装）" class="headerlink" title="虚拟文件系统 &amp; 文件系统挂载（安装）"></a>虚拟文件系统 &amp; 文件系统挂载（安装）</h2><h3 id="普通文件系统"><a href="#普通文件系统" class="headerlink" title="普通文件系统"></a>普通文件系统</h3><p><img src="/../image/assets/image-20230806184119827.png" alt="image-20230806184119827"></p><ul><li>普通文件系统<ul><li>磁盘<ul><li>UFS 文件系统：open(参数 a, b)</li></ul></li><li>移动硬盘<ul><li>NTFS 文件系统：fopen(参数 x)</li></ul></li><li>U盘<ul><li>FAT 文件系统：openf(参数 p, q)</li></ul></li></ul></li><li>不同的硬件存储设备采用的文件系统不同，对应的函数方法不同</li></ul><p><img src="/../image/assets/image-20230806184415001.png" alt="image-20230806184415001"></p><p><img src="/../image/assets/image-20230806184655709.png" alt="image-20230806184655709"></p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><ul><li>虚拟文件系统（VFS）的特点<ul><li><strong>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</strong><ul><li>不用去管下层具体的文件系统，只需要使用虚拟文件系统 VFS 提供的 POSIX 标准接口 open(x,y,z)就可以实现 open 方法</li></ul></li><li><strong>VFS 要求下层的文件系统必须实现某些规定的函数功能</strong>，如：opem&#x2F;read&#x2F;write<ul><li>一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统 VFS 的要求</li></ul></li><li><strong>每打开一个文件，VFS 就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</strong></li></ul></li></ul><p><img src="/../image/assets/image-20230806184844622.png" alt="image-20230806184844622"></p><p><img src="/../image/assets/image-20230806195515407.png" alt="image-20230806195515407"></p><ul><li>虚拟文件系统<ul><li>存在的问题<ul><li>不同的文件系统，表示文件数据结构各不相同，打开文件后其在内存中的表示就不同</li></ul></li><li>解决方法<ul><li>每打开一个文件，VFS 就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li></ul></li><li>vnode 指存在于主存中，而 inode 既会被调入主存，也会在外存中存储<ul><li>vnode 其实就是在运行过程中声明的一种数据结构，不会提前储存</li><li>当读取硬盘的时候，inode 的信息数据会复制到 vnode 中</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806200213553.png" alt="image-20230806200213553"></p><ul><li>虚拟文件系统使用函数的方法<ul><li>打开文件后，创建 vnode，并将文件信息复制到 vnode 中</li><li>vnode 的功能指针指向具体文件系统的函数功能<ul><li>即虚拟文件系统会调用其下的 UFS、FAT 等不同文件系统自己的函数功能</li></ul></li></ul></li></ul><h3 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h3><p><img src="/../image/assets/image-20230806200524810.png" alt="image-20230806200524810"></p><ul><li>文件系统挂载（mounting）<ul><li>即文件系统安装&#x2F;装载</li><li>如何将一个文件系统挂载到操作系统中？</li><li>文件系统挂载要做的事情？<ul><li>在 VFS 中注册新挂载的文件系统。<ul><li><strong>内存中的挂载表</strong>（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小</li></ul></li><li>新挂载的文件系统，要向 VFS 提供一个函数地址列表</li><li>将新文件系统加到挂载点（mount point）<ul><li>也就是将文件系统挂载在某个父目录下</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806200907719.png" alt="image-20230806200907719"></p><ul><li>Windows 挂载在与 C 盘、D 盘、E盘同级的目录下</li><li>MacOS 挂在到 Volumes 文件夹下</li></ul><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><p><img src="/../image/assets/image-20230806201101786.png" alt="image-20230806201101786"></p><h4 id="磁盘、磁道、扇区的概念"><a href="#磁盘、磁道、扇区的概念" class="headerlink" title="磁盘、磁道、扇区的概念"></a>磁盘、磁道、扇区的概念</h4><p><img src="/../image/assets/image-20230806201319815.png" alt="image-20230806201319815"></p><ul><li>磁盘<ul><li>构成<ul><li>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</li></ul></li><li>磁道<ul><li>磁盘的盘面被划分成一个个磁道</li><li>这样的一个圈就是一个磁道</li></ul></li><li>扇区<ul><li>一个磁道又被划分为一个个扇区，每个扇区就是一个磁盘块</li><li>各个扇区存放的数据量相同（如 1KB）</li></ul></li></ul></li></ul><h4 id="如何在磁盘中读-写数据"><a href="#如何在磁盘中读-写数据" class="headerlink" title="如何在磁盘中读&#x2F;写数据"></a>如何在磁盘中读&#x2F;写数据</h4><p><img src="/../image/assets/image-20230806201445794.png" alt="image-20230806201445794"></p><ul><li>读写数据<ul><li>需要用磁头臂把“磁头”移动到想要读&#x2F;写的扇区所在的磁道</li><li>磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作</li></ul></li></ul><h4 id="盘面、柱面的概念"><a href="#盘面、柱面的概念" class="headerlink" title="盘面、柱面的概念"></a>盘面、柱面的概念</h4><p><img src="/../image/assets/image-20230806202456518.png" alt="image-20230806202456518"></p><ul><li>磁盘<ul><li>盘片<ul><li>就是上图中的一个环形</li></ul></li><li>盘面<ul><li>盘片的一个面</li><li>一个盘片可能会有两个盘面</li></ul></li><li>磁头<ul><li>每个盘面对应一个磁头，可以用磁头在盘面上读取数据</li></ul></li><li>磁臂<ul><li>所有的磁头都是连在同一个磁臂上的，因此所有磁头只能共进退</li><li>磁臂带动着所有磁头在不同磁道上移动、切换</li></ul></li><li>柱面<ul><li>所有盘面中相对位置相同的磁道组成柱面（黄色的是一个柱面）</li></ul></li></ul></li></ul><h4 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h4><p><img src="/../image/assets/image-20230806202004798.png" alt="image-20230806202004798"></p><ul><li>如何确定位置<ul><li>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”</li><li>我们经常提到的文件数据存放在外存中的几号块，这个块号就可以转换为（柱面号，盘面号，扇区号）的地址形式</li></ul></li><li>可根据该地址读取一个“块”<ul><li>根据“柱面号”移动磁臂，让磁头指向指定柱面</li><li>激活指定盘对应的磁头</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写</li></ul></li></ul><h4 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h4><p><img src="/../image/assets/image-20230806202646906.png" alt="image-20230806202646906"></p><ul><li>活动头磁盘<ul><li>磁头可以移动的称为活动头磁盘</li><li>磁臂可以来回伸缩来带动磁头定位磁道</li></ul></li><li>固定头磁盘<ul><li>磁头不可以移动</li><li>每个磁道都有一个磁头</li></ul></li></ul><p><img src="/../image/assets/image-20230806202705319.png" alt="image-20230806202705319"></p><ul><li>可换盘磁盘<ul><li>盘片可以更换</li></ul></li><li>固定盘磁盘<ul><li>盘片不可更换</li></ul></li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="/../image/assets/image-20230806203045991.png" alt="image-20230806203045991"></p><h3 id="一次磁盘读-写需要的时间"><a href="#一次磁盘读-写需要的时间" class="headerlink" title="一次磁盘读&#x2F;写需要的时间"></a>一次磁盘读&#x2F;写需要的时间</h3><h4 id="寻找时间"><a href="#寻找时间" class="headerlink" title="寻找时间"></a>寻找时间</h4><p><img src="/../image/assets/image-20230806203116434.png" alt="image-20230806203116434"></p><ul><li>寻找时间<ul><li>寻道时间，Ts：在读&#x2F;写数据之前，将磁头移动到指定磁道所花的事件<ul><li>启动磁头臂是需要时间的，假设耗时为 s</li><li>移动磁头也是需要时间的，假设磁头均匀移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道</li></ul></li><li>寻道时间 Ts &#x3D; s+m*n</li><li>现在的硬盘移动一个磁道大约需要 0.2ms，磁臂启动时间约为 2ms</li></ul></li></ul><h4 id="延迟时间"><a href="#延迟时间" class="headerlink" title="延迟时间"></a>延迟时间</h4><p><img src="/../image/assets/image-20230806204556756.png" alt="image-20230806204556756"></p><ul><li>延迟事件<ul><li>通过旋转磁盘，使磁头定位到目标扇区所需要的时间</li><li>设磁盘转速为 r（单位：转&#x2F;秒，或转&#x2F;分）</li><li>则平均所需的延迟时间 Tr&#x3D;(1&#x2F;2)*(1&#x2F;r)&#x3D;1&#x2F;2r<ul><li>1&#x2F;r就是转一圈需要的事件</li><li>找到目标扇区平均需要转半圈，因此再乘 1&#x2F;2</li></ul></li></ul></li></ul><h4 id="传输时间"><a href="#传输时间" class="headerlink" title="传输时间"></a>传输时间</h4><p><img src="/../image/assets/image-20230806204613785.png" alt="image-20230806204613785"></p><ul><li>传输时间<ul><li>Tt，从磁盘读出或向磁盘写入数据所经历的时间</li><li>假设磁盘转速为 r，此次读&#x2F;写的字节数为 b，每个磁道上的字节数为 N</li><li>则：传输时间 Tt &#x3D; (1&#x2F;r)*(b&#x2F;N) &#x3D; b&#x2F;(rN)<ul><li>每个磁道可存 N 字节的数据，因此 b 字节的数据需要b&#x2F;N个磁道才能存储</li><li>读写一个磁道所需的事件刚好又是转一圈所需要的时间1&#x2F;r</li></ul></li></ul></li></ul><h4 id="总时间"><a href="#总时间" class="headerlink" title="总时间"></a>总时间</h4><p><img src="/../image/assets/image-20230806204702404.png" alt="image-20230806204702404"></p><ul><li>总的平均存取时间<ul><li>Ta &#x3D; Ts +1&#x2F;2r + b&#x2F;(rN)</li><li>延迟时间和传输时间都与磁盘转速相关，且为线性相关</li><li>转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</li><li>但是操作系统的磁盘调度算法会直接影响寻道时间</li></ul></li></ul><h3 id="磁盘调度算法-1"><a href="#磁盘调度算法-1" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p><img src="/../image/assets/image-20230806204920439.png" alt="image-20230806204920439"></p><ul><li>先来先服务<ul><li>算法思想<ul><li>根据进程请求访问磁盘的先后顺序进行调度</li></ul></li><li>优点<ul><li>公平</li><li>如果请求访问的磁道比较集中的话，算法性能还算过得去</li></ul></li><li>缺点<ul><li>如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，寻道时间长</li></ul></li><li>例子<ul><li>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</li><li>按照 FCFS 的规则，按照请求到达的顺序，磁头需要依次移动到 55、58、39、18、90、160、150、38、184 号磁道</li><li>磁头总共移动了 45+3+19+21+72+70+10+112+146 &#x3D; 498 个磁道</li><li>响应一个请求平均需要移动 498&#x2F;9 &#x3D; 55.3 个磁道（平均寻找长度）</li></ul></li></ul></li></ul><h4 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h4><p><img src="/../image/assets/image-20230806205205147.png" alt="image-20230806205205147"></p><ul><li>最短寻找事件优先（SSTF）<ul><li>算法思想<ul><li>SSTF 算法会优先处理的磁道是与当前磁头最近的磁道</li><li>可以保证每次的寻道时间最短，但是不能保证总的寻道时间最短</li><li>贪心思想，只选择眼前最优，整体未必最优</li></ul></li><li>优点<ul><li>性能较好，平均寻道时间最短</li></ul></li><li>缺点<ul><li>可能产生“饥饿现象”</li></ul></li><li>例子<ul><li>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</li><li>磁头总共移动了 (100-18) + (184-18) &#x3D; 248 个磁道</li><li>响应一个请求平均需要移动 248&#x2F;9 &#x3D; 27.5 个磁道（平均寻找长度）</li><li>本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的 18号、38号磁道的访问请求到来的话，150、160、184 号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。<ul><li>产生饥饿的原因在于：磁头在一个小 区域内来回来去地移动</li></ul></li></ul></li></ul></li></ul><h4 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h4><p><img src="/../image/assets/image-20230806205633174.png" alt="image-20230806205633174"></p><ul><li>扫描算法（电梯算法）<ul><li>算法思想<ul><li>为了解决 SSTF 算法有可能在一个小区域内来回来去地移动，产生饥饿的缺点</li><li>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</li><li>只有到了最边上的磁道才能改变磁头移动方向</li></ul></li><li>优点<ul><li>性能较好，平均寻道时间较短，不会产生饥饿现象</li></ul></li><li>缺点<ul><li><strong>只有到达最边上的磁道时才能改变磁头移动方向</strong>，事实上，处理了 184 号（最高）磁道的访问请求之后就不需要再往右移动磁头了</li><li><strong>SCAN 算法对于各个位置的响应频率不均匀</strong><ul><li>假设此时磁头正往右移动，且刚处理过 90 号磁道，那么下次处理 90 号磁道的请求就需要等磁头移动很长一段距离</li><li>但是响应了 184 号磁道的请求之后，很快又可以再次相应 184 号磁道的请求了</li></ul></li></ul></li><li>例子<ul><li>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</li><li>磁头总共移动了 (200-100) + (200-18) &#x3D; 282 个磁道</li><li>响应一个请求平均需要移动 282&#x2F;9 &#x3D; 31.3 个磁道（平均寻找长度）</li></ul></li></ul></li></ul><h4 id="LOOK-调度算法"><a href="#LOOK-调度算法" class="headerlink" title="LOOK 调度算法"></a>LOOK 调度算法</h4><p><img src="/../image/assets/image-20230806210158515.png" alt="image-20230806210158515"></p><ul><li>LOOk 调度算法<ul><li>算法思想<ul><li>解决了扫描算法中只有到达最边上的磁道时才能改变磁头移动方向的问题</li><li>如果在磁头移动方向上已经没有别的请求了，就可以立即改变磁头移动方向</li><li>边移动便观察，因此叫 LOOK</li><li><strong>只有到了最边上的磁道才能改变磁头移动方向</strong></li></ul></li><li>优点<ul><li>比起 SCAN 算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li></ul></li><li>例子<ul><li>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</li><li>磁头总共移动了 (184-100) + (184-18) &#x3D; 250 个磁道</li><li>响应一个请求平均需要移动 250&#x2F;9 &#x3D; 27.5 个磁道（平均寻找长度）</li></ul></li></ul></li></ul><h4 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h4><p><img src="/../image/assets/image-20230806210718868.png" alt="image-20230806210718868"></p><ul><li>C-SCAN算法<ul><li>算法思想<ul><li>解决各个位置磁道的响应频率不平均的问题</li><li>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求</li><li>只有到了最边上的磁道才能改变磁头移动方向。磁头返回途中不处理任何请求</li></ul></li><li>优点<ul><li>比起 SCAN，对于各个位置磁道的响应频率很平均</li></ul></li><li>缺点<ul><li><strong>只有到达最边上的磁道时才能改变磁头移动方向</strong></li><li>比起 SCAN 算法，<strong>平均寻道时间更长</strong></li></ul></li><li>例子<ul><li>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</li><li>磁头总共移动了 (200-100) + (200-0) + (90-0)&#x3D; 390 个磁道</li><li>响应一个请求平均需要移动 390&#x2F;9 &#x3D; 43.3 个磁道（平均寻找长度）</li></ul></li></ul></li></ul><h4 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h4><p><img src="/../image/assets/image-20230806211134862.png" alt="image-20230806211134862"></p><ul><li>C-LOOK<ul><li>算法思想<ul><li>解决 C-SCAN 算法只有达到最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上的缺点</li><li>如果磁头移动方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可</li><li>磁头只需要返回到最靠近边缘的、并且需要访问的磁道上即可</li><li>如果在磁头移动方向上已 经没有别的请求，就可以立即让磁头返回</li></ul></li><li>优点<ul><li>比起 C-SCAN 算法，不需要每次都移动到最外侧或者最内侧才改变磁头方向，使寻道时间进一步缩短</li></ul></li><li>例子<ul><li>假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</li><li>磁头总共移动了 (184-100) + (184-18) + (90-18)&#x3D; 322 个磁道</li><li>响应一个请求平均需要移动 322&#x2F;9 &#x3D; 35.8 个磁道（平均寻找长度）</li></ul></li></ul></li></ul><h2 id="减少磁盘延迟事件的方法"><a href="#减少磁盘延迟事件的方法" class="headerlink" title="减少磁盘延迟事件的方法"></a>减少磁盘延迟事件的方法</h2><p><img src="/../image/assets/image-20230806211703822.png" alt="image-20230806211703822"></p><ul><li>假设要连续读取橙色区域的 2、3、4 扇区<ul><li>磁头读取一路爱的内容（一个扇区的内容）后，需要一小段时间处理，而扇片又在不停地旋转</li><li>如果 2、3 号扇区相邻着排列，则读完 2 号扇区后无法连续读入 3 号扇区</li><li>必须等扇片继续旋转，3 号扇区再次划过磁头，才能完成扇区读入</li></ul></li><li>结论<ul><li>磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”</li></ul></li></ul><h3 id="交替编号：减少延迟时间"><a href="#交替编号：减少延迟时间" class="headerlink" title="交替编号：减少延迟时间"></a>交替编号：减少延迟时间</h3><p><img src="/../image/assets/image-20230806212146071.png" alt="image-20230806212146071"></p><ul><li>交替编号<ul><li>让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小</li></ul></li></ul><h3 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h3><p><img src="/../image/assets/image-20230806212354768.png" alt="image-20230806212354768"></p><p><img src="/../image/assets/image-20230806212838898.png" alt="image-20230806212838898"></p><ul><li>思考<ul><li>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）<ul><li>若物理地址结构是（盘面号，柱面号，扇区号）且需要连续读取物理地址 （00, 000, 000）~（00, 001, 111）的扇区<ul><li>（00, 000, 000） ~（ 00, 000, 111 ） 转两圈可读完之后再读取物理地址相邻的区域</li><li>即（00, 001, 000） ~（ 00, 001, 111 ），需要启动磁头臂，将磁头移动到下一个磁道</li></ul></li><li>若物理地址结构是（柱面号，盘面号，扇区号），且需要连续读取物理地址 （000, 00, 000）~（000, 01, 111）的扇区<ul><li>（000, 00, 000） ~（ 000, 00, 111 ） 由盘面0的磁头读入数据之后再读取物理地址相邻的区域</li><li>（000, 01, 000） ~（ 000, 01, 111 ），由于柱面号&#x2F;磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</li></ul></li></ul></li><li>读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</li></ul></li></ul><p><img src="/../image/assets/image-20230806212939557.png" alt="image-20230806212939557"></p><h3 id="错位命名：减少延迟事件"><a href="#错位命名：减少延迟事件" class="headerlink" title="错位命名：减少延迟事件"></a>错位命名：减少延迟事件</h3><p><img src="/../image/assets/image-20230806213008853.png" alt="image-20230806213008853"></p><p><img src="/../image/assets/image-20230806213037163.png" alt="image-20230806213037163"></p><ul><li>不同盘面命名<ul><li>方案一：若相邻的盘面相对位置相同处扇区编号相同<ul><li>所有盘面都是一起连轴转的</li><li>读取完磁盘块（000,00, 111）之后，需要短暂的时间处理，而盘面又在不停地转动，因此当（000, 01, 000）<strong>第一次划过1号盘面的磁头下方时，并不能读取数据，只能再等该扇区再次划过磁头</strong></li></ul></li><li>方案二：错位命名<ul><li>由于采用错位命名法，因此读取完磁盘块（000, 00, 111）之后，还有一段时间处理，当（000, 01, 000）第一次划过1号盘面的磁头下方时，就可以直接读取数据。从而减少了延迟时间</li></ul></li></ul></li></ul><h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><p><img src="/../image/assets/image-20230806213427278.png" alt="image-20230806213427278"></p><h3 id="磁盘的初始化"><a href="#磁盘的初始化" class="headerlink" title="磁盘的初始化"></a>磁盘的初始化</h3><p><img src="/../image/assets/image-20230806213452527.png" alt="image-20230806213452527"></p><ul><li>磁盘的初始化<ul><li><strong>进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区</strong><ul><li>一个扇区通常可分为头、数据区域（扇区的内存大小，如 512B 大小）、尾（指向下一个扇区的指针）三个部分组成</li><li>管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC 循环冗余检验码等，检验码用于校验扇区中的数据是否发生错误）</li></ul></li><li><strong>将磁盘分区，每个分区由若干柱面组成</strong>（即分为 C、D、E 盘）</li><li><strong>进行逻辑格式化，创建文件系统</strong><ul><li>包括创建文件系统的根目录、初始化存储空间管理所用的数据结构</li><li>如位示图、空闲分区表</li></ul></li></ul></li></ul><h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p><img src="/../image/assets/image-20230806213817643.png" alt="image-20230806213817643"></p><ul><li><p>引导块</p><ul><li><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行<strong>初始化程序（自举程序）</strong>完成的</p></li><li><p>初始化程序可以放在 ROM（只读存储器）中<strong>，ROM 中的数据在出厂时就写入了，并且以后不能够再修改</strong></p><ul><li>ROM 一般是出厂时就集成在主板上的</li></ul></li><li><p>初始化程序（自举程序）放在 ROM 中存在什么问题？</p><ul><li><p>万一需要更新自举程序，将会很不方便，因为 ROM 中的数据无法更改。如何解决？</p><ul><li><strong>ROM 中只存放很小的“自举装入程序”</strong></li><li><strong>完整的自举程序放在磁盘的启动块（即引导块&#x2F;启动分区）上，启动块位于磁盘的固定位置</strong></li><li>开机时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块，并将完整的“自举程序”读入内存，完成初始化</li><li>拥有启动分区的磁盘称为启动磁盘或系统磁盘（C 盘）</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230806214001594.png" alt="image-20230806214001594"></p><h3 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h3><p><img src="/../image/assets/image-20230806214013758.png" alt="image-20230806214013758"></p><ul><li>坏块的管理<ul><li>坏块<ul><li>坏了无法正常使用的扇区</li><li>属于硬件故障，操作系统是无法修复的</li><li>应该将坏块标记出来，以免错误的使用到它</li></ul></li><li>对于简单的磁盘<ul><li><strong>可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区</strong><ul><li>比如：在 FAT 表上标明</li><li>这种方式，坏块对操作系统不透明</li></ul></li></ul></li><li>对于复杂的磁盘<ul><li>磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表</li><li><strong>在磁盘出厂前进行低级格式化（物理格式化时）就将坏块链进行初始化</strong></li><li>会保留一些“备用扇区”，用于替换坏块<ul><li>这种方法被称为扇区备用</li><li>这种方式，坏块对操作系统透明</li></ul></li></ul></li></ul></li></ul><h2 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘 SSD"></a>固态硬盘 SSD</h2><p><img src="/../image/assets/image-20230806215220092.png" alt="image-20230806215220092"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../image/assets/image-20230806215244117.png" alt="image-20230806215244117"></p><ul><li>固态硬盘<ul><li>原理<ul><li>基于闪存技术 Flash Memory，属于电可擦除 ROM，EEPROM</li></ul></li><li>组成<ul><li>闪存翻译层<ul><li>负责翻译逻辑块号，找到对应页（Page）</li></ul></li><li>存储介质<ul><li>多个闪存芯片（Flash Chip）</li><li>每个芯片包含多个块（block）</li><li>每个块包含多个页（page）</li></ul></li></ul></li><li>读写性能特性<ul><li>以页（page）为单位读&#x2F;写——相对于磁盘的“扇区”</li><li><strong>以块（block）为单位“擦除”，擦干净的块，其中的每页都可以写一次，读无数次</strong></li><li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可以通过电路迅速定位到对应的物理地址</li><li>读快、写慢<ul><li><strong>要写的页如果有数据，则不能直接写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页</strong></li></ul></li></ul></li><li>与机械硬盘相比的特点<ul><li>读写速度<ul><li>SSD 读写速度快，随机访问性能高，用电路控制访问位置</li><li>机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li></ul></li><li>SSD 安静无噪音、耐摔抗震、能耗低、造价更贵</li><li><strong>SSD 的一个块被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</strong></li></ul></li><li>磨损均衡技术<ul><li>思想<ul><li><strong>将擦除平均分布到各个块上，以提升使用寿命</strong></li></ul></li><li>动态磨损均衡<ul><li>写入数据时，优先选择累计擦除次数少的新闪存块</li></ul></li><li>静态磨损均衡<ul><li>SSD 监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务</li></ul></li></ul></li></ul></li></ul><h3 id="固态硬盘的结构"><a href="#固态硬盘的结构" class="headerlink" title="固态硬盘的结构"></a>固态硬盘的结构</h3><p><img src="/../image/assets/image-20230806215335246.png" alt="image-20230806215335246"></p><ul><li>闪存翻译层<ul><li>地址变换</li><li>将系统要读&#x2F;写的逻辑块号翻译成对应的物理地址</li></ul></li></ul><p><img src="/../image/assets/image-20230806220359852.png" alt="image-20230806220359852"></p><ul><li>块<ul><li>大小：16KB~512KB</li><li>磁道</li></ul></li></ul><p><img src="/../image/assets/image-20230806220424712.png" alt="image-20230806220424712"></p><ul><li>页<ul><li>大小：512B~4KB</li><li>扇区</li></ul></li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/../image/assets/image-20230806220506567.png" alt="image-20230806220506567"></p><ul><li><p>理想情况下，固态硬盘的寿命</p><ul><li><p>某固态硬盘采用磨损均衡技术，大小为240B&#x3D;1TB，闪存块的擦写寿命只有2^10&#x3D;1K次。某男子平均每天会对该固态硬盘写237B&#x3D;128GB数据。在最理想的情况下，这个固态硬盘可以用多久？</p><ul><li>SSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。</li><li>1TB &#x2F; 128GB &#x3D; 8</li><li>因此，平均每8天，每个闪存块需要擦除一次。</li><li>每个闪存块可以被擦除1K次，因此，经过8K天，约23年后，该固态硬盘被男子玩坏</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件管理&quot;&gt;&lt;a href=&quot;#文件管理&quot; class=&quot;headerlink&quot; title=&quot;文件管理&quot;&gt;&lt;/a&gt;文件管理&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="操作系统" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/408/"/>
    
    
    <category term="文件管理" scheme="https://sdumoist.github.io/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://sdumoist.github.io/2023/08/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sdumoist.github.io/2023/08/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-08-02T07:37:53.900Z</published>
    <updated>2024-03-30T19:31:47.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul><li><p>操作系统作为系统资源的管理者，要对内存进行管理</p><ul><li><strong>负责内存空间的分配与回收</strong></li><li><strong>提供某种技术从逻辑上对内存空间进行扩充</strong></li><li><strong>提供地址转换功能，负责程序的逻辑地址与物理地址的转换</strong></li><li><strong>提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</strong>-</li></ul></li></ul><p><img src="/../image/assets/image-20230802171710086.png" alt="image-20230802171710086"></p><ul><li><p>覆盖技术、交换技术</p><ul><li>只会在选择题中考察，掌握概念和方法</li></ul></li><li><p>理解基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）的原理 和流程</p></li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230802163712283.png" alt="image-20230802163712283"></p><p><img src="/../image/assets/image-20230802165956959.png" alt="image-20230802165956959"></p><p><img src="/../image/assets/image-20230802172407288.png" alt="image-20230802172407288"></p><p><img src="/../image/assets/image-20230802165202885.png" alt="image-20230802165202885"></p><p><img src="/../image/assets/image-20230802175525951.png" alt="image-20230802175525951"></p><p><img src="/../image/assets/image-20230802194039560.png" alt="image-20230802194039560"></p><p><img src="/../image/assets/image-20230802210612544.png" alt="image-20230802210612544"></p><p><img src="/../image/assets/image-20230802220314184.png" alt="image-20230802220314184"></p><p><img src="/../image/assets/image-20230802223940309.png" alt="image-20230802223940309"></p><p><img src="/../image/assets/image-20230803123226329.png" alt="image-20230803123226329"></p><p><img src="/../image/assets/image-20230803164541433.png" alt="image-20230803164541433"></p><p><img src="/../image/assets/image-20230803174615060.png" alt="image-20230803174615060"></p><p><img src="/../image/assets/image-20230803182302616.png" alt="image-20230803182302616"></p><p><img src="/../image/assets/image-20230803193955856.png" alt="image-20230803193955856"></p><p><img src="/../image/assets/image-20230803202528683.png" alt="image-20230803202528683"></p><p><img src="/../image/assets/image-20230803213035658.png" alt="image-20230803213035658"></p><p><img src="/../image/assets/image-20230803222912834.png" alt="image-20230803222912834"></p><p><img src="/../image/assets/image-20230803223307787.png" alt="image-20230803223307787"></p><h2 id="知识滚雪球：指令的工作原理"><a href="#知识滚雪球：指令的工作原理" class="headerlink" title="知识滚雪球：指令的工作原理"></a>知识滚雪球：指令的工作原理</h2><p><img src="/../image/assets/image-20230802155512624.png" alt="image-20230802155512624"></p><ul><li>一个高级程序语言要先经过编译器的编译，变成一个个CPU能看懂的二进制指令</li><li>这些指令会告诉 CPU 应该去内存的哪个地址读&#x2F;写数据，这个数据应该做什么样的处理（移动到其他寄存器、加减乘除…）</li><li>在上述例子中<ul><li>默认让这个进程的相关内容从地址#0 开始连续存放，指令中的地址参数直接给出了变量 x 的实际存放地址（物理地址）</li><li>思考<ul><li>如果这个进程不是从地址#0 开始存放的，会影响指令的正常执行吗？</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802160157985.png" alt="image-20230802160157985"><br><img src="/../image/assets/image-20230802160516894.png" alt="image-20230802160516894"></p><ul><li>使用逻辑地址<ul><li><p>默认操作系统给进程分配的是一片连续的内存空间</p></li><li><p>C 语言程序经过编译、链接处理后，生成装入模块，即可执行文件</p><ul><li>int x &#x3D; 10;</li><li>x &#x3D; x+ 1;</li></ul></li><li><p>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址）</p><ul><li>即相对于进程的初始地址而言的地址</li></ul></li><li><p>如果在逻辑地址中指明要对内存地址为 79 的存储单元进行操作，而该程序在物理地址中第一句指令的存放位置不是 0，79 的空间可能早就被其他程序占用了，那么就会发生可能占用其他进程的内存空间的问题</p><ul><li>如何将指令中的逻辑地址转换为物理地址？——三种装入方式<ul><li>绝对装入</li><li>可重定位装入（静态重定位）</li><li>动态运行时装入（动态重定位）</li></ul></li></ul></li></ul></li></ul><h3 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h3><p><img src="/../image/assets/image-20230802165003401.png" alt="image-20230802165003401"></p><h4 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h4><p><img src="/../image/assets/image-20230802161013796.png" alt="image-20230802161013796"></p><ul><li>绝对装入<ul><li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码</li><li>装入程序按照装入模块中的地址，将程序 和数据装入内存<ul><li>如果知道装入模块要从地址为 100 的地方开始存放<ul><li>编译、链接后得到的装入模块的指令直接就使用了绝对地址</li><li>将相对地址直接修改为正确地址</li></ul></li></ul></li><li>绝对装入<strong>只适用于单道程序环境</strong><ul><li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予</li><li>通常情况下都是编译或汇编时再转换为绝对地址</li></ul></li><li>灵活性很差</li></ul></li></ul><h4 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h4><p><img src="/../image/assets/image-20230802161759067.png" alt="image-20230802161759067"></p><ul><li>静态重定位<ul><li>又称可重定位装入</li><li>编译、链接后的装入模块地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址</li><li><strong>可根据内存的当前情况，将装入模块装入到内存的适当位置</strong></li><li>装入时对地址进行“重定位”，将逻辑地址变换为物理地址（<strong>地址变换是在装入时一次完成的</strong>）</li></ul></li><li>程序装入时根据装入的起始物理地址，将所有地址相关的参数进行相加</li><li>特点<ul><li>一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong></li><li>如果没有足够的内存，就不能装入该作业</li><li>作业一旦进入内存后，<strong>在运行期间就不能再移动</strong></li></ul></li></ul><h4 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h4><p><img src="/../image/assets/image-20230802162059730.png" alt="image-20230802162059730"><br><img src="/../image/assets/image-20230802162424288.png" alt="image-20230802162424288"></p><ul><li><p>动态重定位</p><ul><li>又称动态运行时装入</li><li>编译、链接后的装入模块的地址都是从 0 开始的</li><li>装入程序把装入模块装入内存后，并不会立即把逻辑地址转化为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才运行</strong></li><li>因此<strong>装入内存后所有的地址依然是逻辑地址</strong></li><li>这种方式需要一个重定位寄存器的支持<ul><li>重定位寄存器：<strong>存放装入模块存放的起始位置</strong></li></ul></li></ul></li><li><p>实际物理地址 &#x3D; 重定位寄存器 + 逻辑地址</p><ul><li>采用动态重定位时<strong>允许程序在内存中发生移动</strong></li><li>并且可将程序分配到不连续的存储区中<ul><li>在程序运行前只需装入它的部分代码即可投入运行</li><li>然后在程序运行期间，根据需要动态申请分配内存</li></ul></li></ul></li><li><p>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</p></li></ul><h3 id="从写程序到程序运行"><a href="#从写程序到程序运行" class="headerlink" title="从写程序到程序运行"></a>从写程序到程序运行</h3><p><img src="/../image/assets/image-20230802162858955.png" alt="image-20230802162858955"></p><ul><li><p>编译：</p><ul><li>由编译程序将用户源代码编译成若干个目标模块</li><li>将高级语言翻译成机器语言</li></ul></li><li><p>链接</p><ul><li>由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块（可执行文件）</li></ul></li><li><p>装入（装载）</p><ul><li>由装入程序将装入模块装入内存运行</li></ul></li></ul><h4 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h4><p><img src="/../image/assets/image-20230802163201048.png" alt="image-20230802163201048"></p><ul><li>链接的三种方式<ul><li>静态链接（一次合成，终身受益）<ul><li>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后便不再拆开</li></ul></li><li>装入时动态链接（硬盘中不一定连续，内存中连续）<ul><li>将各目标模块装入内存时，边装入边链接</li></ul></li><li>运行时链接（用的时候再链接）<ul><li>在程序执行中需要该目标模块时，才对它进行链接</li><li>用不到的模块不需要装入内存</li><li>优点：便于修改和更新，便于实现对目标模块的共享</li></ul></li></ul></li></ul><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><p><img src="/../image/assets/image-20230802153834580.png" alt="image-20230802153834580"></p><p><img src="/../image/assets/image-20230803182620981.png" alt="image-20230803182620981"></p><h3 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h3><h4 id="什么是内存，有什么作用？"><a href="#什么是内存，有什么作用？" class="headerlink" title="什么是内存，有什么作用？"></a>什么是内存，有什么作用？</h4><p><img src="/../image/assets/image-20230802155011150.png" alt="image-20230802155011150"></p><ul><li>内存可存放数据<ul><li>程序执行前需要先放到内存中才能被 CPU 处理——缓和 CPU 与硬盘之间的速度矛盾</li></ul></li><li>思考<ul><li>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。</li><li>那么如何区分各个程序的数据时放在什么地方的呢？<ul><li>方案：给内存的存储单元编地址<ul><li>内存中一个一个的小房间就是<strong>存储单元</strong></li><li>内存地址从 0 开始，<strong>每个地址对应一个存储单元</strong></li><li>如果计算机“按字节编址”，则每个存储单元大小为 1 字节，即 1B，即 8 个二进制位</li><li>如果字长为 16 位的计算机“按字编址”</li></ul></li></ul></li></ul></li></ul><h3 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h3><p><img src="/../image/assets/image-20230802165202885.png" alt="image-20230802165202885"></p><ul><li>操作系统作为系统资源的管理者，要对内存进行管理<ul><li><strong>负责内存空间的分配与回收</strong></li><li><strong>提供某种技术从逻辑上对内存空间进行扩充</strong></li><li><strong>提供地址转换功能，负责程序的逻辑地址与物理地址的转换</strong></li><li><strong>提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</strong></li></ul></li><li>问题<ul><li>操作系统要怎么记录哪些内存区域已经被分配出去了？哪些又还空闲？</li><li>当进程运行结束之后，如果将进程占用的内存空间回收？</li><li>内存很多位置都可以放，那应该放在哪里？</li></ul></li></ul><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ul><li>连续分配：为用户进程分配的必须是一个<strong>连续的内存空间</strong></li></ul><h5 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h5><p><img src="/../image/assets/image-20230802180221925.png" alt="image-20230802180221925"></p><ul><li>单一连续分配方式<ul><li>内存被分为<strong>系统区和用户区</strong><ul><li>系统区<ul><li>通常位于内存的低地址部分，用于存放操作系统相关数据</li></ul></li><li>用户区<ul><li>用于存放用户进程相关数据</li></ul></li></ul></li><li>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。<ul><li>有很大一部分用户区空闲，内存利用率低</li></ul></li></ul></li><li>优点<ul><li>实现简单</li><li>无外部碎片</li><li>可以采用覆盖技术拓展内存</li><li>不一定需要采取内存保护</li></ul></li><li>缺点<ul><li>只能用于单用户、单任务的操作系统</li><li>有内部碎片<ul><li><strong>分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”</strong></li></ul></li><li>存储器利用率极低</li></ul></li></ul><h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><p><img src="/../image/assets/image-20230802180751903.png" alt="image-20230802180751903"></p><ul><li>固定分区分配<ul><li>目的<ul><li>多道程序系统为了能在内存中装入多道程序，且这些程序之间又不会相互干扰</li></ul></li><li>解决方案<ul><li>将整个用户空间划分为若干个固定大小的 分区</li><li><strong>在每个分区中只装入一道作业</strong></li><li>这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式</li></ul></li><li>两种方案<ul><li>分区大小相等<ul><li>缺乏灵活性</li><li><strong>适合用于一台计算机控制多个相同对象的场合</strong><ul><li>比如：钢铁厂有 n 个相同的炼钢炉，就可以把内存分为 n 个大小相等的区域存放 n 个炼钢炉控制程序</li></ul></li></ul></li><li>分区大小不等<ul><li>增加了灵活性</li><li>可以满足不同大小的进程需求</li><li>根据常在系统中运行的作业大小情况进行划分<ul><li>比如：划分多个小分区、适量中等分区、少量大分区</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802181422777.png" alt="image-20230802181422777"></p><ul><li>如何实现<ul><li>操作系统需要建立一个数据结构——<strong>分区说明表</strong>，来实现各个分区的分配与回收<ul><li>用数据结构的数组（或链表）即可表示这个表</li></ul></li><li>每个表项对应一个分区，通常按分区大小排列</li><li>每个表项包括对应分区的<strong>大小、起始地址、状态</strong>（是否已分配）</li></ul></li><li>实现过程<ul><li><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”</p></li><li><p>优点</p><ul><li>实现简单，无外部碎片</li></ul></li><li><p>缺点</p><ul><li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li><li><strong>会产生内部碎片</strong>，内存利用率低</li></ul></li></ul></li></ul><h5 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h5><p><img src="/../image/assets/image-20230802191311909.png" alt="image-20230802191311909"></p><ul><li><p>动态分区分配</p><ul><li>又称<strong>可变分区分配</strong></li><li><strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态的建立分区</strong>，并使分区的大小正好适合进程的需要</li><li>因此系统分区的大小和数目是可变的</li></ul></li><li><p>问题</p><ul><li><p>假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56MB</p><ul><li><p>系统要用什么样的数据结构记录内存的使用情况？</p></li><li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p></li><li><p>如何进行分区的分配与回收操作？</p></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802191815612.png" alt="image-20230802191815612"></p><ul><li>系统要用什么样的数据结构记录内存的使用情况？<ul><li>空闲分区表<ul><li>每个空闲分区对应一个表项</li><li>表项中包含分区号、分区大小、分区起始地址等信息</li></ul></li><li>空闲分区链<ul><li>每个分区的起始部分和末尾部分分别设置前向指针和后向指针</li><li>起始部分处还可记录分区大小等信息</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802192045465.png" alt="image-20230802192045465"></p><ul><li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？<ul><li>应该用最大的分区进行分配？还是用最小的分区进行分配？又或是用地址最低的部分进行分配？</li><li>把一个新作业装入内存时，需按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业</li><li>分配算法对系统性能有很大影响</li></ul></li></ul><p><img src="/../image/assets/image-20230802192448898.png" alt="image-20230802192448898"><br><img src="/../image/assets/image-20230802192605134.png" alt="image-20230802192605134"></p><ul><li>空闲分区表<ul><li>如果分区大小&gt;进程大小，直接修改分区大小和起始地址</li><li>如果分区大小&#x3D;进程大小，直接删去分区</li></ul></li><li>空闲分区链<ul><li>如果分区大小&gt;进程大小，直接修改分区大小</li><li>如果分区大小&#x3D;进程大小，直接删去分区节点</li></ul></li></ul><p><img src="/../image/assets/image-20230802193118101.png" alt="image-20230802193118101"></p><p><img src="/../image/assets/image-20230802193057824.png" alt="image-20230802193057824"></p><p><img src="/../image/assets/image-20230802193130662.png" alt="image-20230802193130662"></p><p><img src="/../image/assets/image-20230802193430953.png" alt="image-20230802193430953"></p><ul><li><p>空闲分区表</p><ul><li>回收区的后面有一个相邻的空闲分区<ul><li>两个相邻的空闲分区合并为一个</li></ul></li><li>回收区的前面有一个相邻的空闲分区<ul><li>两个相邻的空闲分区合并为一个</li></ul></li><li>回收区的前、后各有一个相邻的空闲分区<ul><li>三个相邻的空闲分区合并为一个</li></ul></li><li>回收区的前、后都没有相邻的空闲分区<ul><li>新增一个表项</li></ul></li></ul></li><li><p>各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</p></li></ul><p><img src="/../image/assets/image-20230802193416909.png" alt="image-20230802193416909"></p><ul><li>动态分区分配<strong>没有内部碎片，但是有外部碎片</strong><ul><li>内部碎片<ul><li><strong>分配给某进程的内存区域，如果有些部分没有用上</strong></li></ul></li><li>外部碎片<ul><li><strong>内存中的某些空闲分区由于太小而难以利用</strong></li></ul></li></ul></li><li>如果内存中空闲时间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求<ul><li>可以通过紧凑（拼凑，Compaction）技术来解决外部碎片<ul><li>把各个进程挪位，拼凑在一起，得到一片连续的内存空间</li></ul></li></ul></li><li>回忆交换技术<ul><li>什么是换入换出？</li><li>什么是中级调度（内存调度）？</li></ul></li><li>思考动态分区分配应使用哪种装入方式？紧凑之后需要做什么处理？</li></ul><h5 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h5><p><img src="/../image/assets/image-20230802194233743.png" alt="image-20230802194233743"></p><p><img src="/../image/assets/image-20230802210629847.png" alt="image-20230802210629847"></p><h6 id="首次适应算法（First-Fit）（最好）"><a href="#首次适应算法（First-Fit）（最好）" class="headerlink" title="首次适应算法（First Fit）（最好）"></a>首次适应算法（First Fit）（最好）</h6><p><img src="/../image/assets/image-20230802194406142.png" alt="image-20230802194406142"></p><ul><li>算法思想<ul><li>每次都从低地址开始查找，找到第一个能满足大小的空闲分区</li></ul></li><li>如何实现<ul><li><strong>空闲分区以地址递增的次序排列</strong></li><li>每次分配内存时，顺序查找空闲分区链（空闲分区表），找到<strong>大小能满足要求的第一个空闲分区</strong></li></ul></li></ul><h6 id="最佳适应算法（Best-Fit）"><a href="#最佳适应算法（Best-Fit）" class="headerlink" title="最佳适应算法（Best Fit）"></a>最佳适应算法（Best Fit）</h6><p><img src="/../image/assets/image-20230802204728169.png" alt="image-20230802204728169"></p><ul><li>算法思想<ul><li>由于动态分区分配时一种连续分配方式，为各进程分配的空间必须是连续的一整片区域</li><li>为了保证当大进程到来时能有连续的大片空间，可以尽可能多的留下大片的空闲区</li></ul></li><li>如何实现<ul><li><strong>空闲分区按容量递增次序连接</strong></li><li>每次分配内存时顺序查找空闲分区链&#x2F;空闲分区表，找到大小能满足要求的第一个空闲分区</li></ul></li><li>缺点<ul><li>每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块</li><li>会产生很多的外部碎片</li></ul></li></ul><h6 id="最坏适应算法（Worst-Fit）"><a href="#最坏适应算法（Worst-Fit）" class="headerlink" title="最坏适应算法（Worst Fit）"></a>最坏适应算法（Worst Fit）</h6><p><img src="/../image/assets/image-20230802205128995.png" alt="image-20230802205128995"></p><ul><li>又称最大适应算法（Largest Fit）</li><li>算法思想<ul><li>为了解决最佳适应算法的问题——即留下太多难以利用的小碎片</li><li>可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</li></ul></li><li>如何实现<ul><li><strong>空闲分区按容量递减次序连接</strong></li><li>每次分配内存时顺序查找空闲分区链&#x2F;空闲分区表，找到大小能满足要求的第一个内存分区</li></ul></li><li>缺点<ul><li>每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完</li><li>如果之后有“大进程”到达，就没有内存分区可用了</li></ul></li></ul><h6 id="临近适应算法（Next-Fit）"><a href="#临近适应算法（Next-Fit）" class="headerlink" title="临近适应算法（Next Fit）"></a>临近适应算法（Next Fit）</h6><p><img src="/../image/assets/image-20230802205618239.png" alt="image-20230802205618239"></p><ul><li>算法思想<ul><li>首次适应算法每次都从链头开始查找，这可能会导致低地址部分出现很多小的空闲分区</li><li>而每次分配查找时，就要经过这些分区，因此也增加了查找的开销</li><li>如果<strong>每次都从上次查找结束的位置开始检索</strong>，就能解决上述问题</li></ul></li><li>如何实现<ul><li><strong>空闲分区以地址递增的顺序排列</strong>（可排成一个循环链表）</li><li>每次分配内存时从上次查找结束的位置开始查找空闲分区链&#x2F;空闲分区表，找到大小能满足要求的第一个空闲分区</li></ul></li><li>对比<ul><li>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区</li><li>这样的规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分得小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</li><li>临近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更有可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</li><li>总和来看，<strong>首次适应算法的效果最好</strong></li></ul></li></ul><h4 id="非连续分配的管理方式"><a href="#非连续分配的管理方式" class="headerlink" title="非连续分配的管理方式"></a>非连续分配的管理方式</h4><p><img src="/../image/assets/image-20230802210706784.png" alt="image-20230802210706784"></p><ul><li>连续分配：为用户进程分配的必须是一个连续的内存空间</li><li>非连续分配：为用户进程分配的可以是一些分散的内存空间</li></ul><h5 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h5><p><img src="/../image/assets/image-20230802211037197.png" alt="image-20230802211037197"></p><ul><li>分页存储<ul><li><strong>将内存空间空间分为一个个大小相等的分区</strong><ul><li>比如：每个分区 4KB</li><li>每个分区就是一个“<strong>页框</strong>”<ul><li>页框 &#x3D; 页帧 &#x3D; 内存块 &#x3D; 物理块 &#x3D; 物理页面</li></ul></li><li>每个页框有一个编号，即<strong>页框号</strong>，页框号从 0 开始<ul><li>页框号 &#x3D; 页帧号 &#x3D; 内存块号 &#x3D; 物理块号 &#x3D; 物理页号</li></ul></li></ul></li><li>将进程的<strong>逻辑地址空间也分为与页框大小相等</strong>的一个个部分<ul><li>每个部分称为一个<strong>页或页面</strong></li><li>每个页面也有一个编号，即<strong>页号</strong>，页号也是从 0 开始</li></ul></li><li>页号、页面号 VS 页框号、页帧号、物理块号<ul><li><strong>操作系统以页框为单位为各个进程分配内存空间</strong></li><li><strong>进程的每个页面分别放入一个页框中</strong><ul><li>进程的页面与内存的页框一一对应</li></ul></li><li>各个页面不必连续存放，可以放到不想理你的各个页框中</li></ul></li></ul></li><li>进程的最后一个页面可能没有一个页框那么大<ul><li>分页存储可能会产生内部碎片</li><li><strong>页框不能太大，否则可能产生过大的内部碎片造成浪费</strong></li></ul></li><li>自己理解<ul><li>类似于分区相等的固定分区分配</li><li>把内存分为不大的一个个小段，然后把进程也分为同样大小的小段，一个小段对应一个小段</li><li>跟内存有关的叫页框、页帧、物理啥、内存块（比较拗口）；跟进程有关的叫页&#x2F;页面（比较简单）</li></ul></li></ul><p><img src="/../image/assets/image-20230802212211893.png" alt="image-20230802212211893"></p><ul><li>页表<ul><li>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表<ul><li>页表通常存在 PCB（进程控制块）中</li></ul></li><li>一个进程对应一张页表</li><li>进程的每个页面对应一个页表项</li><li>每个<strong>页表项</strong>由“页号”和“块号”组成</li><li><strong>页表记录进程页面和实际存放的内存块之间的映射关系</strong></li><li>每个页表项的长度是相同的</li></ul></li><li>问题<ul><li>每个页表项多大？占几个字节？</li><li>如何通过页表实现逻辑地址到物理地址的转换？</li></ul></li></ul><p><img src="/../image/assets/image-20230802212720661.png" alt="image-20230802212720661"></p><ul><li><p>每个页表项栈多少字节？</p><ul><li>Eg：假设某系统物理内存大小为4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？<ul><li>内存块大小 &#x3D; 页面大小 &#x3D; 4KB &#x3D; 2^12B</li><li>4GB的内存总共会被分为 2^32&#x2F;2^12&#x3D;2^20 个内存块</li><li>内存块号的范围应该是 0~2^20-1</li><li>内存块号至少要用 20bit 表示</li><li>至少要用 3B 来表示块号（3*8&#x3D;24bit）<ul><li>计算机中内存块的数量 —&gt; 页表项中块号至少占多少字节</li></ul></li></ul></li><li>注意：页表记录的只是内存块号，而不是内存块的起始地址！<ul><li><strong>J 号内存块的起始地址 &#x3D; J * 内存块大小</strong></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802213212624.png" alt="image-20230802213212624"></p><ul><li>页号又要占多少字节呢？<ul><li>页表项连续存放，因此页表可以是隐含的，不占存储空间（类比数组）<ul><li>每个页表项占 3B 并且都是连续存放<ul><li>假设页表中的各页表项从内存地址为 x 的地方开始连续存放</li><li>如何找到页号为 i 的页表项？</li><li><strong>i 号页表项的存放地址 &#x3D; x + 3*i</strong></li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802213553006.png" alt="image-20230802213553006"></p><ul><li>如何实现地址的转换？<ul><li>进程在内存中连续存放时，操作系统是如何实现逻辑地址到物理地址的转换的？<ul><li>重定位寄存器：指明了进程在内存中的起始位置</li><li>目标逻辑地址：相对于其实位置的偏移量</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802213733618.png" alt="image-20230802213733618"></p><ul><li>将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？<ul><li>特点<ul><li>虽然进程的各个页面是离散存在的，但是页面内部是连续存放的</li></ul></li><li>如果想要访问逻辑地址 A，则<ul><li>确定逻辑地址 A 对应的<strong>“页号”P</strong></li><li>找到 P 号页面在内存中的起始地址（需要查页表）</li><li>确定逻辑地址 A 的<strong>页内偏移量 W</strong></li></ul></li><li>逻辑地址 A 对应的物理地址 &#x3D; P 号页面在内存中的起始地址 + 页内偏移量 W</li></ul></li></ul><p><img src="/../image/assets/image-20230802214203853.png" alt="image-20230802214203853"></p><ul><li>如何确定一个逻辑地址对应的页号、页内偏移量<ul><li>在某个计算机系统中，页面大小是 50B。某进程逻辑地址空间大小为 200B，则逻辑地址 110 对应的页号、页内偏移量是多少？<ul><li>页号 &#x3D; 逻辑地址&#x2F;页面长度（取除法的整数部分）<ul><li>页号 &#x3D; 110&#x2F;50 &#x3D; 2</li></ul></li><li>页内偏移量 &#x3D; 逻辑地址 % 页面长度（取触发的余数部分）<ul><li>页内偏移量 &#x3D; 110 % 50 &#x3D; 10</li></ul></li><li><strong>逻辑地址可以拆分为（页号，页内偏移量）</strong></li><li>通过页号查询页表，可以知道页面在内存中的起始地址</li><li>页面在内存中的起始地址 + 页内偏移量 &#x3D; 实际的物理地址</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802215031514.png" alt="image-20230802215031514"></p><ul><li>如果每个页面大小为 2^kB，用二进制数表示逻辑地址，则末尾 k 位即为页偏移量，其余部分就是页号</li></ul><p><img src="/../image/assets/image-20230802215313209.png" alt="image-20230802215313209"></p><ul><li>如果页面大小刚好是 2 的整数幂，则只需把页表中记录的物理块号拼接上页内偏移量就能得到对应的物理地址</li></ul><p><img src="/../image/assets/image-20230802215511487.png" alt="image-20230802215511487"></p><ul><li>总结<ul><li>页面大小刚好是 2 的整数次幂有什么好处？<ul><li>逻辑地址的拆分更加迅速<ul><li>如果每个页面大小为 2^kB，用二进制数表示逻辑地址，则末尾 k 位即为页内偏移量，其余部分就是页号</li><li>如果让每个页面的大小为 2 的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度</li></ul></li><li>物理地址的计算更加迅速<ul><li>根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802215901131.png" alt="image-20230802215901131"></p><ul><li><p>逻辑地址结构</p><ul><li>地址结构包含两个部分<ul><li>前一部分是页号P</li><li>后一部分是页内偏移量 W</li></ul></li><li>地址长度为 32 位，其中 0<del>11 是页内偏移量&#x2F;页内地址，12</del>31 位为页号</li></ul></li><li><p><strong>如果有 k 位表示页内偏移量，则说明该系统中一个页面的大小是 2^k个内存单元</strong></p><ul><li>页面大小 &#x3D; 业内偏移量 &#x3D; 逻辑地址结构</li></ul></li><li><p><strong>如果有 M 为表示页号，则说明在该系统中，一个进程最多允许有 2^M个页面</strong></p></li><li><p>有些奇葩题目中页面大小有可能不是2的整数次幂，这种情况还是得用最原始的方法计算：</p></li></ul><p>​<strong>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</strong></p><p>​<strong>页内偏移量 &#x3D; 逻辑地址 % 页面长度（取除法的余数部分）</strong></p><h6 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h6><p><img src="/../image/assets/image-20230802221238041.png" alt="image-20230802221238041"></p><ul><li>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址</li><li>通常会在系统中设置一个页表寄存器（PTR）<ul><li>存放<strong>页表在内存中的起始地址 F 和页表长度M</strong></li><li>页表寄存器的作用类似于一个快速访问的缓存，它存储了最近使用的页表的物理地址，以减少地址转换的开销。这有助于提高程序的执行效率，特别是在涉及频繁的内存访问操作时。<ul><li>这个是 <strong>CPU 从内存中取数据时</strong>使用的，记录当前访问到的页表的地址，就可以很方便的继续向下读取未执行的页表项</li></ul></li></ul></li><li>进程未执行时，<strong>页表的始址和页表长度放在进程控制块 PCB 中</strong></li><li>当进程被调度时，操作系统内核会把它们放到页表寄存器中</li></ul><p><img src="/../image/assets/image-20230802221535376.png" alt="image-20230802221535376"></p><ul><li>过程<ul><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界</li><li>查询页表，找到页号对应的页表项，确定页面存放的内存块号</li><li>用内存块号和页内偏移量得到物理地址</li><li>访问目标内存单元</li></ul></li></ul><p><img src="/../image/assets/image-20230802221829340.png" alt="image-20230802221829340"></p><ul><li>文字描述<ul><li>设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下<ul><li>计算页号 P 和页内偏移量 W<ul><li>如果用十进制手算，则 P&#x3D;A&#x2F;L, W&#x3D;A%L</li><li>在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量</li></ul></li><li>比较页号 P 和页表长度M，<strong>若 P&gt;&#x3D; M，则产生越界中断</strong>，否则继续执行<ul><li><strong>页号是从 0 开始的，而页表长度至少是 1，因此 P&#x3D;M 时也会越界</strong></li></ul></li><li>页表中   <strong>页号 P 对应的页表项地址 &#x3D; 页表起始地址 F + 页表 P * 页表项长度</strong><ul><li>取出该页表项内容 b，即为内存块号<ul><li>注意区分页表项长度、页表长度、页面大小的区别</li><li>页表项长度：这个页表中总共有几个页表项，即总共有几个页</li><li>页表长度：每个页表项占多大的存储空间</li><li>页表大小：一个页面占多大的存储空间</li></ul></li></ul></li><li>计算 E&#x3D;b*L + W，用得到的物理地址 E 去方寸<ul><li>如果内存块号、页内偏移量是用二进制表示的，那么把两者拼接起来就是最终的物理地址了</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802223059776.png" alt="image-20230802223059776"></p><ul><li>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了<ul><li><strong>页式管理中地址是一维的</strong></li><li>只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显示的告诉系统这个逻辑地址中，页内偏移量占多少位</li></ul></li></ul><p><img src="/../image/assets/image-20230802223524246.png" alt="image-20230802223524246"><br><img src="/../image/assets/image-20230802223636193.png" alt="image-20230802223636193"></p><ul><li><p>对页表项大小的进一步探讨</p><ul><li><p>如果每个页表项占 4 个字节</p><ul><li>1024 号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用 X+4*1024 得出</li></ul></li><li><p>结论</p><ul><li>页表项长度为 3B 即可表示内存块号的范围</li><li>但是为了方便页表的查询，常常会让一个页表项占更多的字节，使得<strong>每个页面恰好可以装得下整数个页表项</strong></li></ul></li><li><p>进程页表通常是装在连续的内存块中的</p></li></ul></li></ul><h6 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h6><p><img src="/../image/assets/image-20230802224141351.png" alt="image-20230802224141351"></p><ul><li>什么是快表(TLB)</li></ul><p><img src="/../image/assets/image-20230802224212930.png" alt="image-20230802224212930"></p><ul><li>快表（高速缓存，不是内存）<ul><li>又称联想寄存器（TLB，translation lookaside buffer）</li><li>是一种<strong>访问速度比内存快很多的高速缓存</strong>，用来<strong>存放最近访问的页表项的副本</strong>，可以加速地址变换的速度<ul><li>TLB 不是内存</li><li>TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</li></ul></li><li><strong>内存中的页表常称为慢表</strong></li></ul></li></ul><p><img src="/../image/assets/image-20230802224739956.png" alt="image-20230802224739956"></p><ul><li>使用过程<ul><li>CPU 每次访问内存中的逻辑地址，会先查找高速缓存中的快表，快表中没有想要的页表项才回去内存中访问页表&#x2F;慢表<ul><li><strong>最近使用过的页表项会放入快表，快表存放的是页表的一部分副本</strong></li><li>若快表命中就不需要再访问内存了</li><li>若快表中没有目标页表项，则需要查询内存中的页表</li></ul></li><li>先检查是否越界<ul><li>页号&gt;&#x3D;页表长度</li></ul></li><li>再看快表是否命中<ul><li>命中直接访问内存中的物理地址</li><li>未命中就要去内存中访问页表，然后再去内存中访问目标页面</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230803122835122.png" alt="image-20230803122835122"></p><ul><li>局部性原理<ul><li>时间局部性<ul><li>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行</li><li>如果某个数据被访问过，不久之后该数据很可能再次被访问</li><li>原因：程序中存在大量的循环</li></ul></li><li>空间局部性<ul><li>一旦程序访问了某个存储单元，在不就之后，其附近的存储单元也很有可能被访问</li><li>原因：很多数据在内存中都是连续存放的</li></ul></li></ul></li><li>基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表<ul><li>由于局部性原理，可能连续很多次查到的都是同一个页表项</li></ul></li></ul><p><img src="/../image/assets/image-20230803122508319.png" alt="image-20230803122508319"></p><ul><li>引入快表后，地址的变换过程<ul><li>CPU 给出逻辑地址，由某个硬件算的页号、页内偏移量，将页号与快表中的所有页号进行比较</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本<ul><li>直接从中取出该页对应的内存块号</li><li>再将内存块号与页内偏移量拼接形成物理地址</li><li>最后，访问该物理地址对应的内存单元</li></ul></li><li>如果没有找到匹配的页号<ul><li>需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号</li><li>再将内存块号与页内偏移量拼接形成物理地址</li><li>最后访问该物理地址对应的内存单元<ul><li>因此若快表未命中，则访问某个逻辑地址需要两次访存</li><li>在找到页表项后，应同时将其存入快表，以便后面可能的再次访问</li><li>但若快表已满，则必须按照一定的算法对就得页表项进行替换</li></ul></li></ul></li></ul></li><li>查询快表的速度比查询页表的速度快很多<ul><li>只要快表命中就可以节省很多时间</li><li>因为局部性原理，一般来说，快表的命中率可以达到 90%以上</li></ul></li><li>三种查询方式<ul><li>先查快表，快表查不到再去查慢表</li><li>快表慢表一起查</li><li>未采用快表机制</li></ul></li></ul><p><img src="/../image/assets/image-20230803124117474.png" alt="image-20230803124117474"></p><h6 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h6><p><img src="/../image/assets/image-20230803154044738.png" alt="image-20230803154044738"></p><ul><li>单级页表存在什么问题？如何解决？</li></ul><p><img src="/../image/assets/image-20230803154223318.png" alt="image-20230803154223318"></p><ul><li><p>某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为 4KB，页表项长度为 4B</p><ul><li>页面大小就是一个页框的大小，4KB&#x3D;2^12B，因此页内地址要用 12 位表示，剩余 20 位表示页号</li><li>因此该系统中用户进程最多有 2^20页</li><li>一个进程的页表中，最多会有 2^20&#x3D;1M&#x3D;1048576个页表项</li><li>一个页表最大需要2^20 * 4B(页表项长度) &#x3D; 2^22B，共需要 2^22&#x2F;2^12 &#x3D; 2^10个页框存储该页表<ul><li>需要专门给进程分配 2^10&#x3D;1024个连续的页框来存放它的页表</li></ul></li><li>根据页号查询页表的方法<ul><li>k 号页对应的页表项存放位置 &#x3D; 页表始址+K*4</li></ul></li><li>要在<strong>所有的页表项都连续存放</strong>的基础上才能用这种方法找到页表项</li></ul></li><li><p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，</p><ul><li>没有必要让整个页表都常驻内存</li></ul></li></ul><p><img src="/../image/assets/image-20230803155842609.png" alt="image-20230803155842609"></p><ul><li>问题<ul><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</li><li>没有必要将整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</li></ul></li><li>解决方法<ul><li>把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表</li></ul></li></ul><p><img src="/../image/assets/image-20230803160527412.png" alt="image-20230803160527412"></p><p><img src="/../image/assets/image-20230803160917448.png" alt="image-20230803160917448"></p><ul><li>32 位逻辑地址空间，页表项为 4B，页面大小为 4KB，则页内地址占 12 位<ul><li>0#页表：第一位是 0</li><li>1#页表：第一位是原来的 1024</li><li>……</li></ul></li><li>进程最多有 2^20 个页面，用 20 位二进制刚好可以表示 0~2^20-1个页号<ul><li>每个页面可以存放 4K&#x2F;4 &#x3D; 1K &#x3D; 2^10&#x3D;1024 个页表项</li><li>10 位一级页号刚好可以表示 0~1023</li></ul></li></ul><p><img src="/../image/assets/image-20230803161127859.png" alt="image-20230803161127859"></p><ul><li>如何实现地址变换<ul><li>按照地址结构将逻辑地址拆分成三部分</li><li>从 PCB 中读出页目录表始址，再根据一级页号查页目标表，找到下一级页表在内存中的存放位置</li><li>根据二级页号查二级页表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理内存</li></ul></li><li>逻辑地址<ul><li>一级页号（页目录号）</li><li>二级页号</li><li>页内偏移量</li></ul></li></ul><p><img src="/../image/assets/image-20230803161529866.png" alt="image-20230803161529866"></p><ul><li>解决方法<ul><li>可以在需要访问页面时才把页面调入内存（虚拟存储技术）</li><li>可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存了</li></ul></li><li>若想访问的页面不在内存中，则产生缺页中断（内中断&#x2F;异常），然后将目标页面从外存调入内存</li></ul><p><img src="/../image/assets/image-20230803162429904.png" alt="image-20230803162429904"></p><ul><li>题目<ul><li>先计算页内偏移量 4KB &#x3D; 2^12B，按字节编址，因此页内偏移量是 12 位</li><li>页号 &#x3D; 40 - 12 &#x3D; 28</li><li>页面大小 &#x3D; 2^12B，页表项 &#x3D; 4B，则每个页面可存放 2^12&#x2F;4 &#x3D; 2^10个页表项</li><li>各级页表最多包含 2^10个页表项，需要 10 位二进制位才能映射到 2^10个页表项，因此每一级的页表对应页号应为 10 位</li><li>总共 28 位的页号至少要分为三级</li></ul></li><li>两级页表的访存次数分析（假设没有快表机构）<ul><li>第一次访存<ul><li>访问内存中的页目录表</li></ul></li><li>第二次访存<ul><li>访问内存中的二级页表</li></ul></li><li>第三次访存<ul><li>访问目标内存单元</li></ul></li></ul></li></ul><h5 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h5><p><img src="/../image/assets/image-20230803164613477.png" alt="image-20230803164613477"></p><ul><li>与分页最大的区别就是——离散分配时所分配地址空间的基本单位不同</li></ul><h6 id="什么是分段"><a href="#什么是分段" class="headerlink" title="什么是分段"></a>什么是分段</h6><p><img src="/../image/assets/image-20230803165359307.png" alt="image-20230803165359307"></p><ul><li>进程的地址空间<ul><li>会按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名</li><li>在在低级语言中，程序员使用段名来编程，每段从 0 开始编址</li></ul></li><li>内存分配规则<ul><li>以段为单位进行分配</li><li>每个段在内存中占据连续空间，但各段之间可以不相邻</li></ul></li><li>按逻辑功能模块划分<ul><li>用户编程更方便，程序可读性更高<ul><li>STORE 1, [X] | &lt;B&gt;; &#x2F;&#x2F;将寄存器1的内容存入X 分段的B单元中</li><li>LOAD 1, [D] | &lt;A&gt;;          &#x2F;&#x2F;将分段D中A单元内的值读入寄存器1</li></ul></li></ul></li></ul><h6 id="什么是段表"><a href="#什么是段表" class="headerlink" title="什么是段表"></a>什么是段表</h6><p><img src="/../image/assets/image-20230803165517603.png" alt="image-20230803165517603"></p><ul><li><p>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成</p><ul><li><p>段号的位数决定了每个进程最多可以分为几个段</p></li><li><p>段内地址位数决定了每个段的最大长度是多少</p></li></ul></li><li><p>若系统是按字节寻址的</p><ul><li>段号占 16 位，因此在该系统中，每个进程最多有 2^16 &#x3D; 64K个段</li><li>段内地址占16位，因此每个段的最大长度是 2^16&#x3D;64KB</li></ul></li><li><p>STORE 1, [X] | &lt;B&gt;; &#x2F;&#x2F;将寄存器1的内容存入X 分段的B单元中</p></li><li><p>LOAD 1, [D] | &lt;A&gt;;          &#x2F;&#x2F;将分段D中A单元内的值读入寄存器1</p><ul><li>写程序时使用的段名 D、X 会被编译程序翻译成对应段号</li><li>A 单元、B 单元会被编译程序翻译成段内地址</li></ul></li></ul><p><img src="/../image/assets/image-20230803170005529.png" alt="image-20230803170005529"></p><ul><li>段表<ul><li>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置</li><li>需要为每个进程建立一张段映射表，简称段表<ul><li>建立了逻辑段到物理内存的映射关系</li></ul></li></ul></li><li>每个段对应一个段表项，其中记录了该段在内存中的起始位置（基址）和段的长度（每一段长度不一定相同）</li><li>各个段表项的长度是相同的<ul><li>某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号 16 位，段内地址 16 位）<ul><li>因此用 16 位即可表示最大段长</li></ul></li><li>物理内存大小为 4GB（<ul><li>可用 32 位表示整个物理内存地址空间</li></ul></li><li>因此可以让每个段表项占 16+32&#x3D;48 位，即 6B</li></ul></li><li>由于段表项长度相同，因此段号可以是隐含的不占内存空间<ul><li>若段表存放的起始地址为 M，则 k 号段对应的段表项存放的地址为 M+K*6</li></ul></li></ul><h6 id="如何实现地址转换"><a href="#如何实现地址转换" class="headerlink" title="如何实现地址转换"></a>如何实现地址转换</h6><p><img src="/../image/assets/image-20230803171342207.png" alt="image-20230803171342207"></p><ul><li>LOAD 1, [D] | &lt;A&gt;;          &#x2F;&#x2F;将分段D中A单元内的值读入寄存器1<ul><li>经过编译程序编译后，形成等价的机器指令<ul><li>取出段号为 2，段内地址为 1024 的内存单元中的内容，放到寄存器 1 中</li><li>机器指令中的逻辑地址用二进制表示：00000000000000010 0000000100000000</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230803171936002.png" alt="image-20230803171936002"></p><ul><li>实现过程<ul><li>进程切换相关的内核程序负责恢复进程运行环境<ul><li>其中最重要的就是段表寄存器</li></ul></li><li>当进程开始执行，进入内存时，首先就会访问段表寄存器</li><li>根据逻辑地址找到段号、段内地址</li><li>判断段号是否越界<ul><li>若 S&gt;&#x3D;M，则产生越界中断<ul><li>段表的长度至少是 1，而段号从 0开始</li></ul></li><li>若 S&lt;M，则继续执行查找</li></ul></li><li>查询段表，找到对应的段表项，段表项的存放地址为 F+S*段表项长度</li><li>检查段内地址是否超过段长<ul><li>若 W&gt;&#x3D;C，则产生越界中断</li><li>若 W&lt;C，继续执行</li></ul></li><li>计算得到物理地址</li><li>访问目标内存单元</li></ul></li></ul><h6 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h6><p><img src="/../image/assets/image-20230803172517903.png" alt="image-20230803172517903"></p><ul><li>页<ul><li>页是信息的物理单位<ul><li>分页的主要目的是为了<strong>实现离散分配</strong>，提高内存利用率</li><li><strong>分页仅仅是系统管理上的需要</strong>，完全是系统行为，对用户是不可见的</li></ul></li><li>页的大小固定且由系统决定</li><li>分页的用户进程<strong>地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址<ul><li>用户进程看起来好像在使用一个连续的地址空间，而不需要担心物理内存中的实际分布。程序员只需要提供一个虚拟地址即可，操作系统会将这个虚拟地址映射到正确的物理地址。</li></ul></li></ul></li><li>段<ul><li>段是信息的逻辑单位<ul><li><strong>分段的主要目的是更好的满足用户需求</strong></li><li>一个段通常包含着一组属于一个逻辑模块的信息</li><li>分段<strong>对用户是可见的</strong>，用户编程时需要显式的给出段名</li></ul></li><li>段的长度不固定，决定于用户编写的程序</li><li>分段的用户进程<strong>地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址<ul><li>用户进程的虚拟地址空间被划分为不同大小的段，每个段有一个名字。不同的段可以表示不同类型的数据或代码。因此，程序员需要提供两个信息：段名和段内地址，才能准确地标识一个地址。</li></ul></li></ul></li><li>一维 VS 二维<ul><li>分页的话不用考虑分配问题，在用户进程看来它是连续存储的；而分段要考虑分配，所以既要提供段名又要提供段内地址</li></ul></li></ul><p><img src="/../image/assets/image-20230803174655212.png" alt="image-20230803174655212"></p><ul><li>访问一个逻辑地址需要几次访存<ul><li><p>分页（单级页表）</p><ul><li>第一次访存——查内存中的页表</li><li>第二次访存——访问目标内存单元</li><li>总共两次访存</li></ul></li><li><p>分段</p><ul><li>第一次访存——查内存中的段表</li><li>第二次访存——访问目标内存单元</li><li>总共两次访存</li><li>与分页系统类似，分段存储也可用引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访存，加快地址变换速度</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230803173700888.png" alt="image-20230803173700888"><br><img src="/../image/assets/image-20230803174051795.png" alt="image-20230803174051795"></p><ul><li>分段比分页更容易实现信息的共享和保护<ul><li>不能被修改的代码（比如变量可被修改就不属于此类代码）称为纯代码或可重入代码（不属于临界资源），可以共享</li><li>可修改的代码是不能够共享的<ul><li>比如有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致</li><li>有点类似于并行里面的变量</li></ul></li></ul></li><li>实现代码段共享只需要让各进程的段表项指向同一个段</li><li>而页面不是按逻辑模块划分的，可能只有一部分允许其他进程访问，一部分不允许</li></ul><h5 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h5><p><img src="/../image/assets/image-20230803175051378.png" alt="image-20230803175051378"></p><h6 id="分页、分段的优缺点分析"><a href="#分页、分段的优缺点分析" class="headerlink" title="分页、分段的优缺点分析"></a>分页、分段的优缺点分析</h6><p><img src="/../image/assets/image-20230803175300218.png" alt="image-20230803175300218"></p><ul><li>分页管理<ul><li>优点<ul><li>内存空间利用率高</li><li>不会产生外部碎片，只会有少量的页内碎片</li></ul></li><li>缺点<ul><li>不方便按照逻辑模块实现信息的共享和保护</li></ul></li></ul></li><li>分段管理<ul><li>优点<ul><li>很方便按照逻辑模块实现信息的共享和保护</li></ul></li><li>缺点<ul><li>如果段长过大，为其分配很大的连续空间会很不方便</li><li>段式管理会产生外部碎片<ul><li>分段管理中产生的外部碎片也可以用紧凑来解决，只是需要付出较大的事件代价</li></ul></li></ul></li></ul></li></ul><h6 id="分段-分页-段页式管理"><a href="#分段-分页-段页式管理" class="headerlink" title="分段+分页&#x3D;段页式管理"></a>分段+分页&#x3D;段页式管理</h6><p><img src="/../image/assets/image-20230803175627071.png" alt="image-20230803175627071"></p><ul><li>如何实现段页式管理？（先分段再分页）<ul><li>将进程按逻辑模块分段，再将各段分页（如每个页面 4KB）</li><li>再将内存空间分为大小相同的内存块&#x2F;页框&#x2F;页帧&#x2F;物理块</li><li>进程执行前将各页面分别装入各内存块</li></ul></li></ul><h6 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h6><p><img src="/../image/assets/image-20230803175932682.png" alt="image-20230803175932682"></p><ul><li>分段系统：段号+段内地址</li><li>分页系统：页号+页内偏移量</li><li>段页式系统：段号+页号+页内偏移量<ul><li>段号的位数决定了每个进程最多可以分几个段</li><li>页号位数决定了每个段最大有多少页</li><li>页内偏移量决定了页面大小、内存块大小是多少</li></ul></li><li>若系统是按字节寻址的，段号 16<del>31，页号 12</del>15，页内偏移量0~11<ul><li>段号占 16 位，因此在该系统中，每个进程最多有 2^16&#x3D;64K 个段</li><li>页号占 4 位，因此每个段最多有 2^4&#x3D;16 页</li><li>页内偏移量占 12 位，因此每个页面&#x2F;每个内存块大小为2^12&#x3D;4096&#x3D;4KB</li></ul></li><li>分段对用户是可见的<ul><li>程序员编程时需要显式的给出段号、段内地址</li><li>而将各段分页对用户是不可见的</li><li>系统会根据段内地址自动划分页号和页内偏移量</li></ul></li><li>因此段页式管理的地址是二维的</li></ul><h6 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h6><p><img src="/../image/assets/image-20230803181042534.png" alt="image-20230803181042534"></p><ul><li>每个段对应一个段表项<ul><li><strong>每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成</strong><ul><li><strong>与分段存储管理不同：段表项由段号、段的长度、起始存放地址</strong></li></ul></li><li>每个段表项长度相等，段号是隐含的</li></ul></li><li>每个页面对应一个页表项<ul><li>每个页表项由页号、页面存放的内存块号组成</li><li>每个页表项长度相等，页号是隐含的</li></ul></li><li>一个进程对应一个段表，但是可能对应多个页表</li></ul><p><img src="/../image/assets/image-20230803181447496.png" alt="image-20230803181447496"></p><ul><li><p>用逻辑地址查找物理地址的过程</p><ul><li>根据逻辑地址得到段号、页号、页内偏移量</li><li>判断段号是否越界<ul><li>若S&gt;&#x3D;M，则产生越界中断</li><li>若 S&lt;M，则继续执行</li></ul></li><li>查询段表，找到对应的段表项，段表项的存放地址为 F+S*段表项长度<ul><li>第一次访存</li></ul></li><li>检查页号是否越界<ul><li>页号&lt;页表长度，继续执行</li><li>页号&gt;&#x3D;页表长度，则发生越界中断</li></ul></li><li>根据页表存放块号、页号查询页表，找到对应页表项<ul><li>第二次访存</li></ul></li><li>根据内存块号、页内偏移量得到最终的物理地址访问目标内存单元<ul><li>第三次访存</li></ul></li></ul></li><li><p>可以引用快表机构</p><ul><li>用段号和页号座位查询快表的关键字</li><li>若快表命中则仅需一次访存</li></ul></li></ul><h3 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h3><ul><li>虚拟技术（操作系统的虚拟性）</li></ul><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p><img src="/../image/assets/image-20230802172744558.png" alt="image-20230802172744558"></p><ul><li><p>情况</p><ul><li>计算机内存小，内存大小不够用</li></ul></li><li><p>目的</p><ul><li>为了<strong>解决“程序大小超过物理内存总和”的问题</strong></li></ul></li><li><p>思想</p><ul><li><p><strong>将程序分为多个段</strong>（多个模块）</p></li><li><p>常用的段常驻内存，不常用的段在需要时调入内存</p><ul><li><p>内存中分为<strong>一个固定区</strong>和<strong>若干个覆盖区</strong></p><ul><li>需要常驻内存的段放在固定区中，<strong>调入后就不再调出（除非运行结束）</strong></li><li>不常用的段放在覆盖区，<strong>需要用到时调入内存，用不到时调出内存</strong></li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802173143392.png" alt="image-20230802173143392"></p><ul><li>问题描述<ul><li>只有直接相连的上级模块才能调用下级模块</li><li>同一等级的模块不可能被同时调用</li></ul></li><li>解决方法<ul><li>按照自身逻辑结构，让哪些不能同时被访问的程序段共享同一个覆盖区</li></ul></li><li>缺点<ul><li><strong>必须由程序员声明覆盖结构</strong>，操作系统完成自动覆盖</li><li><strong>对用户不透明</strong>，增加了用户编程负担</li></ul></li><li>只用于早期的操作系统，现在已成为历史</li></ul><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p><img src="/../image/assets/image-20230802174143942.png" alt="image-20230802174143942"></p><ul><li>交换（对换）技术<ul><li>设计思想<ul><li>内存空间紧张时，系统<strong>将内存中某些进程暂时换出外存</strong></li><li>把外存中某些已具备运行条件的进程<strong>换入内存</strong><ul><li>进程在内存与磁盘间动态调度</li></ul></li></ul></li><li>中级调度（内存调度）<ul><li>决定将哪些处于挂起状态的进程重新调入内存</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802174451654.png" alt="image-20230802174451654"></p><ul><li>暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）<ul><li>就绪挂起、阻塞挂起</li></ul></li></ul><p><img src="/../image/assets/image-20230802174734911.png" alt="image-20230802174734911"></p><ul><li>问题<ul><li>应该在外存（磁盘）的什么位置保存被换出的进程？<ul><li>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分<ul><li>文件区<ul><li>主要存放文件</li><li><strong>主要追求存储空间的利用率</strong></li><li>对文件区空间的管理采用<strong>离散分配</strong>方式</li></ul></li><li>对换区<ul><li>主要存放被换出的进程数据，只占磁盘空间的小部分，</li><li><strong>主要追求换入换出速度</strong></li><li>采用<strong>连续分配</strong>方式</li></ul></li><li>对换区的 I&#x2F;O速度比文件区的更快</li></ul></li></ul></li><li>什么时候应该交换？<ul><li>通常在很多进程运行且内存吃紧时运行，而系统负荷降低就暂停<ul><li>例如<ul><li>发现很多进程运行时经常发生缺页，说明内存紧张，此时可以换出一些进程</li><li>如果缺页率明显下降，就可以暂停换出</li></ul></li></ul></li></ul></li><li>应该换出哪些进程？<ul><li>可优先换出阻塞进程</li><li>可换出优先级低的进程<ul><li>为了防止优先级低的进程再被调入内存后很快又被换出，有些系统还会考虑进程在内存的驻留时间</li></ul></li><li><strong>注意：PCB 会常驻内存</strong>，不会被换出外存</li></ul></li></ul></li></ul><h4 id="覆盖技术和交换技术的区别"><a href="#覆盖技术和交换技术的区别" class="headerlink" title="覆盖技术和交换技术的区别"></a>覆盖技术和交换技术的区别</h4><ul><li>覆盖是在<strong>同一个程序或进程</strong>中进行的</li><li>交换技术是在****<strong>不同进程（或作业）</strong>之间<ul><li>需要的进程调入内存</li><li>不紧急&#x2F;不需要的进程调出内存</li></ul></li></ul><h4 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h4><ul><li>使用下面一大节的内容具体介绍虚拟存储技术</li></ul><h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p><img src="/../image/assets/image-20230802164927041.png" alt="image-20230802164927041"></p><ul><li>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址</li><li>而<strong>逻辑地址到物理地址的转换（这个过程称为地址重定位）</strong>，应该由操作系统负责</li><li>这样就保证了程序员写程序时不需要关注物理内存的实际情况</li></ul><h3 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h3><p><img src="/../image/assets/image-20230802165520119.png" alt="image-20230802165520119"><br><img src="/../image/assets/image-20230802165810886.png" alt="image-20230802165810886"></p><ul><li>让一个进程只能访问系统分配的它所在的内存空间，而不能访问内存中其他程序或者操作系统所在的内存空间，防止恶意篡改<ul><li>假设进程 1 的逻辑地址空间为 0<del>179；实际物理地址空间为 100</del>279<ul><li>两种方法进行内存保护<ul><li>方法一：在 CPU 中设置一对<strong>上下限寄存器</strong>，存放进程的上、下限地址。进程指令要访问某个地址时，CPU 检查是否越界<ul><li>上限寄存器：100</li><li>下限寄存器：279</li></ul></li><li>方法二：采用<strong>重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查。</strong>重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong><ul><li>重定位寄存器：100</li><li>界地址寄存器：179</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a>进程的内存映像</h3><p><img src="/../image/assets/image-20230802170158942.png" alt="image-20230802170158942"></p><ul><li><p><strong>操作系统内核区</strong></p></li><li><p>占用 1GB，从内存的最高位地址开始</p><ul><li>存放内核代码、内核数据结构等<ul><li>进程调度就是内核代码中的一段代码</li><li>进程控制块 PCB</li></ul></li></ul></li><li><p>普通程序员写的程序只能访问用户区的数据，不能访问操作系统内核区的数据</p></li><li><p>用户区</p><ul><li><p>低位1GB区域，0x00000000 到 0x40000000</p><ul><li><strong>未使用区</strong></li><li><strong>只读代码&#x2F;数据</strong><ul><li>存放在用户区最低地址上</li><li>存放程序指令、只读数据（在程序运行过程中只能读，不能写）<ul><li>由 const 关键字修饰的常变量</li><li>程序代码</li></ul></li></ul></li><li><strong>读&#x2F;写数据</strong><ul><li>存放在第二低的地址上<ul><li>存放定义在函数外的全局变量</li><li>由 static 关键字修饰的静态变量</li></ul></li></ul></li><li>以上两种数据，在进程启动时确定大小，固定不变</li><li><strong>堆（heap）</strong><ul><li>存放在第三低的地址上<ul><li>malloc&#x2F;free 分配、回收的数据</li></ul></li></ul></li></ul></li><li><p>中间 2GB 区域</p><ul><li><strong>共享库的存储映射区</strong><ul><li>存放在中间区域的低位<ul><li>存放被调用的库函数代码，如：&lt;stdio.h&gt;中的print函数的代码</li></ul></li></ul></li><li><strong>用户栈(Stack)</strong><ul><li>存放在中间区域的高位</li><li>由各函数的栈帧组成，包含局部变量、函数调用相关的信息<ul><li>递归中函数调用就是存放在这里</li><li>在函数大括号内定义的局部变量</li><li>函数调用时传入的参数</li></ul></li></ul></li></ul></li></ul></li><li><p>宏定义的常量不会在内存中分配存储空间，在预编译阶段，会直接将代码中的 X 替换为 1024，然后隐含到程序指令中（立即数）</p></li></ul><p><img src="/../image/assets/image-20230802171740451.png" alt="image-20230802171740451"></p><ul><li><p>根据 C 语言程序回答存储区域</p><ul><li><p>操作系统内核区</p><ul><li>进程控制块 PCB</li></ul></li><li><p>用户栈</p><ul><li>在函数大括号内定义的局部变量、函数调用时传入的参数</li></ul></li><li><p>共享库的存储映射区</p><ul><li>被调用的库函数</li></ul></li><li><p>堆</p><ul><li>由 mallo&#x2F;free分配、回收的数据</li></ul></li><li><p>读写数据</p><ul><li>定义在函数外的全局变量，由 static 关键字修饰的变量</li></ul></li><li><p>只读代码&#x2F;数据</p></li><li><p>程序代码、由 const 关键字修饰的常变量</p></li></ul></li></ul><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><p><img src="/../image/assets/image-20230803182824565.png" alt="image-20230803182824565"></p><h4 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h4><p><img src="/../image/assets/image-20230803183000406.png" alt="image-20230803183000406"></p><ul><li>一次性<ul><li><strong>作业必须一次性全部装入内存后才能开始运行</strong><ul><li>作业很大时，不能全部装入内存，导致<strong>大作业无法运行</strong></li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong></li></ul></li></ul></li><li>驻留性<ul><li>一旦作业被装入内存，就会<strong>一直驻留在内存</strong>中，直到作业运行结束</li><li>在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源</li></ul></li><li>自己理解<ul><li>大程序装不进来</li><li>程序多了后面的进不来了</li><li>用不到的程序也走不了</li></ul></li></ul><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><img src="/../image/assets/image-20230803184116259.png" alt="image-20230803184116259"></p><h5 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h5><ul><li>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行</li><li>如果某个数据被访问过，不久之后该数据很可能再次被访问<ul><li>因为程序中存在大量的循环</li></ul></li></ul><h5 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h5><ul><li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问<ul><li>因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序的在内存中存放</li></ul></li></ul><h5 id="高速缓存技术"><a href="#高速缓存技术" class="headerlink" title="高速缓存技术"></a>高速缓存技术</h5><ul><li>思想<ul><li>将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中</li></ul></li></ul><h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><p><img src="/../image/assets/image-20230803184955997.png" alt="image-20230803184955997"></p><ul><li>基于局部性原理<ul><li>在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行</li><li>程序执行时，当所访问的信息不在内存中，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</li><li>在操作系统的管理下，用户看来似乎有一个比实际内存大的多的内存，虚拟内存<ul><li>操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充</li></ul></li></ul></li><li>主要特征<ul><li>多次性（少量多次）<ul><li>无需再作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li></ul></li><li>对换性（交换技术）<ul><li>在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li></ul></li><li>虚拟性（虚拟变大了）<ul><li>从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230803190451069.png" alt="image-20230803190451069"></p><ul><li>虚拟内存的最大容量是由计算机的地址结构（CPU 寻址范围）确定的</li><li>虚拟内存的实际容量 &#x3D; min（内存和外存容量之和，CPU 寻址范围）<ul><li>如：某计算机地址结构为 32 位，按地址编址，内存大小为 512MB，外存大小为 2GB<ul><li>虚拟内存的最大容量为2^32B &#x3D; 4GB</li><li>虚拟内存的实际容量 &#x3D; min(2^32B, 512MB+2GB) &#x3D; 2GB + 512MB</li></ul></li></ul></li></ul><h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h4><p><img src="/../image/assets/image-20230803190757164.png" alt="image-20230803190757164"></p><ul><li><p>虚拟内存技术</p><ul><li>允许一个作业分多次调入内存</li><li>如果采用连续分配方式，会不方便实现</li><li><strong>虚拟内存的实现需要建立在离散分配的内存管理方式基础上</strong></li></ul></li><li><p>虚拟内存实现  VS  传统的非连续分配存储管理</p><ul><li><p>在程序执行过程中，<strong>当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</strong></p><ul><li>操作系统要提供请求调页（或请求调段）功能</li></ul></li><li><p>若内存空间不够，由操作系统负责将<strong>内存中暂时用不到的信息换出到外存</strong></p><ul><li>操作系统要提供页面置换（或段置换）的功能</li></ul></li></ul></li></ul><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p><img src="/../image/assets/image-20230803194221851.png" alt="image-20230803194221851"></p><ul><li>请求分页存储管理与基本分页存储管理的主要区别<ul><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</li><li>操作系统要提供请求调页功能，将缺失页面从外存调入内存</li></ul></li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存<ul><li>操作系统要提供页面置换功能，将暂时用不到的页面换出外存</li></ul></li></ul><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p><img src="/../image/assets/image-20230803194709014.png" alt="image-20230803194709014"></p><ul><li>与基本分页管理相比<ul><li>请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存</li><li>如果还没调入，那么也需要知道该页面在外存中存放的位置</li></ul></li><li>当内存空间不够时，要实现“页面置换”<ul><li>操作系统需要通过某些指标来决定到底换出哪些页面</li><li>有的页面没有被修改过，就不用再浪费时间写回外存</li><li>有的页面修改过，就需要将外存中的旧数据覆盖</li><li>因此操作系统也需要记录各个页面是否被修改的信息</li></ul></li><li>基本分页存储管理的页表<ul><li>页号</li><li>内存块号</li></ul></li><li>请求分页存储管理的页表<ul><li>页号</li><li>内存块号</li><li>状态位：是否已调入内存</li><li>访问字段：可记录最近被访问过几次，或记录上次访问的事件，供置换算法选择换出页面时参考</li><li>修改位：页面调入内存后是否被修改过</li><li>外存地址：页面在外存中的存放位置</li></ul></li></ul><h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p><img src="/../image/assets/image-20230803195405705.png" alt="image-20230803195405705"><br><img src="/../image/assets/image-20230803195837114.png" alt="image-20230803195837114"></p><ul><li><p>假设此时要访问逻辑地址 &#x3D; （页号，页内偏移量）&#x3D;（0,1024）</p></li><li><p>在请求分页系统中，每当<strong>要访问的页面不在内存</strong>时，便会<strong>产生一个缺页中断</strong>，然后由操作系统的缺页<strong>中断处理程序处理中断</strong></p><ul><li>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页<strong>完成后再将其唤醒</strong>，放回就绪队列</li></ul></li><li><p>如果内存中有<strong>空闲块</strong>，则为进程<strong>分配一个空闲块</strong>，将所缺页面装入该块，并修改页表中相应的页表项</p></li><li><p><strong>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰</strong></p><ul><li>若该页面在内存期间被修改过，则要将其写回外存</li><li>未修改过的页面不用写回外存</li></ul></li></ul><p><img src="/../image/assets/image-20230803200047024.png" alt="image-20230803200047024"></p><ul><li>缺页中断<ul><li>使因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</li></ul></li><li>一条指令在执行期间，可能产生多次缺页中断<ul><li>copy A to B</li><li>即将逻辑地址 A 中的数据复制到逻辑地址 B，而 A、B 属于不同的页面，则可能产生两次中断</li></ul></li></ul><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><img src="/../image/assets/image-20230803200904110.png" alt="image-20230803200904110"></p><ul><li>新增步骤<ul><li>请求调页（查到页表项时进行判断）</li><li>页面置换（需要调入页面，但没有空闲内存块时进行）</li><li>需要修改请求页表中新增的表项</li></ul></li></ul><p><img src="/../image/assets/image-20230803201151191.png" alt="image-20230803201151191"></p><ul><li>快表中有的页面一定是在内存中的<ul><li>若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面</li><li>如果在快表中查询到页表项，就不用去页表中查找了，可以直接访问目标页面的物理地址</li></ul></li><li>找到对应页表项后，若对应页面未调入内存，则会产生缺页中断<ul><li>之后由操作系统的缺页中断处理程序进行处理</li></ul></li></ul><p><img src="/../image/assets/image-20230803201719700.png" alt="image-20230803201719700"></p><ul><li>只有“写指令”才需要修改“修改位”<ul><li>一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表</li><li>这可以减少访存次数</li></ul></li><li>和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场</li><li>需要用某种“页面置换算法”来决定一个换出页面</li><li>换入&#x2F;换出页面都需要启动慢速的 I&#x2F;O操作<ul><li>如果需要换入&#x2F;换出太频繁，会有很大的开销</li></ul></li><li>页面调入内存中，需要修改慢表，同时也需要将表项复制到快表中</li></ul><p><img src="/../image/assets/image-20230803202047056.png" alt="image-20230803202047056"></p><ul><li>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是<ul><li>差快表（未命中）</li><li>查慢表（发现未调入内存）</li><li>调页（调入的页面对应的表项会直接加入快表）</li><li>查快表（命中）</li><li>访问目标内存单元</li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p><img src="/../image/assets/image-20230803202907044.png" alt="image-20230803202907044"></p><ul><li>请求分页存储管理与基本分页存储管理的主要区别<ul><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存<ul><li>用页面置换算法决定应该换出哪个页面</li></ul></li></ul></li><li>页面的换入、换出都需要磁盘I&#x2F;O，会有较大的开销<ul><li>因此<strong>好的页面置换算法应该追求更少的缺页率</strong></li></ul></li></ul><h4 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h4><p><img src="/../image/assets/image-20230803203243659.png" alt="image-20230803203243659"><br><img src="/../image/assets/image-20230803203647395.png" alt="image-20230803203647395"></p><ul><li><p>每次选择淘汰的页面将是以后永不使用，或者最长时间内不再被访问的页面，这样可以保证最低的缺页率</p></li><li><p>选择从当前内存块中淘汰一页</p><ul><li>按最佳置换的规则，往后寻找</li><li><strong>最后一个出现的页号就是要淘汰的页面</strong></li></ul></li><li><p>整个过程缺页中断发生了 9 次，页面置换发生了 6 次</p><ul><li><p>缺页时未必发生页面置换，若还有可用的空闲内存块，就不用进行页面置换</p></li><li><p>缺页率 &#x3D; 9&#x2F;20 &#x3D; 45%</p></li></ul></li><li><p>最佳置换算法是无法实现的</p></li><li><p>只有在进程执行的过程中才能知道接下来会访问到的是哪个页面</p><ul><li>操作系统无法提前预判页面访问序列</li></ul></li></ul><h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p><img src="/../image/assets/image-20230803203820761.png" alt="image-20230803203820761"></p><ul><li>先进先出置换算法<ul><li><strong>每次选择淘汰的页面是最早进入内存的页面</strong></li></ul></li><li>实现方法<ul><li>把调入内存的页面根据调入的先后顺序排成一个队列</li><li>需要换出页面时，选择队头页面即可</li><li>队列的最大长度取决于系统为进程分配了多少个内存块</li></ul></li></ul><p><img src="/../image/assets/image-20230803204057305.png" alt="image-20230803204057305"></p><ul><li>Belady 异常<ul><li>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</li></ul></li><li>只有 FIFO 算法会产生 Belady 异常</li><li>FIFO 虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问<ul><li>因此，算法性能差</li></ul></li></ul><h4 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h4><p><img src="/../image/assets/image-20230803204239408.png" alt="image-20230803204239408"></p><ul><li>最近最久未使用置换算法<ul><li>每次淘汰的页面是最近最久未使用的页面</li></ul></li><li>实现方法<ul><li>赋予每个页面对应的页表项，<strong>用访问字段记录该页面自上次被访问以来所经历的事件 t</strong>，当需要淘汰一个页面时，选择现有页面中 t 最大的，即最近最久未使用的页面</li></ul></li><li>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大</li><li>做题过程中<ul><li>若需要淘汰页面，可以你想检查此时在内存中的几个页面号</li><li>在逆向扫描过程中最后一个出现的页号就是要淘汰的页面</li></ul></li></ul><h4 id="时钟置换算法（CLOCK，NRU）"><a href="#时钟置换算法（CLOCK，NRU）" class="headerlink" title="时钟置换算法（CLOCK，NRU）"></a>时钟置换算法（CLOCK，NRU）</h4><p><img src="/../image/assets/image-20230803204603330.png" alt="image-20230803204603330"></p><ul><li>时钟置换算法<ul><li>最佳置换算法性能最好，但无法实现</li><li>先进先出置换算法实现简单，但算法性能差</li><li>最近最久未使用置换算法性能好，使最接近 OPT 算法性能的，但是实现起来需要专门的硬件支持，算法开销 da</li><li>时钟置换算法是一种性能和开销较均衡的算法，又称 CLOCK 算法，或最近未用算法</li></ul></li><li>实现方法<ul><li>为每个页面设置一个访问位</li><li>再将内存中的页面都通过链接指针链接成一个循环队列</li><li>当某页被访问时，其访问位置为 1</li><li>当需要淘汰一个页面时，只需检查页的访问位<ul><li>如果是 0，就选择该页换出</li><li>如果是 1，就将它置为 0，暂不换出，继续检查下一个页面</li></ul></li><li>若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描<ul><li>第二轮扫描中一定会有访问位为 0 的页面</li><li>因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</li></ul></li></ul></li><li>访问位<ul><li>为 1，说明最近访问过</li><li>为 0，说明最近没有访问过</li></ul></li></ul><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><p><img src="/../image/assets/image-20230803205219240.png" alt="image-20230803205219240"></p><ul><li>简单的时钟置换算法<ul><li>仅考虑到一个页面最近是否被访问过</li><li>事实上，如果被淘汰的页面，没有被修改过，就不需要执行 I&#x2F;O操作写回外存</li><li>只有被淘汰的页面被修改过，才需要写回外存</li></ul></li><li>改进型的时钟置换算法<ul><li>除了考虑一个页面最近又没有被修改过之外，操作系统还应考虑页面又没有被修改过</li><li>在其他条件都相同时，应优先淘汰没有被修改过的页面，避免 I&#x2F;O操作</li></ul></li><li>修改位<ul><li>为 0，说明页面没有被修改过</li><li>为 1，说明页面被修改过</li></ul></li><li>（访问位，修改位）&#x3D; （1,1）说明一个页面最近被访问过并且被修改过</li><li>算法规则<ul><li>将所有可能被置换的页面排成一个循环队列</li><li>第一轮：没访问且没修改（0,0）<ul><li>从当前位置开始扫描到第一个（0,0）的帧用于替换。</li><li>本轮扫描不修改任何标志位</li></ul></li><li>第二轮：没访问但修改过<ul><li>若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为 0</li></ul></li><li>第三轮：访问过但没修改（1,0）—&gt; (0,0)<ul><li>若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮不修改任何标志位</li></ul></li><li>第四轮：访问过且修改过（1,1）—&gt; (0,1)<ul><li>若第三轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。</li></ul></li><li>由于第二轮已将所有帧的访问位置为 0，因此经过第三轮、第四轮扫描一定会有一个帧被选中<ul><li>因此改进型 CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230803211233491.png" alt="image-20230803211233491"></p><ul><li>自己理解<ul><li>为啥只修改访问位不修改 修改位？<ul><li>因为修改位代表着这个帧是否被修改过，如果被修改了CPU 就不知道要不要写回外存了，所以这个位的数据不能动</li></ul></li></ul></li></ul><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p><img src="/../image/assets/image-20230803213126032.png" alt="image-20230803213126032"></p><h4 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h4><p><img src="/../image/assets/image-20230803213632107.png" alt="image-20230803213632107"></p><ul><li><p>驻留集</p><ul><li><p>请求分页存储管理中给进程分配的物理块的集合</p></li><li><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</p></li><li><p>若驻留集太小</p><ul><li>会导致缺页频繁，系统要花大量的事件来处理缺页，实际用于进程推进的时间很少</li></ul></li><li><p>若驻留集太大</p><ul><li>导致多道程序并发度下降，资源利用率降低</li></ul></li></ul></li></ul><h4 id="页面分配、置换策略（选择）"><a href="#页面分配、置换策略（选择）" class="headerlink" title="页面分配、置换策略（选择）"></a>页面分配、置换策略（选择）</h4><p><img src="/../image/assets/image-20230803213648613.png" alt="image-20230803213648613"></p><ul><li>固定分配<ul><li>操作系统为每个进程分配一组固定数目的物理块，在程序运行期间不再改变</li><li>即驻留集大小不变</li></ul></li><li>可变分配<ul><li>先为每个进程分配一定数目的物理块。在进程运行期间，可根据情况做适当的增加或减少</li><li>即驻留集可变</li></ul></li><li>局部置换<ul><li>发生缺页时，只能选进程自己的物理块进行置换<ul><li>可能是固定分配，也可能是可变分配</li></ul></li></ul></li><li>全局置换<ul><li>可以将操作系统保留的空闲物理块分配给缺页进程</li><li>也可以将别的进程持有的物理块置换到外存，再分配给缺页进程<ul><li>全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230803214614806.png" alt="image-20230803214614806"></p><h5 id="固定分配局部替换"><a href="#固定分配局部替换" class="headerlink" title="固定分配局部替换"></a>固定分配局部替换</h5><ul><li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变<ul><li>若进程在运行中发生缺页，则只能从该进程的内存中的页面中选出一页换出，然后再调入需要的页面</li><li>缺点<ul><li>很难再刚开始就确定应为每个进程分配多少个物理块才算合理</li></ul></li><li>采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数</li></ul></li></ul><h5 id="可变分配全局替换"><a href="#可变分配全局替换" class="headerlink" title="可变分配全局替换"></a>可变分配全局替换</h5><ul><li>刚开始会为每个进程分配一定数量的物理块<ul><li>操作系统会保持一个空闲物理块队列</li><li><strong>当某进程发生缺页时</strong>，从空闲物理块中取出一块分配给该进程</li><li><strong>若已经没有空闲物理块</strong>，则选择一个<strong>未锁定</strong>的页面换出外存，在将该物理块分配给缺页的进程<ul><li>采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出</li><li>被选择调出的页可能是系统中任何一个进程中的页<ul><li>系统会锁定一些页面，这些页面中的内容不能置换出外存（如重要的内核数据）</li></ul></li></ul></li><li>因此这个被选中的进程拥有的物理块会减少，缺页率会增加</li></ul></li></ul><h5 id="可变分配局部替换"><a href="#可变分配局部替换" class="headerlink" title="可变分配局部替换"></a>可变分配局部替换</h5><p><img src="/../image/assets/image-20230803215515215.png" alt="image-20230803215515215"></p><ul><li>刚开始会为每个进程分配一定数量的物理块<ul><li><strong>当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存</strong></li><li>如果进程在运行中<strong>频繁缺页</strong>，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当</li><li>如果进程在运行中缺页率特别低，可适当减少分配给该进程的物理块</li></ul></li></ul><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li>可变分配全局置换：只要缺页就给分配新物理块</li><li>可变分配局部置换：要根据发生缺页的频率来动态的增加或减少进程的物理块</li></ul><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><p><img src="/../image/assets/image-20230803220001870.png" alt="image-20230803220001870"></p><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><ul><li>预调页策略（运行前调入）<ul><li>根据局部性原理<ul><li>空间局部性，如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元</li></ul></li><li>一次调入若干个相邻的页面可能比一次调入一个页面更高效<ul><li>但如果提前调入的页面中大多数都没被访问过，又很低效</li><li>可以预测不久之后可能访问到的页面，将它们预先调入内存</li><li>但目前预测成功率只有 50 左右</li></ul></li><li>主要用于进程的首次调入，由程序员指出应该调入哪些部分</li></ul></li></ul><h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><ul><li>请求调页策略（运行后调入）<ul><li>进程在运行期间发现缺页时才将所缺页面调入内存</li><li>由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I&#x2F;O操作，因此 I&#x2F;O开销较大</li></ul></li></ul><h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><p><img src="/../image/assets/image-20230803220622545.png" alt="image-20230803220622545"></p><ul><li><p>系统拥有足够的对换区空间</p><ul><li><p>原因</p><ul><li>对换区：读写速度更快，采用连续分配方式</li><li>文件区：读写速度更慢，采用离散分配方式</li></ul></li><li><p>过程</p><ul><li><p>页面的调入、调出都是在<strong>内存与对换区</strong>中间进行的</p></li><li><p>可以保证页面的调入、调出速度更快</p></li><li><p><strong>在进程运行前，需将进程相关的数据从文件区复制到对换区</strong></p></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230803221714062.png" alt="image-20230803221714062"></p><ul><li>系统缺少足够的对换区空间<ul><li>凡是不会被修改的数据都直接从文件区调入<ul><li>这些页面会不被修改，换出时不必写回磁盘，下次需要时再从文件区调入即可</li></ul></li><li>可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</li></ul></li></ul><p><img src="/../image/assets/image-20230803221853819.png" alt="image-20230803221853819"></p><ul><li>Unix 方式<ul><li>运行之前进程有关的数据全部放在文件区<ul><li>未使用过的页面，都要从文件区调入</li></ul></li><li>被使用过的页面需要换出，则写回对换区，下次有需要时从对换区调入</li></ul></li></ul><h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><p><img src="/../image/assets/image-20230803222012091.png" alt="image-20230803222012091"></p><ul><li>抖动（颠簸）<ul><li>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动</li><li>主要原因<ul><li>进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）</li></ul></li></ul></li></ul><h4 id="工作集（了解）"><a href="#工作集（了解）" class="headerlink" title="工作集（了解）"></a>工作集（了解）</h4><p><img src="/../image/assets/image-20230803222436356.png" alt="image-20230803222436356"></p><ul><li>驻留集<ul><li>请求分页存储管理中给进程分配的内存块的集合</li></ul></li><li>工作集<ul><li>在某段时间间隔里，进程实际访问页面的集合</li></ul></li><li>操作系统会根据“窗口尺寸”来算出工作集<ul><li>工作集大小可能小于窗口尺寸<ul><li>实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块</li></ul></li><li><strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</strong></li></ul></li><li>拓展<ul><li>基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的</li><li>可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法<ul><li>选择一个不在工作集中的页面进行淘汰</li></ul></li></ul></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p><img src="/../image/assets/image-20230803223000057.png" alt="image-20230803223000057"></p><h4 id="定义和作用"><a href="#定义和作用" class="headerlink" title="定义和作用"></a>定义和作用</h4><p><img src="/../image/assets/image-20230803223102898.png" alt="image-20230803223102898"></p><ul><li>内存映射文件<ul><li>操作系统向上层程序员提供的功能——系统调用<ul><li>方便程序员访问文件数据</li><li>方便多个进程共享同一个文件</li></ul></li></ul></li></ul><h4 id="传统的文件访问方式"><a href="#传统的文件访问方式" class="headerlink" title="传统的文件访问方式"></a>传统的文件访问方式</h4><p><img src="/../image/assets/image-20230803223211233.png" alt="image-20230803223211233"></p><ul><li>传统文件的访问方式<ul><li>open 系统调用——打开文件</li><li>seek 系统调用——将读写指针移到某个位置</li><li>read 系统调用——从读写指针所指位置读入若干数据（从磁盘读入内存）</li><li>write 系统调用——将内存中的指定数据，写回磁盘（根据写指针确定要写回什么位置）</li></ul></li></ul><h4 id="内存映射文件的原理和作用"><a href="#内存映射文件的原理和作用" class="headerlink" title="内存映射文件的原理和作用"></a>内存映射文件的原理和作用</h4><p><img src="/../image/assets/image-20230803223238631.png" alt="image-20230803223238631"></p><ul><li>内存映射文件的访问方式<ul><li>open 系统调用——打开文件</li><li>mmap 系统调用——将文件映射到进程的虚拟地址空间</li></ul></li><li>以访问内存的方式访问文件数据</li><li>文件数据的读入、写出由操作系统自动完成</li><li>进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘</li></ul><p><img src="/../image/assets/image-20230803223252198.png" alt="image-20230803223252198"></p><ul><li>多个进程可以映射同一个文件，实现共享</li><li>在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时，另一个文件可以立马看到</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="操作系统" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/408/"/>
    
    
    <category term="内存" scheme="https://sdumoist.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>进程和线程</title>
    <link href="https://sdumoist.github.io/2023/07/29/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://sdumoist.github.io/2023/07/29/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-07-29T09:59:24.227Z</published>
    <updated>2024-03-30T19:31:43.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul><li>调度算法的评价指标<ul><li>理解并且会计算</li></ul></li></ul><p><img src="/../image/assets/image-20230801172212199.png" alt="image-20230801172212199"></p><ul><li>要会自己定义记录型信号量</li><li>但如果题目中没特别说明，可以把信号量的声明简写成这种形式</li></ul><p><img src="/../image/assets/image-20230801175516957.png" alt="image-20230801175516957"></p><ul><li>大题</li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230729205341824.png" alt="image-20230729205341824"></p><p><img src="/../image/assets/image-20230729213510373.png" alt="image-20230729213510373"></p><p><img src="/../image/assets/image-20230729224351508.png" alt="image-20230729224351508"></p><p><img src="/../image/assets/image-20230730215529834.png" alt="image-20230730215529834"></p><p><img src="/../image/assets/image-20230730224910575.png" alt="image-20230730224910575"></p><p><img src="/../image/assets/image-20230731144758529.png" alt="image-20230731144758529"></p><p><img src="/../image/assets/image-20230731150253815.png" alt="image-20230731150253815"></p><p><img src="/../image/assets/image-20230731152614700.png" alt="image-20230731152614700"></p><p><img src="/../image/assets/image-20230731161403740.png" alt="image-20230731161403740"></p><p><img src="/../image/assets/image-20230731165604684.png" alt="image-20230731165604684"></p><p><img src="/../image/assets/image-20230731181244842.png" alt="image-20230731181244842"></p><p><img src="/../image/assets/image-20230731210756707.png" alt="image-20230731210756707"></p><p><img src="/../image/assets/image-20230731215701874.png" alt="image-20230731215701874"></p><p><img src="/../image/assets/image-20230731225055140.png" alt="image-20230731225055140"></p><p><img src="/../image/assets/image-20230801144041257.png" alt="image-20230801144041257"></p><p><img src="/../image/assets/image-20230801170800592.png" alt="image-20230801170800592"></p><p><img src="/../image/assets/image-20230801175506143.png" alt="image-20230801175506143"></p><p><img src="/../image/assets/image-20230801201649385.png" alt="image-20230801201649385"></p><p><img src="/../image/assets/image-20230801204833197.png" alt="image-20230801204833197"><br><img src="/../image/assets/image-20230801204844852.png" alt="image-20230801204844852"></p><p><img src="/../image/assets/image-20230801211559705.png" alt="image-20230801211559705"></p><p><img src="/../image/assets/image-20230801215900722.png" alt="image-20230801215900722"></p><p><img src="/../image/assets/image-20230801223933484.png" alt="image-20230801223933484"></p><p><img src="/../image/assets/image-20230802153419487.png" alt="image-20230802153419487"></p><p><img src="/../image/assets/image-20230809153311455.png" alt="image-20230809153311455"></p><p><img src="/../image/assets/image-20230809160208718.png" alt="image-20230809160208718"></p><p><img src="/../image/assets/image-20230809165535329.png" alt="image-20230809165535329"></p><p><img src="/../image/assets/image-20230809170241971.png" alt="image-20230809170241971"></p><h2 id="知识滚雪球：程序是如何运行的"><a href="#知识滚雪球：程序是如何运行的" class="headerlink" title="知识滚雪球：程序是如何运行的"></a>知识滚雪球：程序是如何运行的</h2><p><img src="/../image/assets/image-20230729203811979.png" alt="image-20230729203811979"></p><p><img src="/../image/assets/image-20230729203823777.png" alt="image-20230729203823777"></p><p><img src="/../image/assets/image-20230729223642916.png" alt="image-20230729223642916"></p><p><img src="/../image/assets/image-20230729223653958.png" alt="image-20230729223653958"></p><p><img src="/../image/assets/image-20230729224229544.png" alt="image-20230729224229544"></p><p><img src="/../image/assets/image-20230731160323649.png" alt="image-20230731160323649"></p><ul><li>程序是如何运行的<ul><li>C 语言代码经过编译器翻译编程二进制的机器指令<ul><li>一条高级语言的代码翻译过来可能会对应多条机器指令</li><li>存放指令序列的就是可执行文件（*.exe）</li></ul></li><li>程序在等待运行之前要先放在外存中的作业后备队列，等待被服务（调度）</li><li>程序运行之前要把可执行文件放入内存当中（高级调度&#x2F;作业调度）<ul><li>创建对应的进程，也就是要创建相应的 <strong>PCB</strong></li><li>内存中会有一串串包含程序指令的<strong>程序段</strong></li><li>还有包含运行过程中产生的各种数据的<strong>数据段</strong>（变量）</li></ul></li><li>CPU 从内存中取出指令（进程调度）<ul><li>CPU 中会设置很多寄存器，用来存放程序运行过程中所需的某些数据<ul><li>PSW：程序状态字寄存器</li><li>PC：程序计数器，存放下一条指令的地址</li><li>IR：指令寄存器，存放当前正在执行的指令</li><li>通用寄存器：其他一些必要信息</li></ul></li><li>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的<ul><li>这些寄存器并不是进程独属的，其他进程上 CPU 也会使用这些寄存器</li><li>思考：执行完指令后，另一个进程开始上 CPU 运行<ul><li>另一个指令在运行过程中也会使用各个寄存器，之前指令的寄存器的中间结果就会被覆盖</li></ul></li><li>解决方法：在进程切换时先<strong>在 PCB 中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息）<ul><li>PSW：xxxxxxx</li><li>PC：指令 4 的地址</li><li>通用寄存器：2</li></ul></li><li>当原来的进程再次投入运行时，可以通过 PCB 恢复它的运行环境</li></ul></li></ul></li></ul></li><li>程序运行的过程其实就是 CPU 执行一条条的机器指令的过程</li></ul><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>进程与程序的区别<ul><li>程序<ul><li>静态的，就是个存放在磁盘里的可执行文件，是一系列的指令集合</li></ul></li><li>进程<ul><li>动态的，是程序的一次执行过程</li><li>同一个程序多次执行会对应多个进程</li></ul></li></ul></li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="/../image/assets/image-20230729201858195.png" alt="image-20230729201858195"></p><ul><li><p>思考：操作系统是这些进程的管理者，它们要怎么区分各个进程</p></li><li><p>一个进程由哪些部分组成</p><ul><li>PCB：进程控制块(Process Control Block)，一个数据结构，操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在 PCB 中（<strong>操作系统用的</strong>）<ul><li>PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”——PID（Process ID，进程 ID）</li><li>UID：进程所属用户 ID（基本的进程描述信息，可以让操作系统区分各个进程）</li><li>记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些 I&#x2F;O 设备、正在使用哪些文件）（可用于实现操作系统对资源的 管理）</li><li>记录进程的运行情况（如：CPU 使用时间、磁盘使用情况、网络流量使用情况）（用于实现操作系统对进程的控制、调度）</li></ul></li><li>程序段（进程自己用的）：程序的代码（指令序列）</li><li>数据段（进程自己用的）：运行过程中产生的各种数据（如：程序中定义的变量）</li></ul></li></ul><h5 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h5><p><img src="/../image/assets/image-20230729201914500.png" alt="image-20230729201914500"></p><ul><li><p>进程控制块（PCB）</p><ul><li>PCB 是进程存在的唯一标志，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB</li><li>操作系统对进程进行管理工作所需的信息都存在PCB 中</li><li>进程描述信息<ul><li>进程标识符 PID</li><li>用户标识符 UID</li></ul></li><li>进程控制和管理信息<ul><li>CPU、磁盘、网络流量使用情况</li><li>进程当前状态——就绪态&#x2F;阻塞态&#x2F;运行态</li></ul></li><li>资源分配清单<ul><li>正在使用哪些文件</li><li>正在使用哪些内存区域</li><li>正在使用哪些I&#x2F;O设备</li></ul></li><li>处理机相关信息<ul><li>如 PSW、PC 等等各种寄存器的值（用于实现进程切换）</li></ul></li></ul><h5 id="程序段、数据段"><a href="#程序段、数据段" class="headerlink" title="程序段、数据段"></a>程序段、数据段</h5></li></ul><p><img src="/../image/assets/image-20230729202522577.png" alt="image-20230729202522577"></p><ul><li>进程的组成<ul><li>PCB：给操作系统用的</li><li>程序段：给自己用的，与进程自身的运行逻辑有关<ul><li>程序的代码（指令序列）</li></ul></li><li>数据段：给自己用的，与进程自身的运行逻辑有关<ul><li>运行过程中产生的各种数据（如：程序中定义的变量）</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230729205226585.png" alt="image-20230729205226585"></p><ul><li><p>进程与进程实体（一般不用抠字眼）</p><ul><li><p>一个进程实体（进程映像）由PCB、程序段、数据段组成</p></li><li><p>进程是动态的，进程实体（进程映像，某一时刻内存中进程状态的快照）是静态的</p></li><li><p>进程实体反应了进程在某一时刻的状态（如：x++后，x&#x3D;2）</p></li></ul></li><li><p>引入进程实体的概念后，进程可以定义为</p><ul><li><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong><ul><li>一个进程被调度，就是指操作系统决定让这个进程上 CPU 运行</li></ul></li><li>PCB 是进程存在的唯一标志</li></ul></li><li><p>如果同时挂三个 QQ 号，会对应 3 个 QQ 进程，它们的 <strong>PCB、数据段各不相同</strong>，但<strong>程序段的内容都是相同</strong>的（都是运行着相同的 QQ程序）</p></li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li><p>进程有那些重要特征</p><ul><li><p>动态性（进程最基本的特征）</p><ul><li>进程是程序的一次执行过程，是动态地产生、变化和消亡</li></ul></li><li><p>并发性</p><ul><li>内存中有多个进程实体，各进程可<strong>并发执行</strong></li></ul></li><li><p>独立性</p><ul><li>进程是能<strong>独立运行</strong>、<strong>独立获得资源、独立接收调度的基本单位</strong></li></ul></li><li><p>异步性</p><ul><li>各进程按<strong>各自独立</strong>的、不可预支的速度向前推进<ul><li>异步性会导致并发程序执行结果的不确定性</li></ul></li><li>操作系统要提供“进程同步机制”来解决异步问题</li></ul></li><li><p>结构性</p><ul><li>每个进程都会配置一个 PCB</li><li>结构上看，进程由程序段、数据段、PCB 组成</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230729205242234.png" alt="image-20230729205242234"></p><h4 id="状态与转换"><a href="#状态与转换" class="headerlink" title="状态与转换"></a>状态与转换</h4><p><img src="/../image/assets/image-20230729210504819.png" alt="image-20230729210504819"></p><h5 id="创建态"><a href="#创建态" class="headerlink" title="创建态"></a>创建态</h5><ul><li>进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化 PCB</li></ul><p><img src="/../image/assets/image-20230729210519736.png" alt="image-20230729210519736"></p><h5 id="就绪态"><a href="#就绪态" class="headerlink" title="就绪态"></a>就绪态</h5><ul><li><p>当进程创建完成后，便进入“就绪态”</p><ul><li>处于就绪态的进程已经具备运行条件，但由于没有空闲 CPU，就暂时不能运行</li></ul></li><li><p>系统中可能会有很多个进程都处于就绪态</p></li></ul><p><img src="/../image/assets/image-20230729210545198.png" alt="image-20230729210545198"></p><h5 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h5><ul><li>当 CPU 空闲时，操作系统就会选择一个就绪进程，让它上处理机运行</li><li><strong>如果一个进程此时在 CPU 上运行</strong>，那么这个进程处于“运行态”<ul><li>CPU 会执行该进程对应的程序（执行指令序列）</li></ul></li></ul><p><img src="/../image/assets/image-20230729210614486.png" alt="image-20230729210614486"></p><h5 id="阻塞态"><a href="#阻塞态" class="headerlink" title="阻塞态"></a>阻塞态</h5><ul><li>如果一个进程正在CPU 里运行，处于<strong>“运行态”</strong></li><li>当运行指令：发出系统调用，请求使用打印机资源，但是打印机资源正在被其他进程占用<ul><li>在进程运行的过程中，可能会<strong>请求等待某个事件的发生</strong>（如等待某种系统资源的分配，或者等待其他进程的响应）</li></ul></li><li>在获取所需资源之前，进程无法再往下进行，此时操作系统会让这个进程下 CPU，并让它进入<strong>“阻塞态”</strong></li><li>当 CPU 空闲时，又会选择另一个“就绪态”进程上 CPU 运行</li><li>当等待的事件发生之后（如打印机空闲），之前阻塞态的进程就会重新变成就绪态，等待上 CPU 运行</li></ul><p><img src="/../image/assets/image-20230729211038502.png" alt="image-20230729211038502"></p><h5 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h5><ul><li><p>当一个进程运行结束以后，这个进程可以执行 exit 系统调用，请求操作系统终止该进程</p></li><li><p>此时该进程会进入“终止态”，操作系统会让该进程下 CPU，并回收内存空间等资源，最后还要回收该进程的 PCB</p></li><li><p>当终止进程的工作完成之后，这个进程就彻底消失了</p></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="/../image/assets/image-20230729212104792.png" alt="image-20230729212104792"></p><ul><li>进程开始创建：创建态</li><li>系统完成创建进程的一系列工作：就绪态<ul><li>此时除了处理机资源，其他一切资源都已经具备</li></ul></li><li>就绪态的进程被调度：运行态<ul><li>此时一切资源都已经具备：处理机和其他</li></ul></li><li>时间片到，或处理机被抢占：就绪态</li><li>进程用“系统调用”的方式申请某种系统资源，或者请求等待某个事件发生：阻塞态<ul><li>运行态 —&gt;阻塞态是一种进程自身做出的 主动行为</li></ul></li><li>申请的资源被分配，或者等待的事件发生：就绪态<ul><li>阻塞态—&gt;就绪态不是进程自身能控制的，是一种被动行为</li></ul></li><li>注意<ul><li><strong>不能由阻塞态直接转换为运行态</strong></li><li><strong>不能由就绪态直接转换为阻塞态</strong></li><li>因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</li></ul></li></ul><p><img src="/../image/assets/image-20230729212149345.png" alt="image-20230729212149345"></p><ul><li><p>进程的三种基本状态：进程的整个生命周期中，大部分事件都处于这三种基本状态</p><ul><li>运行态：占用 CPU，并在 CPU 上运行<ul><li>单核 CPU 情况下，同一时刻只会有一个进程处于运行态，多核 CPU 可能会有多个进程处于运行态</li></ul></li><li>就绪态：已经具备运行条件，但由于没有空闲 CPU，而暂时不能运行</li><li>阻塞态（等待态）：因等待某一事件而暂时不能运行</li></ul></li><li><p>另外两种状态</p><ul><li>创建态（新建态）：进程正在被创建，操作系统为进程分配资源，初始化 PCB</li><li>终止态（结束态）：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销 PCB</li></ul></li><li><p>进程 PCB 中，会有一个变量 state 来表示进程的当前状态</p><ul><li>如：1 表示创建态；2 表示就绪态；3 表示运行态</li><li>为了对统一状态下的各个进程进行统一的管理，操作系统会将各个进程的 PCB 组织起来</li></ul></li></ul><p><img src="/../image/assets/image-20230729213455299.png" alt="image-20230729213455299"></p><h4 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h4><p><img src="/../image/assets/image-20230729213013922.png" alt="image-20230729213013922"><br><img src="/../image/assets/image-20230729213313473.png" alt="image-20230729213313473"></p><h5 id="链接方式（大部分）"><a href="#链接方式（大部分）" class="headerlink" title="链接方式（大部分）"></a>链接方式（大部分）</h5><ul><li>三个指针<ul><li>执行指针：指向当前处于运行态（之形态）的进程<ul><li>单 CPU 计算机中，同一时刻只会有一个进程处于运行态</li></ul></li><li>就绪队列指针：指向当前处于就绪态的进程<ul><li>通常会把优先级高的进程放在队头</li></ul></li><li>阻塞队列指针：指向当前处于阻塞态的进程<ul><li>很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列<ul><li>等待打印机的阻塞队列</li><li>等待磁盘的阻塞队列</li></ul></li></ul></li></ul></li></ul><h5 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h5><ul><li>使用索引表</li></ul><p><img src="/../image/assets/image-20230729213420043.png" alt="image-20230729213420043"></p><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p><img src="/../image/assets/image-20230729214154224.png" alt="image-20230729214154224"></p><h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li><p>对系统中的所有进程实施有效的管理</p></li><li><p>具有创建新进程、撤销已有进程、实现进程状态转换等功能</p></li><li><p>简化理解：<strong>进程控制就是要实现进程的状态转换</strong></p></li></ul><h5 id="如何实现——原语"><a href="#如何实现——原语" class="headerlink" title="如何实现——原语"></a>如何实现——原语</h5><ul><li>用原语实现<ul><li>原语是一种特殊的程序，它的<strong>执行具有原子性</strong></li><li>这段程序<strong>运行必须一气呵成，不可中断</strong></li></ul></li></ul><p><img src="/../image/assets/image-20230729214212986.png" alt="image-20230729214212986"></p><ul><li>如果不能一气呵成，就有可能导致操作系统中的某些关键数据结构信息不统一，这会映像操作系统进行别的管理工作<ul><li>假设此时进程 2 等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事<ul><li>将 PCB 的 state 设为 1<ul><li>若此时收到中断信号停止，则 PCB2 中的 state&#x3D;1，但是它却被放在阻塞队列里</li></ul></li><li>将 PCB2 从阻塞队列放到就绪队列</li></ul></li></ul></li></ul><h5 id="原语如何实现原子性"><a href="#原语如何实现原子性" class="headerlink" title="原语如何实现原子性"></a>原语如何实现原子性</h5><p><img src="/../image/assets/image-20230729214852272.png" alt="image-20230729214852272"><br><img src="/../image/assets/image-20230729215050670.png" alt="image-20230729215050670"></p><ul><li>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断<ul><li>可以用：<strong>关中断指令</strong>和<strong>开中断指令</strong>这两个<strong>特权指令</strong>实现原子性</li></ul></li><li>正常情况<ul><li><strong>CPU每执行完一条指令都会例行检查是否有中断信号需要处理</strong>，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。</li><li>中断处理结束之后也不一定会直接回到原进程执行</li></ul></li><li>关中断之后<ul><li>CPU 不再例行检查中断信号，直到执行开中断指令之后才会恢复检查</li><li>这样关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了原子性</li></ul></li><li>如果这两个特权指令允许用户程序使用的话，会发生什么情况？</li></ul><h5 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h5><p><img src="/../image/assets/image-20230729215456361.png" alt="image-20230729215456361"></p><ul><li>引起进程创建的原语<ul><li>创建原语：操作系统创建一个进程时使用的原语<ul><li>申请空白 PCB</li><li>为新进程分配所需资源</li><li>初始化 PCB</li><li>将 PCB 插入就绪队列（创建态—&gt;就绪态）</li></ul></li><li>引起进程创建的事件<ul><li>用户登录<ul><li>分时系统中，用户登陆成功，系统会为其建立起一个新的进程</li></ul></li><li>作业调度（作业：外存中没有投入运行的程序）<ul><li>多道批处理系统中，有新作业放入内存时，会为其建立一个新的进程</li></ul></li><li>提供服务<ul><li>用户向操作系统提出某些请求时，会新建一个进程处理该请求</li></ul></li><li>应用请求<ul><li>由用户进程主动请求创建一个子进程</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230729215955845.png" alt="image-20230729215955845"></p><ul><li>引起进程终止的原语<ul><li><p>撤销原语：就绪态&#x2F;阻塞态&#x2F;运行态 —&gt;终止态—&gt;无</p><ul><li>从 PCB 集合中找到终止进程的 PCB</li><li>若进程正在运行，立即剥夺 CPU，将 CPU 分配给其他进程</li><li>终止其所有子进程：<strong>进程间的关系是树形结构</strong></li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除 PCB</li></ul></li><li><p>引起进程终止的事件</p><ul><li>正常结束：进程自己请求终止（exit 系统调用）</li><li>异常结束：整数除以 0，非法使用特权指令，然后被操作系统强行杀掉</li><li>外界干预：Ctrl+Alt+delete，用户选择杀掉进程</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230729220717735.png" alt="image-20230729220717735"></p><ul><li><p>阻塞原语和唤醒原语必须成对使用</p></li><li><p>引起进程阻塞原语</p><ul><li><p>阻塞原语：运行态—&gt;阻塞态</p><ul><li>找到要阻塞的进程对应的 PCB</li><li><strong>保护进程运行现场</strong>，将 PCB 状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将 PCB 插入相应事件的等待队列</li></ul></li><li><p>引起进程阻塞的事件</p><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul></li><li><p>引起进程唤醒原语</p><ul><li><p>唤醒原语：阻塞态—&gt;就绪态</p><ul><li>在事件等待队列中找到 PCB</li><li>将 PCB 从等待队列移除，设置进程为就绪态</li><li>将 PCB 插入就绪队列，等待被调度</li></ul></li><li><p>引起进程唤醒的事件</p><ul><li>等待的事件发生：因何事阻塞，就应由何事唤醒</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230729222753089.png" alt="image-20230729222753089"></p><ul><li>进程切换的原语<ul><li>切换原语（运行态—&gt;就绪态，就绪态—&gt;运行态）<ul><li>将<strong>运行环境信息</strong>存入 PCB<ul><li>进程上下文</li></ul></li><li>PCB移入相应队列</li><li>选择另一个进程执行，并更新其 PCB</li><li>根据 PCB 恢复进程所需的运行环境</li></ul></li><li>引起进程切换的事件<ul><li>当前进程事件片到</li><li>有更高优先级的进程 daoda</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul></li></ul><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p><img src="/../image/assets/image-20230729224515923.png" alt="image-20230729224515923"></p><h5 id="什么是进程间通信"><a href="#什么是进程间通信" class="headerlink" title="什么是进程间通信"></a>什么是进程间通信</h5><ul><li>进程间通信（IPC，Inter-Process Communication）是指两个进程之间产生数据交互</li></ul><h5 id="为什么进程通信需要操作系统支持？"><a href="#为什么进程通信需要操作系统支持？" class="headerlink" title="为什么进程通信需要操作系统支持？"></a>为什么进程通信需要操作系统支持？</h5><ul><li>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong></li><li>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong></li></ul><p><img src="/../image/assets/image-20230729224936559.png" alt="image-20230729224936559"></p><h5 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h5><p><img src="/../image/assets/image-20230730212351000.png" alt="image-20230730212351000"></p><h6 id="基于共享存储区的共享"><a href="#基于共享存储区的共享" class="headerlink" title="基于共享存储区的共享"></a>基于共享存储区的共享</h6><ul><li><p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式</p></li><li><p>通过系统调用，申请一片共享存储区</p><ul><li>通过 mmap 系统调用，将共享内存区映射到进程自己的地址空间</li><li>通过“增加页表项&#x2F;段表项”即可将同一片共享内存区映射到各个进程的地址空间中</li></ul></li><li><p>两个进程都可以访问这个共享存储区</p><ul><li>进程 Q 写入</li><li>进程 P 读取</li></ul></li><li><p>为了避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的</p></li><li><p>各个进程可以使用操作系统内核提供的同步互斥工具（如 P、V 操作）</p><ul><li>避免对共享存储区的同时使用</li></ul></li></ul><p><img src="/../image/assets/image-20230729225116804.png" alt="image-20230729225116804"></p><h6 id="基于数据结构的共享"><a href="#基于数据结构的共享" class="headerlink" title="基于数据结构的共享"></a>基于数据结构的共享</h6><ul><li>比如共享空间只能放一个长度为 10 的数组</li><li>这种共享方式速度慢、限制多，是一种低级通信方式</li></ul><h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><p><img src="/../image/assets/image-20230730212535199.png" alt="image-20230730212535199"></p><ul><li>进程间的数据交换以<strong>格式化的消息</strong>（message）为单位。<ul><li>格式化的消息<ul><li>消息头<ul><li>发送进程 ID</li><li>接收进程 ID</li><li>消息长度</li></ul></li><li>消息体</li></ul></li></ul></li><li>进程通过操作系统提供的“发送信息&#x2F;接收信息”两个<strong>原语</strong>进行数据交换</li></ul><p><img src="/../image/assets/image-20230730212853516.png" alt="image-20230730212853516"></p><p><img src="/../image/assets/image-20230730213304074.png" alt="image-20230730213304074"></p><p><img src="/../image/assets/image-20230730213326268.png" alt="image-20230730213326268"></p><ul><li>消息传递<ul><li>直接通信方式<ul><li>消息发送进程要指明接收进程的 ID</li><li>过程<ul><li>进程 P 要向进程 Q 发送 msg 消息</li><li>使用 发送原语 send(Q,msg) 将消息 msg 发送到操作系统内核区的进程 Q 的 PCB 的消息队列</li><li>进程 Q 想要接收进程 P 发送的消息</li><li>使用接受原语 receive(P,&amp;msg) 将消息队列中 P 发送的消息msg从操作系统的内核区复制到进程 Q 的地址空间</li></ul></li></ul></li><li>间接通信方式（信箱通信方式）<ul><li>通过“信箱”间接地通信，以“信箱”作为中间实体进行信息传递</li><li>过程<ul><li>进程 P 想要向进程 Q 发送消息 msg</li><li>先使用发送原语，send(A,msg)往信箱 A 发送消息 msg</li><li>操作系统内核区中的信箱 A 中就有了 msg 这条消息</li><li>进程 Q 想要接收信箱 A 中的消息 msg</li><li>使用接收原语 send(A,&amp;msg)从信箱中接收消息</li></ul></li><li>可以多个进程往同一个信箱 send 消息，也可用多个进程从同一个信箱中 receive 消息</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230730214409664.png" alt="image-20230730214409664"></p><p><img src="/../image/assets/image-20230730214421570.png" alt="image-20230730214421570"></p><p><img src="/../image/assets/image-20230730214434494.png" alt="image-20230730214434494"></p><h5 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h5><ul><li>管道是一个特殊的共享文件，又名 pipe 文件，其实就是在内存中开辟一个<strong>大小固定的内存缓冲区</strong></li><li>管道通信 VS 共享内存的通信<ul><li>管道通信按顺序进行存储和读取（循环队列， FIFO）</li><li>共享内存的通信可以随机位置存储和读取</li></ul></li><li>管道通信只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输<ul><li>如果想要实现<strong>双向同时通信，则需要设置两个管道</strong></li></ul></li><li>各进程要<strong>互斥</strong>的访问管道（由操作系统实现）</li><li>当<strong>管道写满</strong>时，<strong>写进程将阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程</li><li>当<strong>管道读空</strong>时，<strong>读进程将阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程</li><li>管道中的数据一旦被读出，就彻底消失。<ul><li>当多个进程读同一个管道时，可能会错乱</li><li>解决方法<ul><li><strong>一个管道允许多个写进程一个读进程</strong></li><li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230730215417864.png" alt="image-20230730215417864"></p><ul><li>写进程往管道写数据，即使管道没被写满，<strong>只要管道没空，读进程就可以从管道读数据</strong></li><li>读进程从管道读数据，即使管道没被读空，<strong>只要管道没满，写进程就可以往管道写数据</strong></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><img src="/../image/assets/image-20230730220618058.png" alt="image-20230730220618058"></p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><h5 id="什么是线程，为什么要引入线程？"><a href="#什么是线程，为什么要引入线程？" class="headerlink" title="什么是线程，为什么要引入线程？"></a>什么是线程，为什么要引入线程？</h5><ul><li>还没有引入进程之前，系统中各个程序只能串行执行</li><li>引入了进程后，可以进行程序的并行运行（边听歌边聊天）</li><li>但是进程实际上是对程序的一次执行，如果想要实现多个功能（QQ 视频、聊天、文件传输），那么没有办法执行一次就完成<ul><li>进程是程序的一次执行，但这些功能显然不可能是由一个程序顺序处理就能实现的</li></ul></li><li>有的进程可能需要“同时”做很多事，而传统的<strong>进程只能串行的执行一系列程序</strong><ul><li>因此引入线程，增加并发度</li></ul></li><li><strong>传统的进程是程序执行流的最小单位</strong></li><li><strong>引入线程后，线程成为了程序执行流的最小单位</strong><ul><li>一个进程可以有多个线程<ul><li>两个不同的线程（QQ 视频聊天处理程序、QQ 传送文件处理程序）</li><li>两个相同的线程（两个 QQ 文字聊天处理程序）<ul><li>线程运行的程序代码相同但是数据不相同</li></ul></li></ul></li></ul></li><li>可以把线程理解为“轻量级进程”<ul><li>线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位</li><li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而提升了系统的并发度</li><li>一个进程内也可以并发处理各种任务（QQ 视频、文件聊天、传文件）</li></ul></li><li>引入线程后，进程只作为除 CPU 之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）</li></ul><p><img src="/../image/assets/image-20230730220745127.png" alt="image-20230730220745127"></p><p><img src="/../image/assets/image-20230730221811371.png" alt="image-20230730221811371"></p><ul><li>资源分配、调度<ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程后，<strong>进程是资源分配的基本单位，线程是调度的基本单位</strong></li></ul></li><li>并发性<ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各线程间也能并发，提升了并发度</li></ul></li><li>系统开销<ul><li>传统的进程间并发，需要切换进程的开发环境，系统开销很大</li><li><strong>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</strong></li><li>引入线程后，<strong>并发所带来的系统开销减少</strong></li></ul></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程的属性<ul><li>线程是处理机调度的单位</li><li>多 CPU 计算机中，<strong>各个线程可占用不同的 CPU</strong></li><li><strong>每个线程都有一个线程 ID、线程控制块</strong>（TCB）</li><li>线程也有<strong>就绪、阻塞、运行</strong>三个基本状态</li><li><strong>线程几乎不拥有系统资源</strong></li><li><strong>同一进程的不同线程间共享进程的资源</strong></li><li>由于共享内存地址空间，<strong>同一进程中的线程间通信甚至无需系统干预</strong></li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很少</li><li>切换进程，系统开销较大</li></ul></li></ul><p><img src="/../image/assets/image-20230730224856355.png" alt="image-20230730224856355"></p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p><img src="/../image/assets/image-20230730224937959.png" alt="image-20230730224937959"></p><p><img src="/../image/assets/image-20230730225226976.png" alt="image-20230730225226976"></p><p><img src="/../image/assets/image-20230730225251081.png" alt="image-20230730225251081"></p><p><img src="/../image/assets/image-20230731142204793.png" alt="image-20230731142204793"></p><p><img src="/../image/assets/image-20230731142219212.png" alt="image-20230731142219212"></p><ul><li><p>实现方式</p><ul><li><p>用户级线程（ULT，User-Level Thread）（只支持进程，不支持线程）</p><ul><li><p>历史背景</p><ul><li>早期的操作系统只支持进程，不支持线程</li><li>当时的线程是由线程库来实现的</li></ul></li><li><p>从代码角度看，线程其实就是一段代码逻辑</p><ul><li>上述三段代码逻辑上可以看做三个“线程”</li><li>while 循环就是一个最弱智的“线程库”</li><li>线程库完成了对线程的管理工作（如调度）</li></ul></li><li><p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能</p><ul><li><p>线程的管理工作由谁来完成</p><ul><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</li></ul></li><li><p>线程切换是否需要 CPU 变态？</p><ul><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预</li></ul></li><li><p>操作系统是否能意识到用户级线程的存在？</p><ul><li><p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</p></li><li><p>用户级线程就是从用户视角看能看到的线程</p></li></ul></li><li><p>优缺点</p><ul><li>优点：用户级线程的切换在用户空间即可完成切换，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个进程不可在多核处理机上并行运行</li></ul></li></ul></li></ul></li><li><p>内核级线程（Kernel-Level Thread, KLT,又称“内核支持的线程”）（由操作系统支持的线程）</p><ul><li><p>历史背景</p><ul><li>大多数现代操作系统都实现了内核级线程，如 Windows、Linux</li></ul></li><li><p>线程的管理工作由谁来完成？</p><ul><li>内核级线程的管理工作都由操作系统内核完成</li></ul></li><li><p>线程的切换是否需要 CPU 变态？</p><ul><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</li></ul></li><li><p>操作系统是否能意识到内核级线程的存在？</p><ul><li>操作系统会为每个内核级线程建立相应的 TCB（Thread Control Block,线程控制块）通过 TCB 对线程进行管理、“内核级线程”就是“从操作系统内核角度看能看到的线程”</li></ul></li><li><p>优缺点</p><ul><li><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多核处理机上并行执行</p></li><li><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</p></li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230731142649775.png" alt="image-20230731142649775"><br><img src="/../image/assets/image-20230731142701443.png" alt="image-20230731142701443"></p><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p><img src="/../image/assets/image-20230731143205469.png" alt="image-20230731143205469"></p><p><img src="/../image/assets/image-20230731144212943.png" alt="image-20230731144212943"></p><p><img src="/../image/assets/image-20230731144231725.png" alt="image-20230731144231725"></p><ul><li>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</li><li>一对一模型<ul><li>一个用户级线程映射到一个内核级线程</li><li>每个用户进程有与用户级线程同数量的内核级线程</li><li>优点<ul><li>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li></ul></li><li>缺点<ul><li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li></ul></li></ul></li><li>多对一模型<ul><li>多个用户级线程映射到一个内核级线程</li><li>一个进程只被分配一个内核级线程</li><li>优点<ul><li>用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li></ul></li><li>缺点<ul><li>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个进程不可在多核处理机上并行运行</li></ul></li><li>操作系统只看得见内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong></li></ul></li><li>多对多模型<ul><li>n 用户及线程映射到 m 个内核级线程（n&gt;&#x3D;m）每个用户进程对应 m 个内核级进程</li><li>优点<ul><li>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</li></ul></li></ul></li><li>理解<ul><li>用户级线程是“代码逻辑”的载体</li><li>内核级线程是“运行机会”的载体</li><li><strong>内核级线程才是处理机分配的单位</strong>。<ul><li>例如：多核 CPU 环境下，左边的进程最多被分配两个核（因为只有两个内核级线程）</li></ul></li><li>一段“代码逻辑”只有获得了“运行机会”才能被 CPU 执行<ul><li>内核级线程中可以运行任意一个有映射关系的用户级代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</li></ul></li><li><strong>只有所有的内核级线程都被阻塞，这个进程才会被阻塞</strong></li></ul></li></ul><h4 id="线程状态与转换"><a href="#线程状态与转换" class="headerlink" title="线程状态与转换"></a>线程状态与转换</h4><p><img src="/../image/assets/image-20230731145122938.png" alt="image-20230731145122938"></p><h4 id="线程的组织和控制"><a href="#线程的组织和控制" class="headerlink" title="线程的组织和控制"></a>线程的组织和控制</h4><p><img src="/../image/assets/image-20230731145218776.png" alt="image-20230731145218776"></p><ul><li>TCB（线程控制块）<ul><li>线程标识符TID：与 PID 类似</li><li>程序计数器 PC<ul><li>线程目前执行到哪里</li></ul></li><li>其他寄存器<ul><li>线程运行的中间结果</li></ul></li><li>堆栈指针<ul><li>堆栈保存函数调用信息、局部变量</li></ul></li><li>线程运行状态<ul><li>运行&#x2F;就绪&#x2F;阻塞</li></ul></li><li>优先级<ul><li>线程调度、资源分配的参考</li></ul></li></ul></li></ul><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p><img src="/../image/assets/image-20230731150559926.png" alt="image-20230731150559926"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。</li><li>这就需要某种规则来决定处理这些任务的顺序，这就是调度研究的问题</li></ul><h3 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h3><ul><li>作业：一个具体的任务</li><li>用户向系统提交了一个作业 &#x3D; 用户让操作系统启动一个程序（来处理一个具体的任务）</li></ul><p><img src="/../image/assets/image-20230731151936668.png" alt="image-20230731151936668"></p><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><ul><li>内存空间有限，有时无法将用户提交的作业全部放入内存</li><li>高级调度（作业调度）<ul><li>简化理解：好几个程序需要启动，到底先启动哪个</li><li>按一定的原则从<strong>外存的作业后备队列中挑选一个作业调入内存</strong>，并创建进程</li><li>每个作业只调入一次，调出一次</li><li>作业调入时会建立 PCB，调出时才撤销 PCB</li></ul></li></ul><p><img src="/../image/assets/image-20230731151950882.png" alt="image-20230731151950882"></p><h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><ul><li>低级调度（进程调度&#x2F;处理机调度）<ul><li>安装某种策略<strong>从就绪队列中选取一个进程</strong>，<strong>将处理机分配给它</strong></li><li><strong>进程调度是操作系统中最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度</li><li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次</li></ul></li></ul><p><img src="/../image/assets/image-20230731152004854.png" alt="image-20230731152004854"></p><h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><ul><li>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存</li><li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程 PCB会被组织成<strong>挂起队列</strong></li><li>中级调度（内存调度）——<strong>按照某种策略决定将哪个处于挂起状态的进程重新调入内存</strong><ul><li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高</li></ul></li></ul><h4 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h4><ul><li>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）</li><li>挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态</li><li>挂起 VS  阻塞<ul><li>相同点<ul><li>都是暂时不能获得 CPU 的服务</li></ul></li><li>不同点<ul><li>挂起态是将进程映像调到外存去了</li><li>阻塞态下进程映像还在内存中</li></ul></li></ul></li><li>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列</li></ul><p><img src="/../image/assets/image-20230731152237536.png" alt="image-20230731152237536"></p><h4 id="三层调度的联系、对比"><a href="#三层调度的联系、对比" class="headerlink" title="三层调度的联系、对比"></a>三层调度的联系、对比</h4><p><img src="/../image/assets/image-20230731152523475.png" alt="image-20230731152523475"></p><ul><li>作业调度<ul><li>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</li><li>外存—&gt;内存（面向作业）</li><li>发生频率最低</li><li>无—&gt;创建态—&gt;就绪态</li></ul></li><li>内存调度<ul><li>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</li><li>外存—&gt;内存（面向过程）</li><li>发生频率中等</li><li>挂起态—&gt;就绪态（阻塞挂起—&gt;阻塞态）</li></ul></li><li>进程调度<ul><li>安装某种规则，从就绪队列中选择一个进程为其分配处理机</li><li>内存—&gt;CPU</li><li>发生频率最高</li><li>就绪态—&gt;运行态</li></ul></li></ul><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><img src="/../image/assets/image-20230731153801721.png" alt="image-20230731153801721"></p><h4 id="CPU-利用率"><a href="#CPU-利用率" class="headerlink" title="CPU 利用率"></a>CPU 利用率</h4><ul><li>指 CPU“忙碌”的时间占总时间的比例</li><li>利用率 &#x3D; 忙碌的时间&#x2F;总时间（有的题目还会要求计算某种设备的利用率）<ul><li>EG：某计算机只支持单道程序，某个作业刚开始需要再 CPU 上运行 5 秒，再用打印机打印输出 5 秒，之后再执行 5 秒，才能够结束。在此过程中，CPU 利用率、打印机利用率分别是多少？<ul><li>CPU 利用率 &#x3D; (5+5)&#x2F;(5+5+5) &#x3D; 2&#x2F;3</li><li>打印机利用率 &#x3D; 5&#x2F;(5+5+5) &#x3D; 1&#x2F;3</li></ul></li><li>通常会考察多道程序并发执行的情况，可以用“甘特图”来辅助计算</li></ul></li></ul><p><img src="/../image/assets/image-20230731155450341.png" alt="image-20230731155450341"></p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><ul><li>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业<ul><li>系统吞吐量：<strong>单位时间内完成作业的数量</strong></li><li>系统吞吐量 &#x3D; 总共完成了多少道作业 &#x2F; 总共花了多少时间<ul><li>EG：某计算机系统处理完 10 道作业，共花费 100 秒，则系统吞吐量为？<ul><li>10&#x2F;100 &#x3D; 0.1道&#x2F;秒</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230731155503648.png" alt="image-20230731155503648"></p><h4 id="周转时间（对作业）"><a href="#周转时间（对作业）" class="headerlink" title="周转时间（对作业）"></a>周转时间（对作业）</h4><ul><li><strong>作业从提交到完成花了多少时间</strong><ul><li>作业与进程的概念不同<ul><li>作业不仅要考虑建立进程后的时间，还要加上作业在外存后备队列中等待的时间</li><li>程序只有在进入内存之后才会形成进程，所以作业的时间是包括进程的所有存在时间的</li></ul></li></ul></li><li>周转时间<ul><li>从作业被提交给系统开始，到作业完成为止的这段时间间隔</li><li>包括四个部分<ul><li>作业在外存后备队列上等待作业调度（高级调度）的时间</li><li>进程在就绪队列上等待进程调度（低级调度）的事件</li><li>进程在 CPU 上执行的时间</li><li>进程等待 I&#x2F;O操作完成的事件<ul><li>后三项在一个作业的整个处理过程中，可能发生多次</li></ul></li></ul></li><li>（作业）周转时间 &#x3D; 作业完成时间 - 作业提交时间<ul><li>对于用户来说，更关心自己的单个作业的周转时间</li></ul></li><li>平均周转时间 &#x3D; 各作业的周转时间之和 &#x2F; 作业数<ul><li>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值</li></ul></li></ul></li><li>思考<ul><li>有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的<ul><li>排队十分钟，运行一分钟</li><li>排队一分钟，运行十分钟</li><li>这两个的周转时间相同，但是感受不同</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230731155525631.png" alt="image-20230731155525631"></p><h4 id="带权周转时间"><a href="#带权周转时间" class="headerlink" title="带权周转时间"></a>带权周转时间</h4><ul><li>带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行的事件 &#x3D; （作业完成时间 - 作业提交时间）&#x2F; 作业实际运行的时间<ul><li>带权周转时间必然 &gt;&#x3D; 1</li><li><strong>带权周转时间与周转时间都是越小越好</strong></li><li>对于<strong>周转时间相同</strong>的两个作业，<strong>实际运行时间长</strong>的作业在相同时间内<strong>被服务的时间更多，带权周转时间更小，用户满意度更高</strong></li><li>对于<strong>实际运行时间相同</strong>的两个作业<strong>，周转时间短的带权周转时间更小，用户满意度更高</strong></li></ul></li><li>平均带权周转时间 &#x3D; 各作业带权周转时间之和 &#x2F;  作业数</li></ul><p><img src="/../image/assets/image-20230731160015086.png" alt="image-20230731160015086"></p><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><ul><li>计算机用户希望自己的作业尽可能少的等待处理机</li><li>等待时间<ul><li>进程&#x2F;作业处于等待处理机状态时间之和</li><li>等待时间越长，用户满意度越低</li><li>过程<ul><li>作业在后备队列（在外存中）<strong>等待被服务（调度）</strong></li><li>作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被 CPU 服务，会被 I&#x2F;O设备服务，当然也会有<strong>等待被服务</strong>的时候</li></ul></li><li>进程等待时间 VS 作业等待时间<ul><li>对于进程来说，等待时间就是指进程建立后<strong>等待被服务的事件之和</strong>，在等待 I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间</li><li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</li></ul></li><li>一个作业总共需要被 CPU 服务多久，被 I&#x2F;O设备服务多久一般是确定不变的</li><li>因此调度算法其实只会影响作业&#x2F;进程的等待时间</li><li>也有“平均等待时间”来评价整体性能</li></ul></li></ul><p><img src="/../image/assets/image-20230731161217498.png" alt="image-20230731161217498"></p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><ul><li>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早的开始被系统服务、回应</li><li>相应时间<ul><li>指从用户提交请求到首次产生响应所用的时间</li></ul></li></ul><p><img src="/../image/assets/image-20230731161342186.png" alt="image-20230731161342186"></p><h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p><img src="/../image/assets/image-20230731161510280.png" alt="image-20230731161510280"></p><ul><li>进程调度（低级调度）<ul><li>按照某种算法从就绪队列中选择一个进程为其分配处理机</li></ul></li><li>需要进行进程调度与切换的情况<ul><li>当前运行的进程主动放弃处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如等待 I&#x2F;O）</li></ul></li><li>当前运行的进程被动放弃处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如 I&#x2F;O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li>不能进行进程调度与切换的情况<ul><li>在处理中断的过程中<ul><li>中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li></ul></li><li>进程在<strong>操作系统内核程序临界区中</strong></li><li>在原子操作过程中（原语）<ul><li>原子操作不可中断，要一气呵成（如之前讲过的修改 PCB 中进程状态标志，并把 PCB 放到相应队列）</li></ul></li></ul></li><li>临界资源<ul><li><strong>一个时间段内只允许一个进程使用的资源</strong></li><li>各进程需要互斥地访问临界资源</li></ul></li><li>临界区<ul><li>访问临界资源的那段代码</li></ul></li><li><strong>内核程序的临界区</strong><ul><li>一般是用来访问某种内核数据结构的</li><li>比如进程的就绪队列（由各就绪进程的 PCB 组成）</li></ul></li><li>临界区进行进程调度与切换的过程<ul><li>情况一：内核程序临界区不能进行进程调度与切换<ul><li>当前进程在临界区并且想访问就绪队列，在访问之前就会先对就绪队列上锁</li><li>如果还没有退出临界区（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</li><li>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。</li><li>因此在访问内核程序临界区期间不能进行程序调度与切换（让当前临界区的进程尽快执行完内核程序，快点解锁）</li></ul></li><li>情况二：普通临界区可以进行进程调度与切换<ul><li>进程想要请求打印机资源，但打印机已经上锁</li><li>在打印机打印完成之前，进程一直处于临界区内，临临界资源不会解锁。</li><li>但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致 CPU 一直空闲</li><li>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作</li><li>因此在访问普通临界区时可以进行调度与切换</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230731163451016.png" alt="image-20230731163451016"></p><p><img src="/../image/assets/image-20230731163509188.png" alt="image-20230731163509188"></p><h3 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h3><p><img src="/../image/assets/image-20230731163624091.png" alt="image-20230731163624091"></p><ul><li>非剥夺调度方式<ul><li>又称非抢占方式</li><li>只允许进程主动放弃处理机</li><li>在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</li><li>特点<ul><li>实现简单，系统开销小，但是无法及时处理紧急任务，适合于早期的批处理系统</li></ul></li></ul></li><li>剥夺调度方式<ul><li>又称抢占方式</li><li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程</li><li>优点<ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）</li><li>适合于分时操作系统、实时操作系统</li></ul></li></ul></li></ul><h3 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h3><p><img src="/../image/assets/image-20230731165425028.png" alt="image-20230731165425028"></p><ul><li>狭义的进程调度 VS 进程切换<ul><li><strong>狭义的进程调度</strong><ul><li><strong>指的是从就绪队列中选中一个要运行的进程</strong></li><li>这个进程可以是刚刚被暂停执行的进程，也可能是<strong>另一个进程</strong>，后一种情况就需要<strong>进程切换</strong></li></ul></li><li>进程切换<ul><li>指的是一个进程让出处理机，由另一个进程占用处理机的过程</li></ul></li></ul></li><li>广义的进程调度包含了<strong>选择一个进程和进程切换</strong>两个步骤</li><li>进程切换的过程主要完成了<ul><li>对原来运行进程各种数据的<strong>保存</strong></li><li>对新的进程各种数据的<strong>恢复</strong><ul><li>如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块</li></ul></li></ul></li><li><strong>进程切换是有代价的</strong><ul><li>如果<strong>过于频繁的</strong>进行进程调度、切换，必然会使<strong>整个系统的效率降低</strong></li><li>使系统大部分时间都花在了进程转换上，而真正用于执行过程的事件减少</li></ul></li></ul><h3 id="调度器-调度程序"><a href="#调度器-调度程序" class="headerlink" title="调度器&#x2F;调度程序"></a>调度器&#x2F;调度程序</h3><p><img src="/../image/assets/image-20230731172144398.png" alt="image-20230731172144398"></p><ul><li>就绪态—&gt;运行态&#x2F;运行态—&gt;就绪态<ul><li>被调度程序选中</li><li>时间片用完（不同的程序可以分配不同的时间片大小）<ul><li>这两个过程都由调度程序引起，调度程序决定<ul><li>让谁运行？——调度算法</li><li>运行多长时间？——时间片大小</li></ul></li></ul></li></ul></li><li>调度时机——什么事件会触发“调度程序”？<ul><li><strong>创建新进程</strong><ul><li>就绪队列可能会改变，从而抢占当前运行程序的CPU</li></ul></li><li><strong>进程退出</strong><ul><li>当前正在运行的程序自己终结自己，使得 CPU 空闲</li></ul></li><li>运行<strong>进程阻塞</strong></li><li><strong>I&#x2F;O中断</strong>发生（可能唤醒某些阻塞进程）<ul><li>可能会使得某些进程从阻塞态回到就绪态</li></ul></li></ul></li><li>非抢占式调度策略，只有<strong>运行进程阻塞或退出</strong>才出发调度程序工作</li><li>抢占式调度策略，<strong>每个时钟中断或 k 个时钟中断</strong>会触发调度程序工作</li></ul><p><img src="/../image/assets/image-20230731172312946.png" alt="image-20230731172312946"></p><ul><li>不支持内核级线程的操作系统，调度程序的处理对象是进程</li><li>支持内核级线程的操作系统，调度程序的处理对象是内核线程</li></ul><h3 id="闲逛进程（idle）"><a href="#闲逛进程（idle）" class="headerlink" title="闲逛进程（idle）"></a>闲逛进程（idle）</h3><ul><li>调度程序永远的备胎，没有其他就绪进程中，运行闲逛进程</li><li>特性<ul><li>优先级最低，只有其他指令都执行完成之后，CPU 才会运行闲逛进程</li><li>可以是0 地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li><li>能耗低</li></ul></li></ul><p><img src="/../image/assets/image-20230731172713757.png" alt="image-20230731172713757"></p><h3 id="早期批处理系统的调度算法（重点）"><a href="#早期批处理系统的调度算法（重点）" class="headerlink" title="早期批处理系统的调度算法（重点）"></a>早期批处理系统的调度算法（重点）</h3><p><img src="/../image/assets/image-20230731172754837.png" alt="image-20230731172754837"></p><ul><li>饥饿：某进程&#x2F;作业长期得不到服务</li></ul><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p><img src="/../image/assets/image-20230731174502388.png" alt="image-20230731174502388"></p><p><img src="/../image/assets/image-20230731173334052.png" alt="image-20230731173334052"></p><ul><li><p>First Come First Serve</p></li><li><p>算法思想</p><ul><li>主要从“公平”的角度考虑<ul><li>类似于排队买东西</li></ul></li><li>按照作业&#x2F;进程到达的先后顺序进行服务</li></ul></li><li><p>算法规则</p><ul><li>按照到达的先后顺序调度</li><li>事实上就是等待时间越久的越优先得到服务</li></ul></li><li><p>用于作业&#x2F;进程调度</p><ul><li>用于作业调度时，考虑的是哪个作业先到达后备队列</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li></ul></li><li><p>是否可抢占？</p><ul><li>一般是非抢占式的算法</li></ul></li><li><p>优缺点</p><ul><li>优点：公平，算法实现简单</li><li>缺点：<ul><li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好</li><li>对长作业有利，对短作业不利</li></ul></li></ul></li><li><p>是否会导致饥饿？</p><ul><li>不会</li></ul></li></ul><h4 id="最短作业优先（SJF）"><a href="#最短作业优先（SJF）" class="headerlink" title="最短作业优先（SJF）"></a>最短作业优先（SJF）</h4><p><img src="/../image/assets/image-20230731174529060.png" alt="image-20230731174529060"></p><p><img src="/../image/assets/image-20230731174557373.png" alt="image-20230731174557373"></p><p><img src="/../image/assets/image-20230731174612732.png" alt="image-20230731174612732"></p><p><img src="/../image/assets/image-20230731174907506.png" alt="image-20230731174907506"></p><ul><li><p>Shortest Job First</p></li><li><p>算法思想</p><ul><li>追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</li></ul></li><li><p>算法规则</p><ul><li>最短的作业&#x2F;进程优先得到服务（所谓最短，是指要求服务时间最短）</li></ul></li><li><p>用于作业&#x2F;进程调度</p><ul><li>既可用于作业调度，也可用户进程调度</li><li>用于进程调度时称为“短进程优先（SPF, Shortest Process First）”算法</li></ul></li><li><p>是否可抢占？</p><ul><li>SJF 和 SPF <strong>是非抢占式</strong>的算法</li><li>但是<strong>最短剩余时间优先算法</strong>（SRTN,Shortest Remaining Time Next）是<strong>抢占式版本</strong></li></ul></li><li><p>优缺点</p><ul><li>优点：“最短的 ”平均等待时间、平均周转时间</li><li>缺点：<ul><li>不公平</li><li><strong>对短作业有利，对长作业不利</strong></li><li>可能产生<strong>饥饿</strong>现象</li><li>作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li></ul></li><li><p>是否会导致饥饿？</p><ul><li>会</li><li>如果源源不断地有短作业&#x2F;进程到来，可能使长作业&#x2F;进程长时间得不到服务，产生饥饿现象</li><li>如果一直得不到服务，则称为饿死</li></ul></li><li><p>注意</p><ul><li>如果题目中没有特别说明，所提到的“短作业&#x2F;进程优先算法”默认是非抢占式的</li><li>很多书上都会说“SJF 调度算法 的平均等待时间、平均周转时间”最少<ul><li>严格来说，这个表述是错误的、不严谨的。</li><li>之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</li><li>应该加上一个条件，“在所有进程同时可运行时，采用 SJF”调度算法的平均等待时间、平均周转时间最少</li><li>或者是说“在所有进程都几乎同时到达时，采用 SJF 调度算法的平均等待时间、平均周转时间最少”<ul><li>如果不加上述前提条件，则应该说“抢占式的短作业&#x2F;进程优先调度算法（最短剩余时间优先，SRNT 算法）的平均等待时间、平均周转时间最少”</li></ul></li></ul></li><li>虽然严格来说，SJF 的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF 依然可以获得较少的平均等待时间、平均周转时间</li><li>如果选择题里面遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li></ul></li></ul><p><img src="/../image/assets/image-20230731174922716.png" alt="image-20230731174922716"></p><h4 id="思考：FCFS-VS-SJF"><a href="#思考：FCFS-VS-SJF" class="headerlink" title="思考：FCFS  VS  SJF"></a>思考：FCFS  VS  SJF</h4><ul><li>FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务<ul><li>但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题</li></ul></li><li>SJF 算法是选择一个执行时间最短的作业为其服务<ul><li>但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题</li></ul></li></ul><h4 id="最高响应比优先（HRRN）"><a href="#最高响应比优先（HRRN）" class="headerlink" title="最高响应比优先（HRRN）"></a>最高响应比优先（HRRN）</h4><p><img src="/../image/assets/image-20230731180554689.png" alt="image-20230731180554689"></p><ul><li>算法思想<ul><li>要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</li></ul></li><li>算法规则<ul><li>在每次调度时先计算各个作业&#x2F;进程的响应比最高的作业&#x2F;进程为其服务<ul><li>响应比 &#x3D; 等待时间 + 要求服务时间 &#x2F; 要求服务时间 &gt;&#x3D; 1</li></ul></li></ul></li><li>用于作业&#x2F;进程调度<ul><li>既可以用于作业调度，又可以用于进程调度</li></ul></li><li>是否可抢占？<ul><li>非抢占式的算法</li><li>只有当前运行的作业&#x2F;进程主动放弃处理机（正常&#x2F;异常完成，或主动阻塞）时，才需要调度</li><li>调度时计算所有就绪进程的响应比，选择响应比最高的进程上处理机</li></ul></li><li>优缺点<ul><li>优点<ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF 的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS 的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li></ul></li></ul></li><li>是否会导致饥饿？<ul><li>不会</li></ul></li></ul><p><img src="/../image/assets/image-20230731180957246.png" alt="image-20230731180957246"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="/../image/assets/image-20230731181447584.png" alt="image-20230731181447584"></p><ul><li>这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</li><li>但是不关心“响应时间”，也不区分任务的紧急程度</li><li>因此对于用户来说，<strong>交互性很糟糕</strong></li><li>因此这三种算法一般<strong>适合用于早期的批处理系统</strong></li></ul><h3 id="交互式系统的调度算法（重点）"><a href="#交互式系统的调度算法（重点）" class="headerlink" title="交互式系统的调度算法（重点）"></a>交互式系统的调度算法（重点）</h3><p><img src="/../image/assets/image-20230731190445164.png" alt="image-20230731190445164"></p><h4 id="时间片轮转调度算法（RR）"><a href="#时间片轮转调度算法（RR）" class="headerlink" title="时间片轮转调度算法（RR）"></a>时间片轮转调度算法（RR）</h4><p><img src="/../image/assets/image-20230731190521671.png" alt="image-20230731190521671"></p><ul><li><p>Round-Robin，RR</p></li><li><p>算法思想</p><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li></ul></li><li><p>算法规则</p><ul><li>按照各进程到达就绪队列的顺序，轮流地让各个进程执行一个时间片（如 100ms）</li><li>若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队<ul><li>若 P1 下处理机，同一时刻新进程 P2 到达，某人新到达的进程先进入就绪队列</li></ul></li></ul></li><li><p>适用于作业调度还是进程调度？</p><ul><li>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li></ul></li><li><p>抢占式还是非抢占式？</p><ul><li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转豆豆算法属于抢占式算法</li><li>由时钟装置发出时钟中断来通知 CPU 时间片已到</li></ul></li><li><p>优缺点</p><ul><li>优点<ul><li>公平；响应快，适用于分时操作系统</li></ul></li><li>缺点<ul><li>由于高频率的进程切换，因此有一定开销</li><li>不区分任务的紧急程度</li></ul></li></ul></li><li><p>是否会导致饥饿？</p><ul><li>不会</li></ul></li><li><p>补充</p><ul><li>时间片太大或太小分别有什么影响？</li></ul></li><li><p>时间片为 2</p></li></ul><p><img src="/../image/assets/image-20230731192218537.png" alt="image-20230731192218537"><br><img src="/../image/assets/image-20230731192305139.png" alt="image-20230731192305139"><br><img src="/../image/assets/image-20230731192320759.png" alt="image-20230731192320759"></p><ul><li>时间片为 5</li></ul><p><img src="/../image/assets/image-20230731192343151.png" alt="image-20230731192343151"></p><ul><li>FCFS 先来先服务算法</li></ul><p><img src="/../image/assets/image-20230731192459980.png" alt="image-20230731192459980"></p><ul><li><p>如果<strong>时间片太大</strong>，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退<strong>化为先来先服务调度算法，并且会增加进程响应时间</strong></p></li><li><p>因此时间片不能太大</p><ul><li>比如：系统中有 10 个进程在并发执行，如果时间片为 1 秒，则一个进程被响应可能需要等待 9 秒<ul><li>也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待 9 秒才能够被系统响应</li></ul></li></ul></li><li><p>时间片太小，因为进程调度、切换都是有时间代价的（保存、恢复运行环境），会导致进程切换过于频繁，系统会花费大量的时间来处理进程切换，从而导致实际用于进程执行的事件比例减少</p></li><li><p>因此时间片也不能太小</p><ul><li>一般来说，设计时间片时要让切换进程的开销占比不超过 1%</li></ul></li></ul><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p><img src="/../image/assets/image-20230731194314759.png" alt="image-20230731194314759"></p><ul><li><p>算法思想</p><ul><li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li></ul></li><li><p>算法规则</p><ul><li>调度时选择优先级最高的作业&#x2F;进程</li></ul></li><li><p>适用于作业调度还是进程调度？</p><ul><li>既可以用于作业调度，又可以用于进程调度</li><li>甚至可用于 I&#x2F;O调度</li></ul></li><li><p>抢占式还是非抢占式？</p><ul><li>抢占式、非抢占式都有</li><li>非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占</li></ul></li><li><p>优缺点</p><ul><li><p>优点</p><ul><li>用优先级区分紧急程度、重要程度，适用于实时操作系统</li><li>可灵活地调整对各种作业&#x2F;进程的偏好程度</li></ul></li><li><p>缺点</p><ul><li>若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul></li></ul></li><li><p>是否会导致饥饿？</p><ul><li>会</li></ul></li><li><p>非抢占式的优先级调度算法</p></li></ul><p><img src="/../image/assets/image-20230731194850678.png" alt="image-20230731194850678"></p><ul><li>抢占式的优先级调度算法</li></ul><p><img src="/../image/assets/image-20230731194921845.png" alt="image-20230731194921845"></p><ul><li>就绪队列未必只有一个，可以按照不同优先级来组织<ul><li>不同优先级进入不同的队列</li><li>从优先级比较高的队列开始调度运行</li></ul></li><li>根据优先级是否可以改变，可以将优先级分为 静态优先级 和 动态优先级 两种<ul><li>静态优先级：创建进程时确定，之后一直不变</li><li>动态优先级：创建时有一个初始值，之后会根据情况动态的调整优先级</li></ul></li><li>如何合理地设置各类进程的优先级？<ul><li><strong>系统进程的优先级高于用户进程</strong></li><li><strong>前台进程优先级高于后台进程</strong></li><li><strong>操作系统更偏好 I&#x2F;O 型进程（或称 I&#x2F;O繁忙型进程）</strong><ul><li>I&#x2F;O 设备和 CPU 可以并行工作</li><li>如果优先让 I&#x2F;O繁忙型进程优先运行的话，则越有可能让 I&#x2F;O设备尽早的投入工作，则资源利用率、系统吞吐量都会得到提升</li><li>与 I&#x2F;O繁忙型进程相对的是计算型进程（或称 CPU 繁忙型进程）</li></ul></li></ul></li><li>如果采用的是动态优先级，什么时候应该调整？<ul><li>可以从追求公平、提升资源利用率等角度考虑</li><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可以适当降低其优先级</li><li>如果发现一个进程频繁地进行 I&#x2F;O操作，则可以适当的提升其优先级</li></ul></li></ul><p><img src="/../image/assets/image-20230731205241161.png" alt="image-20230731205241161"></p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="/../image/assets/image-20230731205414418.png" alt="image-20230731205414418"></p><ul><li><p>算法思想</p><ul><li>对其他调度算法的折中权衡</li></ul></li><li><p>算法规则</p><ul><li>设置多级就绪队列，各级队列<strong>优先级从高到低，时间片从小到大</strong></li><li>新进程到达时<strong>先进入第一级队列</strong>，按 <strong>FCFS 原则</strong>排队等待被分配时间片，若用完时间片进程还未结束，则进程<strong>进入下一级</strong>队列队尾。如果此时<strong>已经是在最下级</strong>的队列，则<strong>重新放回该队列队尾</strong></li><li>只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片</li><li><strong>被抢占处理机的进程</strong>重新放回原队列的<strong>队尾</strong></li></ul></li><li><p>适用于作业调度还是进程调度？</p><ul><li>用于进程调度</li></ul></li><li><p>抢占式还是非抢占式？</p><ul><li><strong>抢占式算法</strong></li><li>在 k 级队列的进程运行过程中，若更上级的队列（1~k-1 级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新队列会抢占处理机，原来运行的进程放回 k 级队列的队尾</li></ul></li><li><p>优缺点</p><ul><li>对各类型进程相对公平（FCFS 的优点）</li><li>每个新到达的进程都可以很快就得到响应（RR 的优点）</li><li>短进程只用较少的事件就可以完成（SPF 的优点）</li><li>不必实现估计进程的运行时间（避免用户作假）</li><li>饥饿灵活的调整对各类进程的偏好程度，比如 CPU 密集型进程、I&#x2F;O密集型进程<ul><li>可以将因 I&#x2F;O阻塞的进程重新放回原队列，这样 I&#x2F;O型进程就可以保持较高的优先级</li></ul></li></ul></li><li><p>是否会导致饥饿？</p><ul><li>会</li></ul></li></ul><p><img src="/../image/assets/image-20230731210421459.png" alt="image-20230731210421459"></p><h4 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h4><p><img src="/../image/assets/image-20230731211421218.png" alt="image-20230731211421218"></p><ul><li>系统中按进程类型设置多个队列，进程创建成功后插入，某个队列</li><li>优先级从高到低（可以划分为更多队列）<ul><li>系统进程：内存管理进程</li><li>交互式进程：游戏、打字软件</li><li>批处理进程：AI 模型训练、视频特效渲染</li></ul></li><li>队列之间可采取固定优先级，或时间片划分<ul><li>固定优先级：高优先级空的时候低优先级进程才能被调度</li><li>时间片划分：三个队列分配时间 50%,40%,10%</li></ul></li><li>各队列采用不同的调度策略，如<ul><li>系统进程队列采用优先级调度</li><li>交互式队列采用 RR</li><li>批处理队列采用 FCFS</li></ul></li></ul><h3 id="调度算法总结"><a href="#调度算法总结" class="headerlink" title="调度算法总结"></a>调度算法总结</h3><ul><li>FCFS 算法的优点是公平</li><li>SJF 算法的优点是能尽快处理完短作业；平均等待时间&#x2F;平均周转时间等参数很优秀</li><li>时间片轮转调度算法可以让各个进程得到及时响应</li><li>优先级调度算法可以灵活地调整各种进程被服务的机会</li><li>多级反馈队列调度算法综合以上的所有优点</li></ul><p><img src="/../image/assets/image-20230731181244842.png" alt="image-20230731181244842"><br><img src="/../image/assets/image-20230731210756707.png" alt="image-20230731210756707"></p><ul><li>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。</li><li>因此这三种算法适合用于交互式系统<ul><li>UNIX 就是使用的多级反馈队列调度算法</li></ul></li><li>之前的三种算法则更加注重平均周转&#x2F;等待时间</li></ul><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><p><img src="/../image/assets/image-20230731213111129.png" alt="image-20230731213111129"></p><h3 id="进程同步的概念"><a href="#进程同步的概念" class="headerlink" title="进程同步的概念"></a>进程同步的概念</h3><p><img src="/../image/assets/image-20230731213133921.png" alt="image-20230731213133921"></p><ul><li><p>异步性</p><ul><li><p>进程具有异步性的特征</p><ul><li>各并发执行的进程以<strong>各自独立</strong>的<strong>不可预知</strong>的速度向前推进</li></ul></li><li><p>异步性执行的顺序是不可预知的，但是有时候我们又要对执行顺序有一定的要求</p><ul><li>操作系统要提供“进程同步机制”来实现上述要求</li></ul></li></ul></li><li><p>进程通信——管道通信</p><ul><li>读进程和写进程并发地执行</li><li>由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的</li><li>而实际应用中，又必须按照“写数据-&gt;读数据”的顺序来执行的</li></ul></li><li><p>如何解决这种异步问题，就是进程同步所讨论的内容</p></li><li><p>同步</p><ul><li>直接制约关系</li><li>指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系</li><li>进程间的直接制约关系就是源于它们之间的相互合作</li></ul></li></ul><h3 id="进程互斥的概念"><a href="#进程互斥的概念" class="headerlink" title="进程互斥的概念"></a>进程互斥的概念</h3><p><img src="/../image/assets/image-20230731213154941.png" alt="image-20230731213154941"></p><ul><li><p>进程的“并发需要“共享”的支持</p><ul><li>各个并发执行的进程不可避免的需要共享一些系统资源（比如内存、打印机、摄像头这样的 I&#x2F;O设备）</li></ul></li><li><p>两种资源共享方式</p><ul><li>互斥共享方式<ul><li>系统中的某些资源，<strong>虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</strong></li></ul></li><li>同时共享方式<ul><li>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></li></ul></li></ul></li><li><p>临界资源</p><ul><li><strong>一个时间段内只允许一个进程使用的资源</strong><ul><li>许多物理设备（如摄像头、打印机）都属于临界资源</li><li>许多变量、数据、内存缓冲区</li></ul></li><li>对临界资源的访问，必须互斥地进行</li></ul></li><li><p>互斥</p><ul><li>又称间接制约关系</li><li>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待</li><li>当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</li></ul></li></ul><p><img src="/../image/assets/image-20230731214342409.png" alt="image-20230731214342409"></p><ul><li><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分</p><ul><li>进入区<ul><li>entry section</li><li>负责检查是否可进入临界区</li><li>若可进入，则应设置<strong>正在访问临界资源的标志</strong>（理解为上锁），以组织其他进程同时进入临界区</li></ul></li><li>临界区<ul><li>critical section</li><li>访问临界资源的那段代码</li></ul></li><li>退出区<ul><li>负责解除<strong>正在访问临界资源的标志</strong>（可以理解为解锁）</li></ul></li><li>剩余区<ul><li>remainder section</li><li>做其他处理</li></ul></li></ul></li><li><p><strong>临界区是进程中访问临界资源的代码段</strong></p></li><li><p><strong>进入区和退出区是负责实现互斥地代码段</strong></p></li><li><p>临界区也可称为“临界段”</p></li><li><p>如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？该进程又没有可能一直进入不了临界区？</p></li></ul><p><img src="/../image/assets/image-20230731214910017.png" alt="image-20230731214910017"></p><ul><li><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下 原则</p><ul><li><p>空闲让进</p><ul><li>临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li></ul></li><li><p>忙则等待</p><ul><li>当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li></ul></li><li><p>优先等待</p><ul><li>对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li></ul></li><li><p>让权等待</p><ul><li>当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ul></li></ul></li><li><p>人话：临界区空闲，可以让进程用；临界区忙&#x2F;占用，其他想用的就得等；等待的时间不能太长；要等的话就赶紧先离开</p></li></ul><h3 id="进程互斥的软件实现办法"><a href="#进程互斥的软件实现办法" class="headerlink" title="进程互斥的软件实现办法"></a>进程互斥的软件实现办法</h3><p><img src="/../image/assets/image-20230731220133751.png" alt="image-20230731220133751"></p><ul><li>如果没有进程互斥<ul><li>进程 A、进程 B 在系统中并发地运行<ul><li>A、B 都要使用打印机</li><li>先调度 A 上处理机运行</li><li>当 A 在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度 B 让它上处理机运行</li><li>进程 B 也在使用打印机</li></ul></li><li>结局：A、B 的打印内容混在一起了</li></ul></li></ul><p><img src="/../image/assets/image-20230731220422494.png" alt="image-20230731220422494"></p><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p><img src="/../image/assets/image-20230731220435016.png" alt="image-20230731220435016"><br><img src="/../image/assets/image-20230731221443111.png" alt="image-20230731221443111"></p><ul><li><p>算法思想</p><ul><li>两个进程在<strong>访问完临界区后</strong>会把使用临界区的权限转交给另一个进程<ul><li><strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></li></ul></li></ul></li><li><p>过程</p><ul><li>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区</li><li>若 P1 先上处理机运行，则会一直卡在 5；直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行</li><li>代码 1 不会卡住 P0，P0 可以正常访问临界区；在 P0 访问临界区期间即使切换回 P1，P1 依然会卡在 5</li><li>只有 P0 在退出区将 turn 改为 1 后，P1 才能进入临界区</li></ul></li><li><p>优点</p><ul><li>该算法可以实心“同一时刻最多只允许一个进程访问临界区”</li></ul></li><li><p>缺点</p><ul><li>只能按 P0-&gt;P1-&gt;P0-&gt;P1-&gt;…这样轮流访问</li><li>这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问</li><li><strong>单标志法存在的主要问题是：违背空闲让进原则</strong>（资源空着就让进程使用）</li></ul></li></ul><h4 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h4><p><img src="/../image/assets/image-20230731221720804.png" alt="image-20230731221720804"><br><img src="/../image/assets/image-20230731223240023.png" alt="image-20230731223240023"></p><ul><li><p>算法思想</p><ul><li>设置一个布尔型数组 flag[]，数组中各个元素用来<strong>标记各进程想进入临界区的意愿</strong><ul><li>“flag[0]&#x3D;true”意味着 0 号进程P0 现在想要进入临界区</li></ul></li><li>每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区<ul><li>如果没有，则把自身对应的标志 flag[i]设为 true，之后开始访问临界区</li></ul></li></ul></li><li><p>过程</p><ul><li>用 flag[]表示进入临界区意愿的数组</li><li>刚开始设置为两个进程都不想进入临界区</li><li>当 P1 想要进入临界区之前，检查 P0 是否想要进入临界区<ul><li>如果此时 P0 想要进入临界区，P1 就一直循环等待</li></ul></li><li>标记为 P1 进程想要进入临界区</li><li>访问临界区</li><li>访问完临界区，修改标记为 P1 不想使用临界区</li></ul></li><li><p>缺点</p><ul><li>违反忙则等待的原则（可能会导致两个进程同时访问临界区）</li></ul></li><li><p>原因</p><ul><li>进入区的“检查”和“上锁”两个处理不是一气呵成的</li><li>检查后，上锁前可能发生进程切换</li></ul></li></ul><h4 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h4><p><img src="/../image/assets/image-20230731223354172.png" alt="image-20230731223354172"><br><img src="/../image/assets/image-20230731223405416.png" alt="image-20230731223405416"></p><ul><li><p>算法思想</p><ul><li>双标志先检查法的改版</li><li>前一个算法是先检查后上锁，这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题</li><li>因此采用先上锁后检查的方法，避免上述问题</li></ul></li><li><p>过程</p><ul><li>flag[]表示进入临界区意愿的数组</li><li>刚开始设置两个进程都不想进入临界区</li><li>标记为 P1 进程想要进入临界区</li><li>如果 P0 也想进入临界区，则 P1 循环等待</li><li>访问临界区</li><li>访问完临界区，修改标记为 P1 不想使用临界区</li></ul></li><li><p>问题</p><ul><li>虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则，会因各进程都长期无法访问临界资源而产生饥饿现象</li><li>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区</li></ul></li></ul><h4 id="Peterson-算法"><a href="#Peterson-算法" class="headerlink" title="Peterson 算法"></a>Peterson 算法</h4><p><img src="/../image/assets/image-20230731224106572.png" alt="image-20230731224106572"><br><img src="/../image/assets/image-20230731224638219.png" alt="image-20230731224638219"></p><ul><li><p>算法思想</p><ul><li><p>结合双标志法、单标志法的思想</p></li><li><p>如果双方都争着想进入临界区，那可以让进程尝试“谦让”，做一个有礼貌的进程</p></li></ul></li><li><p>过程</p><ul><li>flag[]表示进入临界区意愿的数组，初始值都是 false</li><li>turn 表示优先让哪个进程进入临界区</li><li>先将 flag 设置为 true，表达自己想要进入临界区的意愿</li><li>然后将 turn 设置为对方的值，表明自己愿意让对方先使用</li><li>当（对方想要使用临界区）并且（自己愿意让给对方），就会一直循环等待<ul><li>主动争取</li><li>主动谦让</li><li>检查对方是否也想使用，且最后一次是不是自己说了客气话</li></ul></li><li>进入临界区使用临界资源</li><li>flag设置为 false，修改标记为不想使用临界区</li></ul></li><li><p>优点</p><ul><li>Peterson 算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙 则等待、有限等待 三个原则</li></ul></li><li><p>缺点</p><ul><li>但是依然未遵循让权等待的原则(自己进入不了临界区就立马释放 CPU 资源)</li><li>Peterson 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好</li></ul></li></ul><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p><img src="/../image/assets/image-20230731225249973.png" alt="image-20230731225249973"></p><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p><img src="/../image/assets/image-20230801140306031.png" alt="image-20230801140306031"></p><ul><li><p>利用“开&#x2F;关中断指令”实现</p><ul><li><p>与原语的实现思想相同</p></li><li><p>在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况</p></li><li><p>过程</p><ul><li><p>关中断后即不允许当前进程被中断，也必然不会发生进程切换</p></li><li><p>直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</p></li></ul></li><li><p>优点</p><ul><li>简单、高效</li></ul></li><li><p>缺点</p><ul><li>不适用于多处理机（关中断指令只对执行关中断的处理机有效，对其他处理机无效）</li><li>只适用于操作系统内核程序，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</li></ul></li></ul></li></ul><h4 id="TestAndSet（TS-指令-TSL指令）"><a href="#TestAndSet（TS-指令-TSL指令）" class="headerlink" title="TestAndSet（TS 指令&#x2F;TSL指令）"></a>TestAndSet（TS 指令&#x2F;TSL指令）</h4><p><img src="/../image/assets/image-20230801140749191.png" alt="image-20230801140749191"></p><ul><li><p>简称 TS 指令，有地方称为 TestAndSetLock 指令，或 TSL 指令</p><ul><li>TSL 指令是<strong>用硬件实现</strong>的，执行的过程不允许被中断，只能一气呵成</li><li>双标志先检查法</li></ul></li><li><p>实现方式（用代码模拟硬件）</p><ul><li>布尔型共享变量 lock 表示当前临界区是否被加锁<ul><li>所有进程都可以访问</li><li>true表示已加锁，false 表示未加锁</li></ul></li><li>old 存放lock 原来的值</li><li>返回 old 原来的值</li><li>无论之前是否已经加锁，都将 lock 设为 true</li></ul></li><li><p>使用 TSL 指令实现互斥的算法逻辑（使用硬件，使上锁和检查一气呵成）</p><ul><li>上锁并检查是否之前已上锁<ul><li>lock &#x3D; true 已上锁，一直执行 while 循环</li><li>lock &#x3D; false 未上锁，进入临界区</li></ul></li><li>执行临界区代码段</li><li>解锁 lock &#x3D; false</li></ul></li><li><p>若刚开始 lock 使 false，则 TSL 返回的 old 值是 false，while 循环条件不满足，直接跳过循环，进入临界区</p></li><li><p>若刚开始 lock 是 true，则执行 TSL 后 old 的返回值是 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在推出区进行解锁</p></li><li><p>相比软件实现方式</p><ul><li>TSL 把上锁和检查操作用硬件的方式改变成了一气呵成的原子操作</li></ul></li><li><p>优点</p><ul><li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul></li><li><p>缺点</p><ul><li>不满足“让权等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致忙等</li></ul></li></ul><h4 id="Swap指令（XCHG-指令）"><a href="#Swap指令（XCHG-指令）" class="headerlink" title="Swap指令（XCHG 指令）"></a>Swap指令（XCHG 指令）</h4><p><img src="/../image/assets/image-20230801143309510.png" alt="image-20230801143309510"></p><ul><li>Exchange指令</li><li>Swap 指令也是用硬件实现的，执行的过程不允许被中断，只能一气呵成</li><li>实现思路<ul><li>Swap 指令的作用是交换两个变量的值</li><li>lock 表示当前临界区是否被加锁，初始化为 false</li><li>初始化 old 值为 true</li><li>当 old &#x3D;&#x3D; true 不断交换 old 和 lock 的值</li><li>执行临界区代码段</li><li>将 lock 设置为 false</li></ul></li><li>逻辑上看Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old<ul><li>如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区</li></ul></li><li>优点<ul><li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞</li><li>适用于多处理机环境</li></ul></li><li>缺点<ul><li>不满足“忙则等待”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致忙等</li></ul></li></ul><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><img src="/../image/assets/image-20230801151113016.png" alt="image-20230801151113016"></p><ul><li>互斥锁<ul><li>解决临界区最简单的工具</li><li>一个进程在进入临界区时应获得锁<ul><li>函数 acquire()获得锁</li></ul></li><li>退出临界区时释放锁<ul><li>函数 release()释放锁</li></ul></li></ul></li><li>每个互斥锁都有一个布尔变量 available<ul><li>表示锁是否可用<ul><li>如果锁是可用的，调用 acquire()会成功，且锁不再可用</li><li>当锁不可用时，会被阻塞，直到锁释放</li></ul></li></ul></li><li>acquire()或 release()的执行必须是原子操作，因此互斥通常采用硬件机制来实现</li><li>互斥锁的主要缺点是忙等待<ul><li>当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用 acquire()</li><li>当多个进程共享同一个 CPU 时，就浪费了 CPU 周期</li><li>因此<strong>互斥锁通常用于多处理器系统</strong>，一个线程可以在一个处理器上等待，不影响其他线程的执行<ul><li>自己理解<ul><li>一个进程a发现 available&#x3D;false，没有自己想要的资源A，会一直在一个核上自娱自乐地忙等待</li><li>另外的核可能正在运行着占用A资源的进程b，当这个进程用完资源 A 后，便会释放资源 A，使 available&#x3D;true</li><li>此时本来在自娱自乐忙等待的进程a 便会发现 available&#x3D;true，便会停止忙等待，将 available&#x3D;false，占用资源 A</li></ul></li></ul></li></ul></li><li>需要连续循环忙等的互斥锁，都可以称为<strong>自旋锁（spin lock）</strong>，如 TSL 指令，Swap 指令，单标志法</li></ul><p><img src="/../image/assets/image-20230801151137051.png" alt="image-20230801151137051"></p><ul><li><p>特性</p><ul><li><p>需忙等，进程时间片用完才下处理机，违反“让权等待”</p></li><li><p>优点</p><ul><li>等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li></ul></li><li><p>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</p></li><li><p>不太适用于单处理机系统，忙等的过程中不可能解锁</p></li></ul></li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><img src="/../image/assets/image-20230801151918135.png" alt="image-20230801151918135"></p><ul><li><p>进程互斥的问题</p><ul><li>所有解决方案都无法实现“让权等待”</li><li>在双标志先检查法中，进入区的“检查”、“上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题</li></ul></li><li><p>解决方案——信号量机制</p></li></ul><p><img src="/../image/assets/image-20230801152309811.png" alt="image-20230801152309811"></p><ul><li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步</li><li>信号量其实就是一个变量<ul><li><strong>可以是一个整数，也可以是更复杂的记录型变量</strong></li><li>表示<strong>系统中某种资源的数量</strong><ul><li>比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量</li></ul></li></ul></li><li>原语是一种特殊的程序段<ul><li><strong>执行只能一气呵成，不可被中断</strong></li><li>原语是由<strong>关中断&#x2F;开中断指令</strong>实现的</li><li>软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”<ul><li>如果把进入区、退出区的操作都用“原语”实现，这些操作就能一气呵成</li></ul></li></ul></li><li>一对原语<ul><li>wait(S)原语：P(S)</li><li>Signal(S)原语: V(S)</li><li>可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数<ul><li>wait、signal 原语常简称为 P、V 操作（来自于荷兰语 proberen 和 verhogen）</li></ul></li></ul></li></ul><h4 id="整数信号量"><a href="#整数信号量" class="headerlink" title="整数信号量"></a>整数信号量</h4><p><img src="/../image/assets/image-20230801153251167.png" alt="image-20230801153251167"></p><ul><li>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong><ul><li>与普通整数变量的区别<ul><li>对信号量的操作只有三种：初始化、P 操作、V 操作</li></ul></li></ul></li><li>实现过程<ul><li>初始化整型信号量 S，表示当前系统中可用的打印机资源数</li><li>wait<ul><li>wait 原语，相当于进入区<ul><li>检查和上锁一气呵成，避免了并发、异步导致的问题</li></ul></li><li>如果资源数不够，就一直循环等待<ul><li>存在的问题：<strong>不满足让权等待原则，会发生忙等</strong></li></ul></li><li>如果资源数够，就占用一个资源</li></ul></li><li>signal<ul><li>signal 原语，相当于“退出区”</li><li>使用完资源后，在退出区释放资源</li></ul></li></ul></li><li>使用过程<ul><li>wait(S)<ul><li>进入区，申请资源</li></ul></li><li>使用打印机资源<ul><li>临界区，访问资源</li></ul></li><li>Signal(S)<ul><li>退出区，释放资源</li></ul></li></ul></li></ul><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><ul><li>为了解决整型信号量的“忙等”问题，因此又提出了“记录型信号量”，即用记录型数据结构表示的信号量</li></ul><p><img src="/../image/assets/image-20230801154624424.png" alt="image-20230801154624424"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录型信号量的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;              <span class="comment">//剩余资源数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *L;      <span class="comment">//等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某进程需要使用资源时，通过wait 原语申请</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">block</span>(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程使用完资源后，通过 signal 原语释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现过程<ul><li>记录型信号量的定义<ul><li>int value：剩余资源数</li><li>struct process *L：等待队列</li></ul></li><li>wait<ul><li>某进程需要使用资源时，通过 wait 原语申请</li><li>Value–</li><li>如果剩余资源数不够，使用 block 原语使进程从运行态进入阻塞态</li><li>并挂到信号量 S 的等待队列（即阻塞队列中）</li></ul></li><li>signal<ul><li>进程使用完资源后，通过 signal 原语释放</li><li>value++</li><li>释放完资源后，若还有别的进程在等待这种资源，则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230801165710741.png" alt="image-20230801165710741"></p><ul><li>使用过程<ul><li>某个计算机系统中有 2 台打印机，则初始化信号量 S 时将 S.value的值设为 2，队列 S.L设置为空</li><li>申请资源 wait()<ul><li>P0 进程申请资源，wait(), value–，此时value&gt;0 得到资源</li><li>P1 进程申请资源，wait(), value–，此时 value&#x3D;0 资源恰好分配完</li><li>P2 进程申请资源，wait(), value–，此时 value&#x3D;-1&lt;0，执行 block进入等待队列，有一个进程在等待</li><li>P3 进程申请资源，wait(), value–，此时 value&#x3D;-2&lt;0，执行 block进入等待队列，有两个进程在等待</li></ul></li><li>释放资源 signal()<ul><li>P0使用资源完毕，signal(), value++，此时 value&#x3D;-1&lt;0说明有进程在等待队列，执行 wakeup 唤醒等待队列中的进程P2</li><li>P1使用资源完毕，signal(), value++，此时 value&#x3D;0&#x3D;0说明有进程在等待队列，执行 wakeup 唤醒等待队列中的进程P3</li><li>P2使用资源完毕，signal(), value++，此时 value&#x3D;1&gt;0说明没有进程在等待该资源</li><li>P3使用资源完毕，signal(), value++，此时 value&#x3D;2&gt;0说明没有进程在等待该资源</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230801165905317.png" alt="image-20230801165905317"></p><ul><li>在考研题目中 wait(S)、signal(S)也可用记为P(S), V(S)<ul><li>这对原语可用于实现系统资源的“申请”和“释放”</li></ul></li><li>S.value的初值表示系统中某种资源的 数目</li><li><strong>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源</strong><ul><li>需要执行 S.value–，表示资源数-1</li><li>当S.value&lt;0时，表示该类资源已经分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞<strong>（当前运行的进程从</strong>运行态-&gt;阻塞态</strong>）</li><li>主动放弃处理机，并插入该类资源的等待队列 S.L</li></ul></li><li>由此可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现忙等现象</li><li><strong>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源</strong><ul><li>需要执行 S.value++,表示资源数+1</li><li>若加 1 后仍是 S.value&lt;&#x3D;0，表示仍有进程在等待该类资源</li><li>因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态-&gt;就绪态</strong>）</li></ul></li></ul><h3 id="用信号量实现进程互斥、进程同步、进程的前驱"><a href="#用信号量实现进程互斥、进程同步、进程的前驱" class="headerlink" title="用信号量实现进程互斥、进程同步、进程的前驱"></a>用信号量实现进程互斥、进程同步、进程的前驱</h3><p><img src="/../image/assets/image-20230801171654026.png" alt="image-20230801171654026"></p><ul><li>一个信号量对应一种资源</li><li>信号量的值 &#x3D; 这种资源的剩余数量（信号量的值如果小于 0，说明此时有进程在等待这种资源）</li><li>P(S)——申请一个资源 S，如果资源不够就阻塞等待</li><li>V(S)——释放一个资源 S，如果有进程在等待该资源，则唤醒一个进程</li></ul><h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><p><img src="/../image/assets/image-20230801172212199.png" alt="image-20230801172212199"></p><ul><li>分析并发进程的关键活动，划定临界区<ul><li>如：对临界资源打印机的访问就应放在临界区</li></ul></li><li>定义<ul><li>设置互斥信号量 mutex，初值为 1</li><li>在进入区P(mutex)——申请资源</li><li>在退出区V(mutex)——释放资源<ul><li>对于 P、V 操作是具有“排队阻塞”功能的，并不需要忙等</li></ul></li></ul></li><li>信号量机制实现互斥<ul><li>semaphore mutex &#x3D; 1<ul><li>初始化信号量</li></ul></li><li>P(mutex)<ul><li>使用临界资源前需要加锁</li></ul></li><li>临界区代码</li><li>V(mutex)<ul><li>使用临界资源后需要解锁</li></ul></li></ul></li><li><strong>对不同的临界资源需要设置不同的互斥信号量</strong></li><li><strong>P、V操作必须成对出现</strong><ul><li>缺少 P(mutex)就不能保证临界资源的互斥访问</li><li>缺少 V(mutex)会导致资源永不被唤醒</li></ul></li></ul><h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><p><img src="/../image/assets/image-20230801172930916.png" alt="image-20230801172930916"></p><ul><li>进程同步<ul><li>要让各并发进程按要求有序地推进</li><li>比如，P1，P2 并发执行，由于存在异步性，因此二者交替推进的顺序是不固定的<ul><li>若 P2 的代码 4 要基于 P1 的代码 1 和代码 2 的运行结果才能执行，那么我们就必须保证代码 4 一定要在代码 2 之后才会执行</li></ul></li><li>进程同步问题就是让本来异步的进程相互配合，有序推进</li></ul></li></ul><p><img src="/../image/assets/image-20230801172941345.png" alt="image-20230801172941345"></p><ul><li>用信号量实现进程同步（前 V 后 P）<ul><li>分析什么地方需要实现“同步关系”，即必须保证“<strong>一前一后</strong>”执行的两个操作（或两句代码）</li><li>设置<strong>同步信号量 S，初始为 0</strong></li><li><strong>在“前操作”之后执行 V(S)</strong></li><li><strong>在“后操作”之前执行 P(S)</strong></li></ul></li><li>保证代码 4 一定是在代码2 之后执行<ul><li>semaphore &#x3D; 0<ul><li>初始化同步信号量，初始化为 0</li><li>理解<ul><li>信号量 S 代表“某种资源”，刚开始是没有这种资源的。</li><li>P2 需要使用这种资源，而又只能由 P1 产生这种资源</li></ul></li></ul></li><li>若先执行到 V(S)操作<ul><li>则 S++后 S&#x3D;1</li><li>之后当执行到 P(S)操作时，由于 S&#x3D;1，表示有可用资源，会执行 S–，S 的值变回 0</li><li>P2 进程不会执行 block 原语，而是继续往下执行代码 4</li></ul></li><li>若先执行到 P(S)操作<ul><li>由于 S&#x3D;0，S–后 S&#x3D;-1</li><li>此时没有可用资源，因此 P 操作中会执行 block 原语，主动请求阻塞</li><li>之后当执行完代码 2，继而执行 V(S)操作，S++，使 S 变回0</li><li>由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行wakeup 原语，唤醒 P2 进程</li><li>这样 P2 进程就可以继续执行代码 4</li></ul></li></ul></li></ul><h4 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h4><p><img src="/../image/assets/image-20230801174331731.png" alt="image-20230801174331731"></p><ul><li>进程 P1 有句代码 S1，P2 有句代码S2，P3 有句代码 S3….这些代码要求按如下前驱图所示的顺序来执行<ul><li>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）<ul><li>要为每一对前驱关系各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行 V 操作</li><li>在“后操作”之间对相应的同步信号量执行 P 操作</li></ul></li></ul></li></ul><h3 id="经典信号量同步、互斥问题"><a href="#经典信号量同步、互斥问题" class="headerlink" title="经典信号量同步、互斥问题"></a>经典信号量同步、互斥问题</h3><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><p><img src="/../image/assets/image-20230801175958178.png" alt="image-20230801175958178"></p><ul><li>问题描述<ul><li>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（这里的产品理解为某种数据）<ul><li>生产者、消费者共享一个初始为空、大小为 n 的缓冲区</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待<ul><li>缓冲区没满—&gt;生产者生产</li></ul></li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待<ul><li>缓冲区没空—&gt;消费者消费</li></ul></li><li>缓冲区时临界资源，各进程必须互斥地访问<ul><li>互斥关系</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230801180431367.png" alt="image-20230801180431367"><br><img src="/../image/assets/image-20230801181034147.png" alt="image-20230801181034147"></p><ul><li>PV 操作题目分析步骤<ul><li>关系分析<ul><li>找出题目中描述的各个过程，分析它们之间的同步、互斥关系</li></ul></li><li>整理思路<ul><li>根据各个进程的操作流程确定 P、V 操作的大致顺序</li></ul></li><li>设置信号量<ul><li>根据题目条件确定信号量初值</li><li>互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230801181209016.png" alt="image-20230801181209016"></p><ul><li><p>实现过程</p><ul><li>producer<ul><li>生产一个产品</li><li>P(empty)<ul><li>消耗一个空闲缓冲区</li></ul></li><li>P(mutex)</li><li>把产品放入缓冲区</li><li>V(mutex)<ul><li>实现互斥</li></ul></li><li>V(full)<ul><li>增加一个产品</li></ul></li></ul></li><li>consumer<ul><li>P(full)<ul><li>消耗一个产品（非空缓冲区）</li></ul></li><li>P(mutex)</li><li>从缓冲区取出一个产品</li><li>V(mutex)</li><li>V(empty)<ul><li>增加一个空闲缓冲区</li></ul></li><li>使用产品</li></ul></li></ul></li><li><p><strong>实现互斥是在同一进程中进行一对 PV 操作</strong></p></li><li><p><strong>实现两进程的同步关系，是在其中一个进程中执行 P，另一个进程中执行 V</strong></p></li></ul><p><img src="/../image/assets/image-20230801200932887.png" alt="image-20230801200932887"></p><ul><li>能否改变相邻 P、V 操作的顺序？<ul><li>若此时缓冲区内已经放满产品，则 empty&#x3D;0，full&#x3D;n<ul><li>生产者进程执行①使 mutex 变为 0，再执行②</li><li>由于已经没有空闲缓冲区，因此生产者被阻塞</li><li>由于生产者阻塞，因此切换会消费者进程</li><li>消费者进程执行③，由于 mutex 为 0，即生产者还没有释放对临界资源的“锁”，因此消费者也被阻塞</li><li>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况</li><li>生产者和消费者循环等待被对方唤醒，出现“死锁”</li></ul></li><li>同样的，若缓冲区中没有产品，即 full&#x3D;0，empty&#x3D;n<ul><li>按③④①顺序执行就会发生死锁</li></ul></li><li>因此，<strong>实现互斥地 P 操作一定要在实现同步的 P 操作之后</strong></li><li><strong>V 操作不会导致进程阻塞，因此两个 V 操作顺序可以交换</strong></li></ul></li><li>mutex 的 P 操作放在生产之前和使用产品之后<ul><li>可以，但是那样会让临界区上锁的时间变得更长，不利于进程交替的使用临界资源</li></ul></li></ul><h4 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h4><ul><li>关键在于理清复杂的同步关系</li></ul><p><img src="/../image/assets/image-20230801201803089.png" alt="image-20230801201803089"></p><ul><li>问题描述<ul><li>桌子上有一只盘子，每次只能向其中放入一个水果</li><li>爸爸专向盘子中放苹果，妈妈专向盘子中放橘子</li><li>儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果</li><li>只有盘子空时，爸爸或妈妈才可向盘子中放一个苹果</li><li>仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出水果</li></ul></li></ul><p><img src="/../image/assets/image-20230801202225186.png" alt="image-20230801202225186"></p><ul><li><p>关系分析</p><ul><li>找出题目中描述的各个进程，分析它们之间的同步、互斥关系<ul><li>互斥关系（mutex&#x3D;1）<ul><li>对缓冲区（盘子）的访问要互斥地进行</li></ul></li><li>同步关系（一前一后）<ul><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果<ul><li>盘子为空这个时间可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</li></ul></li></ul></li></ul></li></ul></li><li><p>整理思路</p><ul><li>根据各进程的操作流程确定 P、V 操作的大致顺序<ul><li>互斥：在临界区前后分别 PV</li><li>同步：前 V 后 P</li></ul></li></ul></li><li><p>设置信号量</p><ul><li>设置需要的信号量，并根据题目条件确定信号量初值<ul><li>互斥信号量初值一般是 1，同步信号量的初始值要看对应资源的初始值是多少</li></ul></li></ul></li><li><p>设置互斥信号量</p></li></ul><p><img src="/../image/assets/image-20230801203941323.png" alt="image-20230801203941323"></p><ul><li>不设置互斥信号量</li></ul><p><img src="/../image/assets/image-20230801204002813.png" alt="image-20230801204002813"></p><ul><li><p>分析</p><ul><li>刚开始，儿子、女儿进程即使上处理机运行也会被阻塞</li><li>如果刚开始是父亲进程先上处理机运行<ul><li>父亲 P(plate)，可以访问盘子</li><li>母亲P(plate)，阻塞等待盘子</li><li>父亲放入苹果（apple）</li><li>女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）</li><li>女儿P(apple)，访问盘子，V(plate)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒</li><li>母亲进程访问盘子（其他进程暂时都无法进入临界区）</li></ul></li></ul></li><li><p>原因</p><ul><li>本题中的缓冲区大小为 1</li><li>在任何时刻，orange、apple、plate 三个同步信号量中最多只有一个是 1</li><li>因此在任何时刻最多只有一个进程的 P 操作不会被阻塞，并顺利地进入临界区</li></ul></li><li><p>如果盘子容量为 2</p></li></ul><p><img src="/../image/assets/image-20230801204514944.png" alt="image-20230801204514944"></p><ul><li>分析<ul><li>父亲 P(plate)，可以访问盘子</li><li>母亲 P(plate)，可以访问盘子</li><li>父亲在往盘子里放苹果，同时母亲也可用往盘子里放橘子<ul><li>可能会放到缓冲区的同一个位置</li></ul></li><li>于是就出现了两个进程同时访问缓冲区的情况</li><li>有可能导致两个进程写入缓冲区的数据相互覆盖的情况</li><li>因此，如果缓冲区大小大于 1，就必须专门设置一个互斥信号量 mutex 来保证互斥访问缓冲区</li></ul></li></ul><p><img src="/../image/assets/image-20230801204919432.png" alt="image-20230801204919432"></p><ul><li>分析同步问题（一前一后问题）<ul><li>要分析什么事件在前，什么事件在后；而不是什么进程在前，什么进程在后</li><li>不能从单个进程行为的角度分析，要把“一前一后”发生的事看作是两种“事件”的前后关系</li></ul></li><li>比如<ul><li>正确<ul><li>盘子变空—&gt;放入水果<ul><li>盘子变空可能是儿子引起的，也可能是女儿引起的</li><li>放水果可能是父亲放的，也可能是母亲放的</li></ul></li></ul></li><li>错误<ul><li>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲和母亲才能再放入水果</li><li>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果</li></ul></li></ul></li></ul><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><ul><li>解决“可以生产多个产品的单生产者”问题</li></ul><p><img src="/../image/assets/image-20230801205452683.png" alt="image-20230801205452683"></p><ul><li>问题描述<ul><li>假设一个系统有三个抽烟者进程和一个供应者进程</li><li>每个抽烟者不停地卷烟并抽掉它</li><li>但是要卷起并抽调一支烟，抽烟者需要三种材料：烟草、纸和胶水</li><li>三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水</li><li>供应者进程无限的提供三种材料，每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽调它，并给供应者一个信号告诉完成了</li><li>供应者就会放另外两种材料在桌子上</li><li>这个过程一直重复（让三个抽烟者轮流地抽烟）</li></ul></li></ul><p><img src="/../image/assets/image-20230801205836629.png" alt="image-20230801205836629"><br><img src="/../image/assets/image-20230801210452556.png" alt="image-20230801210452556"></p><ul><li>问题分析<ul><li>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”问题</li><li>关系分析<ul><li>同步关系<ul><li>桌子上有组合一——第一个抽烟者取走东西</li><li>桌子上有组合二——第二个抽烟者取走东西</li><li>桌子上有组合三——第三个抽烟者取走东西</li><li>发出完成信号——供应者将下一个组合放到桌上<ul><li>PV 操作——前 V后 P</li></ul></li></ul></li></ul></li><li>整理思路</li><li>设置信号量<ul><li>Offer1 &#x3D; 0</li><li>offer2 &#x3D; 0</li><li>offer3 &#x3D; 0</li><li>finish &#x3D; 0</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230801210514949.png" alt="image-20230801210514949"></p><ul><li><p>如何实现</p><ul><li><p>缓冲区大小为 1，同一时刻，四个同步信号量中，至多有一个的值为 1</p><ul><li>所以不需要设置一个专门的互斥信号量</li></ul></li><li><p>设置信号量</p><ul><li>Semaphore offer1 &#x3D; 0&#x2F;&#x2F;桌上组合 1 的数量</li><li>Semaphore offer2 &#x3D; 0    &#x2F;&#x2F;桌上组合 1 的数量</li><li>Semaphore offer3 &#x3D; 0    &#x2F;&#x2F;桌上组合 1 的数量</li><li>Semaphore finish &#x3D; 0     &#x2F;&#x2F;抽烟是否完成</li><li>int i &#x3D; 0                              &#x2F;&#x2F;用于实现三个抽烟者轮流抽烟</li></ul></li><li><p>生产者</p><ul><li><pre><code class="C++">provider()&#123;    while(1)&#123;        if(i == 0)&#123;            将组合一放桌上;            V(offer1);        &#125;else if(i == 1)&#123;            将组合二放桌上;            V(offer2);        &#125;else if(i == 2)&#123;            将组合三放桌上;            V(offer3);        &#125;        i = (i+1)%3;        P(finish);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 消费者</span><br><span class="line"></span><br><span class="line">  - ```C++</span><br><span class="line">    smoker1()&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            P(offer1);</span><br><span class="line">            从桌上拿走组合一；卷烟；抽掉；</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="C++">smoker2()&#123;    while(1)&#123;        P(offer2);        从桌上拿走组合二；卷烟；抽掉；        V(finish);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```C++</span><br><span class="line">  smoker3()&#123;</span><br><span class="line">      while(1)&#123;</span><br><span class="line">          P(offer3);</span><br><span class="line">          从桌上拿走组合三；卷烟；抽掉；</span><br><span class="line">          V(finish);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><h4 id="读者—写者问题"><a href="#读者—写者问题" class="headerlink" title="读者—写者问题"></a>读者—写者问题</h4><ul><li>解决<strong>复杂的互斥问题</strong>提供参考</li><li>核心思想<ul><li>设置一个计数器 count 用来记录当前正在访问共享文件的读进程数</li><li>可以用 count 的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程</li><li>从而做出不同的处理</li></ul></li><li>对 count 变量的检查和赋值不能一气呵成会导致错误<ul><li>所以要用互斥信号量实现一气呵成</li></ul></li><li>用 P(w)解决写进程饥饿问题</li></ul><p><img src="/../image/assets/image-20230801211831597.png" alt="image-20230801211831597"></p><ul><li><p>问题描述</p><ul><li><p>有读者和写者两组并发进程，共享一个文件</p></li><li><p>当两个或两个以上的读进程同时访问共享数据时不会产生副作用</p></li><li><p>但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误</p></li><li><p>因此要求</p><ul><li><p>允许多个读者可以同时对文件执行读操作</p></li><li><p>只允许一个写者往文件中写信息</p></li><li><p>任一写者在完成写操作前不允许其他读者或写者工作</p></li><li><p>写者执行写操作前，应让已有的读者和写者全部退出</p></li></ul></li></ul></li><li><p><strong>多个读者可以同时访问共享数据</strong></p><ul><li>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。</li></ul></li><li><p><strong>读进程与写进程不能同时共享数据</strong>，可能会导致读出的数据不一致</p></li><li><p><strong>两个写进程不能同时共享数据</strong>，可能导致数据错误覆盖的问题</p></li></ul><p><img src="/../image/assets/image-20230801212716552.png" alt="image-20230801212716552"></p><ul><li><p>问题分析</p><ul><li><p>关系分析</p><ul><li>两类进程：写进程、读进程</li><li>互斥关系：写进程—写进程，写进程—读进程<ul><li>写进程与读进程不存在互斥问题</li></ul></li></ul></li><li><p>整理思路</p></li><li><p>设置信号量</p></li></ul></li></ul><p><img src="/../image/assets/image-20230801213150943.png" alt="image-20230801213150943"></p><ul><li><p>如何实现</p><ul><li><p>信号量设置</p><ul><li>rw &#x3D; 1；       &#x2F;&#x2F;用于实现对共享文件的互斥访问</li><li>count &#x3D; 0； &#x2F;&#x2F;记录当前有几个读进程正在访问文件</li><li>mutex&#x3D;1；  &#x2F;&#x2F;用于保证对 count 变量的互斥访问</li></ul></li><li><p>写者</p><ul><li><pre><code class="C++">writer()&#123;    while(1)&#123;        P(rw);          //写之前加锁        写文件....        V(rw);          //写完了解锁    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 读者</span><br><span class="line"></span><br><span class="line">  - ```C++</span><br><span class="line">    reader()&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            P(mutex);       //各读进程互斥访问 count</span><br><span class="line">            if(count == 0)  //由第一个读进程负责</span><br><span class="line">                P(rw);      //读之前“加锁”</span><br><span class="line">            count++;        //访问文件的读进程+1</span><br><span class="line">            V(mutex);</span><br><span class="line">            读文件....</span><br><span class="line">            P(mutex);       //各读进程互斥访问 count</span><br><span class="line">            count--;        //访问文件的读进程数-1</span><br><span class="line">            if(count==0)</span><br><span class="line">                V(rw);      //读完了“解锁”</span><br><span class="line">            V(mutex);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li><li><p>问题</p><ul><li>若两个读进程并发执行，则 count&#x3D;0 时两个进程也许都能满足 if 条件，都会执行 P(rw)，从而使第二个读进程阻塞的情况</li></ul></li><li><p>如何解决</p><ul><li>出现上述问题的原因在于<strong>对 count 变量的检查和赋值无法一气呵成</strong></li><li>因此可以设置另一个互斥信号量来保证各读进程对 count 的访问是互斥的</li></ul></li><li><p>潜在的问题</p><ul><li>只要有读进程还在读，写进程就要一直阻塞等待，可能饿死</li><li>这种算法是读进程优先的</li></ul></li></ul><p><img src="/../image/assets/image-20230801214509666.png" alt="image-20230801214509666"></p><ul><li><p>读写公平法</p><ul><li><p>信号量设置</p><ul><li><pre><code class="C++">semaphore rw = 1;       //用于实现对共享文件的互斥访问int count = 0;          //记录当前有几个读进程在访问文件semaphore mutex = 1;    //用于保证对 count 变量的互斥访问semaphore w = 1;        //用于实现写优先<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 写者</span><br><span class="line"></span><br><span class="line">  - ```C++</span><br><span class="line">    writer()&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            P(w);</span><br><span class="line">            P(rw);          //写之前加锁</span><br><span class="line">            写文件....</span><br><span class="line">            V(rw);          //写完了解锁</span><br><span class="line">            V(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>读者</p><ul><li><pre><code class="C++">reader()&#123;    while(1)&#123;        P(w);        P(mutex);       //各读进程互斥访问 count        if(count == 0)  //由第一个读进程负责            P(rw);      //读之前“加锁”        count++;        //访问文件的读进程+1        V(mutex);        V(w);        读文件....        P(mutex);       //各读进程互斥访问 count        count--;        //访问文件的读进程数-1        if(count==0)            V(rw);      //读完了“解锁”        V(mutex);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 分析以下并发执行 P(w)的情况</span><br><span class="line">  - 读者 1—&gt;读者2</span><br><span class="line">  - 写者 1—&gt; 写者 2</span><br><span class="line">  - 写者 1 —&gt;读者 1</span><br><span class="line">  - 读者 1—&gt; 写者 1 —&gt;读者 2</span><br><span class="line">  - 写者 1 —&gt;读者 1 —&gt;写者 2</span><br><span class="line"></span><br><span class="line">- 在这种算法中，连续进入的多个读者可以同时读文件</span><br><span class="line">- 写者和其他进程不能同时访问文件</span><br><span class="line">- 写者不会饥饿，但也并不是真正的写优先，而是相对公平的先来先服务的原则</span><br><span class="line"></span><br><span class="line">#### 哲学家进餐问题</span><br><span class="line"></span><br><span class="line">- 核心问题是**避免死锁**</span><br><span class="line">  - 进程之间只存在互斥关系</span><br><span class="line">  - 但是与之前接触到的互斥关系不同，每个进程都需要同时持有两个临界资源，因此就有了死锁的隐患</span><br><span class="line">- 遇到一个进程需要同时持有多个临界资源的情况</span><br><span class="line">  - 应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁</span><br><span class="line">- 哲学家就餐问题的三个思路</span><br><span class="line">  - **可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐**</span><br><span class="line">  - **要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反**</span><br><span class="line">  - **仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子**</span><br><span class="line"></span><br><span class="line">![image-20230801220100034](../image/assets/image-20230801220100034.png)</span><br><span class="line"></span><br><span class="line">- 问题描述</span><br><span class="line">  - 一张圆桌上坐着五名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭</span><br><span class="line">  - 哲学家只会思考和进餐</span><br><span class="line">    - 在思考时，不会影响其他人</span><br><span class="line">    - 饥饿的时候，才试图拿起左右两根筷子（一根一根地拿起）</span><br><span class="line">      - 如果筷子已经在别人手上，则需要等待</span><br><span class="line">  - 饥饿的哲学家只有同时拿起两根筷子才可以开始进餐</span><br><span class="line">  - 当进餐完毕后，放下筷子继续思考</span><br><span class="line">- 问题分析</span><br><span class="line">  - 关系分析</span><br><span class="line">    - 系统中有 5 个哲学家进程，5 位哲学家与左右邻居对其中间筷子的访问是互斥关系</span><br><span class="line">  - 整理思路</span><br><span class="line">    - 这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭</span><br><span class="line">    - 如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓</span><br><span class="line">  - 信号量设置</span><br><span class="line">    - Chopstick[5]=&#123;1,1,1,1,1&#125;        //定义互斥信号量数组</span><br><span class="line">    - 对哲学家按 0~4 编号</span><br><span class="line">      - 哲学家左边的筷子编号为 i，右边的筷子编号为(i+1)%5</span><br><span class="line"></span><br><span class="line">![image-20230801221809741](../image/assets/image-20230801221809741.png)</span><br><span class="line"></span><br><span class="line">- 如何实现</span><br><span class="line"></span><br><span class="line">  - 信号量设置</span><br><span class="line"></span><br><span class="line">    - ```C++</span><br><span class="line">      emophore chopstick[5]=&#123;1,1,1,1,1&#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>哲学家</p><ul><li><pre><code class="C++">Pi()&#123;                               //i 号哲学家的进程    while(i)&#123;               P(chopstick[i]);            //拿左        P(chopstick[(i+1)%5]);      //拿右        吃饭....        V(chopstick[i]);            //放左        V(chopstick[(i+1)%5]);      //放右        思考....    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 存在问题</span><br><span class="line">  - 如果 5 个哲学家并发地拿起了自己左手边的筷子</span><br><span class="line">    - 每位哲学家循环等待右边的人放下筷子（阻塞）</span><br><span class="line">    - 发生死锁</span><br><span class="line"></span><br><span class="line">![image-20230801223809887](../image/assets/image-20230801223809887.png)</span><br><span class="line">![image-20230801223831209](../image/assets/image-20230801223831209.png)</span><br><span class="line"></span><br><span class="line">- 如何防止死锁的发生呢？</span><br><span class="line"></span><br><span class="line">  - **可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐**</span><br><span class="line"></span><br><span class="line">    - 这样可以保证至少有一个哲学家可以拿到左右两只筷子</span><br><span class="line"></span><br><span class="line">  - **要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反**</span><br><span class="line"></span><br><span class="line">    - 用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞</span><br><span class="line">    - 这就避免了占有一支后再等待另一支的情况</span><br><span class="line"></span><br><span class="line">  - **仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子**</span><br><span class="line"></span><br><span class="line">    - 信号量设置</span><br><span class="line"></span><br><span class="line">      - ```C++</span><br><span class="line">        semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;</span><br><span class="line">        semaphore mutex = 1;                //互斥地取筷子</span><br></pre></td></tr></table></figure></code></pre></li><li><p>哲学家</p><ul><li><pre><code class="C++">Pi()&#123;                               //i 号哲学家的进程    while(i)&#123;               P(mutex);        P(chopstick[i]);            //拿左        P(chopstick[(i+1)%5]);      //拿右        P(mutex);        吃饭....        V(chopstick[i]);            //放左        V(chopstick[(i+1)%5]);      //放右        思考....    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      ![image-20230801223911677](../image/assets/image-20230801223911677.png)</span><br><span class="line"></span><br><span class="line">    - 存在问题</span><br><span class="line">      </span><br><span class="line">      - 即使某个哲学家两边的筷子都能用，但是却不能吃饭</span><br><span class="line">      - 而且也不能保证只有两边的筷子都可以用的时候才允许哲学家拿起筷子</span><br><span class="line">      </span><br><span class="line">    - 准确说法</span><br><span class="line">      - 各哲学家拿筷子这件事必须互斥地执行</span><br><span class="line">      - 这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子</span><br><span class="line">      - 当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了</span><br><span class="line">      - 所以不会发生死锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 管程</span><br><span class="line"></span><br><span class="line">#### 为什么引入管程？</span><br><span class="line"></span><br><span class="line">- 信号量机制存在的问题</span><br><span class="line">  - 编写程序困难、易出错（死锁）</span><br><span class="line">  - 程序员编写程序时需要关注复杂的 PV 操作</span><br><span class="line">- 管程</span><br><span class="line">  - 一种高级的同步机制</span><br><span class="line">  - 与信号量机制一样，为了实现临界资源的互斥访问</span><br><span class="line"></span><br><span class="line">#### 定义和基本特征</span><br><span class="line"></span><br><span class="line">![image-20230802142942345](../image/assets/image-20230802142942345.png)</span><br><span class="line"></span><br><span class="line">- 管程时一种特殊的软件模块，由这些部分组成（类似于面向对象的类）</span><br><span class="line">  - 局部于管程的**共享数据结构**说明</span><br><span class="line">    - 数据结构（对象）</span><br><span class="line">  - 对该数据结构进行操作的一组过程</span><br><span class="line">    - 类里的函数</span><br><span class="line">  - 对局部于管程的共享数据设置初始值的语句</span><br><span class="line">    - 变量的初始化</span><br><span class="line">  - 管程有一个名字</span><br><span class="line">    - 类名</span><br><span class="line">- 管程的基本特征</span><br><span class="line">  - 局部于管程的数据只能被局部于管程的过程所访问</span><br><span class="line">    - 对象的局部变量只能被对象的函数方法使用</span><br><span class="line">  - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据</span><br><span class="line">    - 进程必须调用对象的函数才能访问局部变量的数据</span><br><span class="line">  - **每次仅允许一个进程在管程内执行某个内部过程**</span><br><span class="line">    - 核心，保证互斥</span><br><span class="line"></span><br><span class="line">#### 拓展 1：用管程解决生产者消费者问题</span><br><span class="line"></span><br><span class="line">![image-20230802144049330](../image/assets/image-20230802144049330.png)</span><br><span class="line"></span><br><span class="line">- 管程定义与实现（伪代码）</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;      //条件变量用来实现同步（排队）</span><br><span class="line">    int count = 0;              //缓冲区中的产品数</span><br><span class="line"></span><br><span class="line">//由编译器负责实现各进程互斥地进入管程中的过程</span><br><span class="line">    void insert(Item item)&#123;     //把产品 item 放入缓冲区</span><br><span class="line">        if(count == N)</span><br><span class="line">            wait(full);</span><br><span class="line">        count ++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        if(count == 1)</span><br><span class="line">            signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    Item remove()&#123;              //从缓冲区取出一个产品</span><br><span class="line">        if(count == 0)</span><br><span class="line">            wait(empty);</span><br><span class="line">        count--;</span><br><span class="line">        if(count == N-1)</span><br><span class="line">            signal(full);</span><br><span class="line">        return remove_item();</span><br><span class="line">    &#125;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li><li><p>生产者进程</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生存者进程</span></span><br><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProducerConsumer.<span class="built_in">insert</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消费者进程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line"><span class="built_in">consumer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        item = ProducerConsumer.<span class="built_in">remove</span>();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每次仅允许一个进程在管程内执行某个内部过程<ul><li>例一：两个生产者进程并发执行，依次调用了 insert 过程<ul><li>一开始没有任何一个进程正在访问这个管程当中的任何一个函数</li><li>所以第一个生产者进程在调用 insert 函数的时候是可以顺利的执行下去的，会顺利地执行完一系列代码</li><li>包括判断缓冲区是否满了，或者是否有一些消费者进程需要唤醒这系列的事情</li><li>如果在第一个进程里面没有执行完 insert 这个函数相应的这一系列逻辑的时候，第二个进程也想调用 insert 函数</li><li>编译器的功能会暂时阻止第二个进程进入 insert 函数</li><li>就会把第二个进程阻塞在 insert 函数后面，类似于一个排队器，让他先等待</li><li>等第一个进程访问完了 insert 函数之后，才会让第二个进程开始进入 insert 函数，然后执行相应的一系列逻辑</li><li>所以互斥的使用某一些共享数据是由编译器负责实现的，程序员写程序的时候不再需要关心如何实现互斥</li><li>只需要直接调用管程提供的一系列方法，管程本身就能够保证这是互斥地进行的</li></ul></li></ul></li><li>管程中设置条件变量和等待&#x2F;唤醒操作以解决同步问题<ul><li>full，empty</li><li>例二：两个消费者进程先执行，生产者进程后执行<ul><li>第一个消费者进程在执行的时候，首先是调用了管程的 remove 过程</li><li>此时判断缓冲区里面是否有可用的产品，由于刚开始 count 的值是 0，所以第一个消费者进程需要执行 wait(empty),等待操作</li><li>于是第一个消费者进程会等待在 empty 这个条件变量相关的这个队列当中</li><li>同样的第二个消费者进程开始执行 remove 函数的时候也会发现此时 count 的值是 0，所以他也需要执行等待操作</li><li>同样第二个消费者进程也会插入到 等待empty这个条件变量的队列队尾</li><li>随后生产者进程会执行管程的 insert 函数，它会把自己生产的产品放入到缓冲区当中</li><li>并且会检查自己放入的这个产品是不是这个缓冲区当中的第一个产品</li><li>如果说是第一个产品，就意味着此时有可能有其他的消费者进程正在等待产品</li><li>所以接下来生产者进程在执行 insert 函数的时候也会执行一个 signal(empty) 唤醒操作</li><li>用于唤醒等待在 empty 这个条件变量对应的等待队列当中的某一个进程，一般是唤醒排在队头的进程，也就是第一个消费者进程</li><li>由于第一个消费者进程被唤醒之后，就可以继续往下执行</li><li>首先执行 count–，让 count 的值由 1 又变回了 0</li><li>然后再在自己结束离开之前，检查缓冲区是不是已经满了</li><li>如果缓冲区之前已经是满了，那么有可能会有生产者进程正在等待，需要被唤醒</li><li>于是生产者就会调用 signal(full)唤醒操作，用于唤醒等待在 full 这个条件变量对应的等待队列当中的某一个进程，一般是唤醒排在队头的进程，也就是第一个生产者进程</li><li>最后 remove_item()函数会返回一个消费者进程想要的产品（指针）</li><li>第一个消费者进程就能这样得到自己想要的 产品</li></ul></li><li>这两个消费者进程如何实现互斥访问？或者当缓冲区中没有产品的时候消费者进程该如何处理？<ul><li>这些都不用消费者进程关心，由管程负责解决</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230802151203262.png" alt="image-20230802151203262"></p><ul><li>总结<ul><li>引入管程的目的无非就是要更方便的实现进程互斥和同步<ul><li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区 full empty）</li><li>需要再管程中定义用于访问这些共享数据的函数<ul><li>如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品</li></ul></li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入<ul><li>如生产者消费者问题中，各进程需要互斥地访问共享缓冲区</li><li>管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区<ul><li>这种互斥特性是由编译器负责实现的，程序员不用担心</li></ul></li><li>可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题<ul><li>可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）</li><li>可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li></ul></li></ul></li></ul></li><li>程序员可以用特殊的语法定义一个管程<ul><li>monitor PeoducerConsuer</li><li>end monitor</li></ul></li><li>其他程序员就可以使用这个管程提供的特定入口方便的使用实现进程互斥&#x2F;同步</li><li>自己理解<ul><li>其实只有两种状态<ul><li>等待、运行</li></ul></li><li>管程同一时间只能被一个进程访问</li><li>有进程可以畅通无阻的直接运行完管程内定义的方法，然后美美的结束自己的运行</li><li>有的进程运行到一半甚至是刚开始就因为资源被占用&#x2F;资源不足然后卡壳了，只能等着，而且不能干巴巴等着，要主动让出自己对管程的使用权<ul><li>如果不让出去那么就会一直等待，必然不可以</li></ul></li><li>管程中的数据只能用管程中自己的方法访问和改变，外界对它没有影响</li><li>如果想在管程中实现互斥，还是需要定义信号量一样的东西</li></ul></li></ul></li></ul><h4 id="拓展-2：java-中类似于管程的问题"><a href="#拓展-2：java-中类似于管程的问题" class="headerlink" title="拓展 2：java 中类似于管程的问题"></a>拓展 2：java 中类似于管程的问题</h4><p><img src="/../image/assets/image-20230802152608461.png" alt="image-20230802152608461"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item buffer[]=<span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Iteam item)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每次只能有一个线程进入 insert 函数，如果有多个线程同时调用 insert 函数，则后来者需要排队等待</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="/../image/assets/image-20230809141202373.png" alt="image-20230809141202373"></p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p><img src="/../image/assets/image-20230809141457114.png" alt="image-20230809141457114"></p><ul><li>哲学家进餐问题中<ul><li>如果五位哲学家进程并发执行，都拿起了左手边的筷子</li><li>每位哲学家都在等待自己右边的人放下筷子，这些哲学家进程都因等待筷子资源而被阻塞，即发生“死锁”</li></ul></li></ul><p><img src="/../image/assets/image-20230809143823330.png" alt="image-20230809143823330"></p><ul><li>死锁<ul><li>发生死锁<ul><li>每个人都占有一个资源，用时又在等待另一个人手里的资源</li></ul></li><li>什么是死锁？<ul><li>在并发环境下，<strong>各进程因竞争资源而造成的一种相互等待对方手里的资源，导致各进程都阻塞，都无法向前推进</strong>的现象</li></ul></li><li>发生死锁后若没有外力干涉，这些进程都将无法向前推进</li></ul></li></ul><h3 id="进程死锁、饥饿、死循环的区别"><a href="#进程死锁、饥饿、死循环的区别" class="headerlink" title="进程死锁、饥饿、死循环的区别"></a>进程死锁、饥饿、死循环的区别</h3><p><img src="/../image/assets/image-20230809151059782.png" alt="image-20230809151059782"></p><ul><li><p>共同点</p><ul><li>都是进程发生了某种异常的状况而无法向下推进的现象(故意设计的死循环除外)</li></ul></li><li><p>死锁</p><ul><li>各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象<ul><li>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong></li><li>发生死锁的进程一定处于阻塞态</li></ul></li></ul></li><li><p>饥饿</p><ul><li>由于长期得不到想要的资源，某进程无法向前推进的现象<ul><li>比如：短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</li><li><strong>可能只有一个进程发生饥饿</strong></li><li>发生饥饿的进程既可能是阻塞态（长期得不到需要的 I&#x2F;O 设备），也可能是就绪态（长期得不到处理机）</li></ul></li></ul></li><li><p>死循环</p><ul><li>某进程执行过程中一直跳不出某个循环的现象<ul><li>有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的</li><li><strong>可能只有一个进程发生死循环</strong><ul><li>死循环的进程<strong>可以上处理机运行（可以是运行态）</strong>，只不过无法像期待的那样顺利推进</li><li>死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的</li><li><strong>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题</strong></li></ul></li></ul></li></ul></li></ul><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p><img src="/../image/assets/image-20230809151628320.png" alt="image-20230809151628320"></p><ul><li>死锁产生的必要条件<ul><li>产生死锁必须同时满足以下四个条件，只有其中任一条件不成立，死锁就不会发生<ul><li>互斥条件<ul><li><strong>只有对必须互斥使用的资源的争抢才会导致死锁</strong><ul><li>如哲学家的筷子、打印机设备</li></ul></li><li>像扬声器、内存这样可以同时让多个进程使用的资源是不会导致死锁的<ul><li>因为进程不用阻塞等待这种资源</li></ul></li></ul></li><li>不剥夺条件<ul><li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li></ul></li><li>请求和保持条件<ul><li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有</li><li>此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul></li><li>循环等待条件<ul><li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul></li></ul></li><li><strong>发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong><ul><li><strong>循环等待是死锁的必要不充分条件</strong></li></ul></li><li>同类资源数  和  循环等待<ul><li>如果同类资源数大于 1，则即使有循环等待，也未必发生死锁。</li><li>但<strong>如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件</strong>了</li></ul></li></ul></li></ul><h3 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h3><p><img src="/../image/assets/image-20230809152533173.png" alt="image-20230809152533173"></p><ul><li>什么时候会发生死锁？<ul><li><strong>对系统资源的竞争</strong><ul><li>各进程对不可剥夺的资源（如打印机）的竞争可能会引起死锁，对可剥夺的资源（CPU）的竞争不会引起死锁</li></ul></li><li><strong>进程递进顺序非法</strong><ul><li>请求和释放资源的顺序不当，也同样会导致死锁</li><li>例如，并发执行的进程 P1、P2 分别申请占有了资源 R1，R2，之后进程 P1 又紧接着申请资源 R2，而进程 P2 又申请资源 R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li></ul></li><li><strong>信号量的使用不当也会造成死锁</strong><ul><li>生产者—消费者问题中，如果实现互斥的 P 操作在实现同步的 P 操作之前，就有可能导致死锁<ul><li>可以把互斥信号量、同步信号量也看做事一种抽象的系统资源</li></ul></li></ul></li></ul></li><li>总之，对不可剥夺资源的不合理分配，可能导致死锁</li></ul><h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><p><img src="/../image/assets/image-20230809153050547.png" alt="image-20230809153050547"></p><ul><li>死锁的处理策略<ul><li>预防死锁<ul><li>破坏死锁产生的四个必要条件中的一个或几个</li></ul></li><li>避免死锁<ul><li>用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li></ul></li><li>死锁的检测和解除<ul><li>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ul></li></ul></li></ul><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><p><img src="/../image/assets/image-20230809153419522.png" alt="image-20230809153419522"></p><ul><li><p>静态策略：预防死锁</p><ul><li>死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁就不会发生</li></ul></li><li><p>动态策略：避免死锁</p></li><li><p>让资源能共享，不互斥</p></li><li><p>请求资源没有</p><ul><li>软弱：把所有之前有的都释放</li><li>强硬：让操作系统把别的抢过来</li></ul></li><li><p>一次性全都满足，后续不能再要了</p></li><li></li></ul><p><img src="/../image/assets/image-20230809153559302.png" alt="image-20230809153559302"></p><ul><li>破坏互斥条件<ul><li>互斥条件<ul><li>只有对必须互斥使用的资源的争抢才会导致死锁</li></ul></li><li>如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁条件<ul><li>比如 SPOOLing 技术，操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备</li><li>比如用 SPOOLing 技术将打印机改造为共享设备<ul><li>进程 1 还没用完打印机之前，进程 2 申请使用打印机会阻塞</li><li>使用了 SPOOLing 技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待</li></ul></li><li>缺点<ul><li>并不是所有的资源都可以改造成可共享使用的资源，并且为了系统安全，很多地方还必须保护这种互斥性</li><li>因此，很多时候无法破坏互斥条件</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230809154124672.png" alt="image-20230809154124672"></p><ul><li>破坏不剥夺条件<ul><li>不剥夺条件<ul><li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li></ul></li><li>方案一<ul><li>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请</li><li>即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</li></ul></li><li>方案二<ul><li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺</li><li>这种方式一般需要考虑各进程的优先级<ul><li>比如，剥夺调度方式：就是将处理机资源强行剥夺给优先级更高的进程使用</li></ul></li></ul></li><li>缺点<ul><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，比如 CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请<ul><li>如果一直发生这样的情况，就会导致进程饥饿</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230809154812454.png" alt="image-20230809154812454"></p><ul><li>破坏请求和保持条件<ul><li>请求和保持条件<ul><li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul></li><li>可以采用静态分配方法<ul><li>即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行</li><li>一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了</li></ul></li><li>缺点<ul><li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低</li><li>可能导致某些进程饥饿</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230809155214311.png" alt="image-20230809155214311"></p><ul><li>破坏循环等待条件<ul><li>循环等待条件<ul><li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul></li><li>可采用顺序资源分配法<ul><li>首先给系统中的资源编号，规定<strong>每个进程必须按编号递增的顺序请求资源</strong></li><li>同类资源（即编号相同的资源）一次申请完</li></ul></li><li>原理分析<ul><li>一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源</li><li>按此规则，已持有大编号资源的进程不可能逆向地回来请求小编号的资源，从而就不会产生循环等待的现象</li></ul></li><li>假设系统中共有 10 个资源，编号为 1,2，……，10<ul><li>在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请后的资源必然畅通无阻</li><li>因此不可能出现所有进程都阻塞的死锁现象</li></ul></li><li>缺点<ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li><strong>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</strong></li><li>必须按照规定次序申请资源，用户编程麻烦</li></ul></li></ul></li></ul><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p><img src="/../image/assets/image-20230809160355446.png" alt="image-20230809160355446"></p><h5 id="什么是安全序列"><a href="#什么是安全序列" class="headerlink" title="什么是安全序列"></a>什么是安全序列</h5><p><img src="/../image/assets/image-20230809160516805.png" alt="image-20230809160516805"></p><p><img src="/../image/assets/image-20230809160717242.png" alt="image-20230809160717242"></p><h5 id="系统的不安全状态与死锁的联系"><a href="#系统的不安全状态与死锁的联系" class="headerlink" title="系统的不安全状态与死锁的联系"></a>系统的不安全状态与死锁的联系</h5><p><img src="/../image/assets/image-20230809161307968.png" alt="image-20230809161307968"></p><ul><li>安全序列、不安全状态、死锁的联系<ul><li>例子<ul><li>前提：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了</li><li>给 B 借 30 亿是不安全的……之后手里只剩 10 亿，如果 BAT 都提出再借 20 亿的请求，那么任何一个企业的需求都得不到满足</li><li>给 A 借 20 亿是安全的，因为存在 T—&gt;B—&gt;A这样的安全序列</li></ul></li><li>安全序列<ul><li>如果系统按照这种序列分配资源，则每个进程都能顺利完成</li><li>只要能找出一个安全序列，系统就是安全状态</li><li>安全序列可能有多个</li></ul></li><li>不安全状态<ul><li>如果分配了资源之后，系统中找不出任何一个安全序列，系统进入了不安全状态</li><li>之后所有进程可能都无法顺利的执行下去</li><li><strong>如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况</li></ul></li><li>死锁<ul><li>如果系统处于安全状态，就一定不会发生死锁</li><li>如果系统进入了不安全状态，就<strong>可能</strong>发生死锁<ul><li>处于不安全状态未必发生死锁，但发生死锁时一定是在不安全状态</li></ul></li></ul></li></ul></li><li><strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求</strong><ul><li>这是银行家算法的核心思想</li></ul></li></ul><h5 id="银行家算法——如何避免系统进入不安全状态"><a href="#银行家算法——如何避免系统进入不安全状态" class="headerlink" title="银行家算法——如何避免系统进入不安全状态"></a>银行家算法——如何避免系统进入不安全状态</h5><p><img src="/../image/assets/image-20230809161611930.png" alt="image-20230809161611930"></p><ul><li>银行家算法<ul><li>核心思想<ul><li>在进程提出资源申请时，先预判此时分配是否会导致系统进入不安全状态</li><li>如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</li></ul></li><li>拓展为多种资源<ul><li>可以把单维的数字拓展为多维的向量<ul><li>比如：系统中有 5 个进程 P0<del>P4，3 种资源 R0</del>R2，初始数量为（10,5,7），则某一时刻的情况可表示如下</li><li>此时总共已分配 (7, 2, 5)，还剩余 (3, 3, 2)</li><li>可把最大需求、已分配的数据看作矩阵， 两矩阵相减，就可算出各进程最多还需要多少资源了</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230809162056099.png" alt="image-20230809162056099"></p><ul><li>此时系统是否处于安全状态？<ul><li>思路：尝试找出一个安全序列…    {P1，P3，P0，P2，P4}<ul><li>依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求</li><li>可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)</li><li>依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求</li><li>可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)</li><li>依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求……</li><li>……</li><li>以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为安全性算法。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。</li></ul></li><li>实际做题时可以更快速的得到安全序列</li></ul></li></ul><p><img src="/../image/assets/image-20230809163221800.png" alt="image-20230809163221800"></p><ul><li>手算<ul><li>实际做题（手算）时可用更快速的方法找到一个安全序列：<ul><li>经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3 一定可以顺利的执行完，并归还资源。 </li><li>可把 P1、P3 先加入安全序列。</li><li>(2, 0, 0) + (2, 1, 1) + (3, 3, 2) &#x3D; (7, 4, 3)</li><li>剩下的 P0、P2、P4 都可被满足。</li><li>同理，这些进程都可以加入安全序列。</li><li>于是，5个进程全部加入安全序列，说明此时系统处于安全状态，暂不可能发生死锁</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230809164612991.png" alt="image-20230809164612991"></p><ul><li>再看一个找不到安全序列的例子： <ul><li>经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的</li><li>因此P1、P3 一定可以顺利的执行完，并归还资源。</li><li>可把 P1、P3 先加入安全序列。</li><li>(2, 0, 0) + (2, 1, 1) + (3, 3, 2) &#x3D; (7, 4, 3)</li><li>剩下的 P0 需要 (8, 4, 3)，P2 需要 (6, 5, 0)，P4 需要 (4, 3, 4)</li><li>任何一个进程都不能被完全满足于是，无法找到任何一个安全序列</li><li>说明此时系统处于不安全状态，有可能发生死锁。</li></ul></li></ul><p><img src="/../image/assets/image-20230809164739227.png" alt="image-20230809164739227"></p><ul><li>银行家算法完整步骤<ul><li>假设系统中有 n 个进程，m 种资源</li><li>每个进程在运行前先声明对各种资源的最大需求数，则可用一个 n*m 的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。</li><li>不妨称为最大需求矩阵 Max，Max[i, j]&#x3D;K 表示进程 Pi 最多需要 K 个资源Rj。</li><li>同理，系统可以用一个 n*m 的分配矩阵 Allocation表示对所有进程的资源分配情况。</li><li>Max – Allocation &#x3D;Need 矩阵，表示各进程最多还需要多少各类资源。</li><li>另外，还要用一个长度为m的一维数组 Available 表示当前系统中还有多少可用资源。</li><li>某进程Pi向系统申请资源，可用一个长度为m的一维 数组 Requesti 表示本次申请的各种资源量。</li><li>可用银行家算法预判本次分配是否会导致系统进入不安全状态：<ul><li>①如果 Requesti[j]≤Need[i, j] (0≤j≤m)便转向②；否则认为出错。 <ul><li>因为它所需要的资源数已超过 它所宣布的最大值。</li></ul></li><li>②如果 Requesti[j]≤Available[j] (0≤j≤m)，便转向③ ；<ul><li>否则表示尚无足够资源，Pi必须等待。</li></ul></li><li>③系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：<ul><li>Available &#x3D; Available - Requesti;<br>Allocation[i, j] &#x3D; Allocation[i, j] + Requesti[j];<br>Need[i, j] &#x3D; Need[i, j] – Requesti[j]</li></ul></li><li>④操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230809165528449.png" alt="image-20230809165528449"></p><ul><li><p>数据结构： </p><ul><li>长度为 m 的一维数组 Available 表示还有多少可用资源</li><li>n*m 矩阵 Max 表示各进程对资源的最大需求数</li><li>n*m 矩阵 Allocation 表示已经给各进程分配了多少资源</li><li>Max – Allocation &#x3D; Need 矩阵表示各进程最多还需要多少资源</li><li>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</li></ul></li><li><p>银行家算法步骤： </p><p>①检查此次申请是否超过了之前声明的最大需求数</p><p>②检查此时系统剩余的可用资源是否还能满足这次请求</p><p>③试探着分配，更改各数据结构</p><p>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p></li><li><p>安全性算法步骤：</p><ul><li>检查当前的剩余可用资源是否能满足某个进程的最大需求</li></ul></li><li><p>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</p><ul><li>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li></ul></li><li><p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</p></li></ul><h4 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h4><p><img src="/../image/assets/image-20230809165844171.png" alt="image-20230809165844171"></p><ul><li>如果系统中几部采取预防死锁的措施，也不采取避免死锁的错书，系统就很可能发生死锁<ul><li>在这种情况下，系统提供了两种算法<ul><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</li></ul></li></ul></li></ul><h5 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h5><p><img src="/../image/assets/image-20230809170125831.png" alt="image-20230809170125831"></p><ul><li>死锁的检测<ul><li>为了能对系统是否已发生了死锁进行检测，必须<ul><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已经进入死锁状态</li></ul></li><li>资源分配图<ul><li>两种节点<ul><li>进程节点：对应一个进程</li><li>资源节点：对应一类资源，一类资源可能有多个</li></ul></li><li>两种边<ul><li>进程节点—&gt;资源节点：请求边<ul><li>表示进程想申请几个资源（每条边代表一个）</li></ul></li><li>资源节点—&gt;进程节点：分配边<ul><li>表示已经为进程分配了几个资源（每条边代表一个）</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230809170155593.png" alt="image-20230809170155593"></p><ul><li>死锁的检测<ul><li>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</li><li>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。</li><li>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</li></ul></li><li>如果按上述过程分析，最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（相当于能找到一个安全序列）</li><li>如果最终不能消除所有边，那么此时就是发生了死锁</li></ul><p><img src="/../image/assets/image-20230809170211715.png" alt="image-20230809170211715"></p><ul><li>检测死锁的算法：<ul><li>1）在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</li><li>2）进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li></ul></li><li>死锁定理<ul><li><strong>如果某时刻系统的资源分配图时不可完全简化的，那么此时系统死锁</strong></li></ul></li></ul><h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><p><img src="/../image/assets/image-20230809170225446.png" alt="image-20230809170225446"></p><ul><li>死锁的解除<ul><li>一旦检测出死锁的发生，就应该立即解除死锁</li><li><strong>不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</strong></li><li>解除死锁的主要方法<ul><li><strong>资源剥夺法</strong><ul><li>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程</li><li>但是应防止被挂起的进程长时间得不到资源而饥饿</li></ul></li><li><strong>撤销进程法</strong><ul><li>或称终止进程法</li><li>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源</li><li>优点是实现简单，缺点是所付出的代价可能会很大。</li><li>有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓是功亏一篑，以后还要从头再来</li></ul></li><li><strong>进程回退法</strong><ul><li>让一个或多个死锁进程回退到足以避免死锁的地步</li><li>要求系统要记录进程的历史信息，设置还原点</li></ul></li></ul></li><li>如何决定“对谁动手”<ul><li>进程优先级</li><li>已执行时间</li><li>还要多久完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;</summary>
      
    
    
    
    <category term="操作系统" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/408/"/>
    
    
    <category term="进程" scheme="https://sdumoist.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="https://sdumoist.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概述</title>
    <link href="https://sdumoist.github.io/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://sdumoist.github.io/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2023-07-26T16:35:26.090Z</published>
    <updated>2024-03-30T19:31:38.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><ul><li>操作系统体系结构<ul><li>分层结构、模块化、外核<ul><li>考简单地选择题，了解各种体系结构的特性，了解各自的优缺点</li></ul></li></ul></li></ul><h3 id="常考内容"><a href="#常考内容" class="headerlink" title="常考内容"></a>常考内容</h3><ul><li><p>允许多个用户以交互的方式使用计算机的操作系统：分时操作系统</p></li><li><p>允许多个用户将若干作业提交给计算机系统集中处理：批处理系统</p></li><li><p>计算机系统能及时处理由过程控制反馈的数据，并及时作出相应：实时操作系统</p></li><li><p>在 IBM-PC 中，操作系统称为：微型计算机操作系统</p></li><li><p>操作系统发展历程中的各个阶段，优点缺点，解决技术方案</p><ul><li><p>手工操作阶段</p><ul><li>缺点<ul><li><strong>不脱机，无操作系统</strong></li><li><strong>单用户独占全机</strong>，不会出现因资源被其他用户用户占用而等待的现象，但资源利用率低</li><li>CPU 等待手工操作，CPU 的利用不充分</li></ul></li><li>解决方法<ul><li>用高速的机器代替相对较慢的手工操作来对作业进行控制</li></ul></li></ul></li><li><p>批处理阶段</p><ul><li><p>解决问题</p><ul><li><p><strong>多用户</strong></p></li><li><p>人机矛盾</p></li><li><p>CPU 及 I&#x2F;O 设备之间不匹配的矛盾</p></li><li><p><strong>实现作业自动控制而无需人工干预</strong></p></li></ul></li><li><p>单道批处理系统</p><ul><li><p>解决方案</p><ul><li><strong>操作系统开始出现</strong></li><li>引入脱机输入输出技术，并由监督程序负责控制作业的输入输出</li></ul></li><li><p>特点</p><ul><li>缓解了一定程度的人机速度矛盾，资源利用率有所提升</li><li><strong>自动性</strong>：在顺利的情况下，磁带上一批作业能自动地逐个运行，而<strong>无需人工干涉</strong></li><li><strong>顺序性</strong>：磁带上的各道作业顺利地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，即<strong>先调入内存的作业先完成</strong></li></ul></li><li><p>缺点</p><ul><li>每次主机内存中仅能存放一道作业，每当它在运行期间（而不是完成后）发出输入输出请求后，高速的 CPU 便处于等待低速 I&#x2F;O 完成的状态</li><li><strong>单道性</strong>：内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行。当该程序完成或发生异常情况时，才换入其后继程序进入内存运行</li><li>CPU 有大量的时间是在空闲等待 I&#x2F;O 完成。资源利用率很低</li></ul></li></ul></li><li><p>多道批处理系统</p><ul><li>目标<ul><li>为了进一步提高资源利用率和系统的吞吐量</li></ul></li><li>技术<ul><li><p><strong>多道程序设计技术</strong></p><ul><li>允许<strong>多个程序</strong>同时进入内存并允许他们在 CPU 中交替地运行，这些程序共享系统中的各种软&#x2F;硬件资源</li></ul></li><li><p>把用户提交的作业成批的送入计算机内存，然后由作业调度程序自动地选择作业运行</p></li><li><p>可以实现系统各部件之间的<strong>并行工作</strong>，使其整体在单位时间内的效率翻倍</p></li></ul></li><li>特点<ul><li><p><strong>多道</strong>：</p><ul><li>计算机内存中同时存放多道相互独立的程序</li></ul></li><li><p><strong>宏观上并行</strong>：</p><ul><li>同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行但都未运行完成</li></ul></li><li><p><strong>微观上串行</strong>：</p><ul><li>内存中的多道程序轮流占有 CPU，交替执行</li></ul></li></ul></li><li>需要解决的问题<ul><li><p>如何分配处理器</p></li><li><p>多道程序的内存分配问题</p></li><li><p>I&#x2F;O 设备如何<strong>分配</strong></p></li><li><p>如何组织和存放大量的程序和数据，以方便用户使用并保证其<strong>安全性和一致性</strong></p></li></ul></li><li>优点<ul><li><p>资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用</p></li><li><p>系统吞吐量大、CPU 和其他资源保持“忙碌”状态</p></li><li><p><strong>多道程序并发执行</strong></p></li></ul></li><li>缺点<ul><li>用户响应时间长</li><li><strong>不提供人机交互</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</li></ul></li></ul></li></ul></li><li><p>分时操作系统</p><ul><li><p>目标</p><ul><li>人机交互</li></ul></li><li><p>技术</p><ul><li>分时技术<ul><li>把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用</li><li>若作业在分配给它的时间片内不能完成计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续执行</li><li>每个用户都感觉自己独占一台计算机：计算机速度很快，作业运行轮转的很快</li></ul></li></ul></li><li><p>需要解决的问题</p><ul><li>如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令</li><li><strong>实现人机交互</strong></li></ul></li><li><p>特点</p><ul><li><p>多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰</p></li><li><p>计算机以<strong>时间片</strong>为单位轮流给各个用户&#x2F;作业服务，各个用户可通过终端与计算机交互</p></li><li><p>同时性：多路性，允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上这些用户可以同时或基本同时使用计算机</p></li><li><p>交互性：用户能够方便的与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互</p></li><li><p>独立性：系统中多个用户可以彼此独立的进行操作，互不干扰，单个用户感受不到别人也在用这台计算机，好像只有自己单独使用这台计算机一样</p></li><li><p>及时性：用户请求能在短时间内获得响应，分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意</p></li></ul></li><li><p>优点</p><ul><li>用户请求可以被及时响应，解决了<strong>人机交互</strong>问题</li><li><strong>允许多个用户同时使用一台计算机</strong>，并且用户对计算机的操作相互独立，感受不到别人的存在</li></ul></li><li><p>缺点</p><ul><li><strong>不能优先处理一些紧急的任务</strong></li><li>操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务紧急性</li></ul></li></ul></li><li><p>实时操作系统</p><ul><li>目标<ul><li>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队</li></ul></li><li>分类<ul><li>硬实时系统<ul><li>某个动作必须在规定的时刻（或规定的时间范围内）发生</li><li>飞行器的飞行自动控制系统</li></ul></li><li>软实时系统<ul><li>能够接受偶尔违反时间规定且不会引起任何永久性的损害</li><li>飞机订票系统、银行管理系统</li></ul></li></ul></li><li>特点<ul><li>及时性</li><li>可靠性</li><li>计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件</li></ul></li><li>优点<ul><li>能够优先处理响应一些紧急任务，某些紧急任务不需要时间片排队</li></ul></li></ul></li></ul></li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230727205624269.png" alt="image-20230727205624269"></p><p><img src="/../image/assets/image-20230727213258016.png" alt="image-20230727213258016"></p><p><img src="/../image/assets/image-20230727221048516.png" alt="image-20230727221048516"></p><p><img src="/../image/assets/image-20230727224814514.png" alt="image-20230727224814514"></p><p><img src="/../image/assets/image-20230728104722790.png" alt="image-20230728104722790"></p><p><img src="/../image/assets/image-20230728214948804.png" alt="image-20230728214948804"></p><p><img src="/../image/assets/image-20230728220812316.png" alt="image-20230728220812316"></p><p><img src="/../image/assets/image-20230729145048319.png" alt="image-20230729145048319"></p><p><img src="/../image/assets/image-20230729151915593.png" alt="image-20230729151915593"></p><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><h3 id="操作系统的概念（定义）"><a href="#操作系统的概念（定义）" class="headerlink" title="操作系统的概念（定义）"></a>操作系统的概念（定义）</h3><h4 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h4><ul><li>操作系统<ul><li>控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配</li><li>以提供给用户和其他软件方便的接口和环境</li><li>它是计算机系统中最基本的系统软件</li></ul></li><li>特征<ul><li>系统资源的管理者</li><li>向上层提供方便易用的服务</li><li>是最接近硬件的一层软件</li></ul></li></ul><p><img src="/../image/assets/image-20230727181956790-0453204.png" alt="image-20230727181956790"></p><h3 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h3><ul><li><p>作为系统资源的管理者</p><ul><li><p>提供的功能</p><ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></li><li><p>目标</p><ul><li>安全、高效</li></ul></li></ul></li><li><p>向上层提供方便易用的服务</p><ul><li><p>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令</p></li><li><p>GUI：图形化用户接口</p></li><li><p>用户接口</p><ul><li>命令接口<ul><li>联机命令接口（交互式命令接口）<ul><li>用户说一句，系统跟着做一句</li></ul></li><li>脱机命令接口（批处理命令接口）<ul><li>*.bat文件</li></ul></li></ul></li><li>程序接口（广义命令）<ul><li>可以在程序中进行系统调用来使用程序接口。</li><li>普通用户不能直接使用程序接口，只能通过程序代码间接使用</li><li>类似于函数调用，是应用程序请求操作系统服务的唯一方式</li><li>例如：printf函数</li></ul></li></ul></li></ul></li><li><p>作为最接近硬件的层次</p><ul><li><p>需要<strong>实现对硬件机器的拓展</strong></p><ul><li>将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能</li></ul></li><li><p>没有任何软件支持的计算机称为裸机</p><ul><li>在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</li></ul></li><li><p>通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong></p></li></ul></li></ul><p><img src="/../image/assets/image-20230727194612239.png" alt="image-20230727194612239"></p><p><img src="/../image/assets/image-20230727194726978.png" alt="image-20230727194726978"></p><p><img src="/../image/assets/image-20230727205428339.png" alt="image-20230727205428339"></p><h4 id="操作系统要做什么"><a href="#操作系统要做什么" class="headerlink" title="操作系统要做什么"></a>操作系统要做什么</h4><ul><li>执行一个程序前，需要将该程序放到内存中</li><li>以QQ为例<ul><li>逐层打开文件夹，找到可执行文件的存放位置</li><li>该程序相关数据放入内存</li><li>对应的进程被处理机（CPU处理）</li><li>将设备分配给进程</li></ul></li></ul><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><ul><li>并发、共享（两个最基本的特征，二者互为存在条件）、虚拟、异步</li></ul><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul><li><p>并发</p><ul><li>两个或多个事件在同一时间间隔内发生</li><li>这些事件<strong>在宏观上是同时发生</strong>的，但<strong>微观上是交替发生</strong>的</li></ul></li><li><p>并行</p><ul><li>两个或多个事件在同一时刻同时发生</li></ul></li><li><p>操作系统的并发性</p><ul><li>计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的</li></ul></li><li><p>操作系统就是伴随着“多道程序技术”而出现的。因此，<strong>操作系统和程序并发是一起诞生的</strong></p></li><li><p>注意：</p><ul><li>单核CPU同一时刻只能执行<strong>一个程序</strong>，多个程序只能<strong>并发</strong>地执行</li><li>多核CPU同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行</li></ul></li><li><p><strong>并发性是操作系统一个最基本的特征</strong></p></li></ul><p><img src="/../image/assets/image-20230727210500273.png" alt="image-20230727210500273"><br><img src="/../image/assets/image-20230727210512729.png" alt="image-20230727210512729"></p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><ul><li><strong>共享</strong>即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</li><li>两种资源共享方式<ul><li>互斥共享方式<ul><li>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong></li><li>例如：使用QQ和微信视频。同一时间段内，摄像头只能分配给其中一个进程</li></ul></li><li>同时共享方式<ul><li>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong></li><li>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</li><li>例如：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230727211218498.png" alt="image-20230727211218498"></p><h4 id="并发和共享的关系"><a href="#并发和共享的关系" class="headerlink" title="并发和共享的关系"></a>并发和共享的关系</h4><ul><li><p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序</p></li><li><p><strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用</p></li><li><p>并发与共享的关系</p><ul><li>使用QQ发送文件A，同时使用微信发送文件B<ul><li>两个进程正在并发执行<strong>（并发性）</strong></li><li>需要共享地访问硬盘资源<strong>（共享性）</strong></li><li>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li><li>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230727211914801.png" alt="image-20230727211914801"></p><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><ul><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物<ul><li>物理实体（前者）是<strong>实际存在</strong>的</li><li>逻辑上的对应物（后者）是<strong>用户感受到</strong>的<ul><li>例子：<strong>空分复用技术</strong>（虚拟存储器技术）、<strong>时分复用技术</strong>（微观上处理剂在各个微小的时间段内交替着为各个进程服务，<strong>虚拟处理器技术</strong>）</li></ul></li></ul></li><li>如果失去并发性，则一个时间段内系统中只能运行一道程序，那么就失去了实现虚拟性的意义<ul><li>没有并发性，就谈不上虚拟性</li></ul></li></ul><p><img src="/../image/assets/image-20230727212532037.png" alt="image-20230727212532037"><br><img src="/../image/assets/image-20230727212557686.png" alt="image-20230727212557686"><br><img src="/../image/assets/image-20230727212616772.png" alt="image-20230727212616772"></p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>异步<ul><li>在多道程序环境下，允许多个程序并行执行</li><li>但由于资源有限，进程的执行并不是一贯到底的，而是走走停停，以不可预知的速度向前推进</li></ul></li><li>并发运行的程序会争抢着使用系统资源，而<strong>系统中的资源有限</strong>，因此进程的执行不是一贯到底的，有时候阻塞，有时候运行</li><li>如果失去并发性，系统只能串行地运行各个程序，那么所有程序的执行会一贯到底</li><li><strong>只有系统拥有并发性，才有可能导致异步性</strong></li></ul><p><img src="/../image/assets/image-20230727213214733.png" alt="image-20230727213214733"></p><h2 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h2><ul><li>重点：各类操作系统主要想<strong>解决的是什么问题</strong>，各自的<strong>优缺点</strong></li></ul><p><img src="/../image/assets/image-20230727213615844.png" alt="image-20230727213615844"></p><h3 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h3><h4 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h4><ul><li>速度<ul><li>超慢</li></ul></li><li>设备<ul><li>纸带机，输入输出速度慢</li></ul></li><li>流程<ul><li>程序员将程序打在纸带机上，再将纸带机插入计算机运行计算</li></ul></li><li>主要缺点<ul><li>用户独占全机</li><li>人机速度矛盾导致资源利用率极低</li></ul></li></ul><p><img src="/../image/assets/image-20230727213953398.png" alt="image-20230727213953398"></p><h4 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h4><ul><li>非剥夺调度方式<ul><li>只允许进程主动放弃处理机</li><li>无法及时处理紧急任务<ul><li>如 FCFS 先来先服务、SJF 最短作业优先、HRRN 最高响应比优先算法</li></ul></li></ul></li></ul><h5 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h5><ul><li><p>速度</p><ul><li>磁带的读&#x2F;写速度比纸带机快很多</li></ul></li><li><p>设备</p><ul><li>磁带、外围机</li><li>通过外围机把程序提前存到磁带里</li></ul></li><li><p>流程</p><ul><li><p>引入<strong>脱机输入&#x2F;输出技术</strong>（用外围机+磁带完成）</p></li><li><p>由<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出</p></li></ul></li><li><p>主要缺点</p><ul><li><strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序</li><li><strong>CPU有大量的时间是在空闲，等待 I&#x2F;O 完成</strong></li><li>资源利用率依然很低</li></ul></li></ul><p><img src="/../image/assets/image-20230727214312524.png" alt="image-20230727214312524"></p><p><img src="/../image/assets/image-20230727214403246.png" alt="image-20230727214403246"></p><h5 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h5><ul><li><p>特点</p><ul><li>多道程序设计技术</li><li>每次往内存中读入多道程序，允许多个程序同时进入内存并允许它们在 CPU 中交替地运行，这些程序共享系统中的各种软&#x2F;硬件资源</li><li>操作系统正式诞生，用于支持多道程序并发运行</li></ul></li><li><p>主要优点</p><ul><li>多道程序<strong>并发执行</strong>，<strong>共享</strong>计算机资源</li><li><strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大</li></ul></li><li><p>主要缺点</p><ul><li>用户响应时间长</li><li><strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</li><li>eg：无法调适程序&#x2F;无法再程序运行过程中输入一些参数</li></ul></li></ul><p><img src="/../image/assets/image-20230727214903409.png" alt="image-20230727214903409"></p><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><ul><li><p>剥夺调度方式</p><ul><li>当一个进程正在处理机上执行时，如果有一个更重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程</li><li>如时间片轮转算法（RR，Round-Robin）</li></ul></li><li><p>计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可通过终端与计算机进行交互</p></li><li><p>主要优点</p><ul><li>用户请求可以被即时响应，<strong>解决了人机交互问题</strong></li><li>允许多个用户同时使用一台计算机</li><li>用户对操作系统的操作相互独立，感受不到别人的存在</li></ul></li><li><p>主要缺点</p><ul><li><strong>不能优先处理一些紧急任务</strong></li><li>操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片，不区分任务的紧急性</li></ul></li></ul><p><img src="/../image/assets/image-20230727215346475.png" alt="image-20230727215346475"></p><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><ul><li><p>主要优点</p><ul><li>能够优先响应一些紧急任务，某些紧急任务不需时间片排队</li></ul></li><li><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong></p></li><li><p>主要特点</p><ul><li>及时性、可靠性</li></ul></li><li><p>实时操作系统</p><ul><li>硬实时系统<ul><li>必须在绝对严格的规定时间内完成处理</li><li>eg：导弹控制系统，自动驾驶系统</li></ul></li><li>软实时系统<ul><li>能接受偶尔违反时间规定</li><li>eg：12306火车订票系统</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230727220145586.png" alt="image-20230727220145586"></p><h4 id="网络操作系统和分布式操作系统"><a href="#网络操作系统和分布式操作系统" class="headerlink" title="网络操作系统和分布式操作系统"></a>网络操作系统和分布式操作系统</h4><ul><li>网络操作系统<ul><li>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能</li><li><strong>实现网络中各种资源等共享（如文件共享）和各台计算机之间的通信</strong></li><li>eg：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用</li></ul></li><li>分布式操作系统<ul><li>主要特点<ul><li><strong>分布式和并行性</strong></li></ul></li><li>系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong></li></ul></li></ul><h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><ul><li>个人计算机操作系统<ul><li>Windows、MaxOS 方便个人使用</li></ul></li></ul><h2 id="操作系统运行机制"><a href="#操作系统运行机制" class="headerlink" title="操作系统运行机制"></a>操作系统运行机制</h2><p><img src="/../image/assets/image-20230727222546577.png" alt="image-20230727222546577"></p><ul><li>程序的运行机制<ul><li>C语言代码  通过编译器的“翻译”  会变成计算机能看懂的二进制机器指令<ul><li>一条高级语言的代码翻译过来可能会对应多条机器指令</li></ul></li><li>程序执行的过程就是CPU执行一条一条的机器指令的过程</li><li><strong>在CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU执行一条指令前就能判断出其类型</li></ul></li><li>“指令”是处理器CPU能识别、执行的最基本命令</li><li>CPU能判断出指令类型，但它怎么区分此时正在运行的是内核程序 or 应用程序？<ul><li>CPU有两种状态，<strong>“内核态”和“用户态”</strong></li><li>处于内核态时，说明此时<strong>正在运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong></li><li>处于用户态时，说明此时<strong>正在运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong><ul><li>CPU中有一个寄存器叫 程序状态字寄存器（PSW），其中有个二进制位</li><li>1 表示“内核态”</li><li>0 表示”用户态“</li></ul></li></ul></li><li>切换状态<ul><li>刚开机时，CPU为“内核态”，操作系统先上CPU运行</li><li>开机完成后，用户可以启动某个应用程序</li><li>操作系统内核程序会在合适的时候主动让出CPU，让该应用程序上CPU运行<ul><li>操作系统内核在让出CPU之前，会<strong>用一条特权指令把PSW的标志位设置为用户态</strong></li></ul></li><li>应用程序运行在用户态</li><li>假如：此时一个黑客在应用程序中植入了一条特殊指令，企图破坏系统</li><li>CPU发现接下来要执行的这条指令时特权指令，但是自己又处于“用户态”</li><li>这个非法事件会引发一个<strong>中断信号</strong><ul><li><strong>CPU监测到中断信号后</strong>，会立即<strong>变为“核心态”</strong>，并停止运行当前的应用程序，转而运行处理终端信号的内核程序</li></ul></li><li>“中断”使操作系统再次夺回CPU的控制权</li><li>操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</li></ul></li><li>如何切换<ul><li><strong>内核态-&gt;用户态</strong><ul><li>执行一条<strong>特权指令——修改PSW的标志位为“用户态”</strong>，这个动作意味着操作系统将主动让出CPU使用权</li></ul></li><li><strong>用户态-&gt;内核态</strong><ul><li>由<strong>“中断”</strong>引发，硬件<strong>自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回CPU的使用权<ul><li>除了非法使用特权指令之外，还有很多事件会触发中断信号</li><li>一个共性：<strong>但凡需要操作系统介入的地方，都会触发中断信号</strong></li></ul></li></ul></li></ul></li></ul><h3 id="CPU-指令级别（后面的知识）"><a href="#CPU-指令级别（后面的知识）" class="headerlink" title="CPU 指令级别（后面的知识）"></a>CPU 指令级别（后面的知识）</h3><p><img src="/../image/assets/image-20230729152312954.png" alt="image-20230729152312954"></p><ul><li>支持虚拟化的 CPU 通常分更多指令等级<ul><li>Ring 0 ~ Ring 3，数字越大权限越低</li></ul></li></ul><h3 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h3><p><img src="/../image/assets/image-20230727222608201.png" alt="image-20230727222608201"></p><h4 id="内核程序"><a href="#内核程序" class="headerlink" title="内核程序"></a>内核程序</h4><ul><li>负责实现操作系统的“内核程序”</li><li>由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“内核（kernel）”</li><li>内核是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong><ul><li>一个操作系统甚至只要有内核就够了</li><li>eg：Docker -&gt;仅需Linux内核</li></ul></li><li>操作系统的功能未必都在内核中，如图形化用户界面GUI</li><li>操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”<ul><li>如：内存清零指令</li><li>这些指令影响重大，只允许“管理者”——即操作系统内核来使用</li></ul></li></ul><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><ul><li><p>普通程序员写的程序</p></li><li><p>应用程序只能使用“非特权指令”</p><ul><li>如：加法指令、减法指令等</li></ul></li></ul><h3 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h3><ul><li><p>程序执行的过程就是CPU执行一条一条的机器指令的过程</p></li><li><p><strong>在CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU执行一条指令前就能判断出其类型</p></li></ul><p><img src="/../image/assets/image-20230727222626838.png" alt="image-20230727222626838"></p><h4 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h4><ul><li>操作系统内核程序才能够发出特权指令</li><li>操作系统可以发出特权指令把PSW的标志位设置为用户态，让CPU处于“用户态”</li></ul><h4 id="非特权指令"><a href="#非特权指令" class="headerlink" title="非特权指令"></a>非特权指令</h4><ul><li>应用程序只能发出非特权指令<ul><li>加法指令、乘法指令等</li></ul></li></ul><h3 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h3><p>CPU能判断出指令类型，但它怎么区分此时正在运行的是内核程序 or 应用程序？</p><ul><li><p>CPU有两种状态，<strong>“内核态”和“用户态”</strong></p></li><li><p>处于内核态时，说明此时<strong>正在运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong></p></li><li><p>处于用户态时，说明此时<strong>正在运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></p><ul><li>CPU中有一个寄存器叫 程序状态字寄存器（PSW），其中有个二进制位</li><li>1 表示“内核态”</li><li>0 表示”用户态“</li></ul></li><li><p>切换状态</p><ul><li>刚开机时，CPU为“内核态”，操作系统先上CPU运行</li><li>开机完成后，用户可以启动某个应用程序</li><li>操作系统内核程序会在合适的时候主动让出CPU，让该应用程序上CPU运行<ul><li>操作系统内核在让出CPU之前，会<strong>用一条特权指令把PSW的标志位设置为用户态</strong></li></ul></li><li>应用程序运行在用户态</li><li>假如：此时一个黑客在应用程序中植入了一条特殊指令，企图破坏系统</li><li>CPU发现接下来要执行的这条指令时特权指令，但是自己又处于“用户态”</li><li>这个非法事件会引发一个<strong>中断信号</strong><ul><li><strong>CPU监测到中断信号后</strong>，会立即<strong>变为“核心态”</strong>，并停止运行当前的应用程序，转而运行处理终端信号的内核程序</li></ul></li><li>“中断”使操作系统再次夺回CPU的控制权</li><li>操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</li></ul></li><li><p>如何切换</p><ul><li><strong>内核态-&gt;用户态</strong><ul><li>执行一条<strong>特权指令——修改PSW的标志位为“用户态”</strong>，这个动作意味着操作系统将主动让出CPU使用权</li></ul></li><li><strong>用户态-&gt;内核态</strong><ul><li>由<strong>“中断”</strong>引发，硬件<strong>自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回CPU的使用权<ul><li>除了非法使用特权指令之外，还有很多事件会触发中断信号</li><li>一个共性：<strong>但凡需要操作系统介入的地方，都会触发中断信号</strong></li></ul></li></ul></li></ul></li></ul><h4 id="内核态（核心态、管态）"><a href="#内核态（核心态、管态）" class="headerlink" title="内核态（核心态、管态）"></a>内核态（核心态、管态）</h4><ul><li>处于内核态时，说明此时<strong>正在运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong></li><li>PSW &#x3D; 1</li></ul><h4 id="用户态（目态）"><a href="#用户态（目态）" class="headerlink" title="用户态（目态）"></a>用户态（目态）</h4><ul><li>处于用户态时，说明此时<strong>正在运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong></li><li>PSW &#x3D; 0</li></ul><p><img src="/../image/assets/image-20230727223252424.png" alt="image-20230727223252424"></p><p><img src="/../image/assets/image-20230727224542848.png" alt="image-20230727224542848"></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h4><ul><li><p>作用</p><ul><li>使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li></ul></li><li><p>CPU上会运行两种程序</p><ul><li>操作系统内核程序——整个系统的管理者</li><li>应用程序</li></ul></li><li><p>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序</p></li><li><p>“中断”是<strong>让操作系统内核夺回CPU使用权的唯一途径</strong></p><ul><li>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序</li><li>没有中断，也就没有操作系统的并发，没有操作系统</li></ul></li><li><p>状态转化</p><ul><li>内核态-&gt;用户态：执行一条<strong>特权指令——修改PSW</strong>的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</li><li>用户态-&gt;内核态：由<strong>中断</strong>引发，<strong>硬件自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回 CPU 的使用权<ul><li>可以通过<strong>陷入指令</strong>引发内部中断信号</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230728101905385.png" alt="image-20230728101905385"></p><h4 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h4><ul><li>异常<ul><li>内中断、例外</li><li>分类<ul><li>陷阱、陷入<ul><li>由陷入指令引起，是应用程序故意引发的</li></ul></li><li>故障<ul><li>由错误条件引起，可能被内核程序修复</li><li>内核程序修复故障后会把 CPU 使用权还给应用程序，让它继续执行下去</li><li>如：缺页故障</li></ul></li><li>终止<ul><li>由致命错误引起，内核程序无法修复该错误</li><li>因此一般不再将 CPU 使用权还给引发终止的应用程序，而是直接终止该应用程序</li><li>如：整数除 0、非法使用特权指令</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230728103536281.png" alt="image-20230728103536281"></p><h5 id="内中断（异常）"><a href="#内中断（异常）" class="headerlink" title="内中断（异常）"></a>内中断（异常）</h5><ul><li><p>与当前执行的指令有关</p></li><li><p>中断信号来源于 CPU 内部</p></li><li><p>触发事件</p><ul><li>当前执行的指令是非法的</li></ul></li><li><p>例子</p><ul><li>试图在用户态下执行特权指令</li><li>执行除法指令时发现除数为 0</li><li>应用系统想请求操作系统内核的服务，此时会执行一条<strong>特殊的指令——陷入指令</strong>，该指令会引发一个内部中断信号<ul><li>执行陷入指令，意味着应用程序主动地将 CPU 控制权还给操作系统内核</li><li>系统调用就是通过陷入指令完成的</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230728103442604.png" alt="image-20230728103442604"><br><img src="/../image/assets/image-20230728103456045.png" alt="image-20230728103456045"></p><h5 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h5><ul><li><p>与当前执行的指令无关</p></li><li><p>中断信号来源于 CPU 外部</p></li><li><p>例子</p><ul><li><p>时钟中断</p><ul><li>时钟部件每隔一个时间片（如 50ms）会给 CPU 发送一个时钟中断信号</li><li>CPU 从用户态切换回内核态，执行处理时钟中断的内核程序</li><li>操作系统内核决定接下来让另一个应用程序上 CPU 运行</li></ul></li><li><p>I&#x2F;O 中断</p><ul><li>由输入&#x2F;输出设备发来的中断信号</li><li>当输入输出任务完成时，向 CPU 发送中断信号</li><li>CPU 从用户态切回内核态，执行处理 I&#x2F;O中断的内核程序</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230728103042833.png" alt="image-20230728103042833"></p><h4 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a>中断机制的基本原理</h4><ul><li><p>检查中断信号</p><ul><li>内中断：<strong>CPU 在执行指令时会检查是否有异常发生</strong></li><li>外中断：<strong>每个指令周期末尾，CPU 都会检查是否有外中断信号需要处理</strong></li></ul></li><li><p>找到相应的中断处理程序</p><ul><li><p>不同的中断信号，需要不同的中断处理程序来处理</p></li><li><p>当 CPU 检测到中断信号后，会根据中断信号的类型去查询“中断向量表”</p></li><li><p>以此来找到相应的中断处理程序在内存中的存放位置</p></li></ul></li><li><p>显然，中断处理程序一定是内核程序，需要运行在“内核态”</p></li></ul><p><img src="/../image/assets/image-20230728104432091.png" alt="image-20230728104432091"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h4><ul><li><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的接口。</p><ul><li>命令接口：联机命令接口、脱机命令接口</li><li>程序接口：一组<strong>程序调用</strong>组成</li></ul></li><li><p>系统调用时操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口</p><ul><li>一种可供应用程序调用的特殊函数</li><li><strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></li></ul></li></ul><p><img src="/../image/assets/image-20230728132745137.png" alt="image-20230728132745137"></p><h4 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h4><ul><li>裸机</li><li>操作系统：向上提供系统调用，使得上层程序能请求内核的服务</li><li>编程语言：向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便</li><li>普通应用程序：可直接进行系统调用，也可以使用库函数<ul><li>有些库函数涉及系统调用，有些不涉及<ul><li>不涉及：取绝对值的函数</li><li>涉及：创建文件的函数</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230728151454450.png" alt="image-20230728151454450"></p><h4 id="系统调用的必要性"><a href="#系统调用的必要性" class="headerlink" title="系统调用的必要性"></a>系统调用的必要性</h4><ul><li>两个进程并发执行，如果都共用统一计算机资源，可能会导致错误<ul><li>解决方法<ul><li>由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”</li><li>用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求</li><li>内核会对各个请求进行协调处理</li></ul></li></ul></li></ul><h4 id="什么功能需要系统调用实现"><a href="#什么功能需要系统调用实现" class="headerlink" title="什么功能需要系统调用实现"></a>什么功能需要系统调用实现</h4><p><img src="/../image/assets/image-20230728181853672.png" alt="image-20230728181853672"></p><ul><li><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务</p><ul><li><p>系统中的各种共享资源都由操作系统内核统一掌控</p></li><li><p><strong>凡是与共享资源有关的操作——存储分配、I&#x2F;O操作、文件管理，都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成</p></li><li><p>可以<strong>保证系统的稳定性和安全性</strong>，防止用户进行非法操作</p></li></ul></li><li><p>系统调用（按功能分类）</p><ul><li><p>设备管理</p><ul><li>完成设备的 请求&#x2F;释放&#x2F;启动等功能</li></ul></li><li><p>文件管理</p><ul><li>完成文件的 读&#x2F;写&#x2F;创建&#x2F;删除 等功能</li></ul></li><li><p>进程控制</p><ul><li>完成进程的 创建&#x2F;销毁&#x2F;阻塞&#x2F;删除&#x2F;唤醒 等功能</li></ul></li><li><p>进程通信</p><ul><li>完成进程之间的 消息传递&#x2F;信号传递 等功能</li></ul></li><li><p>内存管理</p><ul><li>完成内存的 分配&#x2F;回收 等功能</li></ul></li></ul></li></ul><h4 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h4><ul><li><p><strong>陷入指令</strong>是在<strong>用户态</strong>执行的，执行陷入指令之后立即引发一个<strong>内中断</strong>，使 CPU <strong>进入核心态</strong></p></li><li><p><strong>发出系统调用请求是在用户态，对系统调用的相应处理是在核心态下进行</strong></p></li><li><p>应用程序调用</p><ul><li>应用程序需要请求系统调用的时候，会执行“陷入指令”制造中断</li><li>CPU收到 由陷入指令造成的中断信号 从用户态转到内核态，并且转入<strong>相应的中断处理程序</strong> ——系统调用的入口程序</li><li>系统调用入口程序会根据寄存器中的参数判断用户需要哪种系统调用服务</li><li>然后进行相应系统调用服务</li></ul></li><li><p>高级语言代码调用</p><ul><li>代码中 调用库函数（该库函数内部封装了系统调用的复杂细节）</li><li>编译成机器语言指令（运行在用户态）<ul><li><p>前期处理相关指令</p></li><li><p>传参指令（将系统调用需要的参数放到某些通用寄存器中）</p></li><li><p>陷入指令（trap 指令&#x2F;访管指令）</p><ul><li>运行在核心态</li><li>处理系统调用的内核程序</li></ul></li><li><p>后续处理相关指令</p></li></ul></li></ul></li><li><p>流程</p><ul><li>传递系统调用参数</li><li>执行陷入指令（用户态）</li><li>执行相应的内请求核程序处理系统调用（核心态）</li><li>返回应用程序</li></ul></li></ul><p><img src="/../image/assets/image-20230728194253125.png" alt="image-20230728194253125"></p><p><img src="/../image/assets/image-20230728214121295.png" alt="image-20230728214121295"></p><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p><img src="/../image/assets/image-20230728221454653.png" alt="image-20230728221454653"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>宏内核<ul><li>特性、思想<ul><li>所有系统功能都放在内核里（大内核结构的 OS 通常也采用了模块化的设计思想）</li></ul></li><li>优点<ul><li>性能高，内核内部各种功能都可以直接相互调用</li></ul></li><li>缺点<ul><li>内核庞大功能复杂，难以维护</li><li>大内核中某个功能模块出错，就可能导致整个系统大崩溃</li></ul></li></ul></li><li>微内核<ul><li>特性、思想<ul><li>只把中断、原语、进程通信等最核心的功能放入内核</li><li>进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</li></ul></li><li>优点<ul><li>内核小功能少，易于维护，内核可靠性高</li><li>内核外的某个功能模块出错不会导致整个系统崩溃</li></ul></li></ul></li><li>分层结构<ul><li>特性、思想<ul><li>内核分多层，每一层可单向调用更低一层提供的接口</li></ul></li><li>优点<ul><li>便于调试和验证，自底向上逐层调试验证</li><li>易扩充和易维护，各层之间调用接口清晰固定</li></ul></li><li>缺点<ul><li>仅可调用相邻低层，难以合理定义各层的便捷</li><li>效率低，不可跨层调用，系统调用执行时间长</li></ul></li></ul></li><li>模块化<ul><li>特性、思想<ul><li>将内核划分为多个模块，各模块之间相互协作</li><li>内核 &#x3D; 主模块 + 可加载内核模块</li><li>主模块：只负责核心功能，如进程调度、内存管理</li><li>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核</li></ul></li><li>优点<ul><li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发</li><li>支持动态加载新的内存模块：如安装设备驱动程序、安装新的文件系统模块到内核，增强 OS 适应性</li><li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高</li></ul></li><li>缺点<ul><li>模块间的接口定义未必合理、实用</li><li>模块间相互依赖，更难调试和验证</li></ul></li></ul></li><li>外核<ul><li>特性、思想<ul><li>内核负责进程调度、进程通信等功能</li><li>外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全</li></ul></li><li>优点<ul><li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源</li><li>减少了虚拟硬件资源的“映射层”，提升效率</li></ul></li><li>缺点<ul><li>降低了系统的一致性</li><li>使系统变得更复杂</li></ul></li></ul></li></ul><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><ul><li><p><strong>内核是操作系统最基本最核心的部分</strong></p></li><li><p>实现操作系统内核功能的那些程序就是内核程序</p></li><li><p>操作系统</p><ul><li>内核功能：<ul><li>进程管理、存储器管理、设备管理：<strong>对系统资源进行管理的功能</strong><ul><li>更多的是对数据结构的操作，不会直接涉及到硬件</li></ul></li><li>时钟管理、中断处理、原语（设备驱动、CPU 切换）：<strong>与硬件关联较为紧密的模块</strong><ul><li>时钟管理：利用时钟中断实现<strong>计时功能</strong></li><li>中断处理：负责实现中断机制</li><li>原语<ul><li>是一种特殊的程序</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>具有原子性——运行必须一气呵成，不可被“中断”</li><li>运行时间较短、调用频繁</li></ul></li></ul></li></ul></li><li>非内核功能<ul><li>GUI</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230728215222933.png" alt="image-20230728215222933"></p><p><img src="/../image/assets/image-20230728220242332.png" alt="image-20230728220242332"></p><h4 id="大内核（宏内核-单内核）"><a href="#大内核（宏内核-单内核）" class="headerlink" title="大内核（宏内核&#x2F;单内核）"></a>大内核（宏内核&#x2F;单内核）</h4><p><img src="/../image/assets/image-20230728220931516.png" alt="image-20230728220931516"></p><ul><li>大内核<ul><li>功能<ul><li>进程管理、存储器管理、设备管理等功能</li><li>时钟处理、中断处理、原语等功能</li></ul></li><li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点<ul><li>高性能，需要 CPU 状态转换的次数较少</li></ul></li><li>缺点<ul><li>内核代码庞大，结构混乱，难以维护</li></ul></li><li>典型的大内核操作系统：Linux、UNIX</li></ul></li><li>微内核中<ul><li>只有 时钟处理、中断处理、原语等功能</li><li>优点<ul><li>内核功能少，结构清晰，方便维护</li></ul></li><li>缺点<ul><li>需要频繁地在核心态和用户态之间切换，性能低</li></ul></li><li>典型的微内核操作系统：Windows NT</li></ul></li><li>变态的过程是有成本的，要消耗不少时间，频繁的变态会降低系统性能</li></ul><p><img src="/../image/assets/image-20230728220324009.png" alt="image-20230728220324009"></p><p><img src="/../image/assets/image-20230728220613336.png" alt="image-20230728220613336"></p><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>宏内核<ul><li>特性、思想<ul><li>所有系统功能都放在内核里（大内核结构的 OS 通常也采用了模块化的设计思想）</li></ul></li><li>优点<ul><li>性能高，内核内部各种功能都可以直接相互调用</li></ul></li><li>缺点<ul><li>内核庞大功能复杂，难以维护</li><li>大内核中某个功能模块出错，就可能导致整个系统大崩溃</li></ul></li></ul></li><li>微内核<ul><li>特性、思想<ul><li>只把中断、原语、进程通信等最核心的功能放入内核</li><li>进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</li></ul></li><li>优点<ul><li>内核小功能少，易于维护，内核可靠性高</li><li>内核外的某个功能模块出错不会导致整个系统崩溃</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230728220328461.png" alt="image-20230728220328461"></p><p><img src="/../image/assets/image-20230728220609877.png" alt="image-20230728220609877"></p><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><ul><li>考点：考察简单的选择题，了解各种体系结构的特性，了解各自的优缺点</li></ul><p><img src="/../image/assets/image-20230728223935276.png" alt="image-20230728223935276"></p><ul><li><p>最底层是硬件，最高层是用户接口</p></li><li><p>每层可调用更低一层</p></li><li><p>特性、思想</p><ul><li>内核分多层，每一层可单向调用更低一层提供的接口</li></ul></li><li><p>优点</p><ul><li>便于调试和验证，自底向上逐层调试验证</li><li>易扩充和易维护，各层之间调用接口清晰固定</li></ul></li><li><p>缺点</p><ul><li>仅可调用相邻低层，难以合理定义各层的便捷<ul><li>进程管理有时候会调用内存管理</li><li>内存管理有时候也会调用 进程管理</li></ul></li><li>效率低，不可跨层调用，系统调用执行时间长<ul><li>最高层要想调用最底层，需要层层调用</li></ul></li></ul></li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><img src="/../image/assets/image-20230728224534267.png" alt="image-20230728224534267"></p><ul><li>特性、思想<ul><li>将内核划分为多个模块，各模块之间相互协作</li><li>内核 &#x3D; 主模块 + 可加载内核模块</li><li>主模块：只负责核心功能，如进程调度、内存管理</li><li>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核</li></ul></li><li>优点<ul><li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发</li><li>支持动态加载新的内存模块：如安装设备驱动程序、安装新的文件系统模块到内核，增强 OS 适应性</li><li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高</li></ul></li><li>缺点<ul><li>模块间的接口定义未必合理、实用</li><li>模块间相互依赖，更难调试和验证</li></ul></li></ul><h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a>外核</h3><p><img src="/../image/assets/image-20230728224925218.png" alt="image-20230728224925218"></p><ul><li>特性、思想<ul><li>内核负责进程调度、进程通信等功能</li><li>外核负责为用户进程分配<strong>未经抽象的硬件资源</strong>（连续的内存和外存存储空间），且由外核负责保证资源使用安全</li></ul></li><li>优点<ul><li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源</li><li>减少了虚拟硬件资源的“映射层”，提升效率</li></ul></li><li>缺点<ul><li>降低了系统的一致性<ul><li>情况增加：有些连续、有些不连续</li></ul></li><li>使系统变得更复杂</li></ul></li></ul><h2 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>操作系统引导<ul><li>开机的时候，怎么让操作系统运行起来</li></ul></li></ul><h4 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h4><ul><li>一个空磁盘</li></ul><p><img src="/../image/assets/image-20230729132243520.png" alt="image-20230729132243520"></p><ul><li>安装操作系统之后</li></ul><p><img src="/../image/assets/image-20230729132256455.png" alt="image-20230729132256455"></p><ul><li>磁盘<ul><li>主引导记录（MBR）<ul><li>包含 磁盘引导程序和分区表</li></ul></li><li>C盘<ul><li>是这个磁盘的<strong>活动分区</strong>，安装了操作系统</li></ul></li><li>D、E、F 盘</li></ul></li></ul><p><img src="/../image/assets/image-20230729132358526.png" alt="image-20230729132358526"></p><ul><li>C盘内容<ul><li>引导记录 PBR（负责找到“启动管理器”）</li><li>根目录</li><li>其他</li></ul></li></ul><p><img src="/../image/assets/image-20230729132443110.png" alt="image-20230729132443110"></p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul><li>操作系统引导开机过程</li><li>内存<ul><li>RAM：随机存取存储器（Random Access Memory），也叫主存，是与CPU直接交换数据的内部存储器。<ul><li>RAM断电时将丢失其存储内容，故主要用于存储短时间使用的程序</li></ul></li><li>ROM：只读内存(Read-Only Memory)，ROM所存数据，一般是装入整机前事先写好的，整机工作过程中<strong>只能读出</strong>，而不像RAM那样能快速地、方便地加以改写<ul><li>包含 BIOS，ROM 引导程序，即自荐程序</li><li>即使计算机关闭，ROM也会保留其内容。ROM被称为非易失性</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230729132654966.png" alt="image-20230729132654966"></p><h3 id="引导过程"><a href="#引导过程" class="headerlink" title="引导过程"></a>引导过程</h3><ul><li>操作系统引导<ul><li>CPU 从一个特定主存地址开始，取指令，执行 ROM 中的引导程序（先进行<strong>硬件自检</strong>，在开机）</li><li>将磁盘的第一块——主引导记录读入内存，执行磁盘引导程序，扫描分区块</li><li>从活动分区（C 盘，又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序</li><li>从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作</li></ul></li></ul><p><img src="/../image/assets/image-20230729133020071.png" alt="image-20230729133020071"></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="传统计算机的缺点"><a href="#传统计算机的缺点" class="headerlink" title="传统计算机的缺点"></a>传统计算机的缺点</h3><ul><li><p>缺点</p><ul><li><p>一台物理机器上只能运行一个操作系统</p></li><li><p>两个进程运行在同一个操作系统上可能会有安全隐患或者争夺系统资源</p></li></ul></li><li><p>解决办法</p><ul><li>将其中一个应用迁移到其他操作系统上（物理机器&#x2F;硬件的极大浪费）</li><li>使用虚拟机</li></ul></li></ul><p><img src="/../image/assets/image-20230729145029333.png" alt="image-20230729145029333"></p><h3 id="两类虚拟机"><a href="#两类虚拟机" class="headerlink" title="两类虚拟机"></a>两类虚拟机</h3><p><img src="/../image/assets/image-20230729145048319.png" alt="image-20230729145048319"></p><p><img src="/../image/assets/image-20230729151915593.png" alt="image-20230729151915593"></p><ul><li><p>采用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine, VM)，每个虚拟机器都可以独立运行一个操作系统</p></li><li><p>同义术语</p><ul><li>虚拟机管理程序、虚拟机监控程序、Virtual Machine Monitor(VMM)、Hypervisor</li></ul></li><li><p>两类VMM</p><ul><li><p>直接运行在硬件上（裸金属架构）</p><ul><li>将一台物理机器虚拟化为多台虚拟机器，将总的物理资源划分为多个部分，分配给多个虚拟机使用</li><li>每个虚拟机上可以安装不同的操作系统</li><li>在每个操作系统上又可以运行各自的进程<ul><li>只有最深层的虚拟机管理程序是运行在内核态的，运行在它上面的操作系统都是用户态<ul><li>虚拟机上的操作系统认为自己运行在内核态（实际上不是）</li><li>虚拟机上的用户进程认为自己运行在用户态（实际上确实是）</li></ul></li><li>当虚拟机上的操作系统想要执行特权指令，虚拟机管理程序会进行截获（虚拟机操作系统陷入虚拟机管理程序），然后做出相应的处理<ul><li>检查这条指令是由虚拟机中的操作系统执行的，安排这条指令功能的正确执行</li><li>检查这条指令是虚拟机中用户程序执行的，模拟真实硬件面对用户态执行敏感指令时的行为</li></ul></li></ul></li><li>对物理资源的控制权<ul><li>直接运行在硬件上，能直接控制和分配物理资源</li></ul></li><li>资源分配方式<ul><li>在安装 GuestOS 时，VMM 要在原本的硬盘上自行分配存储空间，类似于外核的分配方式，分配未经抽象的物理硬件</li></ul></li><li>性能<ul><li>更好</li></ul></li><li>可支持的虚拟机数量<ul><li>更多，不需要和 Host OS 竞争资源，相同的硬件资源可以支持更多的虚拟机</li></ul></li><li>虚拟机的可迁移性<ul><li>更差</li></ul></li><li>运行模式<ul><li>第一类 VMM 运行在最高特权级（Ring 0），可以执行最高特权的指令</li></ul></li></ul></li><li><p>运行在宿主操作系统上（寄居架构）</p><ul><li><p>宿主操作系统运行在底层硬件上</p></li><li><p>用户操作系统运行在虚拟机管理程序</p></li><li><p>虚拟机管理程序很像一个普通进程，依赖于 Windows、Linux 等操作系统分配和调度资源</p><ul><li>伪装成具有 CPU 和各种设备的计算机</li><li>只有VM 驱动（虚拟机驱动）是运行在内核态的，其他都运行在用户态<ul><li>当 GuestOS 中的用户进程想要进行系统调用<ul><li>GuestOS 的操作系统不可以直接读写磁盘</li><li>虚拟机管理程序截获特权指令</li><li>代替用户进程向底层宿主操作系统发出请求</li></ul></li></ul></li></ul></li><li><p>对物理资源的控制权</p><ul><li>运行在 HostOS 上，依赖于 Host OS 为其分配物理资源</li></ul></li><li><p>资源分配方式</p><ul><li>GuestOS 拥有自己的虚拟磁盘，该盘实际上是 Host OS 文件系统中的一个<strong>大文件</strong></li><li>GuestOS 分配到的内存是虚拟内存</li></ul></li><li><p>性能</p><ul><li>性能更差，需要 HostOS 作为中介</li></ul></li><li><p>可支持的虚拟机数量</p><ul><li>更少，HostOS 本身需要使用物理资源，HostOS 上运行的其他进程也需要物理资源</li></ul></li><li><p>虚拟机的可迁移性</p><ul><li>更好，只需导出虚拟机镜像文件即可迁移到另一台 HostOS 上，商业化应用更广泛</li></ul></li><li><p>运行模式</p><ul><li>第二类 VMM 部分运行在用户态、部分运行在内核态</li><li>GuestOS 发出的系统调用会被 VMM 截获，并转化为 VMM 对 HostOS 的系统调用</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机系统概述&quot;&gt;&lt;a href=&quot;#计算机系统概述&quot; class=&quot;headerlink&quot; title=&quot;计算机系统概述&quot;&gt;&lt;/a&gt;计算机系统概述&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="操作系统" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/408/"/>
    
    
    <category term="基础概念" scheme="https://sdumoist.github.io/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://sdumoist.github.io/2023/07/24/%E6%8E%92%E5%BA%8F/"/>
    <id>https://sdumoist.github.io/2023/07/24/%E6%8E%92%E5%BA%8F/</id>
    <published>2023-07-24T14:41:52.306Z</published>
    <updated>2024-03-30T19:25:38.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul><li>堆插入删除过程中，关键字对比次数</li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230724224004190.png" alt="image-20230724224004190"></p><p><img src="/../image/assets/image-20230725152123705.png" alt="image-20230725152123705"></p><p><img src="/../image/assets/image-20230725160050422.png" alt="image-20230725160050422"></p><p><img src="/../image/assets/image-20230725162425916.png" alt="image-20230725162425916"></p><p><img src="/../image/assets/image-20230725174048936.png" alt="image-20230725174048936"></p><p><img src="/../image/assets/image-20230725175748489.png" alt="image-20230725175748489"></p><p><img src="/../image/assets/image-20230725195653067.png" alt="image-20230725195653067"></p><p><img src="/../image/assets/image-20230725201620490.png" alt="image-20230725201620490"></p><p><img src="/../image/assets/image-20230725210510348.png" alt="image-20230725210510348"></p><p><img src="/../image/assets/image-20230725215127204.png" alt="image-20230725215127204"></p><p><img src="/../image/assets/image-20230725224348354.png" alt="image-20230725224348354"></p><p><img src="/../image/assets/image-20230726143444178.png" alt="image-20230726143444178"></p><p><img src="/../image/assets/image-20230726145617274.png" alt="image-20230726145617274"></p><p><img src="/../image/assets/image-20230726152812736.png" alt="image-20230726152812736"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>排序（sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程<ul><li>输入：n 个记录 R1,R2,…,Rn对应的关键字为 k1，k2，k3</li><li>输出：输入序列的一个重排，使得有 K1&lt;&#x3D;K2&lt;&#x3D;K3…&lt;&#x3D;KN（也可以递减）</li></ul></li></ul><p><img src="/../image/assets/image-20230724223313575.png" alt="image-20230724223313575"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li><p>若待排序表中有两个元素<em>Ri</em>和<em>Rj</em>，其对应的关键字相同即key<em>i</em> &#x3D; key<em>j</em>，且在排序前<em>Ri</em>在<em>Rj</em>的前⾯，若使⽤某⼀排序算法排序后，<em>Ri</em>仍然在<em>Rj</em>的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p><ul><li><p>稳定的：关键字相同的元素在排序之后<strong>相对位置</strong>不变</p></li><li><p>不稳定的：排序之后相对位置会改变</p></li></ul></li><li><p>稳定的排序算法不一定比不稳定排序算法好，看实际需求</p></li></ul><p><img src="/../image/assets/image-20230724223453761.png" alt="image-20230724223453761"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h4><ul><li>数据都在内存中</li><li>关注点：如何让算法时空复杂度更低</li></ul><h4 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h4><ul><li><p>数据太多，无法全部放入内存</p></li><li><p>关注点：如何使读、写磁盘次数更少</p></li></ul><p><img src="/../image/assets/image-20230724223944694.png" alt="image-20230724223944694"></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成</li></ul><p><img src="/../image/assets/image-20230724225344906.png" alt="image-20230724225344906"></p><p><img src="/../image/assets/image-20230724225359534.png" alt="image-20230724225359534"></p><p><img src="/../image/assets/image-20230724225409283.png" alt="image-20230724225409283"></p><p><img src="/../image/assets/image-20230724225419234.png" alt="image-20230724225419234"></p><p><img src="/../image/assets/image-20230724225435427.png" alt="image-20230724225435427"></p><p><img src="/../image/assets/image-20230724225445134.png" alt="image-20230724225445134"></p><p><img src="/../image/assets/image-20230724225455508.png" alt="image-20230724225455508"></p><p><img src="/../image/assets/image-20230724225506642.png" alt="image-20230724225506642"></p><p><img src="/../image/assets/image-20230724225520263.png" alt="image-20230724225520263"></p><p><img src="/../image/assets/image-20230724225529427.png" alt="image-20230724225529427"></p><p><img src="/../image/assets/image-20230724225539069.png" alt="image-20230724225539069"></p><p><img src="/../image/assets/image-20230724225548863.png" alt="image-20230724225548863"><br><img src="/../image/assets/image-20230725144652437.png" alt="image-20230725144652437"></p><p><img src="/../image/assets/image-20230725144701573.png" alt="image-20230725144701573"></p><p><img src="/../image/assets/image-20230725144713594.png" alt="image-20230725144713594"></p><p><img src="/../image/assets/image-20230725144722865.png" alt="image-20230725144722865"></p><p><img src="/../image/assets/image-20230725144735499.png" alt="image-20230725144735499"></p><p><img src="/../image/assets/image-20230725144756848.png" alt="image-20230725144756848"></p><p><img src="/../image/assets/image-20230725144807505.png" alt="image-20230725144807505"></p><p><img src="/../image/assets/image-20230725144818286.png" alt="image-20230725144818286"></p><p><img src="/../image/assets/image-20230725144829170.png" alt="image-20230725144829170"></p><p><img src="/../image/assets/image-20230725144837620.png" alt="image-20230725144837620"></p><p><img src="/../image/assets/image-20230725144846993.png" alt="image-20230725144846993"></p><p><img src="/../image/assets/image-20230725144855740.png" alt="image-20230725144855740"></p><p><img src="/../image/assets/image-20230725144906674.png" alt="image-20230725144906674"></p><p><img src="/../image/assets/image-20230725144915837.png" alt="image-20230725144915837"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="/../image/assets/image-20230725144949809.png" alt="image-20230725144949809"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i ++)&#123;             <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;                <span class="comment">//若A[i]关键字小于前驱</span></span><br><span class="line">            temp=A[i];                  <span class="comment">//用temp暂存A[i]</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; temp; j --)      <span class="comment">//检查所有前面已经排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];            <span class="comment">//所有大于temp的元素都将向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法实现（带哨兵）"><a href="#算法实现（带哨兵）" class="headerlink" title="算法实现（带哨兵）"></a>算法实现（带哨兵）</h3><ul><li>优点：不用每轮循环都判断 j&gt;&#x3D;0</li></ul><p><img src="/../image/assets/image-20230725145012208.png" alt="image-20230725145012208"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序（带哨兵）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort2</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i ++)                <span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;                    <span class="comment">//若A[0]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];                    <span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; A[<span class="number">0</span>]&lt;A[j]; --j)    <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];              <span class="comment">//向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];                  <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul><li><p>空间复杂度：O(1)</p></li><li><p>时间复杂度：主要来自对比关键字、移动元素</p><ul><li>若有n个元素，则需要n-1次处理</li><li>最好情况：原本有序<ul><li>共n-1次处理，每一次都只需要对比关键字1次，不用移动元素</li><li>最好时间复杂度：O(n)</li></ul></li><li>最坏情况：原本是倒序<ul><li>第一趟：对比关键字2次，移动元素3次</li><li>第二趟：对比关键字3次，移动元素4次</li><li>…</li><li>第 i 趟，对比关键字i+1次，移动元素i+2次</li><li>…</li><li>第n-1趟，对比关键字n次，移动元素n+1次</li><li>最坏时间复杂度：O(n^2)</li></ul></li></ul></li><li><p>稳定性：稳定</p></li></ul><p><img src="/../image/assets/image-20230725145527757.png" alt="image-20230725145527757"></p><p><img src="/../image/assets/image-20230725145539397.png" alt="image-20230725145539397"></p><p><img src="/../image/assets/image-20230725145603222.png" alt="image-20230725145603222"></p><p><img src="/../image/assets/image-20230725145616707.png" alt="image-20230725145616707"></p><h3 id="算法优化（折半查找）"><a href="#算法优化（折半查找）" class="headerlink" title="算法优化（折半查找）"></a>算法优化（折半查找）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li><p>先用折半查找找到应该插入的位置，再移动元素</p></li><li><p>折半查找的终点都是low &gt; high</p><ul><li>将 [low, i-1]内的元素全部右移，并将 A[0]复制到low所指位置</li><li>当 A[mid] &#x3D;&#x3D; A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插入位置</li><li>为了保证算法的稳定性，即使前面排好序的元素中出现与待插入元素相同的元素，也不能停止查找，直到 low &gt; high</li></ul></li></ul><p><img src="/../image/assets/image-20230725150749312.png" alt="image-20230725150749312"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化——折半插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i ++)&#123;               <span class="comment">//依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];                        <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;                <span class="comment">//设置折半查找范围</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;                  <span class="comment">//折半查找（默认递增有序）</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;           <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>]) high = mid <span class="number">-1</span>;<span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;             <span class="comment">//查找右半子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">            A[j<span class="number">-1</span>] = A[j];                  <span class="comment">//统一后移元素</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];                     <span class="comment">//插入操作</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><ul><li>比起“直接插入排序”，比较关键字的次数减少了，但是移动元素的次数没变</li><li>整体来看时间复杂度依然是O(n^2)</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="元素不相等"><a href="#元素不相等" class="headerlink" title="元素不相等"></a>元素不相等</h5><p><img src="/../image/assets/image-20230725145928376.png" alt="image-20230725145928376"></p><p><img src="/../image/assets/image-20230725145938369.png" alt="image-20230725145938369"></p><p><img src="/../image/assets/image-20230725145947543.png" alt="image-20230725145947543"></p><p><img src="/../image/assets/image-20230725145959257.png" alt="image-20230725145959257"></p><p><img src="/../image/assets/image-20230725150008971.png" alt="image-20230725150008971"></p><p><img src="/../image/assets/image-20230725150018986.png" alt="image-20230725150018986"></p><h5 id="元素相等"><a href="#元素相等" class="headerlink" title="元素相等"></a>元素相等</h5><p><img src="/../image/assets/image-20230725150112106.png" alt="image-20230725150112106"></p><p><img src="/../image/assets/image-20230725150123491.png" alt="image-20230725150123491"></p><p><img src="/../image/assets/image-20230725150136440.png" alt="image-20230725150136440"></p><p><img src="/../image/assets/image-20230725150146489.png" alt="image-20230725150146489"></p><p><img src="/../image/assets/image-20230725150159984.png" alt="image-20230725150159984"></p><p><img src="/../image/assets/image-20230725150211713.png" alt="image-20230725150211713"></p><h5 id="元素最大"><a href="#元素最大" class="headerlink" title="元素最大"></a>元素最大</h5><p><img src="/../image/assets/image-20230725150352312.png" alt="image-20230725150352312"></p><p><img src="/../image/assets/image-20230725150402243.png" alt="image-20230725150402243"></p><h5 id="元素最小"><a href="#元素最小" class="headerlink" title="元素最小"></a>元素最小</h5><p><img src="/../image/assets/image-20230725150416321.png" alt="image-20230725150416321"></p><p><img src="/../image/assets/image-20230725150426528.png" alt="image-20230725150426528"></p><p><img src="/../image/assets/image-20230725150436234.png" alt="image-20230725150436234"></p><p><img src="/../image/assets/image-20230725150448588.png" alt="image-20230725150448588"></p><p><img src="/../image/assets/image-20230725150500677.png" alt="image-20230725150500677"></p><h3 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a>对链表进行插入排序</h3><ul><li>移动元素的次数变少，但是关键字对比的次数依然是O(n^2)数量级</li><li>整体来看时间复杂度依然是O(n^2)</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul><li><p>对直接插入排序对优化</p></li><li><p>先追求表中元素部分有序，再逐渐逼近全局有序</p></li></ul><p><img src="/../image/assets/image-20230725152824128.png" alt="image-20230725152824128"></p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>先将待排序表分割成若干形如 L[i, i+的, i+2d,… , i +kd] 的“特殊”子表，对各个子表分别进行直接插入排序。</li><li>缩小增量的，重复上述过程，直到 d&#x3D;1</li><li>希尔本人建议：每次将增量缩小一半</li></ul><p><img src="/../image/assets/image-20230725152928019.png" alt="image-20230725152928019"></p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><ul><li><p>d1 &#x3D; n&#x2F;2 &#x3D; 4d2 &#x3D; d1&#x2F;2 &#x3D; 2d3 &#x3D; d2 &#x2F;2 &#x3D; 1</p></li><li><p>结果</p></li></ul><p><img src="/../image/assets/image-20230725153128418.png" alt="image-20230725153128418"></p><ul><li>第一趟</li></ul><p><img src="/../image/assets/image-20230725153144613.png" alt="image-20230725153144613"></p><p><img src="/../image/assets/image-20230725153200461.png" alt="image-20230725153200461"></p><p><img src="/../image/assets/image-20230725153222915.png" alt="image-20230725153222915"></p><p><img src="/../image/assets/image-20230725153211788.png" alt="image-20230725153211788"></p><ul><li>第二趟</li></ul><p><img src="/../image/assets/image-20230725153247144.png" alt="image-20230725153247144"></p><p><img src="/../image/assets/image-20230725153257347.png" alt="image-20230725153257347"></p><p><img src="/../image/assets/image-20230725153307380.png" alt="image-20230725153307380"></p><p><img src="/../image/assets/image-20230725153317170.png" alt="image-20230725153317170"></p><ul><li>第三趟</li></ul><p><img src="/../image/assets/image-20230725153331420.png" alt="image-20230725153331420"></p><p><img src="/../image/assets/image-20230725153343624.png" alt="image-20230725153343624"></p><p><img src="/../image/assets/image-20230725153355778.png" alt="image-20230725153355778"></p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><ul><li>d1 &#x3D; 3d2 &#x3D; 1</li></ul><p><img src="/../image/assets/image-20230725153630391.png" alt="image-20230725153630391"></p><p><img src="/../image/assets/image-20230725153645310.png" alt="image-20230725153645310"></p><p><img src="/../image/assets/image-20230725153656108.png" alt="image-20230725153656108"></p><p><img src="/../image/assets/image-20230725153713761.png" alt="image-20230725153713761"></p><p><img src="/../image/assets/image-20230725153724639.png" alt="image-20230725153724639"></p><p><img src="/../image/assets/image-20230725153734875.png" alt="image-20230725153734875"></p><p><img src="/../image/assets/image-20230725153746266.png" alt="image-20230725153746266"></p><p><img src="/../image/assets/image-20230725153757283.png" alt="image-20230725153757283"></p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="/../image/assets/image-20230725154406706.png" alt="image-20230725154406706"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d, i, j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已经找到</span></span><br><span class="line">    <span class="keyword">for</span>(d = n/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d = d/<span class="number">2</span>)           <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i-d])&#123;              <span class="comment">//需要将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i];                <span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j = i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j]; j-=d)</span><br><span class="line">                    A[j+d]=A[<span class="number">0</span>];</span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];                <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230725154806049.png" alt="image-20230725154806049"></p><p><img src="/../image/assets/image-20230725154816418.png" alt="image-20230725154816418"></p><p><img src="/../image/assets/image-20230725154825639.png" alt="image-20230725154825639"></p><p><img src="/../image/assets/image-20230725154838147.png" alt="image-20230725154838147"></p><p><img src="/../image/assets/image-20230725154848777.png" alt="image-20230725154848777"></p><p><img src="/../image/assets/image-20230725154900428.png" alt="image-20230725154900428"></p><p><img src="/../image/assets/image-20230725154910366.png" alt="image-20230725154910366"></p><p><img src="/../image/assets/image-20230725154920906.png" alt="image-20230725154920906"></p><p><img src="/../image/assets/image-20230725154931179.png" alt="image-20230725154931179"></p><p><img src="/../image/assets/image-20230725154949914.png" alt="image-20230725154949914"></p><p><img src="/../image/assets/image-20230725155000546.png" alt="image-20230725155000546"></p><p><img src="/../image/assets/image-20230725155011353.png" alt="image-20230725155011353"></p><p><img src="/../image/assets/image-20230725155022441.png" alt="image-20230725155022441"></p><p><img src="/../image/assets/image-20230725155032485.png" alt="image-20230725155032485"></p><p><img src="/../image/assets/image-20230725155042949.png" alt="image-20230725155042949"></p><p><img src="/../image/assets/image-20230725155052204.png" alt="image-20230725155052204"></p><p><img src="/../image/assets/image-20230725155102115.png" alt="image-20230725155102115"></p><p><img src="/../image/assets/image-20230725155111446.png" alt="image-20230725155111446"></p><p><img src="/../image/assets/image-20230725155121248.png" alt="image-20230725155121248"></p><p><img src="/../image/assets/image-20230725155130511.png" alt="image-20230725155130511"></p><p><img src="/../image/assets/image-20230725155140432.png" alt="image-20230725155140432"></p><p><img src="/../image/assets/image-20230725155149787.png" alt="image-20230725155149787"></p><p><img src="/../image/assets/image-20230725155159735.png" alt="image-20230725155159735"></p><p><img src="/../image/assets/image-20230725155241905.png" alt="image-20230725155241905"></p><p><img src="/../image/assets/image-20230725155300190.png" alt="image-20230725155300190"></p><p><img src="/../image/assets/image-20230725155310963.png" alt="image-20230725155310963"></p><p><img src="/../image/assets/image-20230725155321528.png" alt="image-20230725155321528"></p><p><img src="/../image/assets/image-20230725155332944.png" alt="image-20230725155332944"></p><p><img src="/../image/assets/image-20230725155341856.png" alt="image-20230725155341856"></p><p><img src="/../image/assets/image-20230725155351319.png" alt="image-20230725155351319"></p><p><img src="/../image/assets/image-20230725155402164.png" alt="image-20230725155402164"></p><p><img src="/../image/assets/image-20230725155411779.png" alt="image-20230725155411779"></p><p><img src="/../image/assets/image-20230725155433187.png" alt="image-20230725155433187"></p><p><img src="/../image/assets/image-20230725155444532.png" alt="image-20230725155444532"></p><p><img src="/../image/assets/image-20230725155454050.png" alt="image-20230725155454050"></p><p><img src="/../image/assets/image-20230725155502906.png" alt="image-20230725155502906"></p><p><img src="/../image/assets/image-20230725155514600.png" alt="image-20230725155514600"></p><p><img src="/../image/assets/image-20230725155523879.png" alt="image-20230725155523879"></p><p><img src="/../image/assets/image-20230725155533912.png" alt="image-20230725155533912"></p><p><img src="/../image/assets/image-20230725155543142.png" alt="image-20230725155543142"></p><p><img src="/../image/assets/image-20230725155555358.png" alt="image-20230725155555358"></p><p><img src="/../image/assets/image-20230725155606363.png" alt="image-20230725155606363"></p><p><img src="/../image/assets/image-20230725155616005.png" alt="image-20230725155616005"></p><h3 id="算法实现2"><a href="#算法实现2" class="headerlink" title="算法实现2"></a>算法实现2</h3><ul><li>先处理完一个子表，再处理另一个子表</li></ul><h3 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h3><ul><li>时间复杂度<ul><li>和增量序列 d1, d2, d3… 的选择有关，目前无法通过数学手段证明确切的时间复杂度</li><li>最坏时间复杂度为O(n^2),</li><li>当n再某个范围时，可以达到 O(n^1.3)</li></ul></li></ul><p><img src="/../image/assets/image-20230725155914064.png" alt="image-20230725155914064"></p><ul><li>稳定性：不稳定</li><li>适用性：仅适用于顺序表，不适用于链表</li></ul><p><img src="/../image/assets/image-20230725155953367.png" alt="image-20230725155953367"></p><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul><li>基于交换的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>从后往前（或者从前往后）两两比较元素的值，若为逆序（即A[i-1] &gt; A[i]），则交换它们，直到序列比较完</li><li>这样的过程为一趟冒泡排序</li><li>每趟冒泡都可以将最小值放到前面（后面），前面已经确定最终位置的元素不用再进行比较</li><li>总共进行n-1趟冒泡排序</li></ul><p><img src="/../image/assets/image-20230725160550692.png" alt="image-20230725160550692"></p><p><img src="/../image/assets/image-20230725160600170.png" alt="image-20230725160600170"></p><p><img src="/../image/assets/image-20230725160611438.png" alt="image-20230725160611438"></p><p><img src="/../image/assets/image-20230725160620131.png" alt="image-20230725160620131"></p><p><img src="/../image/assets/image-20230725160628231.png" alt="image-20230725160628231"></p><p><img src="/../image/assets/image-20230725160641034.png" alt="image-20230725160641034"></p><p><img src="/../image/assets/image-20230725160649382.png" alt="image-20230725160649382"></p><p><img src="/../image/assets/image-20230725160700096.png" alt="image-20230725160700096"></p><p><img src="/../image/assets/image-20230725160708412.png" alt="image-20230725160708412"></p><p><img src="/../image/assets/image-20230725160724568.png" alt="image-20230725160724568"></p><p><img src="/../image/assets/image-20230725160733336.png" alt="image-20230725160733336"></p><p><img src="/../image/assets/image-20230725160741865.png" alt="image-20230725160741865"></p><p><img src="/../image/assets/image-20230725160750306.png" alt="image-20230725160750306"></p><p><img src="/../image/assets/image-20230725160853234.png" alt="image-20230725160853234"></p><p><img src="/../image/assets/image-20230725160902405.png" alt="image-20230725160902405"></p><p><img src="/../image/assets/image-20230725160910616.png" alt="image-20230725160910616"></p><p><img src="/../image/assets/image-20230725160920542.png" alt="image-20230725160920542"></p><p><img src="/../image/assets/image-20230725161020538.png" alt="image-20230725161020538"></p><p><img src="/../image/assets/image-20230725161030698.png" alt="image-20230725161030698"></p><p><img src="/../image/assets/image-20230725161038965.png" alt="image-20230725161038965"></p><p><img src="/../image/assets/image-20230725161047632.png" alt="image-20230725161047632"></p><p><img src="/../image/assets/image-20230725161056330.png" alt="image-20230725161056330"></p><p><img src="/../image/assets/image-20230725161105270.png" alt="image-20230725161105270"></p><p><img src="/../image/assets/image-20230725161115357.png" alt="image-20230725161115357"></p><p><img src="/../image/assets/image-20230725161124407.png" alt="image-20230725161124407"></p><p><img src="/../image/assets/image-20230725161154940.png" alt="image-20230725161154940"></p><p><img src="/../image/assets/image-20230725161332713.png" alt="image-20230725161332713"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/../image/assets/image-20230725161925763.png" alt="image-20230725161925763"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;                  <span class="comment">//表示本趟冒泡排序是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>; j &gt; i; j--)        <span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123;              <span class="comment">//若为逆序</span></span><br><span class="line">                <span class="built_in">swap</span>(A[j<span class="number">-1</span>], A[j]);         <span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;           <span class="comment">//本趟遍历没有发生交换，表示表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法性能分析-1"><a href="#算法性能分析-1" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><ul><li><p>空间复杂度：O(n)</p></li><li><p>时间复杂度</p><ul><li>最好情况：有序<ul><li>比较次数 &#x3D; n-1；交换次数 &#x3D; 0;</li><li>最好时间复杂度：O(n)</li></ul></li><li>最坏情况：逆序<ul><li>比较次数 &#x3D; (n-1)+(n-2)+…+1&#x3D; n(n-1)&#x2F;2 &#x3D; 交换次数</li><li>最坏时间复杂度 &#x3D; O(n^2)</li></ul></li><li>平均时间复杂度 &#x3D; O(n^2)</li></ul></li><li><p>稳定性：稳定的</p></li><li><p>适用性：顺序表和链表都适用</p></li></ul><p><img src="/../image/assets/image-20230725162404997.png" alt="image-20230725162404997"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li><p>在待排序表[1..n]中选取一个元素 pivot 作为枢纽（或基准，通常取首元素）</p></li><li><p>通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1,n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1,n]中的所有元素大于等于pivot</p></li><li><p>pivot放在了最终位置 L[k]上</p></li><li><p>这个过程称为一次“划分”</p></li><li><p>然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上</p></li></ul><p><img src="/../image/assets/image-20230725164902540.png" alt="image-20230725164902540"></p><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li>一次划分</li></ul><p><img src="/../image/assets/image-20230725165217109.png" alt="image-20230725165217109"></p><p><img src="/../image/assets/image-20230725165229896.png" alt="image-20230725165229896"></p><p><img src="/../image/assets/image-20230725165242031.png" alt="image-20230725165242031"></p><p><img src="/../image/assets/image-20230725165253940.png" alt="image-20230725165253940"></p><p><img src="/../image/assets/image-20230725165304030.png" alt="image-20230725165304030"></p><p><img src="/../image/assets/image-20230725165312840.png" alt="image-20230725165312840"></p><p><img src="/../image/assets/image-20230725165326259.png" alt="image-20230725165326259"></p><p><img src="/../image/assets/image-20230725165335459.png" alt="image-20230725165335459"></p><p><img src="/../image/assets/image-20230725165344946.png" alt="image-20230725165344946"></p><p><img src="/../image/assets/image-20230725165355208.png" alt="image-20230725165355208"></p><p><img src="/../image/assets/image-20230725165404411.png" alt="image-20230725165404411"></p><p><img src="/../image/assets/image-20230725165414180.png" alt="image-20230725165414180"></p><p><img src="/../image/assets/image-20230725165425152.png" alt="image-20230725165425152"></p><p><img src="/../image/assets/image-20230725165438932.png" alt="image-20230725165438932"></p><ul><li>第二次划分（左子表）</li></ul><p><img src="/../image/assets/image-20230725165550539.png" alt="image-20230725165550539"></p><p><img src="/../image/assets/image-20230725165646400.png" alt="image-20230725165646400"></p><p><img src="/../image/assets/image-20230725165655414.png" alt="image-20230725165655414"></p><p><img src="/../image/assets/image-20230725165705841.png" alt="image-20230725165705841"></p><p><img src="/../image/assets/image-20230725165714818.png" alt="image-20230725165714818"></p><p><img src="/../image/assets/image-20230725165728560.png" alt="image-20230725165728560"></p><p><img src="/../image/assets/image-20230725165737305.png" alt="image-20230725165737305"></p><ul><li>第二次划分（右子表）</li></ul><p><img src="/../image/assets/image-20230725165748596.png" alt="image-20230725165748596"></p><p><img src="/../image/assets/image-20230725165757908.png" alt="image-20230725165757908"></p><p><img src="/../image/assets/image-20230725165807664.png" alt="image-20230725165807664"></p><p><img src="/../image/assets/image-20230725165817572.png" alt="image-20230725165817572"></p><p><img src="/../image/assets/image-20230725165828077.png" alt="image-20230725165828077"></p><p><img src="/../image/assets/image-20230725165838514.png" alt="image-20230725165838514"></p><p><img src="/../image/assets/image-20230725165849058.png" alt="image-20230725165849058"></p><p><img src="/../image/assets/image-20230725165906203.png" alt="image-20230725165906203"></p><p><img src="/../image/assets/image-20230725170039023.png" alt="image-20230725170039023"></p><ul><li>第三次划分（左子表）</li></ul><p><img src="/../image/assets/image-20230725170025626.png" alt="image-20230725170025626"></p><p><img src="/../image/assets/image-20230725170057204.png" alt="image-20230725170057204"></p><p><img src="/../image/assets/image-20230725170107198.png" alt="image-20230725170107198"></p><p><img src="/../image/assets/image-20230725170117092.png" alt="image-20230725170117092"></p><p><img src="/../image/assets/image-20230725170133088.png" alt="image-20230725170133088"></p><p><img src="/../image/assets/image-20230725170918658.png" alt="image-20230725170918658"></p><p><img src="/../image/assets/image-20230725170927903.png" alt="image-20230725170927903"></p><h4 id="代码实现（最重要）"><a href="#代码实现（最重要）" class="headerlink" title="代码实现（最重要）"></a>代码实现（最重要）</h4><p><img src="/../image/assets/image-20230725170943141.png" alt="image-20230725170943141"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];                       <span class="comment">//第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;                      <span class="comment">//用low、high搜索枢纽的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high];                   <span class="comment">//比枢纽小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) ++high;    </span><br><span class="line">        A[high]=A[low];                     <span class="comment">//比枢纽大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;                         <span class="comment">//枢纽元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;                             <span class="comment">//返回存放枢纽的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;                         <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high); <span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A, low, pivotpos<span class="number">-1</span>);      <span class="comment">//划分左子表</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivotpos + <span class="number">1</span>, high);   <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230726162750805.png" alt="image-20230726162750805"></p><h4 id="算法效率分析-1"><a href="#算法效率分析-1" class="headerlink" title="算法效率分析"></a>算法效率分析</h4><ul><li><p>所有内部排序算法中，平均性能最优秀的排序算法</p></li><li><p>时间复杂度</p><ul><li><p><strong>每⼀层的</strong> QuickSort <strong>只需要处理剩余的</strong> <strong>待排序元素，时间复杂度不超过</strong>O(n)</p></li><li><p>时间复杂度&#x3D;O(n*递归层数)</p></li></ul></li><li><p>空间复杂度</p><ul><li>空间复杂度 &#x3D; O(递归层数)</li></ul></li><li><p>把n个元素组织成二叉树，二叉树的层数就是递归调用的层数</p><ul><li>n个节点的二叉树<ul><li>最小高度 &#x3D; log2n + 1</li><li>最大高度 &#x3D; n</li></ul></li><li>最好时间复杂度 &#x3D;  O(nlog2n)</li><li>最坏时间复杂度 &#x3D;  O(n^2)</li><li>平均时间复杂度 &#x3D; O(nlog2n)</li><li>最好空间复杂度 &#x3D;  O(log2n)</li><li>最坏空间复杂度 &#x3D; O(n)</li><li>最好情况（枢纽在中间）<ul><li>若每一次选中的“枢纽：将排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高</li><li>若每次选中的“枢纽”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高</li></ul></li><li>最坏情况（有序或逆序）<ul><li>若每一次选中的“枢纽”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低</li><li>若初始序列有序或逆序，则快速排序的性能最差（每次选中的都是最靠边的元素）</li></ul></li></ul></li><li><p>优化思路</p><ul><li>尽量选择可以把数据中分的枢纽元素<ul><li>选中头、中、尾三个位置的元素，取中间值作为枢纽元素</li><li>随机选一个元素作为枢轴元素</li></ul></li></ul></li><li><p>稳定性：不稳定</p></li></ul><p><img src="/../image/assets/image-20230725173927315.png" alt="image-20230725173927315"></p><p><img src="/../image/assets/image-20230725173943495.png" alt="image-20230725173943495"></p><ul><li>时间复杂度</li></ul><p><img src="/../image/assets/image-20230725172049560.png" alt="image-20230725172049560"></p><ul><li>空间复杂度</li></ul><p><img src="/../image/assets/image-20230725172443319.png" alt="image-20230725172443319"></p><ul><li>转换成二叉排序树</li></ul><p><img src="/../image/assets/image-20230725172555373.png" alt="image-20230725172555373"></p><ul><li>最坏的情况（逆序）</li></ul><p><img src="/../image/assets/image-20230725173155889.png" alt="image-20230725173155889"></p><ul><li>比较好的情况</li></ul><p><img src="/../image/assets/image-20230725173438773.png" alt="image-20230725173438773"></p><h4 id="一趟排序-一次划分"><a href="#一趟排序-一次划分" class="headerlink" title="一趟排序 !&#x3D; 一次划分"></a>一趟排序 !&#x3D; 一次划分</h4><ul><li>一趟排序：可以确定多个元素的位置</li><li>一次划分：只能确定一个元素的位置</li></ul><p><img src="/../image/assets/image-20230725174202608.png" alt="image-20230725174202608"></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列</li></ul><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>每一趟在待排序元素中选取关键字最小的元素加入有序子序列<ul><li>如果遇到两个相同的最小元素，则选择位置靠前的</li></ul></li><li>最后剩一个不用处理<ul><li>n个元素的简单选择排序需要n-1趟处理</li></ul></li></ul><p><img src="/../image/assets/image-20230725174457542.png" alt="image-20230725174457542"></p><p><img src="/../image/assets/image-20230725174506146.png" alt="image-20230725174506146"></p><p><img src="/../image/assets/image-20230725174515310.png" alt="image-20230725174515310"></p><p><img src="/../image/assets/image-20230725174523975.png" alt="image-20230725174523975"></p><p><img src="/../image/assets/image-20230725174534231.png" alt="image-20230725174534231"></p><p><img src="/../image/assets/image-20230725174547275.png" alt="image-20230725174547275"></p><p><img src="/../image/assets/image-20230725174555452.png" alt="image-20230725174555452"></p><p><img src="/../image/assets/image-20230725174614500.png" alt="image-20230725174614500"></p><p><img src="/../image/assets/image-20230725174627664.png" alt="image-20230725174627664"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/../image/assets/image-20230725175408335.png" alt="image-20230725175408335"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;           <span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min =i;                         <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)      <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min]) min = i;      <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(A[i], A[min]);    <span class="comment">//封装的swap()函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法性能分析-2"><a href="#算法性能分析-2" class="headerlink" title="算法性能分析"></a>算法性能分析</h4><ul><li><p>空间复杂度 &#x3D; O(1)</p></li><li><p>时间复杂度 &#x3D; O(n^2)</p><ul><li>无论有序、逆序、还输乱序，一定需要n-1趟处理</li><li>总共需要对比关键字（n-1)+(n-2)+(n-3)+….+1 &#x3D; n(n-1)&#x2F;2 次</li></ul></li><li><p>稳定性：不稳定</p></li><li><p>适用性：既可以用于顺序表，也可以用于链表</p></li></ul><p><img src="/../image/assets/image-20230725175721087.png" alt="image-20230725175721087"></p><p><img src="/../image/assets/image-20230725175730921.png" alt="image-20230725175730921"></p><h3 id="堆排序（重点）"><a href="#堆排序（重点）" class="headerlink" title="堆排序（重点）"></a>堆排序（重点）</h3><h4 id="堆-heap-顺序存储的完全二叉树"><a href="#堆-heap-顺序存储的完全二叉树" class="headerlink" title="堆(heap):顺序存储的完全二叉树"></a>堆(heap):顺序存储的完全二叉树</h4><ul><li>若n个关键字序列L[1….n] 满足下面某一条性质，则称为堆（Heap）<ul><li>大根堆（大顶堆）：若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>&#x2F;2 ）<ul><li>完全二叉树中：根 &gt;&#x3D; 左右</li></ul></li><li>小根堆（小顶堆）：若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ <em>i</em> ≤<em>n</em>&#x2F;2 ） <ul><li>完全二叉树中：根 &lt;&#x3D; 左右</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230725180409165.png" alt="image-20230725180409165"></p><h5 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h5><p><img src="/../image/assets/image-20230725180215700.png" alt="image-20230725180215700"></p><h4 id="构建操作"><a href="#构建操作" class="headerlink" title="构建操作"></a>构建操作</h4><h5 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h5><ul><li>堆顶元素关键字最大</li></ul><h5 id="简单选择排序-VS-堆排序"><a href="#简单选择排序-VS-堆排序" class="headerlink" title="简单选择排序 VS 堆排序"></a>简单选择排序 VS 堆排序</h5><ul><li><p>简单选择排序：每⼀趟在待排序元素中选取关键字最⼤的元素加⼊有序⼦序列</p></li><li><p>堆排序：每⼀趟将堆顶元素加⼊有序⼦序列（与待排序序列中的最后⼀个元素交换）</p></li></ul><h5 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h5><ul><li><p>思路</p><ul><li>把所有非终端节点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</li><li><strong>在顺序存储的完全二叉树中，非终端节点编号i &lt;&#x3D; [n&#x2F;2]</strong></li></ul></li><li><p>调整</p><ul><li>从 i &#x3D; n&#x2F;2 开始检查当前节点（i &lt;&#x3D; n&#x2F;2）是否满足 <strong>根 &gt;&#x3D; 左、右</strong></li><li>若不满足，将当前节点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整<strong>（小元素不断“下坠”）</strong></li><li>小元素无法下坠，则调整完成</li></ul></li></ul><p><img src="/../image/assets/image-20230725185515129.png" alt="image-20230725185515129"></p><p><img src="/../image/assets/image-20230725185543386.png" alt="image-20230725185543386"></p><p><img src="/../image/assets/image-20230725190017364.png" alt="image-20230725190017364"></p><p><img src="/../image/assets/image-20230725190026570.png" alt="image-20230725190026570"></p><p><img src="/../image/assets/image-20230725190036919.png" alt="image-20230725190036919"></p><p><img src="/../image/assets/image-20230725190045953.png" alt="image-20230725190045953"></p><p><img src="/../image/assets/image-20230725190056157.png" alt="image-20230725190056157"></p><p><img src="/../image/assets/image-20230725190105695.png" alt="image-20230725190105695"></p><p><img src="/../image/assets/image-20230725190114473.png" alt="image-20230725190114473"></p><p><img src="/../image/assets/image-20230725190125706.png" alt="image-20230725190125706"></p><p><img src="/../image/assets/image-20230725190137290.png" alt="image-20230725190137290"></p><p><img src="/../image/assets/image-20230725190145791.png" alt="image-20230725190145791"></p><h5 id="构建的代码实现"><a href="#构建的代码实现" class="headerlink" title="构建的代码实现"></a>构建的代码实现</h5><p><img src="/../image/assets/image-20230725190229628.png" alt="image-20230725190229628"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                            <span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])  </span><br><span class="line">            i++;                            <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;             <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                               </span><br><span class="line">            A[k] =A[i];                     <span class="comment">//将A[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                          <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];                            <span class="comment">//被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)          <span class="comment">//从后往前调整所有非终端节点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230725191359187.png" alt="image-20230725191359187"></p><p><img src="../image/assets/image-20230725191411362.png" alt="image-20230725191411362" style="zoom: 33%;" /><img src="../image/assets/image-20230725191632663.png" alt="image-20230725191632663" style="zoom:33%;" /></p><p><img src="../image/assets/image-20230725191716515.png" alt="image-20230725191716515" style="zoom:33%;" /><img src="../image/assets/image-20230725191732707.png" alt="image-20230725191732707" style="zoom:33%;" /></p><p><img src="../image/assets/image-20230725191841331.png" alt="image-20230725191841331" style="zoom:33%;" /><img src="../image/assets/image-20230725191856662.png" alt="image-20230725191856662" style="zoom:33%;" /></p><p><img src="../image/assets/image-20230725191938091.png" alt="image-20230725191938091" style="zoom:33%;" /><img src="../image/assets/image-20230725191951907.png" alt="image-20230725191951907" style="zoom:33%;" /></p><p><img src="../image/assets/image-20230725192011696.png" alt="image-20230725192011696" style="zoom:33%;" /><img src="../image/assets/image-20230725192034371.png" alt="image-20230725192034371" style="zoom:33%;" /></p><h5 id="排序操作（基于大根堆）"><a href="#排序操作（基于大根堆）" class="headerlink" title="排序操作（基于大根堆）"></a>排序操作（基于大根堆）</h5><ul><li>选择排序：每一趟在待排序元素中选取关键字最大的元素加入有序子序列</li><li>堆排序：每一趟将<strong>堆顶元素</strong>加入有序子序列（与待排序序列中的最后一个元素交换），并将<strong>待排序元素序列</strong>再次调整为大根堆<ul><li>堆排序的堆顶元素就是整个堆中最大的元素</li></ul></li></ul><p><img src="/../image/assets/image-20230725192820097.png" alt="image-20230725192820097"></p><p><img src="/../image/assets/image-20230725193119688.png" alt="image-20230725193119688"></p><p><img src="/../image/assets/image-20230725193139538.png" alt="image-20230725193139538"></p><p><img src="/../image/assets/image-20230725193148450.png" alt="image-20230725193148450"></p><p><img src="/../image/assets/image-20230725193158206.png" alt="image-20230725193158206"></p><p><img src="/../image/assets/image-20230725193210680.png" alt="image-20230725193210680"></p><p><img src="/../image/assets/image-20230725193221058.png" alt="image-20230725193221058"></p><p><img src="/../image/assets/image-20230725193230826.png" alt="image-20230725193230826"></p><p><img src="/../image/assets/image-20230725193241459.png" alt="image-20230725193241459"></p><p><img src="/../image/assets/image-20230725193253337.png" alt="image-20230725193253337"></p><p><img src="/../image/assets/image-20230725193302782.png" alt="image-20230725193302782"></p><p><img src="/../image/assets/image-20230725193311833.png" alt="image-20230725193311833"></p><p><img src="/../image/assets/image-20230725193321733.png" alt="image-20230725193321733"></p><p><img src="/../image/assets/image-20230725193331222.png" alt="image-20230725193331222"></p><p><img src="/../image/assets/image-20230725193340233.png" alt="image-20230725193340233"></p><p><img src="/../image/assets/image-20230725193349899.png" alt="image-20230725193349899"></p><p><img src="/../image/assets/image-20230725193359389.png" alt="image-20230725193359389"></p><p><img src="/../image/assets/image-20230725193410553.png" alt="image-20230725193410553"></p><p><img src="/../image/assets/image-20230725193422264.png" alt="image-20230725193422264"></p><p><img src="/../image/assets/image-20230725193432992.png" alt="image-20230725193432992"></p><p><img src="/../image/assets/image-20230725193442820.png" alt="image-20230725193442820"></p><p><img src="/../image/assets/image-20230725193452779.png" alt="image-20230725193452779"></p><p><img src="/../image/assets/image-20230725193502129.png" alt="image-20230725193502129"></p><p><img src="/../image/assets/image-20230725193511012.png" alt="image-20230725193511012"></p><p><img src="/../image/assets/image-20230725193532774.png" alt="image-20230725193532774"></p><p><img src="/../image/assets/image-20230725193543015.png" alt="image-20230725193543015"></p><p><img src="/../image/assets/image-20230725193552731.png" alt="image-20230725193552731"></p><p><img src="/../image/assets/image-20230725193602185.png" alt="image-20230725193602185"></p><p><img src="/../image/assets/image-20230725193612890.png" alt="image-20230725193612890"></p><p><img src="/../image/assets/image-20230725193717193.png" alt="image-20230725193717193"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/../image/assets/image-20230725193745319.png" alt="image-20230725193745319"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                            <span class="comment">//A[0]暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])  </span><br><span class="line">            i++;                            <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;             <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                               </span><br><span class="line">            A[k] =A[i];                     <span class="comment">//将A[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                          <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];                            <span class="comment">//被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)          <span class="comment">//从后往前调整所有非终端节点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(A, len);                   <span class="comment">//初始建模</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len; i&gt;<span class="number">1</span>; i--)&#123;             <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[<span class="number">1</span>]);                   <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, <span class="number">1</span>, i<span class="number">-1</span>);              <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法效率分析-2"><a href="#算法效率分析-2" class="headerlink" title="算法效率分析"></a>算法效率分析</h4><p><img src="/../image/assets/image-20230725195011852.png" alt="image-20230725195011852"></p><ul><li><p>时间复杂度</p><ul><li><p>BuildMaxHeap(int A[], int len)</p><ul><li>一个节点，每下坠一层，最多只需对比关键字2次</li><li>若树高为h，某节点在第 i 层，则将这个节点向下调整最多只需要下坠 h-i 层，关键字对比次数不超过 2(h-i)</li><li>n个节点的完全二叉树树高 h &#x3D; [log2n] + 1</li><li>第 i 层最多有 2^(i-1) 个节点，而只有第 1～(h-1)层的节点才有可能需要下坠调整</li><li>结论：建立初始堆的过程中，关键字对比次数不超过4n，<strong>建堆时间复杂度&#x3D; O(n)</strong></li></ul></li><li><p>HeapSort(int A[], int len)</p><ul><li>总共需要下坠n-1层</li><li>每下坠一层，最多只需对比关键字2次，每一趟排序复杂度不超过 O(h) &#x3D; O(log2n)</li><li>结论：总的时间复杂度 &#x3D; O(nlog2n)</li></ul></li></ul></li><li><p>堆排序的时间复杂度 &#x3D; <em>O</em>(<em>n</em>) + <em>O</em>(<em>nlog</em>2<em>n</em>) &#x3D; <em>O</em>(<em>nlog</em>2<em>n</em>) </p></li><li><p>堆排序的空间复杂度 &#x3D; <em>O</em>(1)</p></li><li><p>稳定性：不稳定</p></li></ul><p><img src="/../image/assets/image-20230725194857989.png" alt="image-20230725194857989"></p><p>  <img src="/../image/assets/image-20230725194925131.png" alt="image-20230725194925131"></p><p><img src="/../image/assets/image-20230725195413220.png" alt="image-20230725195413220"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>对于小根堆<ul><li>新元素放到表尾，与父节点对比</li><li>若新元素比父节点<strong>更小</strong>，则将两者互换</li><li>新元素这样一路上升，直到无法继续上升为止</li></ul></li><li>对于大根堆<ul><li>新元素放到表尾，与父节点对比</li><li>若新元素比父节点<strong>更大</strong>，则将两者互换</li><li>新元素这样一路上升，直到无法继续上升为止</li></ul></li></ul><p><img src="/../image/assets/image-20230725200533958.png" alt="image-20230725200533958"></p><p><img src="/../image/assets/image-20230725200823026.png" alt="image-20230725200823026"></p><p><img src="/../image/assets/image-20230725200832805.png" alt="image-20230725200832805"></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>对于小根堆<ul><li>被删除的元素用堆底元素替代</li><li>比较该元素与<strong>更小的孩子节点</strong>的元素，如果<strong>大于孩子节点</strong>，让该元素不断下坠</li><li>直到无法下坠为止</li></ul></li><li>对于大根堆<ul><li>被删除的元素用堆底元素替代</li><li>比较该元素与<strong>更大的孩子节点</strong>的元素，如果<strong>小于孩子节点</strong>，让该元素下坠</li><li>直到无法下坠为止</li></ul></li></ul><p><img src="/../image/assets/image-20230725201337325.png" alt="image-20230725201337325"></p><p><img src="/../image/assets/image-20230725201352015.png" alt="image-20230725201352015"></p><p><img src="/../image/assets/image-20230725201401545.png" alt="image-20230725201401545"></p><p><img src="/../image/assets/image-20230725201320610.png" alt="image-20230725201320610"></p><p><img src="/../image/assets/image-20230725201416696.png" alt="image-20230725201416696"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>归并：把两个或多个已经有序的序列合并为一个</li></ul><h4 id="二路归并"><a href="#二路归并" class="headerlink" title="二路归并"></a>二路归并</h4><ul><li><p><strong>对比 i 、j 所指元素，选择更小的一个放入 k 所指位置</strong></p></li><li><p>当一个有序序列已经放完之后，另一个有序序列剩下的值可以依次放入合并序列</p></li><li><p>2个有序序列合并成一个</p></li><li><p>每选出一个小元素需要对比关键字1次</p></li></ul><p><img src="/../image/assets/image-20230725203021969.png" alt="image-20230725203021969"></p><ul><li>二路归并操作</li></ul><p><img src="/../image/assets/image-20230725202651174.png" alt="image-20230725202651174"></p><p><img src="/../image/assets/image-20230725203038524.png" alt="image-20230725203038524"></p><p><img src="/../image/assets/image-20230725203047872.png" alt="image-20230725203047872"></p><p><img src="/../image/assets/image-20230725203059487.png" alt="image-20230725203059487"></p><p><img src="/../image/assets/image-20230725203109773.png" alt="image-20230725203109773"></p><p><img src="/../image/assets/image-20230725203119949.png" alt="image-20230725203119949"></p><p><img src="/../image/assets/image-20230725203130240.png" alt="image-20230725203130240"></p><p><img src="/../image/assets/image-20230725203140609.png" alt="image-20230725203140609"></p><p><img src="/../image/assets/image-20230725203152316.png" alt="image-20230725203152316"></p><p><img src="/../image/assets/image-20230725203207077.png" alt="image-20230725203207077"></p><p><img src="/../image/assets/image-20230725203219245.png" alt="image-20230725203219245"></p><h4 id="4路归并"><a href="#4路归并" class="headerlink" title="4路归并"></a>4路归并</h4><ul><li><p>4个有序序列合并成一个</p></li><li><p>每选出一个小元素需要对比关键字3次</p></li></ul><p><img src="/../image/assets/image-20230725203402908.png" alt="image-20230725203402908"></p><h4 id="m路归并"><a href="#m路归并" class="headerlink" title="m路归并"></a>m路归并</h4><ul><li><p>M个有序序列合并成一个</p></li><li><p>每选出一个小元素需要对比关键字m -1次</p></li></ul><h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><ul><li>内部排序中一般采用2路归并</li></ul><p><img src="/../image/assets/image-20230725203421526.png" alt="image-20230725203421526"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="一次归并"><a href="#一次归并" class="headerlink" title="一次归并"></a>一次归并</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> *B = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k&lt;=high; k++)</span><br><span class="line">        B[k]=A[k];                          <span class="comment">//将A中所有的元素复制到B中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) A[k]=B[i++];         <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span> A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230725204009409.png" alt="image-20230725204009409"></p><p><img src="/../image/assets/image-20230725204827555.png" alt="image-20230725204827555"></p><p><img src="/../image/assets/image-20230725204838432.png" alt="image-20230725204838432"></p><p><img src="/../image/assets/image-20230725204849672.png" alt="image-20230725204849672"></p><p><img src="/../image/assets/image-20230725204859933.png" alt="image-20230725204859933"></p><p><img src="/../image/assets/image-20230725204915610.png" alt="image-20230725204915610"></p><p><img src="/../image/assets/image-20230725204926506.png" alt="image-20230725204926506"></p><p><img src="/../image/assets/image-20230725204937719.png" alt="image-20230725204937719"></p><p><img src="/../image/assets/image-20230725204947549.png" alt="image-20230725204947549"></p><p><img src="/../image/assets/image-20230725205003729.png" alt="image-20230725205003729"></p><p><img src="/../image/assets/image-20230725205017025.png" alt="image-20230725205017025"></p><p><img src="/../image/assets/image-20230725205033397.png" alt="image-20230725205033397"></p><p><img src="/../image/assets/image-20230725205043997.png" alt="image-20230725205043997"></p><p><img src="/../image/assets/image-20230725205055844.png" alt="image-20230725205055844"></p><p><img src="/../image/assets/image-20230725205114216.png" alt="image-20230725205114216"></p><h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><ul><li><p>将一个序列从中间分成两个子序列</p></li><li><p>将左右两个子序列分别进行归并排序得到两个有序子序列</p></li><li><p>然后两个子序列进行归并</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> *B = (<span class="type">int</span> *) <span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low...mid]和 A[mid+1...high]各自有序，将两部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k&lt;=high; k++)</span><br><span class="line">        B[k]=A[k];                          <span class="comment">//将A中所有的元素复制到B中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) A[k]=B[i++];         <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span> A[k]=B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;           <span class="comment">//从中间划分</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A,low,mid);               <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A,mid+<span class="number">1</span>,high);            <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(A,low,mid,high);              <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230725205700754.png" alt="image-20230725205700754"></p><h3 id="算法效率分析-3"><a href="#算法效率分析-3" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul><li><strong>时间复杂度：归并排序——O(nlog2n)     每趟归并——O(n)    归并次数——O(log2n)</strong><ul><li>2路归并到归并树——形态上就是一棵倒立的二叉树<ul><li>二叉树的第h层最多有2^(h-1)个节点</li><li>若树高为h，则应满足 n&lt;&#x3D;2^(h-1)</li><li>即 h-1 &#x3D; log2n</li></ul></li><li>结论：n个元素进行二路归并排序，归并的趟数log2n，每趟归并时间复杂度O(n)，算法时间复杂度O(n*log2n)</li></ul></li><li><strong>空间复杂度 &#x3D; O(n)，辅助数组B</strong></li><li>稳定性：稳定的</li></ul><p><img src="/../image/assets/image-20230725205921824.png" alt="image-20230725205921824"></p><h2 id="基数排序（Radix-Sort）（手算）"><a href="#基数排序（Radix-Sort）（手算）" class="headerlink" title="基数排序（Radix Sort）（手算）"></a>基数排序（Radix Sort）（手算）</h2><ul><li>不是基于比较的排序算法</li><li>通常基于链式存储实现</li></ul><p><img src="/../image/assets/image-20230725214935131.png" alt="image-20230725214935131"></p><h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><ul><li><p>从<strong>个位</strong>开始进行<strong>分配入队</strong>（队列先进先出），直到最大数字的最高位</p></li><li><p>每次分配完都进行一次收集，按照从9~0的顺序，下一次分配也按照上一次收集的顺序进行分配</p></li><li><p>例子</p><ul><li><p>第一趟</p><ul><li>按个位进行分配，<strong>先分配的先入队</strong></li><li>收集结束：得到按<strong>个位递减</strong>排序的序列</li></ul></li><li><p>第二趟</p><ul><li>将第一趟收集得到的序列，按十位进行分配，<strong>个位越大的越先入队</strong></li><li>收集结束：得到按<strong>十位递减</strong>排序的序列，<strong>十位相同的按照个位递减</strong>排序</li></ul></li><li><p>第三趟</p><ul><li>将第二趟收集得到的序列，按百位进行分配，<strong>十位越大的越先入队</strong></li><li>收集结束：得到按<strong>百位递减</strong>排序的序列，百位相同的按照十位递减排序，十位相同的按照个位递减排序</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230725212520973.png" alt="image-20230725212520973"></p><ul><li><p>文字描述</p><ul><li><p>假设⻓度为n的线性表中每个结点<em>a**j</em>的关键字由<em>d</em>元组 (<em>kjd</em>−1, <em>kjd</em>−2, <em>kjd</em>−3, . . . , <em>kj</em>1, <em>kj</em>0) 组成</p><p>其中，0≤kij ≤ r - 1（0≤j＜n, 0≤i≤d - 1），r 称为“基数”（0～9，r&#x3D;10）</p><ul><li>例如：985 由 (9,8,5) 组成<ul><li>最高位关键字（最主位关键字）：9</li><li>最低位关键字（最次位关键字）：5</li></ul></li></ul></li><li><p>基数排序得到递减序列的过程如下</p><ul><li>初始化： 设置 <strong>r 个空队列</strong>，Qr-1, Qr-2,…, Q0 </li><li>按照各个 <strong>关键字位</strong> <strong>权重递增</strong>的次序（个、⼗、百），对 d 个关键字位分别做“分配”和“收集”</li><li>分配：顺序扫描各个元素，若当前处理的关键字位&#x3D;x，则将元素插⼊ Qx 队尾</li><li>收集：把 Qr-1, Qr-2,…, Q0 各个队列中的结点依次出队并链接</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230725213040387.png" alt="image-20230725213040387"></p><ul><li>第一趟 分配+收集</li></ul><p><img src="/../image/assets/image-20230725210817695.png" alt="image-20230725210817695"></p><p><img src="/../image/assets/image-20230725210828667.png" alt="image-20230725210828667"></p><p><img src="/../image/assets/image-20230725210844009.png" alt="image-20230725210844009"></p><p><img src="/../image/assets/image-20230725211001130.png" alt="image-20230725211001130"></p><p><img src="/../image/assets/image-20230725210940638.png" alt="image-20230725210940638"></p><ul><li>第二趟</li></ul><p><img src="/../image/assets/image-20230725211633444.png" alt="image-20230725211633444"></p><p><img src="/../image/assets/image-20230725211905553.png" alt="image-20230725211905553"></p><p><img src="/../image/assets/image-20230725211919446.png" alt="image-20230725211919446"></p><p><img src="/../image/assets/image-20230725211931366.png" alt="image-20230725211931366"></p><p><img src="/../image/assets/image-20230725211949903.png" alt="image-20230725211949903"></p><ul><li>第三趟</li></ul><p><img src="/../image/assets/image-20230725212348607.png" alt="image-20230725212348607"></p><p><img src="/../image/assets/image-20230725212406668.png" alt="image-20230725212406668"></p><p><img src="/../image/assets/image-20230725212420245.png" alt="image-20230725212420245"></p><p><img src="/../image/assets/image-20230725212430973.png" alt="image-20230725212430973"></p><p><img src="/../image/assets/image-20230725212450165.png" alt="image-20230725212450165"></p><h3 id="算法效率分析-4"><a href="#算法效率分析-4" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elemtype int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><ul><li>基数排序通常基于链式存储实现</li><li>空间复杂度 &#x3D; O(r)：需要 r 个辅助队列</li><li>时间复杂度 &#x3D; O(d*(n+r))：一趟分配O(n)，一趟收集O(r)，总共d趟分配收集</li><li>稳定性：稳定的</li></ul><p><img src="/../image/assets/image-20230725213852693.png" alt="image-20230725213852693"></p><ul><li>收集一个队列只需要O(1)</li></ul><p><img src="/../image/assets/image-20230725214449076.png" alt="image-20230725214449076"></p><p><img src="/../image/assets/image-20230725214510767.png" alt="image-20230725214510767"></p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p><img src="/../image/assets/image-20230725214715643.png" alt="image-20230725214715643"></p><h4 id="适合解决的问题"><a href="#适合解决的问题" class="headerlink" title="适合解决的问题"></a>适合解决的问题</h4><ul><li>数据元素的关键字可以方便的拆分为 d 组，且d较小</li><li>每组关键字的取值范围不大，即 r 较小</li><li>数据元素个数 n 较大</li></ul><p><img src="/../image/assets/image-20230725214834606.png" alt="image-20230725214834606"></p><h4 id="不适合解决的问题"><a href="#不适合解决的问题" class="headerlink" title="不适合解决的问题"></a>不适合解决的问题</h4><p><img src="/../image/assets/image-20230725215006532.png" alt="image-20230725215006532"></p><h2 id="外部排序-1"><a href="#外部排序-1" class="headerlink" title="外部排序"></a>外部排序</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="外存与内存之间的数据交换"><a href="#外存与内存之间的数据交换" class="headerlink" title="外存与内存之间的数据交换"></a>外存与内存之间的数据交换</h4><ul><li>外存：磁盘</li><li>内存</li><li>操作系统以“块”为单位对磁盘存储空间进行管理，如：每块大小1KB；各个磁盘块内存放着各种各样的数据</li><li>磁盘的读&#x2F;写以“块”为单位，数据读入内存后才能被修改，修改完了还要写回磁盘</li></ul><p><img src="/../image/assets/image-20230725215415099.png" alt="image-20230725215415099"></p><p><img src="/../image/assets/image-20230725220134285.png" alt="image-20230725220134285"></p><p><img src="/../image/assets/image-20230725220151257.png" alt="image-20230725220151257"></p><p><img src="/../image/assets/image-20230725220446105.png" alt="image-20230725220446105"></p><h4 id="外部排序的原理"><a href="#外部排序的原理" class="headerlink" title="外部排序的原理"></a>外部排序的原理</h4><ul><li>原因：数据元素太多，无法一次全部读入内存进行排序</li><li>使用<strong>归并排序</strong>的方法，最少只需要在内存中分配 3 块大小的缓冲区即可对任意一个大文件进行排序<ul><li>先将两个块的数据传入内存的输入缓冲区1，2</li><li>对输入缓冲区1，2的数据进行归并排序，得到有序序列</li><li>将输入缓冲区去1，2的数据依次放入输出缓冲区，写回磁盘块</li><li>得到一个有序的“<strong>归并段</strong>”（两个磁盘块组成的有序序列）</li></ul></li></ul><p><img src="/../image/assets/image-20230725220216598.png" alt="image-20230725220216598"></p><h5 id="构造初始归并段"><a href="#构造初始归并段" class="headerlink" title="构造初始归并段"></a>构造初始归并段</h5><ul><li>读入到输入缓冲区</li></ul><p><img src="/../image/assets/image-20230725220526055.png" alt="image-20230725220526055"></p><ul><li>归并排序</li></ul><p><img src="/../image/assets/image-20230725220545500.png" alt="image-20230725220545500"></p><ul><li>写入磁盘</li></ul><p><img src="/../image/assets/image-20230725220848703.png" alt="image-20230725220848703"></p><p><img src="/../image/assets/image-20230725220900378.png" alt="image-20230725220900378"></p><ul><li>得到有序的归并段</li></ul><p><img src="/../image/assets/image-20230725220924221.png" alt="image-20230725220924221"></p><p><img src="/../image/assets/image-20230725220953274.png" alt="image-20230725220953274"></p><h5 id="第一趟归并"><a href="#第一趟归并" class="headerlink" title="第一趟归并"></a>第一趟归并</h5><ul><li>把8个有序子序列（初始归并段）两两归并<ul><li>将归并好的元素放到输出缓冲区</li><li>当输出缓冲区满的时候，写回磁盘块中</li><li>缓冲区1 空了就要<strong>⽴即</strong>⽤归并段1 的下⼀块补上</li><li>缓冲区2 空了就要<strong>⽴即</strong>⽤归并段2 的下⼀块补上<ul><li>如果空了，必须要先补上才能进行下一次归并</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230725221326699.png" alt="image-20230725221326699"></p><ul><li>读入归并段1的第一块 和 归并段2的第一块</li></ul><p><img src="/../image/assets/image-20230725221426212.png" alt="image-20230725221426212"></p><ul><li>进行归并排序</li></ul><p><img src="/../image/assets/image-20230725221505754.png" alt="image-20230725221505754"></p><p><img src="/../image/assets/image-20230725221532802.png" alt="image-20230725221532802"></p><p><img src="/../image/assets/image-20230725221544580.png" alt="image-20230725221544580"></p><ul><li>输出缓冲区满，写回磁盘块</li></ul><p><img src="/../image/assets/image-20230725221558304.png" alt="image-20230725221558304"></p><p><img src="/../image/assets/image-20230725221717104.png" alt="image-20230725221717104"></p><ul><li>输入缓冲区1空了要立即用归并段1的下一块补上</li></ul><p><img src="/../image/assets/image-20230725221805157.png" alt="image-20230725221805157"></p><p><img src="/../image/assets/image-20230725221852638.png" alt="image-20230725221852638"></p><p><img src="/../image/assets/image-20230725221903474.png" alt="image-20230725221903474"></p><ul><li>缓冲区2空了就要立即用归并段2的下一块补上</li></ul><p><img src="/../image/assets/image-20230725221915227.png" alt="image-20230725221915227"></p><p><img src="/../image/assets/image-20230725221927162.png" alt="image-20230725221927162"></p><p><img src="/../image/assets/image-20230725221946571.png" alt="image-20230725221946571"></p><p><img src="/../image/assets/image-20230725221956549.png" alt="image-20230725221956549"></p><p><img src="/../image/assets/image-20230725222007523.png" alt="image-20230725222007523"></p><p><img src="/../image/assets/image-20230725222017595.png" alt="image-20230725222017595"></p><ul><li>结束</li></ul><p><img src="/../image/assets/image-20230725222035954.png" alt="image-20230725222035954"></p><p><img src="/../image/assets/image-20230725222317107.png" alt="image-20230725222317107"></p><h5 id="第二趟归并"><a href="#第二趟归并" class="headerlink" title="第二趟归并"></a>第二趟归并</h5><ul><li>与第一趟相同</li></ul><p><img src="/../image/assets/image-20230725222526263.png" alt="image-20230725222526263"></p><p><img src="/../image/assets/image-20230725222630409.png" alt="image-20230725222630409"></p><p><img src="/../image/assets/image-20230725222558152.png" alt="image-20230725222558152"></p><p><img src="/../image/assets/image-20230725222736300.png" alt="image-20230725222736300"></p><p><img src="/../image/assets/image-20230725222748185.png" alt="image-20230725222748185"></p><h5 id="第三趟归并"><a href="#第三趟归并" class="headerlink" title="第三趟归并"></a>第三趟归并</h5><p><img src="/../image/assets/image-20230725222836718.png" alt="image-20230725222836718"></p><p><img src="/../image/assets/image-20230725222847815.png" alt="image-20230725222847815"></p><h4 id="时间开销分析"><a href="#时间开销分析" class="headerlink" title="时间开销分析"></a>时间开销分析</h4><ul><li>外部排序时间开销 &#x3D; 读写外存的时间 + 内部排序所需时间 + 内部归并所需时间</li></ul><p><img src="/../image/assets/image-20230725223001449.png" alt="image-20230725223001449"></p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><h5 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h5><ul><li><p>优点</p><ul><li><p>可以减少归并趟数，从而减少磁盘I&#x2F;O（读写）次数</p><ul><li><p>对 r 个初始归并段，做k路归并，则归并树可⽤ <strong>k</strong> 叉树表示，若树⾼为h，则归并趟数 <strong>&#x3D; h-1 &#x3D;</strong> ⌈logkr⌉</p></li><li><p>k越⼤，r越⼩，归并趟数越少，读写磁盘次数越少</p></li></ul></li></ul></li><li><p>缺点</p></li><li><p>k路归并时，需要开辟k个缓冲区，内存开销增加</p></li><li><p>每挑选一个关键字需要对比关键字（k-1）次，内部归并所需时间增加</p></li></ul><p><img src="/../image/assets/image-20230725223809286.png" alt="image-20230725223809286"></p><p><img src="/../image/assets/image-20230725223208211.png" alt="image-20230725223208211"></p><p><img src="/../image/assets/image-20230725223256627.png" alt="image-20230725223256627"></p><h5 id="减少初始归并段数量"><a href="#减少初始归并段数量" class="headerlink" title="减少初始归并段数量"></a>减少初始归并段数量</h5><ul><li>对r个初始归并段，做k路归并，则归并树可用k叉树表示</li><li>树高为h，则归并趟数 &#x3D; h-1 &#x3D; [logkr]<ul><li>k越大，r越小，归并趟数越少，读写磁盘次数越少</li></ul></li><li>结论：若能增加初始归并段的长度，则可减少初始归并段数量r</li></ul><p><img src="/../image/assets/image-20230725224140759.png" alt="image-20230725224140759"></p><p><img src="/../image/assets/image-20230725224049117.png" alt="image-20230725224049117"></p><p><img src="/../image/assets/image-20230725224104863.png" alt="image-20230725224104863"></p><p><img src="/../image/assets/image-20230725224115937.png" alt="image-20230725224115937"></p><p><img src="/../image/assets/image-20230725224126575.png" alt="image-20230725224126575"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/../image/assets/image-20230725224424029.png" alt="image-20230725224424029"></p><h4 id="纠正：多路平衡归并"><a href="#纠正：多路平衡归并" class="headerlink" title="纠正：多路平衡归并"></a>纠正：多路平衡归并</h4><ul><li>k路平衡归并<ul><li>最多只能有k个段归并为一个</li><li>每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到[m&#x2F;k]个新的归并段</li></ul></li></ul><p><img src="/../image/assets/image-20230725224535205.png" alt="image-20230725224535205"></p><h5 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h5><p><img src="/../image/assets/image-20230725224742543.png" alt="image-20230725224742543"></p><h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><h4 id="多路平衡归并带来的问题"><a href="#多路平衡归并带来的问题" class="headerlink" title="多路平衡归并带来的问题"></a>多路平衡归并带来的问题</h4><ul><li>使用k路平衡归并策略，选出一个最小元素需要对比关键字（k-1）次，导致内部归并所需时间增加</li></ul><p><img src="/../image/assets/image-20230725224915899.png" alt="image-20230725224915899"></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>通俗定义</p><ul><li><p>失败者留在这一回合，胜利者进入下一回合比拼</p></li><li><p>最后只有一个冠军在所有比拼中获胜</p><ul><li>若有8位参赛者，则构造败者树需要7次比拼</li></ul></li></ul></li><li><p>败者树——可视为⼀棵完全⼆叉树（多了⼀个头头）。</p><ul><li><em>k</em>个叶结点分别是当前参加⽐较的元素</li><li>⾮叶⼦结点⽤来记忆左右⼦树中的“失败者”</li><li>⽽胜者往上继续进⾏⽐较，⼀直到根结点。</li></ul></li></ul><p><img src="/../image/assets/image-20230725225342850.png" alt="image-20230725225342850"></p><h4 id="败者树的使用"><a href="#败者树的使用" class="headerlink" title="败者树的使用"></a>败者树的使用</h4><ul><li>基于已经构建好的败者树，选出新的胜者只需进行3场比赛</li></ul><p><img src="/../image/assets/image-20230725225554880.png" alt="image-20230725225554880"></p><p><img src="/../image/assets/image-20230725225605389.png" alt="image-20230725225605389"></p><p><img src="/../image/assets/image-20230725225615486.png" alt="image-20230725225615486"></p><p><img src="/../image/assets/image-20230725225626003.png" alt="image-20230725225626003"></p><h4 id="败者树在多路平衡归并中的应用"><a href="#败者树在多路平衡归并中的应用" class="headerlink" title="败者树在多路平衡归并中的应用"></a>败者树在多路平衡归并中的应用</h4><ul><li><p>构成</p><ul><li><p>每个叶子节点对应一个归并段</p></li><li><p>分支节点记录失败败者来自哪个归并段</p></li><li><p>根节点记录冠军来自哪个归并段</p></li></ul></li><li><p>操作</p><ul><li><p>k路归并，第一次构造败者树需要对比关键字k-1次</p></li><li><p>有了败者树，选出最小元素，只需对比关键字[log2k]（向上取整）次</p></li></ul></li><li><p>第一次构造败者树</p></li></ul><p><img src="/../image/assets/image-20230726142220567.png" alt="image-20230726142220567"></p><p><img src="/../image/assets/image-20230726142241497.png" alt="image-20230726142241497"></p><p><img src="/../image/assets/image-20230726142253675.png" alt="image-20230726142253675"></p><ul><li>选出第二个元素</li></ul><p><img src="/../image/assets/image-20230726142700556.png" alt="image-20230726142700556"></p><p><img src="/../image/assets/image-20230726142712402.png" alt="image-20230726142712402"></p><p><img src="/../image/assets/image-20230726142742972.png" alt="image-20230726142742972"></p><p><img src="/../image/assets/image-20230726143016081.png" alt="image-20230726143016081"></p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li>k路归并的败者树只需要定义一个长度为k的数组即可</li><li>数组中的数据<ul><li>Ls[0]代表胜者</li><li>Ls[1…k-1]代表失败者</li></ul></li></ul><p><img src="/../image/assets/image-20230726143314546.png" alt="image-20230726143314546"></p><p><img src="/../image/assets/image-20230726143325058.png" alt="image-20230726143325058"></p><h3 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h3><h4 id="土方法构造初始归并段"><a href="#土方法构造初始归并段" class="headerlink" title="土方法构造初始归并段"></a>土方法构造初始归并段</h4><ul><li>可以用一片更大的内存区域来进行内部排序<ul><li>如：可容纳18个记录</li><li>每个“初始归并段”可包含18个记录</li></ul></li><li>用于内部排序的内存工作区WA可容纳 l 个记录，则每个初始归并段也只能包含 l 个记录，若文件共有 n 个记录，则初始归并段的数量 r &#x3D; n &#x2F; l</li></ul><p><img src="/../image/assets/image-20230726143821823.png" alt="image-20230726143821823"></p><h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><ul><li><p>使⽤<strong>置换-选择</strong>排序，可以让每个初始归并段的⻓度超越内存⼯作区⼤⼩的限制</p></li><li><p>实现过程</p><ul><li><p>初始化归并段输出文件FO</p></li><li><p>将初始待排序文件 FI 输入到内存工作区 WA 中，将其填满</p></li><li><p>置换</p><ul><li>把内存工作区中最小的元素置换出去，并且记录这一最小元素 MINIMAX</li><li>如果后来输入的元素比 MINIMAX 小，则将其进行标记，不输出；而是选择比 MINIMAX 大的最小值进行输出</li><li>当被标记的元素满的时候（内存工作区中所有元素都小于 MINIMAX），将之前的输出元素作为一个归并段</li><li>选择一个新的归并段</li></ul></li><li><p>重复置换直到待排序文件为空</p></li></ul></li></ul><p><img src="/../image/assets/image-20230726145427072.png" alt="image-20230726145427072"></p><ul><li>初始化</li></ul><p><img src="/../image/assets/image-20230726144452814.png" alt="image-20230726144452814"></p><ul><li>第一趟置换</li></ul><p><img src="/../image/assets/image-20230726144508572.png" alt="image-20230726144508572"></p><p><img src="/../image/assets/image-20230726144520465.png" alt="image-20230726144520465"></p><p><img src="/../image/assets/image-20230726144539913.png" alt="image-20230726144539913"></p><p><img src="/../image/assets/image-20230726144552112.png" alt="image-20230726144552112"></p><p><img src="/../image/assets/image-20230726144605976.png" alt="image-20230726144605976"></p><p><img src="/../image/assets/image-20230726144617031.png" alt="image-20230726144617031"></p><p><img src="/../image/assets/image-20230726144633311.png" alt="image-20230726144633311"></p><ul><li>第二趟置换</li></ul><p><img src="/../image/assets/image-20230726145142679.png" alt="image-20230726145142679"></p><p><img src="/../image/assets/image-20230726145159914.png" alt="image-20230726145159914"></p><ul><li>第三趟置换</li></ul><p><img src="/../image/assets/image-20230726145214685.png" alt="image-20230726145214685"></p><p><img src="/../image/assets/image-20230726145228519.png" alt="image-20230726145228519"></p><h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><h4 id="归并树的性质"><a href="#归并树的性质" class="headerlink" title="归并树的性质"></a>归并树的性质</h4><ul><li>每个初始归并段看作一个叶子节点，归并段的长度作为节点权值，则<ul><li><strong>归并树的带权路径长度 WPL &#x3D; 读磁盘的次数 &#x3D; 写磁盘的次数</strong></li></ul></li><li>结论：归并过程中的磁盘 I&#x2F;O 次数 &#x3D; 归并树的WPL * 2</li><li>要让磁盘 I&#x2F;O 次数最少，就要使归并树 WPL 最小 —— 哈夫曼树</li></ul><p><img src="/../image/assets/image-20230726145934146.png" alt="image-20230726145934146"></p><h4 id="构造二路归并的最佳归并树"><a href="#构造二路归并的最佳归并树" class="headerlink" title="构造二路归并的最佳归并树"></a>构造二路归并的最佳归并树</h4><p><img src="/../image/assets/image-20230726150334074.png" alt="image-20230726150334074"></p><h4 id="多路归并的最佳归并树"><a href="#多路归并的最佳归并树" class="headerlink" title="多路归并的最佳归并树"></a>多路归并的最佳归并树</h4><ul><li><p>只有<strong>叶子节点要 乘以 权值进行相加</strong></p></li><li><p>一般情况</p></li></ul><p><img src="/../image/assets/image-20230726150853636.png" alt="image-20230726150853636"></p><ul><li>最佳归并树</li></ul><p><img src="/../image/assets/image-20230726151115096.png" alt="image-20230726151115096"></p><h4 id="如果减少一个归并段，利用上述规则，无法得到最佳归并树"><a href="#如果减少一个归并段，利用上述规则，无法得到最佳归并树" class="headerlink" title="如果减少一个归并段，利用上述规则，无法得到最佳归并树"></a>如果减少一个归并段，利用上述规则，无法得到最佳归并树</h4><p><img src="/../image/assets/image-20230726151155031.png" alt="image-20230726151155031"></p><ul><li>正确做法<ul><li>对于 k 叉归并，若初始归并段的数量无法满足构成严格的 k 叉归并树，则需要补充几个长度为 0 的“虚段”，再进行 k 叉哈夫曼树的构造</li><li>长度为 0 的虚段：在输入缓冲区什么都不用放</li></ul></li></ul><p><img src="/../image/assets/image-20230726151253362.png" alt="image-20230726151253362"></p><p><img src="/../image/assets/image-20230726151446916.png" alt="image-20230726151446916"></p><h4 id="添加虚段的数量（k-1-u）"><a href="#添加虚段的数量（k-1-u）" class="headerlink" title="添加虚段的数量（k - 1 - u）"></a>添加虚段的数量（k - 1 - u）</h4><ul><li>对于 k  叉归并，若初始归并段的数量无法构成严格的 k 叉归并树，则需要补充几个长度为 0的虚段，再进行 k 叉哈夫曼树的构造</li><li>k 叉的最佳归并树一定是一棵严格的 k 叉树，即树中只包含度为 k、度为 0的节点<ul><li>设度为 k的节点有nk个，度为0的节点有 n0个，归并树的总节点数&#x3D;n</li><li>初始归并段数量 + 虚段数量 &#x3D; n0</li><li>n &#x3D; n0 + nk</li><li>k * nk &#x3D; n - 1</li><li>得到：n0 &#x3D; (k-1) * nk + 1</li><li>结论：**nk &#x3D; (n0 - 1)&#x2F;(k - 1)**（如果是严格k叉树，一定能除得尽（所有的数都是整数））</li></ul></li><li><strong>若（初始归并段数量 - 1）% （k - 1）&#x3D; 0；说明刚好可以构成严格 k 叉树，此时不需要添加虚段</strong></li><li><strong>若（初始归并段数量 - 1）% （k - 1）&#x3D; u !&#x3D; 0；则需要补充（k - 1）- u 个虚段</strong></li></ul><p><img src="/../image/assets/image-20230726151816101.png" alt="image-20230726151816101"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="1-基于小根堆如何建堆、排序"><a href="#1-基于小根堆如何建堆、排序" class="headerlink" title="1. 基于小根堆如何建堆、排序"></a>1. 基于小根堆如何建堆、排序</h3><p><img src="/../image/assets/image-20230725195756007.png" alt="image-20230725195756007"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.htm</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="排序" scheme="https://sdumoist.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="https://sdumoist.github.io/2023/07/20/%E6%9F%A5%E6%89%BE/"/>
    <id>https://sdumoist.github.io/2023/07/20/%E6%9F%A5%E6%89%BE/</id>
    <published>2023-07-20T06:47:23.233Z</published>
    <updated>2024-03-30T19:25:25.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230720151803579.png" alt="image-20230720151803579"></p><p><img src="/../image/assets/image-20230720163518914.png" alt="image-20230720163518914"></p><p><img src="/../image/assets/image-20230720171828290.png" alt="image-20230720171828290"></p><p><img src="/../image/assets/image-20230720193721514.png" alt="image-20230720193721514"></p><p><img src="/../image/assets/image-20230722161737579.png" alt="image-20230722161737579"></p><p><img src="/../image/assets/image-20230722202438050.png" alt="image-20230722202438050"></p><p><img src="/../image/assets/image-20230724142942715.png" alt="image-20230724142942715"></p><p><img src="/../image/assets/image-20230724163237627.png" alt="image-20230724163237627"></p><p><img src="/../image/assets/image-20230724163355112.png" alt="image-20230724163355112"></p><p><img src="/../image/assets/image-20230724163549182.png" alt="image-20230724163549182"></p><p><img src="/../image/assets/image-20230724173036104.png" alt="image-20230724173036104"></p><p><img src="/../image/assets/image-20230724181955470.png" alt="image-20230724181955470"></p><p><img src="/../image/assets/image-20230724195322682.png" alt="image-20230724195322682"></p><p><img src="/../image/assets/image-20230724202139255.png" alt="image-20230724202139255"></p><p><img src="/../image/assets/image-20230724213136956.png" alt="image-20230724213136956"></p><p><img src="/../image/assets/image-20230724220841760.png" alt="image-20230724220841760"></p><p><img src="/../image/assets/image-20230724221816325.png" alt="image-20230724221816325"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p><strong>在数据集合中寻找满足某种条件的数据元素的过程称为查找</strong></p><h3 id="查找表（查找结构）"><a href="#查找表（查找结构）" class="headerlink" title="查找表（查找结构）"></a>查找表（查找结构）</h3><p>用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成</p><h3 id="关键字（类似数据库的主键，唯一不重复）"><a href="#关键字（类似数据库的主键，唯一不重复）" class="headerlink" title="关键字（类似数据库的主键，唯一不重复）"></a>关键字（类似数据库的主键，唯一不重复）</h3><p>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结构应该是唯一的</p><p><img src="/../image/assets/image-20230720145132778.png" alt="image-20230720145132778"></p><p><img src="/../image/assets/image-20230720150747878.png" alt="image-20230720150747878"></p><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ul><li><p>操作</p><ol><li><p>查找复合条件的数据元素</p></li><li><p>插入、删除某个数据元素</p></li></ol></li><li><p>应用</p><ul><li><p>只需进行操作1——静态查找表（仅关注查找速度即可）</p></li><li><p>也要进行操作2——动态查找表（除了查找速度，也要关注插&#x2F;删操作是否方便实现）</p></li></ul></li></ul><p><img src="/../image/assets/image-20230720151115044.png" alt="image-20230720151115044"></p><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><h4 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h4><ul><li>在查找运算中，需要对比关键字的次数称为查找长度</li></ul><h4 id="平均查找长度（ASL，Average-Search-Length"><a href="#平均查找长度（ASL，Average-Search-Length" class="headerlink" title="平均查找长度（ASL，Average Search Length)"></a>平均查找长度（ASL，Average Search Length)</h4><ul><li><p>所有查找过程中进行关键字的比较次数的平均值</p></li><li><p><strong>ASL的数量级反映了查找算法的时间复杂度</strong></p></li></ul><p><img src="/../image/assets/image-20230720151601756.png" alt="image-20230720151601756"></p><p><img src="/../image/assets/image-20230720151629670.png" alt="image-20230720151629670"></p><p><img src="/../image/assets/image-20230720151732726.png" alt="image-20230720151732726"></p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul><li>顺序查找，又叫“线性查找”，通常用于线性表（顺序表，链表）</li></ul><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>从头到jio挨个找（反过来也ok）</li></ul><p><img src="/../image/assets/image-20230720152101739.png" alt="image-20230720152101739"></p><p><img src="/../image/assets/image-20230720152116493.png" alt="image-20230720152116493"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现（查找失败越界返回-1）"><a href="#代码实现（查找失败越界返回-1）" class="headerlink" title="代码实现（查找失败越界返回-1）"></a>代码实现（查找失败越界返回-1）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                     <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;                 <span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;                   <span class="comment">//表的长度</span></span><br><span class="line">&#125;   SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, Elemtype key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ST.TableLen &amp;&amp; ST.elem[i]!= key;++i);</span><br><span class="line">    <span class="comment">//查找成功，则返回元素下标；查找失败，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> i==ST.TableLen? <span class="number">-1</span>:i;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230720153446093.png" alt="image-20230720153446093"></p><p><img src="/../image/assets/image-20230720153617255.png" alt="image-20230720153617255"></p><h4 id="代码实现（哨兵）"><a href="#代码实现（哨兵）" class="headerlink" title="代码实现（哨兵）"></a>代码实现（哨兵）</h4><ul><li>优点：无需判断是否越界，效率更高</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找2（哨兵）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, Elemtype key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key;                 <span class="comment">//“哨兵”</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = ST.TableLen; ST.elem[i]!=key; --i);<span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">return</span> i;                       <span class="comment">//查找成功，则返回元素下标；查找失败，则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230720154028514.png" alt="image-20230720154028514"></p><p><img src="/../image/assets/image-20230720154051155.png" alt="image-20230720154051155"></p><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><p><img src="/../image/assets/image-20230720154501231.png" alt="image-20230720154501231"></p><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h4><ul><li>查找判定树</li></ul><p><img src="/../image/assets/image-20230720154713715.png" alt="image-20230720154713715"></p><h5 id="用查找判定树分析ASL"><a href="#用查找判定树分析ASL" class="headerlink" title="用查找判定树分析ASL"></a>用查找判定树分析ASL</h5><ul><li><p>一个成功节点的查找长度 &#x3D; 自身所在层数</p></li><li><p>一个失败节点的查找长度 &#x3D; 其父节点所在层数</p></li><li><p>默认情况下，各种失败情况或成功情况都等概率发生</p></li></ul><p><img src="/../image/assets/image-20230720154943367.png" alt="image-20230720154943367"></p><h4 id="被查概率不相等"><a href="#被查概率不相等" class="headerlink" title="被查概率不相等"></a>被查概率不相等</h4><ul><li>被查概率大的放在靠前位置</li></ul><p><img src="/../image/assets/image-20230720163441562.png" alt="image-20230720163441562"></p><h2 id="折半查找（有序的顺序表）"><a href="#折半查找（有序的顺序表）" class="headerlink" title="折半查找（有序的顺序表）"></a>折半查找（有序的顺序表）</h2><ul><li>折半查找，又叫“二分查找”，仅适用于<strong>有序的顺序表</strong></li><li>顺序表具有随机访问的特性，链表没有</li></ul><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><h4 id="查找成功"><a href="#查找成功" class="headerlink" title="查找成功"></a>查找成功</h4><p><img src="/../image/assets/image-20230720163809803.png" alt="image-20230720163809803"></p><p><img src="/../image/assets/image-20230720163832693.png" alt="image-20230720163832693"></p><p><img src="/../image/assets/image-20230720163850632.png" alt="image-20230720163850632"></p><p><img src="/../image/assets/image-20230720163947281.png" alt="image-20230720163947281"></p><h4 id="查找失败"><a href="#查找失败" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/../image/assets/image-20230720164025165.png" alt="image-20230720164025165"></p><p><img src="/../image/assets/image-20230720164043841.png" alt="image-20230720164043841"></p><p><img src="/../image/assets/image-20230720164059749.png" alt="image-20230720164059749"></p><p><img src="/../image/assets/image-20230720164111054.png" alt="image-20230720164111054"></p><p><img src="/../image/assets/image-20230720164144253.png" alt="image-20230720164144253"></p><p><img src="/../image/assets/image-20230720164129188.png" alt="image-20230720164129188"></p><p><img src="/../image/assets/image-20230720164229668.png" alt="image-20230720164229668"></p><p><img src="/../image/assets/image-20230720164240561.png" alt="image-20230720164240561"></p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现-升序数组"><a href="#代码实现-升序数组" class="headerlink" title="代码实现(升序数组)"></a>代码实现(升序数组)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                             <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;                         <span class="comment">//动态数组的基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;                           <span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable L,Elemtype key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>, high = L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;                   <span class="comment">//取中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key) <span class="keyword">return</span> mid;    <span class="comment">//查找成功则返回所在位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key) high = mid<span class="number">-1</span>;    <span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;                 <span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                              <span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230720164831854.png" alt="image-20230720164831854"></p><h4 id="效率分析-1"><a href="#效率分析-1" class="headerlink" title="效率分析"></a>效率分析</h4><p><img src="/../image/assets/image-20230720165155165.png" alt="image-20230720165155165"></p><p><img src="/../image/assets/image-20230720165232737.png" alt="image-20230720165232737"></p><h3 id="折半查找判定树的构造（重点）"><a href="#折半查找判定树的构造（重点）" class="headerlink" title="折半查找判定树的构造（重点）"></a>折半查找判定树的构造（重点）</h3><h4 id="奇数个"><a href="#奇数个" class="headerlink" title="奇数个"></a>奇数个</h4><p><img src="/../image/assets/image-20230720165422920.png" alt="image-20230720165422920"></p><p><img src="/../image/assets/image-20230720165449422.png" alt="image-20230720165449422"></p><h4 id="偶数个"><a href="#偶数个" class="headerlink" title="偶数个"></a>偶数个</h4><ul><li>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</li><li>如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</li><li>mid&#x3D;[(low+high)&#x2F;2]，则对任何一个节点，必有：<strong>右子树节点数-左子树节点数&#x3D;0&#x2F;1</strong>（右子树节点数比左子树多）</li></ul><p><img src="/../image/assets/image-20230720165535360.png" alt="image-20230720165535360"></p><p><img src="/../image/assets/image-20230720165555996.png" alt="image-20230720165555996"></p><p><img src="/../image/assets/image-20230720165908597.png" alt="image-20230720165908597"></p><h4 id="构造方法及性质"><a href="#构造方法及性质" class="headerlink" title="构造方法及性质"></a>构造方法及性质</h4><ul><li>构造的形状唯一</li><li>折半查找的判定树一定是平衡二叉树，只有最下面一层是不满的（元素个数为n时，树高h&#x3D;[log2(n+1)]向上取整）</li><li>新节点优先右子树，但是右子树只能最多比左子树多一个<ul><li>左右子树相等，新节点加到右子树</li><li>左右子树不相等（右子树比左子树节点多），新节点加到左子树</li></ul></li></ul><p><img src="/../image/assets/image-20230720170738197.png" alt="image-20230720170738197"><br><img src="/../image/assets/image-20230720171045853.png" alt="image-20230720171045853"></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>判定树节点关键字：左&lt;中&lt;右，满足二叉排序树的定义</li><li>失败节点：n+1个（等于成功节点的空链域数量）</li></ul><p><img src="/../image/assets/image-20230720171259153.png" alt="image-20230720171259153"></p><p><img src="/../image/assets/image-20230720171558671.png" alt="image-20230720171558671"></p><h4 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h4><ul><li>树高h &#x3D; [log2(n+1)]向上取整（不包括失败节点）<ul><li>查找成功：ASL &lt;&#x3D; h</li><li>查找失败：ASL &lt;&#x3D; h</li><li>时间复杂度 &#x3D; O(log2n)</li></ul></li></ul><p><img src="/../image/assets/image-20230720172600920.png" alt="image-20230720172600920"></p><h4 id="另一种情况的折半查找"><a href="#另一种情况的折半查找" class="headerlink" title="另一种情况的折半查找"></a>另一种情况的折半查找</h4><ul><li>mid &#x3D; [(low+high)&#x2F;2]向上取整</li></ul><p><img src="/../image/assets/image-20230720172215927.png" alt="image-20230720172215927"></p><p><img src="/../image/assets/image-20230720172253774.png" alt="image-20230720172253774"></p><p><img src="/../image/assets/image-20230720172400811.png" alt="image-20230720172400811"></p><h3 id="折半查找的速度一定比顺序查找更快？"><a href="#折半查找的速度一定比顺序查找更快？" class="headerlink" title="折半查找的速度一定比顺序查找更快？"></a>折半查找的速度一定比顺序查找更快？</h3><ul><li><p>大部分情况下，折半查找更快；但不是任何情况下都更快</p></li><li><p>折半查找时间复杂度 &#x3D; O(log2n)</p></li><li><p>顺序查找的时间复杂度 &#x3D; O(n)</p></li></ul><p><img src="/../image/assets/image-20230720172019138.png" alt="image-20230720172019138"></p><h2 id="分块查找（选择题）"><a href="#分块查找（选择题）" class="headerlink" title="分块查找（选择题）"></a>分块查找（选择题）</h2><ul><li><strong>分块查找</strong>，又称<strong>索引顺序查找</strong></li></ul><h3 id="算法思想（顺序查找和折半查找的结合）"><a href="#算法思想（顺序查找和折半查找的结合）" class="headerlink" title="算法思想（顺序查找和折半查找的结合）"></a>算法思想（顺序查找和折半查找的结合）</h3><ul><li>索引表：保存每个分块的最大关键字和分块的存储区间</li></ul><p><img src="/../image/assets/image-20230720174031300.png" alt="image-20230720174031300"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>算法过程如下：<ol><li>在索引表中确定待查记录所属的分块（可顺序、可折半）（索引表是有序的）<ul><li>查找目标 &gt; 索引值：下一个</li><li>查找目标 &lt;&#x3D; 索引值：选择该索引范围</li></ul></li><li>在块内顺序查找（块内的元素是无序的）</li></ol></li></ul><h4 id="查找成功-1"><a href="#查找成功-1" class="headerlink" title="查找成功"></a>查找成功</h4><p><img src="/../image/assets/image-20230720174148215.png" alt="image-20230720174148215"></p><p><img src="/../image/assets/image-20230720174234584.png" alt="image-20230720174234584"></p><p><img src="/../image/assets/image-20230720174246063.png" alt="image-20230720174246063"></p><p><img src="/../image/assets/image-20230720174502881.png" alt="image-20230720174502881"></p><p><img src="/../image/assets/image-20230720174518270.png" alt="image-20230720174518270"></p><h4 id="查找失败-1"><a href="#查找失败-1" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/../image/assets/image-20230720174607035.png" alt="image-20230720174607035"></p><p><img src="/../image/assets/image-20230720174620988.png" alt="image-20230720174620988"></p><p><img src="/../image/assets/image-20230720174630296.png" alt="image-20230720174630296"></p><p><img src="/../image/assets/image-20230720174656119.png" alt="image-20230720174656119"></p><p><img src="/../image/assets/image-20230720174704687.png" alt="image-20230720174704687"></p><p><img src="/../image/assets/image-20230720174716649.png" alt="image-20230720174716649"></p><p><img src="/../image/assets/image-20230720174724729.png" alt="image-20230720174724729"></p><p><img src="/../image/assets/image-20230720174750762.png" alt="image-20230720174750762"></p><h4 id="用折半查找查索引"><a href="#用折半查找查索引" class="headerlink" title="用折半查找查索引"></a>用折半查找查索引</h4><ul><li>查找目标在索引表里面</li></ul><p><img src="/../image/assets/image-20230720175129067.png" alt="image-20230720175129067"></p><p><img src="/../image/assets/image-20230720175213153.png" alt="image-20230720175213153"></p><p><img src="/../image/assets/image-20230720175252687.png" alt="image-20230720175252687"></p><p><img src="/../image/assets/image-20230720175232459.png" alt="image-20230720175232459"></p><h4 id="用折半查找查索引2"><a href="#用折半查找查索引2" class="headerlink" title="用折半查找查索引2"></a>用折半查找查索引2</h4><ul><li>查找目标不在索引表里面</li><li>若索引表中不包含目标关键字，则折半查找索引表最终停在low&gt;high,<strong>要在low所指分块中查找</strong><ul><li>原因：最终low左边一定小雨目标关键字，high右边一定大雨目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字</li></ul></li></ul><p><img src="/../image/assets/image-20230720175443863.png" alt="image-20230720175443863"></p><p><img src="/../image/assets/image-20230720175500012.png" alt="image-20230720175500012"></p><p><img src="/../image/assets/image-20230720175516433.png" alt="image-20230720175516433"></p><p><img src="/../image/assets/image-20230720175535318.png" alt="image-20230720175535318"></p><p><img src="/../image/assets/image-20230720175606707.png" alt="image-20230720175606707"></p><p><img src="/../image/assets/image-20230720175624368.png" alt="image-20230720175624368"></p><p><img src="/../image/assets/image-20230720192236475.png" alt="image-20230720192236475"></p><p><img src="/../image/assets/image-20230720192252235.png" alt="image-20230720192252235"></p><p><img src="/../image/assets/image-20230720192305940.png" alt="image-20230720192305940"></p><h4 id="查找失败-2"><a href="#查找失败-2" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/../image/assets/image-20230720192347781.png" alt="image-20230720192347781"></p><h3 id="查找效率分析（ASL）"><a href="#查找效率分析（ASL）" class="headerlink" title="查找效率分析（ASL）"></a>查找效率分析（ASL）</h3><h4 id="查找成功-2"><a href="#查找成功-2" class="headerlink" title="查找成功"></a>查找成功</h4><p><img src="/../image/assets/image-20230720192435475.png" alt="image-20230720192435475"></p><p><img src="/../image/assets/image-20230720192531733.png" alt="image-20230720192531733"></p><ul><li>30：4次</li><li>27：不是2次。因为27不在索引表中，要增加三次直到找到索引表的位置</li></ul><p><img src="/../image/assets/image-20230720192735045.png" alt="image-20230720192735045"></p><h4 id="查找失败-3"><a href="#查找失败-3" class="headerlink" title="查找失败"></a>查找失败</h4><p><img src="/../image/assets/image-20230720192825925.png" alt="image-20230720192825925"></p><h4 id="效率优化"><a href="#效率优化" class="headerlink" title="效率优化"></a>效率优化</h4><ul><li><p>假设：长度为n的查找表被均匀地分为b块，每块s个元素          n&#x3D;s*b</p></li><li><p>设索引查找和块内查找的平均查找长度分别为L1、L2，则分块查找的平均查找长度为ASL&#x3D;Li+Ls</p><ul><li>用<strong>顺序查找</strong>查索引表<ul><li>ASL&#x3D;1&#x2F;2*s + n&#x2F;2*s + 1</li><li>最小的ASL &#x3D; 根号n+1（当s &#x3D; 根号n，b &#x3D; 根号n）</li></ul></li><li>用<strong>折半查找</strong>查索引表</li></ul></li></ul><p><img src="/../image/assets/image-20230720193338939.png" alt="image-20230720193338939"></p><p><img src="/../image/assets/image-20230720193658770.png" alt="image-20230720193658770"></p><h2 id="树形查找"><a href="#树形查找" class="headerlink" title="树形查找"></a>树形查找</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>二叉排序树，又称二叉查找树（<strong>BST</strong>，Binary Search Tree）</li><li>一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：<ul><li>左子树上所有节点的关键字均小于根节点的关键字</li><li>右子树上所有节点的关键字均大于根节点的关键字</li><li>左子树和右子树又各是一棵二叉排序树</li></ul></li><li>左子树节点值 &lt; 根节点值 &lt; 右子树节点值<ul><li>进行中序遍历，可以得到一个递增的有序序列</li></ul></li><li>二叉排序树可用于元素的有序组织、搜索</li></ul><p><img src="/../image/assets/image-20230721222332589.png" alt="image-20230721222332589"></p><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>若树非空，目标值与根节点的值比较：<ul><li>若相等，则查找成功</li><li>若小于根节点，则在左子树上查找，否则在右子树上查找</li></ul></li><li>查找成功，返回节点指针</li><li>查找失败返回NULL</li></ul><h5 id="查找成功-3"><a href="#查找成功-3" class="headerlink" title="查找成功"></a>查找成功</h5><p><img src="/../image/assets/image-20230721222616468.png" alt="image-20230721222616468"></p><p><img src="/../image/assets/image-20230721223154791.png" alt="image-20230721223154791"></p><h5 id="查找失败-4"><a href="#查找失败-4" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/../image/assets/image-20230721223604519.png" alt="image-20230721223604519"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>有两种实现方式<ul><li>一种是非递归<ul><li>while(T !&#x3D; NULL &amp;&amp; key !&#x3D; T-&gt;key);</li></ul></li><li>一种是递归<ul><li>return BST_Search2(T-&gt;lchild, key);</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的节点（非递归）</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;key)&#123;      <span class="comment">//若树空或等于根节点值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;key) T = T -&gt; lchild;   <span class="comment">//小于，则在左子树上查找</span></span><br><span class="line">        <span class="keyword">else</span> T = T-&gt;rchild;                 <span class="comment">//大于，则在右子树上查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树中寻找值为key的节点（递归）</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search2</span><span class="params">(BSTree T, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">//查找失败</span></span><br><span class="line">    <span class="keyword">if</span>(key == T-&gt;key)  <span class="keyword">return</span> T;            <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key) <span class="keyword">return</span> <span class="built_in">BST_Search2</span>(T-&gt;lchild, key);       <span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">BST_Search2</span>(T-&gt;rchild, key);                        <span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230722130753338.png" alt="image-20230722130753338"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>若原二叉排序树为空，则直接插入节点</li><li>若二叉排序树不为空<ul><li>若关键字k小于根节点值，则插入到左子树</li><li>若关键字k大于根节点值，则插入到右子树</li></ul></li></ul><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><p><img src="/../image/assets/image-20230722143338669.png" alt="image-20230722143338669"></p><h5 id="代码实现（递归）"><a href="#代码实现（递归）" class="headerlink" title="代码实现（递归）"></a>代码实现（递归）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树插入关键字为k的新节点（递归实现）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;                            <span class="comment">//原数为空，新插入的节点为根节点</span></span><br><span class="line">        T=(BSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//T-&gt;lchild = T-&gt;rchild = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">//返回1，插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)                      <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)                       <span class="comment">//插入T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild, k);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild, k);   <span class="comment">//插入T的右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码实现（非递归）"><a href="#代码实现（非递归）" class="headerlink" title="代码实现（非递归）"></a>代码实现（非递归）</h5><h4 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h4><ul><li>不同的关键字序列可能得到同款二叉排序树</li></ul><p><img src="/../image/assets/image-20230722143918303.png" alt="image-20230722143918303"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;                               <span class="comment">//初始时，T为空树</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;                           <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        <span class="built_in">BST_Insert</span>(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相同的关键字，不同排列可能得到不同款的二叉排序树</li></ul><p><img src="/../image/assets/image-20230722143956854.png" alt="image-20230722143956854"></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>先搜索找到目标节点<ul><li>若被删除节点z是叶子节点，则直接删除，不会破坏二叉排序树的性质</li><li>若被删除节点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，代替z的位置</li><li>若被删除节点z有左右两棵子树，则令z的直接后继（或直接前驱）代替z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况<ul><li>原理<ul><li>左子树 &lt; 根节点 &lt; 右子树</li><li>进行中序遍历，可以得到一个递增的有序序列</li><li>所以将左子树中最后一个被中序遍历的（左边最大的），或者右子树中最早一个被中序遍历的（右边最小的）删去，放到删除的节点上，就可以保证中序遍历结果不变，且能保持二叉排序树</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230722144151517.png" alt="image-20230722144151517"></p><p><img src="/../image/assets/image-20230722144258357.png" alt="image-20230722144258357"></p><p><img src="/../image/assets/image-20230722144902838.png" alt="image-20230722144902838"></p><p><img src="/../image/assets/image-20230722145007236.png" alt="image-20230722145007236"></p><p><img src="/../image/assets/image-20230722145028053.png" alt="image-20230722145028053"></p><p><img src="/../image/assets/image-20230722145040306.png" alt="image-20230722145040306"></p><h4 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul><li>查找长度<ul><li>在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度</li></ul></li></ul><h5 id="查找成功-4"><a href="#查找成功-4" class="headerlink" title="查找成功"></a>查找成功</h5><ul><li><p>ASL，查找成功的平均查找长度</p></li><li><p>若树高h，找到最下层的一个节点需要对比h次</p></li><li><p>最好情况</p><ul><li>n个节点的二叉树最小高度为[log2n]向下取整+1</li><li>平均查找长度 &#x3D; O(log2n)</li></ul></li><li><p>最坏情况</p><ul><li>每个节点只有一个分支</li><li>树高h &#x3D; 节点数n</li><li>平均查找长度 &#x3D; O(n)</li></ul></li></ul><p><img src="/../image/assets/image-20230722145307895.png" alt="image-20230722145307895"></p><h5 id="查找失败-5"><a href="#查找失败-5" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/../image/assets/image-20230722145836191.png" alt="image-20230722145836191"></p><h5 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h5><ul><li>平衡二叉树，树上任一节点的左子树和右子树的深度之差不超过1</li></ul><p><img src="/../image/assets/image-20230722145755248.png" alt="image-20230722145755248"></p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树）<ul><li>树上任一节点的左子树和右子树的高度之差不超过1</li></ul></li><li>结点的平衡因子 &#x3D; 左子树高 - 右子树高<ul><li>平衡二叉树节点的平衡因子值只可能是-1，0，1</li><li>只要有任一节点的平衡因子绝对值大于1，就不是平衡二叉树</li></ul></li></ul><p><img src="/../image/assets/image-20230722151329439.png" alt="image-20230722151329439"></p><ul><li>结构体定义</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;                        <span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> balancel;                    <span class="comment">//平衡因子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *lchild, *rchild;    </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure><h4 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>每次插入新节点后，调整<strong>最小不平衡子树</strong></li><li>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先节点都会恢复平衡</li></ul><p><img src="/../image/assets/image-20230722151905858.png" alt="image-20230722151905858"></p><h4 id="插入新节点后如何调整“不平衡”问题"><a href="#插入新节点后如何调整“不平衡”问题" class="headerlink" title="插入新节点后如何调整“不平衡”问题"></a>插入新节点后如何调整“不平衡”问题</h4><h5 id="不平衡情况"><a href="#不平衡情况" class="headerlink" title="不平衡情况"></a>不平衡情况</h5><ul><li>LL：在A的左孩子的左子树中插入导致不平衡</li><li>RR：在A的右孩子的右子树中插入导致不平衡</li><li>LR：在A的左孩子的右子树中插入导致不平衡</li><li>RL：在A的右孩子的左子树中插入导致不平衡</li></ul><p><img src="/../image/assets/image-20230722152244959.png" alt="image-20230722152244959"></p><h5 id="调整最小不平衡子树"><a href="#调整最小不平衡子树" class="headerlink" title="调整最小不平衡子树"></a>调整最小不平衡子树</h5><ul><li><p>插入新节点前，应该是有平衡因子为1或-1的情况，即左子树与右子树不相等</p></li><li><p>插入新节点后，平衡因子为2或-2导致不平衡</p></li><li><p>目标</p><ul><li>恢复平衡</li><li>保持二叉排序树的特性<ul><li>左子树节点值 &lt; 根节点值 &lt; 右子树节点值</li></ul></li></ul></li><li><p>LL：右单旋转</p><ul><li>原因：在节点A的左孩子的左子树上插入了新节点，A的平衡因子由1增加到2</li><li>操作：将A的左孩子B向右上旋转代替A成为根节点，将A节点向右下旋转成为B右子树的根节点，B原右子树作为A的左子树</li></ul></li><li><p>RR：左单旋转</p><ul><li>在节点A的右孩子的右子树上插入了新节点，A的平衡因子由-1减小到-2</li><li>操作：将A的右孩子B向左上旋转代替A成为根节点，将A节点向左下旋转成为B的左子树的根节点，而B的原左子树则作为A节点的右子树</li></ul></li></ul><h6 id="LL：右旋"><a href="#LL：右旋" class="headerlink" title="LL：右旋"></a>LL：右旋</h6><ul><li>原因：在节点A的左孩子的左子树上插入了新节点，A的平衡因子由1增加到2</li><li>操作：将A的左孩子B向右上旋转代替A成为根节点，将A节点向右下旋转成为B右子树的根节点，B原右子树作为A的左子树</li></ul><p><img src="/../image/assets/image-20230722152648580.png" alt="image-20230722152648580"></p><h6 id="RR：左旋"><a href="#RR：左旋" class="headerlink" title="RR：左旋"></a>RR：左旋</h6><ul><li>在节点A的右孩子的右子树上插入了新节点，A的平衡因子由-1减小到-2</li><li>操作：将A的右孩子B向左上旋转代替A成为根节点，将A节点向左下旋转成为B的左子树的根节点，而B的原左子树则作为A节点的右子树</li></ul><p><img src="/../image/assets/image-20230722153725461.png" alt="image-20230722153725461"></p><h6 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h6><p><img src="/../image/assets/image-20230722154139187.png" alt="image-20230722154139187"></p><h6 id="LR：先左后右"><a href="#LR：先左后右" class="headerlink" title="LR：先左后右"></a>LR：先左后右</h6><ul><li>原因：由于在A的左孩子的右子树上插入新节点，A的平衡因子由1增加到2</li><li>操作：先将A节点的左孩子B的右子树的根节点C向左上旋转提升到B节点的位置，然后再把C节点向右上旋转提升到A节点的位置</li></ul><p><img src="/../image/assets/image-20230722154639021.png" alt="image-20230722154639021"></p><p><img src="/../image/assets/image-20230722154709712.png" alt="image-20230722154709712"></p><p><img src="/../image/assets/image-20230722154725853.png" alt="image-20230722154725853"></p><h6 id="RL：先右再左"><a href="#RL：先右再左" class="headerlink" title="RL：先右再左"></a>RL：先右再左</h6><ul><li>原因：在A的右孩子的左子树上插入新节点，A的平衡因子由-1减到-2，导致以A为根的子树失去平衡</li><li>操作：先将A节点的左孩子B的根节点C向右上旋转提升到B节点的位置，然后再把该C节点向左上旋转提升到A节点的位置</li></ul><p><img src="/../image/assets/image-20230722154920933.png" alt="image-20230722154920933"></p><p><img src="/../image/assets/image-20230722154933284.png" alt="image-20230722154933284"></p><p><img src="/../image/assets/image-20230722154945762.png" alt="image-20230722154945762"></p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ul><li>只有左孩子才能右上旋</li><li>只有右孩子才能左上旋</li></ul><p><img src="/../image/assets/image-20230722155327108.png" alt="image-20230722155327108"></p><h5 id="只要调整最小平衡子树，其他祖先节点就能恢复平衡"><a href="#只要调整最小平衡子树，其他祖先节点就能恢复平衡" class="headerlink" title="只要调整最小平衡子树，其他祖先节点就能恢复平衡"></a>只要调整最小平衡子树，其他祖先节点就能恢复平衡</h5><ul><li>插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复</li></ul><p><img src="/../image/assets/image-20230722155532175.png" alt="image-20230722155532175"></p><p><img src="/../image/assets/image-20230722155716901.png" alt="image-20230722155716901"></p><p><img src="/../image/assets/image-20230722155730461.png" alt="image-20230722155730461"></p><h6 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h6><ul><li>RR<ul><li>找到第一个不平衡的点</li><li>往下数一个节点——作为新的跟节点</li><li>旧根节点作为新根节点的左子树</li><li>新根节点原来的左子树变成左子树的右子树</li></ul></li></ul><p><img src="/../image/assets/image-20230722160123223.png" alt="image-20230722160123223"></p><p><img src="/../image/assets/image-20230722160133825.png" alt="image-20230722160133825"></p><ul><li>RL<ul><li>找到第一个不平衡的节点</li><li>往下数两个节点——新的根节点</li><li>往下数的第一个节点是新根节点的左节点，旧根节点是新根节点的右节点</li><li>新根节点原先的左子树给到左边的右子树</li><li>新根节点原来的右子树给到右边的左子树</li></ul></li></ul><p><img src="/../image/assets/image-20230722160145092.png" alt="image-20230722160145092"></p><p><img src="/../image/assets/image-20230722160404268.png" alt="image-20230722160404268"></p><p><img src="/../image/assets/image-20230722160548581.png" alt="image-20230722160548581"></p><ul><li>LR</li></ul><p><img src="/../image/assets/image-20230722160839925.png" alt="image-20230722160839925"></p><p><img src="/../image/assets/image-20230722160851663.png" alt="image-20230722160851663"></p><h4 id="查找效率分析-1"><a href="#查找效率分析-1" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul><li>若树高为h，最坏情况下查找一个关键字最多需要对比h次，即查找操作的时间复杂度不肯呢个超过O(h)</li><li>所以应该尽可能降低树高<ul><li>假设以nh表示深度为h的平衡树中含有的最少节点数</li><li>则有n0 &#x3D; 0, n1 &#x3D; 1, n2 &#x3D; 2,并且nh &#x3D; n(h-1) + n(h-2) + 1（n(h-1)：h-1层最少的节点数；n(h-2)：h-2层最少的节点数）</li></ul></li><li>平均查找长度：O(log2n)</li></ul><p><img src="/../image/assets/image-20230722161325806.png" alt="image-20230722161325806"></p><h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="插入-VS-删除"><a href="#插入-VS-删除" class="headerlink" title="插入 VS 删除"></a>插入 VS 删除</h5><ul><li>平衡二叉树的插入操作<ul><li>插入新节点后，要保持二叉排序树的特性不变（左&lt;中&lt;右）</li><li>若插入新节点导致不平衡，则需要调整平衡</li></ul></li><li>平衡二叉树的删除操作<ul><li>删除节点后，要保持二叉排序树的特性不变</li><li>若删除节点导致不平衡，则需要调整平衡</li></ul></li></ul><h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><ul><li>平衡二叉树删除操作<ul><li>删除节点（方法同“二叉排序树”）<ul><li>若被删除节点z是叶子节点，则直接删除，不会破坏二叉排序树的性质</li><li>若被删除节点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，代替z的位置</li><li>若被删除节点z有左右两棵子树，则令z的直接后继（或直接前驱）代替z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况</li></ul></li><li>一路向上找到最小不平衡子树，找不到就完结撒花</li><li>找最小不平衡子树下，个头最高的儿子、孙子</li><li>根据孙子的位置，调整平衡（LL&#x2F;RR&#x2F;LR&#x2F;RL）</li><li>如果不平衡向上传导，继续2</li></ul></li></ul><h5 id="例一：未出现不平衡现象"><a href="#例一：未出现不平衡现象" class="headerlink" title="例一：未出现不平衡现象"></a>例一：未出现不平衡现象</h5><p><img src="/../image/assets/image-20230722170523667.png" alt="image-20230722170523667"></p><h5 id="例二：出现不平衡现象"><a href="#例二：出现不平衡现象" class="headerlink" title="例二：出现不平衡现象"></a>例二：出现不平衡现象</h5><p><img src="/../image/assets/image-20230722170659751.png" alt="image-20230722170659751"></p><ul><li>寻找最小不平衡子树</li></ul><p><img src="/../image/assets/image-20230722170711073.png" alt="image-20230722170711073"></p><ul><li>寻找个头最高的儿子、孙子</li></ul><p><img src="/../image/assets/image-20230722170841722.png" alt="image-20230722170841722"></p><ul><li>根据孙子的位置，调整平衡</li></ul><p><img src="/../image/assets/image-20230722171008471.png" alt="image-20230722171008471"></p><p><img src="/../image/assets/image-20230722171059051.png" alt="image-20230722171059051"></p><ul><li>检查不平衡性是否向上传导（高度减少引起的）</li></ul><p><img src="/../image/assets/image-20230722171140684.png" alt="image-20230722171140684"></p><h5 id="例三：出现不平衡现象"><a href="#例三：出现不平衡现象" class="headerlink" title="例三：出现不平衡现象"></a>例三：出现不平衡现象</h5><ul><li>删除节点</li></ul><p><img src="/../image/assets/image-20230722171239949.png" alt="image-20230722171239949"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/../image/assets/image-20230722171327214.png" alt="image-20230722171327214"></p><ul><li>找个头最高的儿子、孙子</li></ul><p><img src="/../image/assets/image-20230722171353783.png" alt="image-20230722171353783"></p><ul><li>根据孙子的位置，调整平衡</li></ul><p><img src="/../image/assets/image-20230722174330718.png" alt="image-20230722174330718"></p><p><img src="/../image/assets/image-20230722174426010.png" alt="image-20230722174426010"></p><p><img src="/../image/assets/image-20230722174437084.png" alt="image-20230722174437084"></p><ul><li>寻找传导</li></ul><p><img src="/../image/assets/image-20230722174450964.png" alt="image-20230722174450964"></p><h5 id="例四：出现不平衡传导现象"><a href="#例四：出现不平衡传导现象" class="headerlink" title="例四：出现不平衡传导现象"></a>例四：出现不平衡传导现象</h5><ul><li>删除节点</li></ul><p><img src="/../image/assets/image-20230722174533792.png" alt="image-20230722174533792"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/../image/assets/image-20230722174546095.png" alt="image-20230722174546095"></p><ul><li>找到向上传导的不平衡子树</li></ul><p><img src="/../image/assets/image-20230722174556963.png" alt="image-20230722174556963"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/../image/assets/image-20230722174608517.png" alt="image-20230722174608517"></p><ul><li>找到个头最高的儿子、孙子</li></ul><p><img src="/../image/assets/image-20230722174626038.png" alt="image-20230722174626038"></p><ul><li>根据孙子位置，调整平衡</li></ul><p><img src="/../image/assets/image-20230722174636891.png" alt="image-20230722174636891"></p><p><img src="/../image/assets/image-20230722174647349.png" alt="image-20230722174647349"></p><ul><li>寻找向上传导的不平衡</li></ul><p><img src="/../image/assets/image-20230722174747828.png" alt="image-20230722174747828"></p><h5 id="例五：删除的节点不是叶子节点（前驱-后继-不太可能考）"><a href="#例五：删除的节点不是叶子节点（前驱-后继-不太可能考）" class="headerlink" title="例五：删除的节点不是叶子节点（前驱&#x2F;后继  不太可能考）"></a>例五：删除的节点不是叶子节点（前驱&#x2F;后继  不太可能考）</h5><ul><li>按照二叉排序树的顺序，删除叶子节点</li></ul><p><img src="/../image/assets/image-20230722174804992.png" alt="image-20230722174804992"></p><p><img src="/../image/assets/image-20230722201032502.png" alt="image-20230722201032502"></p><p><img src="/../image/assets/image-20230722201306385.png" alt="image-20230722201306385"></p><ul><li>寻找最小不平衡树</li></ul><p><img src="/../image/assets/image-20230722201429690.png" alt="image-20230722201429690"></p><ul><li>找到个头最高的儿子、孙子</li></ul><p><img src="/../image/assets/image-20230722201455517.png" alt="image-20230722201455517"></p><ul><li>根据孙子的位置，调整平衡</li></ul><p><img src="/../image/assets/image-20230722201520289.png" alt="image-20230722201520289"></p><ul><li>寻找向上传导的不平衡子树</li></ul><p><img src="/../image/assets/image-20230722201551458.png" alt="image-20230722201551458"></p><h5 id="例六：孙子-儿子个头相等（不太可能考）"><a href="#例六：孙子-儿子个头相等（不太可能考）" class="headerlink" title="例六：孙子&#x2F;儿子个头相等（不太可能考）"></a>例六：孙子&#x2F;儿子个头相等（不太可能考）</h5><ul><li>删除节点</li></ul><p><img src="/../image/assets/image-20230722201847149.png" alt="image-20230722201847149"></p><p><img src="/../image/assets/image-20230722201857078.png" alt="image-20230722201857078"></p><ul><li>找到最小不平衡子树</li></ul><p><img src="/../image/assets/image-20230722201908691.png" alt="image-20230722201908691"></p><ul><li>找到个头最高的儿子、孙子（这里孙子个头相等）</li><li>假设选择右孙子</li></ul><p><img src="/../image/assets/image-20230722201921210.png" alt="image-20230722201921210"></p><p><img src="/../image/assets/image-20230722201955749.png" alt="image-20230722201955749"></p><ul><li>寻找传导</li></ul><p><img src="/../image/assets/image-20230722202222835.png" alt="image-20230722202222835"></p><ul><li>找到个头最高的儿子、孙子（这里孙子个头相等）</li><li>假设选择左孙子</li></ul><p><img src="/../image/assets/image-20230722202307745.png" alt="image-20230722202307745"></p><ul><li>RL：调整平衡</li></ul><p><img src="/../image/assets/image-20230722202329133.png" alt="image-20230722202329133"></p><p><img src="/../image/assets/image-20230722202346340.png" alt="image-20230722202346340"></p><ul><li>寻找传导</li></ul><p><img src="/../image/assets/image-20230722202402979.png" alt="image-20230722202402979"></p><h3 id="红黑树（RBT）"><a href="#红黑树（RBT）" class="headerlink" title="红黑树（RBT）"></a>红黑树（RBT）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><h5 id="为什么要发明红黑树？"><a href="#为什么要发明红黑树？" class="headerlink" title="为什么要发明红黑树？"></a>为什么要发明红黑树？</h5><ul><li><p>为什么要发明红黑树？</p><ul><li><p>平衡二叉树AVL</p><ul><li>插入&#x2F;删除太麻烦了，适用于以查为主，很少插入&#x2F;删除的场景</li><li>插入&#x2F;删除很容易破坏“平衡”特性，需要频繁调整树的形态</li><li>插入操作导致不平衡，则需先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL&#x2F;RR&#x2F;LR&#x2F;RL调整</li></ul></li><li><p>红黑树RBT</p><ul><li>适用于频繁删除&#x2F;插入的场景，实用性更强</li><li>插入&#x2F;删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。</li><li>即使需要调整，一般都可以在常数级时间内完成</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230722203124639.png" alt="image-20230722203124639"></p><h5 id="红黑树大概会怎么考？"><a href="#红黑树大概会怎么考？" class="headerlink" title="红黑树大概会怎么考？"></a>红黑树大概会怎么考？</h5><p><img src="/../image/assets/image-20230722204326527.png" alt="image-20230722204326527"></p><h5 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h5><ul><li>红黑树是二叉排序树<ul><li>左子树节点值 &lt; 根节点值 &lt; 右子树节点值</li></ul></li><li>与普通BST相比有什么要求？<ul><li>每个节点或是红的，或是黑的</li><li><strong>根节点是黑的</strong></li><li><strong>叶节点</strong>（外部节点、NULL节点、失败节点）均是<strong>黑色</strong>的</li><li><strong>不存在两个相邻的红节点</strong>（即红节点的父节点和孩子节点均是黑色的）</li><li>对每个节点，从该节点到任一叶节点的简单路径上，所含<strong>黑节点的数目</strong>相同</li></ul></li></ul><p><img src="/../image/assets/image-20230722205005924.png" alt="image-20230722205005924"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Elemtype int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBNode</span>&#123;              <span class="comment">//红黑树的节点定义</span></span><br><span class="line">    <span class="type">int</span> key;                <span class="comment">//关键字的值</span></span><br><span class="line">    RBNode* parent;         <span class="comment">//父节点指针</span></span><br><span class="line">    RBNode *lchild;         <span class="comment">//左孩子指针</span></span><br><span class="line">    RBNode *rchild;         <span class="comment">//右孩子指针</span></span><br><span class="line">    <span class="type">int</span> color;              <span class="comment">//节点颜色，如：可用0/1 表示 黑/红，也可以用枚举类型enum表示颜色</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230722205045602.png" alt="image-20230722205045602"></p><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p><img src="/../image/assets/image-20230722205411210.png" alt="image-20230722205411210"></p><p><img src="/../image/assets/image-20230722205423079.png" alt="image-20230722205423079"></p><p><img src="/../image/assets/image-20230722205753797.png" alt="image-20230722205753797"></p><p><img src="/../image/assets/image-20230722205902071.png" alt="image-20230722205902071"></p><p><img src="/../image/assets/image-20230722205918687.png" alt="image-20230722205918687"></p><h4 id="节点的黑高bh"><a href="#节点的黑高bh" class="headerlink" title="节点的黑高bh"></a>节点的黑高bh</h4><ul><li>从某节点出发（不含该节点）到达任一空叶节点的路径上黑节点总数</li></ul><p><img src="/../image/assets/image-20230722210040059.png" alt="image-20230722210040059"></p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul><li><p>节点的黑高bh——从某节点出发（不含该节点）到达任一叶节点的路径上黑节点总数</p></li><li><p>根节点黑高为h的红黑树，内部节点数（关键字）至少有多少个</p><ul><li>满二叉树，并且节点全为黑</li><li>内部节点个数至少为2^h-1</li></ul></li><li><p>根节点黑高为h的红黑树，内部节点最多有多少个？</p><ul><li>h层黑节点，每一层黑节点下都铺满一层红节点。共2h层的满树状态</li><li>最多有2^2h - 1个</li></ul></li><li><p>性质一：<strong>从根节点到叶节点的最长路径不大于最短路径的二倍</strong></p><ul><li>左右子树的高度相差不到2倍（条件更宽松，不太容易被破坏）</li><li>而平衡二叉树AVL要求左右子树高度差不超过1（条件更严格，很容易被破坏）</li><li>任何一条查找失败路径上黑节点数量都是相同的，而路径上不能连续出现两个红节点，即红节点只能穿插在各个黑节点中间</li></ul></li><li><p>性质二：<strong>有n个内部节点的红黑树高度 h &lt;&#x3D; 2log2(n+1)</strong></p><ul><li>若红黑树总高度&#x3D;h，则根节点黑高&gt;h&#x2F;2，因此内部节点数n&gt;&#x3D;2^(h&#x2F;2)-1，由此推出h &lt;&#x3D; 2log2(n+1)</li></ul></li><li><p>查找时间复杂度 &#x3D; O(log2n)</p></li></ul><p><img src="/../image/assets/image-20230724161947156.png" alt="image-20230724161947156"></p><p><img src="/../image/assets/image-20230724162337908.png" alt="image-20230724162337908"></p><p><img src="/../image/assets/image-20230722210146870.png" alt="image-20230722210146870"></p><p><img src="/../image/assets/image-20230724162601947.png" alt="image-20230724162601947"></p><h4 id="插入操作-2"><a href="#插入操作-2" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li>先查找，确认插入位置（原理同二叉排序树），插入新节点</li><li>新节点是<strong>根</strong>——染为黑色</li><li>新节点是非根——染为红色<ul><li>若插入新节点后依然满足红黑树的定义，则插入结束</li><li>若插入新节点后不满足红黑树的定义，需要调整，使其重新满足红黑树定义<ul><li>黑叔：旋转+染色<ul><li>LL型：右单旋转，父换爷+染色</li><li>RR型：左单旋转，父换爷+染色</li><li>LR型：左、右双旋，儿换爷+染色</li><li>RL型：右、左双旋，儿换爷+染色</li></ul></li><li>红叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230723233820042.png" alt="image-20230723233820042"></p><h5 id="插入操作举例"><a href="#插入操作举例" class="headerlink" title="插入操作举例"></a>插入操作举例</h5><ul><li><p>左根右：按照二叉排序树的方式插入</p></li><li><p>根叶黑：很容易添加和判断，根节点和为NULL的叶子节点</p></li><li><p>黑路同：添加的都是非根节点，都为红色，所以不会破坏</p></li><li><p><strong>不红红</strong></p><ul><li>是添加新节点所破坏的特性</li><li>看叔叔颜色</li></ul></li><li><p>黑叔叔：旋转+染色</p><ul><li>LL：右单旋转，父爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724135626653.png" alt="image-20230724135626653"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷（三个）染色，爷变为新节点（有可能爷违反不红红特性）</li></ul></li></ul><p><img src="/../image/assets/image-20230724140956016.png" alt="image-20230724140956016"></p><ul><li>黑叔叔：旋转+染色<ul><li>RR：左单旋转，父爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724141105719.png" alt="image-20230724141105719"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/../image/assets/image-20230724141150466.png" alt="image-20230724141150466"></p><ul><li>不需要变色</li></ul><p><img src="/../image/assets/image-20230724141235255.png" alt="image-20230724141235255"></p><ul><li>黑叔叔：旋转+染色<ul><li>LL：右单旋转，父爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724141251547.png" alt="image-20230724141251547"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/../image/assets/image-20230724141330082.png" alt="image-20230724141330082"></p><ul><li>不需要变色</li></ul><p><img src="/../image/assets/image-20230724141531171.png" alt="image-20230724141531171"></p><ul><li>不需要变色</li></ul><p><img src="/../image/assets/image-20230724141557266.png" alt="image-20230724141557266"></p><ul><li>不需要变色</li></ul><p><img src="/../image/assets/image-20230724141700165.png" alt="image-20230724141700165"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li><li>如果根节点变为红色，要变成黑色</li></ul></li></ul><p><img src="/../image/assets/image-20230724141717596.png" alt="image-20230724141717596"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142107748.png" alt="image-20230724142107748"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142204185.png" alt="image-20230724142204185"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142241883.png" alt="image-20230724142241883"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142320887.png" alt="image-20230724142320887"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/../image/assets/image-20230724142400447.png" alt="image-20230724142400447"></p><ul><li>红叔叔：染色+变新<ul><li>叔父爷染色，爷变为新节点</li></ul></li></ul><p><img src="/../image/assets/image-20230724142430892.png" alt="image-20230724142430892"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142519774.png" alt="image-20230724142519774"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿换爷+染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142555702.png" alt="image-20230724142555702"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142634110.png" alt="image-20230724142634110"></p><ul><li>黑叔叔：旋转+染色<ul><li>LR型：左右双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142709720.png" alt="image-20230724142709720"></p><ul><li>不需要变色</li></ul><p><img src="/../image/assets/image-20230724142753160.png" alt="image-20230724142753160"></p><ul><li>黑叔叔：旋转+染色<ul><li>RL型：右左双旋，儿爷染色</li></ul></li></ul><p><img src="/../image/assets/image-20230724142805621.png" alt="image-20230724142805621"></p><p><img src="/../image/assets/image-20230724142851819.png" alt="image-20230724142851819"></p><p><img src="/../image/assets/image-20230724142908091.png" alt="image-20230724142908091"></p><p><img src="/../image/assets/image-20230724142918548.png" alt="image-20230724142918548"></p><h4 id="删除操作（不考）"><a href="#删除操作（不考）" class="headerlink" title="删除操作（不考）"></a>删除操作（不考）</h4><h5 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h5><ul><li>红黑树删除操作的时间复杂度&#x3D;O(log2n)</li><li>在红黑树中删除节点的处理方式和“二叉排序树的删除一样”</li><li>按上述删除节点后，可能破坏红黑树特性，此时需要调整及诶单颜色、位置，使其在此满足红黑树特性</li></ul><p><img src="/../image/assets/image-20230724163228077.png" alt="image-20230724163228077"></p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul><li>考察的主要是性质和手算方法</li><li>如果每个节点只有一个关键字——二叉排序树</li></ul><h4 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h4><p><img src="/../image/assets/image-20230724164208501.png" alt="image-20230724164208501"></p><ul><li>二叉排序树节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> key;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BSTNode, *BSTree;</span><br></pre></td></tr></table></figure><ul><li>5叉排序树</li></ul><p><img src="/../image/assets/image-20230724164413840.png" alt="image-20230724164413840"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Elemtype keys[<span class="number">4</span>];                   <span class="comment">//最多4个关键字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* child[<span class="number">55</span>];             <span class="comment">//最多5个孩子</span></span><br><span class="line">    <span class="type">int</span> num;                            <span class="comment">//节点中有几个关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>节点中keys是顺序排放的，每个节点内也可以采用折半查找</li></ul><h5 id="查找成功-5"><a href="#查找成功-5" class="headerlink" title="查找成功"></a>查找成功</h5><p><img src="/../image/assets/image-20230724165022783.png" alt="image-20230724165022783"></p><p><img src="/../image/assets/image-20230724165036215.png" alt="image-20230724165036215"></p><h5 id="查找失败-6"><a href="#查找失败-6" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/../image/assets/image-20230724165157934.png" alt="image-20230724165157934"></p><p><img src="/../image/assets/image-20230724165216572.png" alt="image-20230724165216572"></p><h4 id="如何保证查找效率"><a href="#如何保证查找效率" class="headerlink" title="如何保证查找效率"></a>如何保证查找效率</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li><p>若每个节点内关键字太少，导致树变高，要查更多层节点，效率变低</p></li><li><p>不够平衡，树会很高，要查很多层节点</p></li></ul><p><img src="/../image/assets/image-20230724170105992.png" alt="image-20230724170105992"></p><p><img src="/../image/assets/image-20230724170133321.png" alt="image-20230724170133321"></p><h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><ul><li><p>m叉查找树中，规定除了根节点外，任何节点至少有[m&#x2F;2]个分叉，即至少含有 [m&#x2F;2]-1 个关键字</p><ul><li><p>Eg：5叉排序树，规定除了根节点外，任何节点都至少有3个分叉，2个关键字</p></li><li><p>为什么除了根节点外？</p><ul><li>如果整个树只有一个元素，根节点只有两个分叉</li></ul></li></ul></li><li><p>m叉排序素中，规定对于任何一个节点，其所有子树的高度都要相同</p></li></ul><p><img src="/../image/assets/image-20230724165555484.png" alt="image-20230724165555484"></p><p><img src="/../image/assets/image-20230724165844965.png" alt="image-20230724165844965"></p><p><img src="/../image/assets/image-20230724170138709.png" alt="image-20230724170138709"></p><h4 id="B树定义"><a href="#B树定义" class="headerlink" title="B树定义"></a>B树定义</h4><ul><li>B树，又称多路平衡查找树<ul><li>B树中所被允许的孩子个数的最大值成为<strong>B树的阶</strong>，通常用m表示</li><li>一棵m阶B树或为空树，或为满足以下特性的m叉树<ul><li>树中每个节点最多有m棵子树，即至多含有m-1个关键字</li><li>若根节点不是终端节点，则至少有两棵子树</li><li>除根节点外的所有非叶节点至少有  <strong>[m&#x2F;2]向上取整</strong>  棵子树，即至少含有[m&#x2F;2]-1个关键字</li><li>所有的叶节点都出现在同一层次上，并且不带信息（可以视为外部节点或类似于折半查找判定树的查找失败节点，实际上这些节点不存在，指向这些节点的指针为空）</li><li>所有非叶子节点的结构如下：<ul><li>n：节点中关键字的个数（[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m-1）</li><li>Ki：节点的关键字，且满足 K1 &lt; K2 &lt; …. &lt; Kn</li><li>Pi：指向子树根节点的指针，且指针Pi-1所指子树中所有节点的关键字均小于Ki，Pi所指子树中所有节点的关键字均大于Ki</li></ul></li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230724170426451.png" alt="image-20230724170426451"></p><p><img src="/../image/assets/image-20230724171123621.png" alt="image-20230724171123621"></p><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><ol><li><p>根节点的子树数[2,m]，关键字数[1,m-1]</p><p>其他节点的子树数[m&#x2F;2,m]，关键字数[[m&#x2F;2-1,m-1]]</p></li><li><p>对任一节点，其所有子树高度相同</p></li><li><p>关键字的值：子树0 &lt; 关键字1 &lt; 子树1 &lt; 关键字2 &lt; 子树2 &lt;…（类似二叉查找树 左 &lt; 中 &lt; 右）</p></li></ol><p><img src="/../image/assets/image-20230724171823380.png" alt="image-20230724171823380"></p><h4 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h4><ul><li><p>B树的高度不包括叶子节点（失败节点）</p></li><li><p>含有n个关键字的m阶B树，最小高度、最大高度是多少？</p><ul><li><p>最小高度——让每个节点尽可能的满，有m-1个关键字，m个分叉，则有</p><p>n &lt;&#x3D; (m-1)(1 + m + m^2 + m^3 +… + m^(h-1)) &#x3D; m^h -1</p><p>h &gt;&#x3D; logm(n+1)</p></li><li><p>最大高度——让各层的分叉尽可能的少，即根节点只有两个分叉，其他节点只有[m&#x2F;2]个分叉</p><p>各层的节点至少有：第一层 1、第二层 2、第三层 2[m&#x2F;2] … 第h层2([m&#x2F;2])^(h-2)</p><p>第h+1层共有叶子节点（失败节点） 2([m&#x2F;2])^(h-1) 个</p><p>n个关键字的B树必有n+1个叶子节点，则 n+1 &gt;&#x3D; 2([m&#x2F;2])^(h-1)，即 h&lt;&#x3D;log[m&#x2F;2]((n+1)&#x2F;2+1)</p></li></ul></li></ul><p><img src="/../image/assets/image-20230724172944340.png" alt="image-20230724172944340"></p><p><img src="/../image/assets/image-20230724171843466.png" alt="image-20230724171843466"></p><p><img src="/../image/assets/image-20230724172635714.png" alt="image-20230724172635714"></p><p><img src="/../image/assets/image-20230724172903538.png" alt="image-20230724172903538"></p><h4 id="插入操作-3"><a href="#插入操作-3" class="headerlink" title="插入操作"></a>插入操作</h4><ul><li><p>在插入key后，若导致原节点关键字数超过上限</p><ul><li><p>从中间位置（[m&#x2F;2]）将其中的关键字分为两部分</p></li><li><p>左部分包含的关键字放在原节点中</p></li><li><p>右部分包含的关键字放到新节点中</p></li><li><p>中间位置（[m&#x2F;2]）的节点插入原节点的父节点</p></li><li><p>若此时导致其<strong>⽗结点的关键字个数</strong>也超过了上限，则继续进⾏这种分裂操作，直⾄这个过程传到根结点为⽌，进</p><p>⽽导致<em>B</em>树<strong>⾼度增<em>1</em></strong>。</p></li></ul></li><li><p>新元素一定是插入到最底层“终端节点”，用查找来确定插入位置</p><ul><li>原因：B树的失败节点只能出现在最下面一层</li></ul></li></ul><p><img src="/../image/assets/image-20230724173338522.png" alt="image-20230724173338522"></p><p><img src="/../image/assets/image-20230724173316457.png" alt="image-20230724173316457"></p><p><img src="/../image/assets/image-20230724174442318.png" alt="image-20230724174442318"></p><h5 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h5><p><img src="/../image/assets/image-20230724174452820.png" alt="image-20230724174452820"></p><h5 id="正确示范"><a href="#正确示范" class="headerlink" title="正确示范"></a>正确示范</h5><p><img src="/../image/assets/image-20230724174612505.png" alt="image-20230724174612505"></p><p><img src="/../image/assets/image-20230724174624053.png" alt="image-20230724174624053"></p><p><img src="/../image/assets/image-20230724174723342.png" alt="image-20230724174723342"></p><p><img src="/../image/assets/image-20230724174737753.png" alt="image-20230724174737753"></p><p><img src="/../image/assets/image-20230724174750008.png" alt="image-20230724174750008"></p><p><img src="/../image/assets/image-20230724174801298.png" alt="image-20230724174801298"></p><p><img src="/../image/assets/image-20230724174917720.png" alt="image-20230724174917720"></p><p><img src="/../image/assets/image-20230724174927975.png" alt="image-20230724174927975"></p><p><img src="/../image/assets/image-20230724174938113.png" alt="image-20230724174938113"></p><p><img src="/../image/assets/image-20230724174949101.png" alt="image-20230724174949101"></p><p><img src="/../image/assets/image-20230724174959449.png" alt="image-20230724174959449"></p><p><img src="/../image/assets/image-20230724175010391.png" alt="image-20230724175010391"></p><p><img src="/../image/assets/image-20230724175022162.png" alt="image-20230724175022162"></p><p><img src="/../image/assets/image-20230724175113722.png" alt="image-20230724175113722"></p><h5 id="核心要求"><a href="#核心要求" class="headerlink" title="核心要求"></a>核心要求</h5><ol><li>对于m阶B树——除根节点外，节点关键字个数[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m-1</li><li>子树0 &lt; 关键字1 &lt; 子树1 &lt; 关键字2 &lt; 子树2 &lt; …</li></ol><p>新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</p><p>在插入key后，若导致原节点关键字数超过上限</p><ul><li><p>从中间位置（[m&#x2F;2]）将其中的关键字分为两部分</p></li><li><p>左部分包含的关键字放在原节点中</p></li><li><p>右部分包含的关键字放到新节点中</p></li><li><p>中间位置（[m&#x2F;2]）的节点插入原节点的父节点</p></li><li><p>若此时导致其<strong>⽗结点的关键字个数</strong>也超过了上限，则继续进⾏这种分裂操作，直⾄这个过程传到根结点为⽌，进</p><p>⽽导致<em>B</em>树<strong>⾼度增<em>1</em></strong>。</p></li></ul><p><img src="/../image/assets/image-20230724175515975.png" alt="image-20230724175515975"></p><h4 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li><p>本质：要永远保证 ⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2&lt;…</p></li><li><p>若被删除关键字在<strong>终端节点</strong>，则直接删除该关键字（要注意节点关键字个数是否低于下限[m&#x2F;2]-1）</p><ul><li><p>关键字个数高于下限，直接删除</p></li><li><p>关键字个数低于下限</p><ul><li><p>兄弟够借：若与此节点右（或左）兄弟节点的关键字个数还很宽裕，则需要调整该节点、右（或左）兄弟节点及其双亲节点（父子换位法）</p><p>用当前节点的后继、后继的后继来填补空缺</p></li><li><p>兄弟不够：若被删除关键字所在节点删除前的关键字个数低于下限，且此时与该节点相邻的左、右兄弟节点的关键字个数均 &#x3D; [m&#x2F;2]-1，则将关键字删除后与<strong>左（或右）兄弟节点及双亲节点中的关键字</strong>进行合并</p><ul><li><p>在合并过程中，双亲结点中的关键字个数会减<em>1</em>。若<strong>其双亲结点是根结点且关键字个数减少⾄<em>0</em></strong>（根结点关键</p><p>字个数为<em>1</em>时，有<em>2</em>棵⼦树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关</p><p>键字个数减少到 ，则⼜要与它⾃⼰的兄弟结点进⾏调整或合并操作，并重复上述步骤，直⾄符合<em>B</em></p><p>树的要求为⽌。</p></li></ul></li></ul></li></ul></li><li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱</strong>或<strong>直接后继</strong>来替代被删除的关键字</p><ul><li>对非终端节点关键字的删除，必然可以转化为对终端节点的删除操作</li><li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</li><li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</li></ul></li><li><p>删除60（终端节点，关键字个数大于下限）</p></li></ul><p><img src="/../image/assets/image-20230724175642625.png" alt="image-20230724175642625"></p><p><img src="/../image/assets/image-20230724175703525.png" alt="image-20230724175703525"></p><ul><li>删除80（非终端节点）</li></ul><p><img src="/../image/assets/image-20230724180158230.png" alt="image-20230724180158230"></p><ul><li>删除38（终端节点，关键字个数低于下限（[m&#x2F;2]-1，右兄弟够借）</li></ul><p><img src="/../image/assets/image-20230724180706078.png" alt="image-20230724180706078"></p><p><img src="/../image/assets/image-20230724180801039.png" alt="image-20230724180801039"></p><p><img src="/../image/assets/image-20230724180743887.png" alt="image-20230724180743887"></p><p><img src="/../image/assets/image-20230724180820612.png" alt="image-20230724180820612"></p><p><img src="/../image/assets/image-20230724180834789.png" alt="image-20230724180834789"></p><ul><li>删除90（终端节点，关键字个数低于下限（[m&#x2F;2]-1，左兄弟够借）</li></ul><p><img src="/../image/assets/image-20230724181054994.png" alt="image-20230724181054994"></p><p><img src="/../image/assets/image-20230724181106247.png" alt="image-20230724181106247"></p><p><img src="/../image/assets/image-20230724181139105.png" alt="image-20230724181139105"></p><ul><li>删除49（终端节点，关键字个数低于下限（[m&#x2F;2]-1，左右兄弟不够借）</li></ul><p><img src="/../image/assets/image-20230724181548842.png" alt="image-20230724181548842"></p><p><img src="/../image/assets/image-20230724181600641.png" alt="image-20230724181600641"></p><p><img src="/../image/assets/image-20230724181612150.png" alt="image-20230724181612150"></p><p><img src="/../image/assets/image-20230724181623803.png" alt="image-20230724181623803"></p><p><img src="/../image/assets/image-20230724181640464.png" alt="image-20230724181640464"></p><p><img src="/../image/assets/image-20230724181710337.png" alt="image-20230724181710337"></p><p><img src="/../image/assets/image-20230724181721590.png" alt="image-20230724181721590"></p><p><img src="/../image/assets/image-20230724181735840.png" alt="image-20230724181735840"></p><p><img src="/../image/assets/image-20230724181748109.png" alt="image-20230724181748109"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="/../image/assets/image-20230724190455779.png" alt="image-20230724190455779"></p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p><img src="/../image/assets/image-20230724191732976.png" alt="image-20230724191732976"></p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>一棵m阶的B+树需满足下列条件：<ul><li>每个分支节点最多有m棵子树（孩子节点）</li><li>非叶根节点至少两棵子树，其他每个分支节点至少有[m&#x2F;2]棵子树（保证每个节点不要太空）</li><li><strong>节点的子树个数与关键字个数相等</strong></li><li>所有叶节点包含全部<strong>关键字及指向对应记录的指针</strong>，叶节点中将关键字<strong>按大小顺序排列</strong>，并且相邻叶节点按大小顺序相互连接起来</li><li>所有分支节点中仅包含它的各个子节点中关键字的最大值及指向其子节点的指针</li></ul></li><li>B+树支持顺序查找，每个节点中都有顺序，有节点p将叶子节点中的数据从小到大连接起来</li></ul><p><img src="/../image/assets/image-20230724191752521.png" alt="image-20230724191752521"></p><ul><li>非叶根节点至少两棵子树，其他每个分支节点至少有[m&#x2F;2]棵子树</li></ul><p><img src="/../image/assets/image-20230724192047266.png" alt="image-20230724192047266"></p><h4 id="查找操作-2"><a href="#查找操作-2" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>要一直找到<strong>叶子节点</strong></li></ul><h5 id="查找成功-6"><a href="#查找成功-6" class="headerlink" title="查找成功"></a>查找成功</h5><p><img src="/../image/assets/image-20230724192553775.png" alt="image-20230724192553775"></p><p><img src="/../image/assets/image-20230724193232557.png" alt="image-20230724193232557"></p><h5 id="查找失败-7"><a href="#查找失败-7" class="headerlink" title="查找失败"></a>查找失败</h5><p><img src="/../image/assets/image-20230724193244882.png" alt="image-20230724193244882"></p><p><img src="/../image/assets/image-20230724193310419.png" alt="image-20230724193310419"></p><h5 id="对比：B树的查找"><a href="#对比：B树的查找" class="headerlink" title="对比：B树的查找"></a>对比：B树的查找</h5><ul><li>查找成功可能停在任何一层</li></ul><p><img src="/../image/assets/image-20230724193808032.png" alt="image-20230724193808032"></p><h5 id="顺序查找-1"><a href="#顺序查找-1" class="headerlink" title="顺序查找"></a>顺序查找</h5><p><img src="/../image/assets/image-20230724194007548.png" alt="image-20230724194007548"></p><p><img src="/../image/assets/image-20230724194017044.png" alt="image-20230724194017044"></p><h5 id="B树-VS-B-树"><a href="#B树-VS-B-树" class="headerlink" title="B树 VS B+树"></a>B树 VS B+树</h5><ul><li><p>m阶B+树</p><ul><li><p>节点中n个关键字对应n棵子树</p></li><li><p>根节点的关键字数n∈[1, m]</p><p> 其他结点的关键字数n∈[⌈<em>m</em>&#x2F;2⌉, m]</p></li><li><p>在B+树中，叶节点包含全部的关键字，非叶节点中出现过的关键字也会出现在叶节点中</p></li><li><p>在B+树中，<strong>叶结点包含信息</strong>，所有<strong>⾮叶结点仅起索引作⽤</strong>，⾮叶结点中的每个索引项只含有对应⼦</p><p>树的<strong>最⼤关键字</strong>和指向<strong>该⼦树的指针</strong>，不含有该关键字对应记录的存储地址</p></li></ul></li><li><p>m阶B树</p><ul><li><p>结点中的n个关键字对应n+1棵⼦树</p></li><li><p>根节点的关键字数n∈[1, m-1]。</p><p>其他结点的关键字数n∈[⌈<em>m</em>&#x2F;2⌉-1, m-1]</p></li><li><p>在B树中，各结点中包含的关键字是不重复的</p></li><li><p>B树的节点中都包含了关键字对应的记录的存储地址</p></li></ul></li></ul><p><img src="/../image/assets/image-20230724194041626.png" alt="image-20230724194041626"></p><p><img src="/../image/assets/image-20230724194115738.png" alt="image-20230724194115738"></p><p><img src="/../image/assets/image-20230724194707895.png" alt="image-20230724194707895"></p><h4 id="应用（与操作系统有关）"><a href="#应用（与操作系统有关）" class="headerlink" title="应用（与操作系统有关）"></a>应用（与操作系统有关）</h4><ul><li>B+树仅保存索引表，非叶节点不含有该关键字对应记录的存储地址<ul><li>可以使一个磁盘快可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快</li></ul></li></ul><p><img src="/../image/assets/image-20230724195012681.png" alt="image-20230724195012681"></p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul><li>通常不考代码，着重掌握手算分析方法</li></ul><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="散列表、散裂函数"><a href="#散列表、散裂函数" class="headerlink" title="散列表、散裂函数"></a>散列表、散裂函数</h4><ul><li><p>散列表（哈希表，Hash Table）</p><ul><li>一种数据结构</li><li>特点：可以根据数据元素的关键字计算出它在散列表中的存储地址<ul><li>查找<ul><li>先根据散列函数 H(key) 计算出目标元素在散列表中的存储地址</li><li>然后检查这个位置的元素就可以知道是查找成功还是失败</li></ul></li><li>理想情况下，在散列表中查找一个元素的时间复杂度为O(1)</li></ul></li></ul></li><li><p>散列函数（哈希函数）</p><ul><li>Addr &#x3D; H(key) 建立了<strong>“关键字”-&gt;“存储地址”</strong>的映射关系</li></ul></li></ul><p><img src="/../image/assets/image-20230724200816330.png" alt="image-20230724200816330"></p><h4 id="冲突、同义词"><a href="#冲突、同义词" class="headerlink" title="冲突、同义词"></a>冲突、同义词</h4><ul><li><p>冲突（碰撞）</p><ul><li>在散列表中插入一个数据元素时，需要根据关键字的值确定其存储地址</li><li>若该地址已经存储了其他元素，则称这种情况为“冲突（碰撞）”</li></ul></li><li><p>同义词</p><ul><li>若不同的关键字通过散列函数映射到同一个存储地址，则称它们为“同义词”</li></ul></li><li><p>如何减少冲突？</p><ul><li>构造更合适的散列函数，让各个关键字尽可能的映射到不同的存储位置，从而减少“冲突”</li></ul></li></ul><p><img src="/../image/assets/image-20230724201328970.png" alt="image-20230724201328970"></p><p><img src="/../image/assets/image-20230724201711759.png" alt="image-20230724201711759"></p><h4 id="如何处理冲突"><a href="#如何处理冲突" class="headerlink" title="如何处理冲突"></a>如何处理冲突</h4><h5 id="拉链法（链接法、链地址法）"><a href="#拉链法（链接法、链地址法）" class="headerlink" title="拉链法（链接法、链地址法）"></a>拉链法（链接法、链地址法）</h5><ul><li>把所有“同义词”存储到一个链表中</li></ul><p><img src="/../image/assets/image-20230724202026658.png" alt="image-20230724202026658"></p><h5 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h5><ul><li><p>如果发生冲突，就给新元素找一个空闲位置</p></li><li><p>用什么规则确定另一个空闲位置？</p></li></ul><h3 id="构造操作"><a href="#构造操作" class="headerlink" title="构造操作"></a>构造操作</h3><p><img src="/../image/assets/image-20230724202339055.png" alt="image-20230724202339055"></p><h4 id="设计散列函数"><a href="#设计散列函数" class="headerlink" title="设计散列函数"></a>设计散列函数</h4><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li><p>定义域必须涵盖<strong>所有</strong>可能出现的<strong>关键字</strong></p></li><li><p>值域<strong>不能超出</strong>散列表的地址范围</p></li><li><p>尽可能<strong>减少冲突</strong>。</p></li><li><p>散列表计算出来的地址应尽可能<strong>均匀分布</strong>在整个地址空间</p></li><li><p>散列函数尽可能<strong>简单</strong>，能够快速计算出任意一个关键字对应的散列地址</p></li></ul><p><img src="/../image/assets/image-20230724202936639.png" alt="image-20230724202936639"></p><h5 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h5><ul><li><strong>散列函数要尽可能减少冲突</strong></li></ul><h5 id="除留余数法（最常用）"><a href="#除留余数法（最常用）" class="headerlink" title="除留余数法（最常用）"></a>除留余数法（最常用）</h5><ul><li><strong>H(key) &#x3D; key % p</strong></li><li>散列表表长为m，取一个不大于m但最接近或等于m的质数p<ul><li>原因：对质数取余，可以分布更均匀，从而减少冲突</li></ul></li><li>使用场景：较为通用，只要关键字是整数即可</li></ul><p><img src="/../image/assets/image-20230724203058513.png" alt="image-20230724203058513"></p><p><img src="/../image/assets/image-20230724203405020.png" alt="image-20230724203405020"></p><h5 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h5><ul><li><strong>直接定址法 —— H(key) &#x3D; key 或 H(key) &#x3D; a*key + b</strong><ul><li>a和b是常数。</li><li>计算简单，且不会产生冲突。</li><li>缺点：若关键字分布不连续，空位较多，则会造成存储空间的浪费</li></ul></li><li>使用场景：关键字分布基本连续</li></ul><p><img src="/../image/assets/image-20230724203504603.png" alt="image-20230724203504603"></p><h5 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h5><ul><li>选取数码分布较为平均的若干位作为散列地址</li><li>设关键字是r进制数（如十进制数），而r个数码在各位上出现的概率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可以选取数码分布较为均匀的若干位作为散列地址</li><li>适用场景：<strong>关键字集合已知，且关键字的某几个数码位分布均匀</strong></li></ul><p><img src="/../image/assets/image-20230724203734399.png" alt="image-20230724203734399"></p><h5 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h5><ul><li>取关键字的平方值的中间几位作为散列地址</li><li>具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀</li><li>适用场景：<strong>关键字的每位取值都不够均匀</strong></li></ul><p><img src="/../image/assets/image-20230724210926083.png" alt="image-20230724210926083"></p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>把所有“同义词”存储在一个链表中</li></ul><h4 id="插入操作（默认头插法）"><a href="#插入操作（默认头插法）" class="headerlink" title="插入操作（默认头插法）"></a>插入操作（默认头插法）</h4><ul><li>结合散列函数计算新元素的散列地址</li><li>将新元素插入散列地址对应的链表（可用头插法，也可用尾插法）</li></ul><p><img src="/../image/assets/image-20230724212211642.png" alt="image-20230724212211642"></p><p><img src="/../image/assets/image-20230724212425671.png" alt="image-20230724212425671"></p><h5 id="插入操作的优化"><a href="#插入操作的优化" class="headerlink" title="插入操作的优化"></a>插入操作的优化</h5><ul><li>新元素插入链表时，保持链表有序，可以略微提高查找效率</li></ul><h4 id="查找操作-3"><a href="#查找操作-3" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>先计算散列地址</li><li>再查找散列地址里的链表元素</li></ul><h5 id="查找长度-1"><a href="#查找长度-1" class="headerlink" title="查找长度"></a>查找长度</h5><ul><li>在查找计算中，需要对比关键字的次数称为查找长度</li></ul><h5 id="查找成功-7"><a href="#查找成功-7" class="headerlink" title="查找成功"></a>查找成功</h5><ul><li>查找 27，查找长度&#x3D;2</li></ul><p><img src="/../image/assets/image-20230724212458312.png" alt="image-20230724212458312"></p><ul><li>查找 20，查找长度&#x3D;1</li></ul><p><img src="/../image/assets/image-20230724212608907.png" alt="image-20230724212608907"></p><h5 id="查找失败-8"><a href="#查找失败-8" class="headerlink" title="查找失败"></a>查找失败</h5><ul><li>查找 66，查找长度 &#x3D; 4</li></ul><p><img src="/../image/assets/image-20230724212708434.png" alt="image-20230724212708434"></p><ul><li>查找21，查找长度&#x3D;0</li></ul><p><img src="/../image/assets/image-20230724212849726.png" alt="image-20230724212849726"></p><h4 id="删除操作-3"><a href="#删除操作-3" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>先查找<ul><li>查找成功：删除成功</li><li>查找失败：删除失败</li></ul></li></ul><h5 id="删除成功"><a href="#删除成功" class="headerlink" title="删除成功"></a>删除成功</h5><p><img src="/../image/assets/image-20230724213007356.png" alt="image-20230724213007356"></p><p><img src="/../image/assets/image-20230724213021343.png" alt="image-20230724213021343"></p><h5 id="删除失败"><a href="#删除失败" class="headerlink" title="删除失败"></a>删除失败</h5><p><img src="/../image/assets/image-20230724213108823.png" alt="image-20230724213108823"></p><h3 id="开放定址法-1"><a href="#开放定址法-1" class="headerlink" title="开放定址法"></a>开放定址法</h3><p><img src="/../image/assets/image-20230724213538954.png" alt="image-20230724213538954"></p><h4 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>如果发生冲突，就给新元素找另一个空闲位置</li><li>开放定址？<ul><li>一个散列地址，既对同义词开放，也对非同义词开放</li></ul></li><li>用什么规则确定“另一个空闲位置”？<ul><li>需要确定一个探测顺序：从初始散列地址出发，去寻找下一个空闲位置</li></ul></li></ul><h4 id="插入操作（自己理解的）"><a href="#插入操作（自己理解的）" class="headerlink" title="插入操作（自己理解的）"></a>插入操作（自己理解的）</h4><ul><li>插入元素，先按照散列函数插入<ul><li>如果插入位置为空（一个位置一个元素），则直接插入</li><li>如果插入位置有人，则根据探测规则 Hi &#x3D; （H(key) + di）% m 找新位置进行插入，重复以上步骤</li></ul></li><li>查找元素，先按照散列函数求值查找<ul><li>如果查找的位置有元素<ul><li>查找的元素和存储的元素相同，则查找成功</li><li>查找的元素与存储的元素不同，则根据探测规则 Hi &#x3D; （H(key) + di）% m 找下一个元素进行对比，重复上述过程</li></ul></li><li>如果查找的位置没有元素，查找失败</li></ul></li></ul><h4 id="查找操作-4"><a href="#查找操作-4" class="headerlink" title="查找操作"></a>查找操作</h4><ul><li>（自己理解的）查找元素，先按照散列函数求值查找<ul><li>如果查找的位置有元素<ul><li>查找的元素和存储的元素相同，则查找成功</li><li>查找的元素与存储的元素不同，则根据探测规则 Hi &#x3D; （H(key) + di）% m 找下一个元素进行对比，重复上述过程</li></ul></li><li>如果查找的位置没有元素，查找失败</li></ul></li><li>（视频里的）查找操作<ul><li>与插入操作类似</li><li>根据探测序列依次对比各存储单元内的关键字<ul><li>若探测到目标关键字，则查找成功</li><li>若探测到空单元，则查找失败</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230724213643794.png" alt="image-20230724213643794"></p><p><img src="/../image/assets/image-20230724213917963.png" alt="image-20230724213917963"></p><p><img src="/../image/assets/image-20230724214018852.png" alt="image-20230724214018852"></p><h4 id="探测方法"><a href="#探测方法" class="headerlink" title="探测方法"></a>探测方法</h4><h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><ul><li><p>线性探测法，<strong>d****i</strong> <strong>&#x3D; 0, 1, 2, 3, …, m-1</strong></p></li><li><p>不同序列，探测规则相同</p></li><li><p>可以探测到散列表的每个地址</p></li><li><p>插入操作</p><ul><li>先根据散列函数计算插入的位置<ul><li>如果插入位置为空（一个位置一个元素），则直接插入</li><li>如果插入位置有人，则根据探测规则di 找新位置进行插入，重复以上步骤</li></ul></li></ul></li><li><p>查找操作</p><ul><li>与插入操作类似</li><li>根据探测序列依次对比各存储单元内的关键字<ul><li>若探测到目标关键字，则查找成功</li><li>若探测到空单元，则查找失败</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230724214234998.png" alt="image-20230724214234998"></p><h5 id="平方探测法（二次探测法）"><a href="#平方探测法（二次探测法）" class="headerlink" title="平方探测法（二次探测法）"></a>平方探测法（二次探测法）</h5><ul><li><p>跟线性探测法相同</p></li><li><p>平⽅探测法，<em>d**i</em> <em>&#x3D; 0*<em>2</em></em>, 1<strong>2</strong>, -1<strong>2</strong>, 2<strong>2</strong>, -2<strong>2</strong>, …, k<strong>2</strong>, -k*<em>2</em>。</p><p>其中<em>k≤m&#x2F;2</em></p></li></ul><p><img src="/../image/assets/image-20230724215054488.png" alt="image-20230724215054488"></p><h5 id="双散列法"><a href="#双散列法" class="headerlink" title="双散列法"></a>双散列法</h5><ul><li>双散列法，<em>di</em> <em>&#x3D; i×hash*<em>2</em></em>(key)*</li><li><em>hash*<em>2</em></em>(key)&#x3D;13-(key %13)&#x3D;12*</li><li>不同的序列，探测规则不同</li></ul><p><img src="/../image/assets/image-20230724215231918.png" alt="image-20230724215231918"></p><h5 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a>伪随机序列法</h5><ul><li><em>d**i</em> 是⼀个伪随机序列，由题⽬可知 <em>d*<em>i</em></em>&#x3D; 0, 5, 3, 11, …*</li></ul><p><img src="/../image/assets/image-20230724215728836.png" alt="image-20230724215728836"></p><h4 id="删除操作-4"><a href="#删除操作-4" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>先根据散列函数算出散列地址，并对比关键字是否匹配。<ul><li>若匹配，则查找成功</li><li>若不匹配，则根据“探测序列”对比下一个地址的关键字，直到“查找成功”或“查找失败”</li></ul></li><li>若查找成功，则删除找到的元素（逻辑删除，做一个已删除的标记）</li></ul><p><img src="/../image/assets/image-20230724220231531.png" alt="image-20230724220231531"></p><h5 id="特别注意（不能物理删除）"><a href="#特别注意（不能物理删除）" class="headerlink" title="特别注意（不能物理删除）"></a>特别注意（不能物理删除）</h5><ul><li>删除元素不能简单地将被删元素的空间置为零，否则将截断在它之后的探测路径，可以做一个“已删除”标记，进行<strong>逻辑删除</strong></li></ul><h6 id="错误示范-1"><a href="#错误示范-1" class="headerlink" title="错误示范"></a>错误示范</h6><p><img src="/../image/assets/image-20230724220319072.png" alt="image-20230724220319072"></p><p><img src="/../image/assets/image-20230724220328667.png" alt="image-20230724220328667"></p><h6 id="正确示范-1"><a href="#正确示范-1" class="headerlink" title="正确示范"></a>正确示范</h6><p><img src="/../image/assets/image-20230724220422397.png" alt="image-20230724220422397"></p><p><img src="/../image/assets/image-20230724220634586.png" alt="image-20230724220634586"></p><h6 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h6><ul><li>查找效率低下，散列表看起来很满，实则很空</li><li>需要<strong>不定期整理</strong>散列表内的数据</li><li><strong>新元素可以插入到已被逻辑删除的地址</strong></li></ul><p><img src="/../image/assets/image-20230724220753600.png" alt="image-20230724220753600"></p><h4 id="探测覆盖率"><a href="#探测覆盖率" class="headerlink" title="探测覆盖率"></a>探测覆盖率</h4><h5 id="线性探测法-1"><a href="#线性探测法-1" class="headerlink" title="线性探测法"></a>线性探测法</h5><ul><li>一定可以探测到散列表的每个位置</li><li>只要散列表中有空闲位置，就一定可以插入成功</li></ul><p><img src="/../image/assets/image-20230724220929567.png" alt="image-20230724220929567"></p><h5 id="平方探测"><a href="#平方探测" class="headerlink" title="平方探测"></a>平方探测</h5><ul><li>不能探测到所有位置，只可以探测到散列表中至少一半的位置</li><li>即使散列表中有空闲位置，也未必能插入成功</li><li>解决方法<ul><li>若散列表长度 m 是一个可以表示为 4j+3 的素数（如 7,11,19），平方探测法就能探测到所有位置</li></ul></li></ul><p><img src="/../image/assets/image-20230724221122254.png" alt="image-20230724221122254"></p><h5 id="双散列法-1"><a href="#双散列法-1" class="headerlink" title="双散列法"></a>双散列法</h5><ul><li>未必能探测到散列表的所有位置</li><li>覆盖率取决于第二个散列函数设计的是否合理</li><li>结局方法<ul><li>如果 hash2 计算得到的值与散列表表长 m 互质，就能保证双散列法可以探测到所有单元</li><li>令表长 m 本身就是质数，hash2(key)&#x3D;m-(key%m)</li></ul></li></ul><p><img src="/../image/assets/image-20230724221318939.png" alt="image-20230724221318939"></p><h5 id="伪随机序列"><a href="#伪随机序列" class="headerlink" title="伪随机序列"></a>伪随机序列</h5><ul><li>di 是一个伪随机序列，由程序员人为设计</li><li>采用伪随机序列法，是否能探测到散列表中全部位置，取决于伪随机序列的设计是否合理</li></ul><p><img src="/../image/assets/image-20230724221535492.png" alt="image-20230724221535492"></p><p><img src="/../image/assets/image-20230724221801664.png" alt="image-20230724221801664"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="1-若查找表是“动态查找表”，有没有更好的实现方式：链式存储"><a href="#1-若查找表是“动态查找表”，有没有更好的实现方式：链式存储" class="headerlink" title="1. 若查找表是“动态查找表”，有没有更好的实现方式：链式存储"></a>1. 若查找表是“动态查找表”，有没有更好的实现方式：链式存储</h4><p><img src="../image/assets/image-20230720193917761.png" alt="image-20230720193917761" style="zoom:33%;" /><img src="../image/assets/image-20230720194024307.png" alt="image-20230720194024307" style="zoom:33%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;&gt;&lt;/a&gt;考点总结&lt;/h</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="查找" scheme="https://sdumoist.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://sdumoist.github.io/2023/07/06/%E5%9B%BE/"/>
    <id>https://sdumoist.github.io/2023/07/06/%E5%9B%BE/</id>
    <published>2023-07-06T03:35:47.185Z</published>
    <updated>2024-03-30T19:25:54.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><ul><li><p><strong>有向无环图才存在拓扑排序</strong></p><ul><li>检验有向图是否有环<ul><li>深度优先遍历<ul><li>从有向图上的某个顶点 u 出发，在 DFS(u) 结束之前出现一条从顶点 v 到 u 的边，由于 v 在生成树上是 u 的子孙，则图中必定存在包含 u 和 v 的环</li></ul></li><li>拓扑序列<ul><li>存在无法找到下一个可以加入拓扑序列的顶点</li><li>一直存在有入度大于 0 的顶点</li></ul></li></ul></li><li><strong>在拓扑排序算法中为暂存入度为 0 的顶点，可以用栈，也可以用队列</strong><ul><li>若两个节点之间不存在祖先或子孙关系，则它们在拓扑序列中的关系是任意的（即前后关系任意），因此使用栈和队列都可以</li></ul></li></ul></li><li><p><strong>有向图中如果存在顶点数大于 1 的强连通分量，那么这意味着图中存在环。</strong></p><ul><li>强连通分量是指在有向图中，任意两个顶点之间都存在双向路径的一组顶点。</li><li>如果一个有向图中没有环，那么每个顶点都可以看作是一个独立的强连通分量，因为没有循环路径可以连接不同的顶点。</li></ul></li><li><p>最短路径</p><ul><li>BFS：无权图</li><li>Dijkstra：不含负权回路的有向图和无向图<ul><li>与有向无向无关</li><li>与有无环路无关</li></ul></li><li>Floyd 算法：不可以有负权的环路</li></ul></li></ul><h3 id="深度优先生成树和广度优先生成树"><a href="#深度优先生成树和广度优先生成树" class="headerlink" title="深度优先生成树和广度优先生成树"></a>深度优先生成树和广度优先生成树</h3><ul><li>结论<ul><li>深度优先生成树的高度大于等于广度优先生成树的高度</li></ul></li></ul><p><a href="http://data.biancheng.net/view/45.html">原文链接</a></p><p>本章的第一节中，介绍了有关生成树和生成森林的有关知识，本节来解决对于给定的无向图，如何构建它们相对应的生成树或者生成森林。</p><p>其实在对无向图进行遍历的时候，遍历过程中所经历过的图中的顶点和边的组合，就是图的生成树或者生成森林。</p><p><img src="/../image/assets/image-20230818141145777.png" alt="image-20230818141145777"></p><p>例如，图 1 中的无向图是由 V1～V7 的顶点和编号分别为 a～i 的边组成。当使用深度优先搜索 DFS算法时，假设 V1 作为遍历的起始点，涉及到的顶点和边的遍历顺序为（不唯一）：<br><img src="/../image/assets/2-1F912163444395.png" alt="img"></p><p><img src="/../image/assets/image-20230818140957690.png" alt="image-20230818140957690"></p><p>由深度优先搜索得到的树为深度优先生成树。同理，广度优先搜索 DFS生成的树为广度优先生成树，图 1 无向图以顶点 V1 为起始点进行广度优先搜索遍历得到的树，如图 3 所示：</p><p><img src="/../image/assets/image-20230818141122476.png" alt="image-20230818141122476"></p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230706150442768.png" alt="image-20230706150442768"></p><p><img src="/../image/assets/image-20230706154227052.png" alt="image-20230706154227052"></p><p><img src="/../image/assets/image-20230717194724763.png" alt="image-20230717194724763"></p><p><img src="/../image/assets/image-20230718000407288.png" alt="image-20230718000407288"></p><p><img src="/../image/assets/image-20230718011416173.png" alt="image-20230718011416173"></p><p><img src="/../image/assets/image-20230718124704785.png" alt="image-20230718124704785"></p><p><img src="/../image/assets/image-20230718151002528.png" alt="image-20230718151002528"></p><p><img src="/../image/assets/image-20230718164320442.png" alt="image-20230718164320442"></p><p><img src="/../image/assets/image-20230719010308328.png" alt="image-20230719010308328"></p><p><img src="/../image/assets/image-20230720144250289.png" alt="image-20230720144250289"></p><p><img src="/../image/assets/image-20230720144312170.png" alt="image-20230720144312170"></p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><ul><li><p>图G由<strong>顶点集V</strong>和<strong>边集E</strong>组成，记为G&#x3D;(V,E)</p></li><li><p>V(G)表示图G中顶点的有限非空集；</p></li><li><p>E(G)表示图G中顶点之间的关系（边）集合</p></li><li><p>若V&#x3D;{v1,v2…vn},则用|V|表示图G中顶点的个数，也称<strong>图G的阶</strong></p></li><li><p>E&#x3D;{(u,v)|u属于V,v属于V}</p></li><li><p>用**|E|<strong>表示图G中</strong>边的条数**</p></li></ul><blockquote><p>线性表可以是空表，树可以是空树，但图不可以是空图，即V一定是非空集，但是图的边集E可以是空集</p></blockquote><p><img src="/../image/assets/image-20230706114614606.png" alt="image-20230706114614606"></p><h3 id="逻辑结构的应用"><a href="#逻辑结构的应用" class="headerlink" title="逻辑结构的应用"></a>逻辑结构的应用</h3><ul><li>铁路网络：V 车站       E 铁路</li><li>公路交通：V 路口       E 道路</li><li>微信好友关系——边是没有方向的（好友关系是相互的）</li><li>微博粉丝关系——边是有方向的（关注是单向的）</li></ul><h3 id="无向图、有向图"><a href="#无向图、有向图" class="headerlink" title="无向图、有向图"></a>无向图、有向图</h3><ul><li>无向边：边 (v,w)&#x3D;(w,v): v和w是顶点</li><li>有向边：弧     &lt;v,w&gt;: v是弧尾，w是弧头，方向从v-&gt;w(弧尾指向弧头)</li></ul><p><img src="/../image/assets/image-20230706115317748.png" alt="image-20230706115317748"></p><h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><img src="/../image/assets/image-20230706115823764.png" alt="image-20230706115823764"></p><h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><ul><li>对于无向图：顶点v的度是指依附于该顶点的边的条数，记为TD(v)<ul><li>所有顶点的度之和 &#x3D; 2 * |E|（顶点数目的二倍）</li></ul></li><li>对于有向图<ul><li>入度：以顶点v为终点的有向边的数目，记为ID(v)    (进入)</li><li>出度：以顶点v为起点的有向边的数目，记为OD(v)  (发射)</li><li>顶点v的度等于其入度和出度之和，即TD(v)&#x3D;ID(v)+OD(v)</li><li>入度 &#x3D;&#x3D; 出度</li></ul></li></ul><p><img src="/../image/assets/image-20230706120450792.png" alt="image-20230706120450792"></p><h3 id="顶点-顶点的关系描述"><a href="#顶点-顶点的关系描述" class="headerlink" title="顶点-顶点的关系描述"></a>顶点-顶点的关系描述</h3><ul><li><p>路径</p><ul><li>顶点Vp到Vq之间的一条路径是指顶点序列，Vp,V1,V2,…..,Vq</li><li>顶点之间可能不存在路径</li><li>有向图的路径也是有向的</li></ul></li><li><p>回路：第一个顶点和最后一个顶点相同的路径称为回路或环</p></li><li><p>简单路径：在路径序列中，顶点不重复出现的路径称为简单路径</p></li><li><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路</p></li><li><p>路径长度：路径上边的数目</p></li><li><p>点到点的距离</p><ul><li>从顶点u出发到顶点v的最短路径若存在，则<strong>此路径的长度为从u到v的距离</strong></li><li>若从u到v不存在路径，在记该距离为无穷</li></ul></li><li><p>无向图中，若从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的</p></li><li><p>有向图中</p><ul><li>若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<strong>强连通</strong>的</li></ul></li></ul><p><img src="/../image/assets/image-20230706121444298.png" alt="image-20230706121444298"></p><h3 id="连通图、强连通图"><a href="#连通图、强连通图" class="headerlink" title="连通图、强连通图"></a>连通图、强连通图</h3><ul><li>无向图：若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图<ul><li>对于n个顶点的无向图<ul><li>若G是连通图，则最少有n-1条边                          （一个顶点连接其余n-1个顶点）</li><li>若G是非连通图，则最多可能有C(2,n-1)条边        （一个顶点没有边，其余n-1个顶点两两相连）</li></ul></li></ul></li><li>有向图：若图中任何一对顶点都是强连通的，则称此图为强连通图<ul><li>对于n个顶点的有向图G<ul><li>若G是强连通图，则最少有n条边（形成回路）</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230706143401002.png" alt="image-20230706143401002"></p><h3 id="子图、生成子图"><a href="#子图、生成子图" class="headerlink" title="子图、生成子图"></a>子图、生成子图</h3><ul><li><p>设有两个图G&#x3D;(V,E)和G1&#x3D;(V1,E1),若V1是V的子集，且E1是E的子集，则称G1是G的子图</p><ul><li>并非任意挑几个点、几条边都能构成子图（首先要能是个图）</li></ul></li><li><p>若有满足V(G1)&#x3D;V(G)的子图G1，则称其为G的<strong>生成子图</strong>（点都有，可以去除几条边）</p></li></ul><p><img src="/../image/assets/image-20230706143820933.png" alt="image-20230706143820933"></p><h3 id="连通分量、强连通分量"><a href="#连通分量、强连通分量" class="headerlink" title="连通分量、强连通分量"></a>连通分量、强连通分量</h3><ul><li>无向图中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>（只要有能连通的点就要包含到里面）<ul><li>子图必须连通，且包含尽可能多的顶点和边</li></ul></li></ul><p><img src="/../image/assets/image-20230706144148600.png" alt="image-20230706144148600"></p><ul><li>有向图中的极大强连通子图称为有向图的强连通分量<ul><li>子图必须强连通，同时保留尽可能多的边</li></ul></li></ul><p><img src="/../image/assets/image-20230706144306901.png" alt="image-20230706144306901"></p><h3 id="生成树、生成森林（一种保持连通的临界）"><a href="#生成树、生成森林（一种保持连通的临界）" class="headerlink" title="生成树、生成森林（一种保持连通的临界）"></a>生成树、生成森林（一种保持连通的临界）</h3><ul><li><p>连通图的生成树是<strong>包含图中所有顶点的一个极小连通子图</strong></p><ul><li>连通图都是无向的</li><li>边尽可能少，但要保持连通</li><li>一个连通图可能有多个生成树</li></ul></li><li><p>若图中顶点数为n，则它的生成树含有n-1条边。</p><ul><li>对生成树而言，若砍去它的一条边，则会变成非连通图</li><li>若加上一条边则会形成一条回路</li></ul></li></ul><p><img src="/../image/assets/image-20230706144815318.png" alt="image-20230706144815318"></p><ul><li>在非连通图中，连通分量的生成树构成了非连通图的生成森林</li></ul><p><img src="/../image/assets/image-20230706144954104.png" alt="image-20230706144954104"></p><h3 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图&#x2F;网"></a>边的权、带权图&#x2F;网</h3><ul><li>边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值</li><li>带权图&#x2F;网——边上带有权值的图称为带权图，也称网</li><li>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</li></ul><p><img src="/../image/assets/image-20230706145438969.png" alt="image-20230706145438969"></p><h3 id="几种特殊状态的图"><a href="#几种特殊状态的图" class="headerlink" title="几种特殊状态的图"></a>几种特殊状态的图</h3><h4 id="无向完全图"><a href="#无向完全图" class="headerlink" title="无向完全图"></a>无向完全图</h4><ul><li>无向图中任意两个顶点之间都存在边</li><li>若无向图的顶点数|V|&#x3D;n，则|E|&#x3D;n(n-1)&#x2F;2</li></ul><h4 id="有向完全图"><a href="#有向完全图" class="headerlink" title="有向完全图"></a>有向完全图</h4><ul><li>有向图中任意两个顶点之间都存在方向相反的两条弧</li></ul><p><img src="/../image/assets/image-20230706145813009.png" alt="image-20230706145813009"></p><h4 id="稀疏图"><a href="#稀疏图" class="headerlink" title="稀疏图"></a>稀疏图</h4><ul><li>边数很少的图</li><li>只是相对来说，没有明确的界限，一般认为|E|&lt;|V|log|V|就是稀疏图</li></ul><h4 id="稠密图"><a href="#稠密图" class="headerlink" title="稠密图"></a>稠密图</h4><ul><li>边数很多的图</li></ul><p><img src="/../image/assets/image-20230706145910441.png" alt="image-20230706145910441"></p><h4 id="树、有向树"><a href="#树、有向树" class="headerlink" title="树、有向树"></a>树、有向树</h4><ul><li>连通图，各个点之间时连通的<ul><li>n个顶点的树，必有n-1条边</li><li>n个顶点的图，若|E|&gt;n-1，则一定有回路</li><li>若|E|&lt;n-1,则一定有孤零的顶点（森林）</li></ul></li><li>有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图，称为有向树<ul><li>有向树不是强连通图</li></ul></li></ul><p><img src="/../image/assets/image-20230706150357216.png" alt="image-20230706150357216"></p><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ul><li>数组实现的顺序存储，空间复杂度高，不适合存储稀疏图</li></ul><h4 id="存储无权图"><a href="#存储无权图" class="headerlink" title="存储无权图"></a>存储无权图</h4><ul><li>无向图：<ul><li>1: 有一条边，两顶点邻接                        0: 没有边，两个顶点不邻接</li><li>一条边对应两个1: (A,B)是1，(B,A)也是1</li></ul></li><li>有向图：<ul><li>1: 有一条行元素指向列元素的边0: 没有行元素指向列元素的边</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                    <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                 <span class="comment">//顶点表（存放顶点名称，这里是A B C...,可以换成更复杂的比如北京、上海...)</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];   <span class="comment">//邻接矩阵、边表(可以换成bool类型和枚举类型，int：4B, bool: 1B)</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                      <span class="comment">//图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGragh;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230706151618291.png" alt="image-20230706151618291"></p><p><img src="/../image/assets/image-20230706151758698.png" alt="image-20230706151758698"></p><ul><li>求顶点的度、出度、入度：<ul><li>无向图<ul><li>查找顶点所在的一行&#x2F;一列一共有几个1，度就是几</li><li>第i个顶点的度 &#x3D; 第i行（或第i列）的非零元素个数        O(n)</li></ul></li><li>有向图（1表示存在行元素指向列元素的边）：<ul><li>出度：第i行的非零元素个数                              O(n)</li><li>入度：第i列的非零元素个数                              O(n)</li></ul></li></ul></li></ul><h4 id="存储带权图（网）"><a href="#存储带权图（网）" class="headerlink" title="存储带权图（网）"></a>存储带权图（网）</h4><ul><li>如果邻接矩阵的值为0&#x2F;无穷，则说明两点之间没有边</li></ul><p><img src="/../image/assets/image-20230706153022014.png" alt="image-20230706153022014"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                    <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 2147483647                 <span class="comment">//最大的int值 (2^31)-1=2147483647</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;                    <span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;                       <span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵（有权图）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VertexType Vex[MaxVertexNum];           <span class="comment">//顶点</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">//边的权</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;                     <span class="comment">//图的当前顶点数、弧数</span></span><br><span class="line">&#125; MGragh;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230706153202614.png" alt="image-20230706153202614"></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>空间复杂度，n个顶点<ul><li>存储顶点：O(n)</li><li>存储边：O(n^2)</li><li>总：O(|V|^2)       只和顶点数有关，和实际边数无关</li></ul></li><li>适合存储稠密图（边数较多的图）</li><li>无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区&#x2F;下三角区）</li></ul><h4 id="回顾：对称矩阵的压缩存储"><a href="#回顾：对称矩阵的压缩存储" class="headerlink" title="回顾：对称矩阵的压缩存储"></a>回顾：对称矩阵的压缩存储</h4><p><img src="/../image/assets/image-20230706153557402.png" alt="image-20230706153557402"></p><ul><li>邻接矩阵自乘n次—&gt;等于从顶点i到顶点j的长度为n的路径的数目</li></ul><p><img src="/../image/assets/image-20230706153809492.png" alt="image-20230706153809492"></p><p><img src="/../image/assets/image-20230706154051318.png" alt="image-20230706154051318"></p><p><img src="/../image/assets/image-20230706154107656.png" alt="image-20230706154107656"></p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul><li>顺序存储+链式存储</li></ul><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="/../image/assets/image-20230717192008898.png" alt="image-20230717192008898"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//“边/弧”</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;                             <span class="comment">//边/弧指向哪个节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *next;                   <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                        //边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;</span><br><span class="line">    VertexType data;                        <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;                         <span class="comment">//第一条边/弧</span></span><br><span class="line">&#125;VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125; ALGragh;</span><br></pre></td></tr></table></figure><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>有向图：O(V+2E)</li><li>无向图：O(V+E)</li></ul><p><img src="/../image/assets/image-20230717192221675.png" alt="image-20230717192221675"></p><h4 id="入度、出度、度"><a href="#入度、出度、度" class="headerlink" title="入度、出度、度"></a>入度、出度、度</h4><ul><li>无向图的度：节点连接的弧的数量</li><li>有向图<ul><li>入度：把所有点的边链表遍历一遍，找到其中指向该节点的边</li><li>出度：节点连接的弧的数量</li></ul></li></ul><h4 id="邻接表不唯一（边链表的顺序任意）"><a href="#邻接表不唯一（边链表的顺序任意）" class="headerlink" title="邻接表不唯一（边链表的顺序任意）"></a>邻接表不唯一（边链表的顺序任意）</h4><p><img src="/../image/assets/image-20230717192719492.png" alt="image-20230717192719492"></p><h3 id="邻接矩阵和邻接表的劣势"><a href="#邻接矩阵和邻接表的劣势" class="headerlink" title="邻接矩阵和邻接表的劣势"></a>邻接矩阵和邻接表的劣势</h3><ul><li>邻接矩阵：空间复杂度高</li><li>邻接表：找顶点的入度不方便（找到指向该节点的边不方便）</li></ul><p><img src="/../image/assets/image-20230715175549075.png" alt="image-20230715175549075"></p><h3 id="十字链表（只能存储有向图）"><a href="#十字链表（只能存储有向图）" class="headerlink" title="十字链表（只能存储有向图）"></a>十字链表（只能存储有向图）</h3><h4 id="弧节点（存储弧）"><a href="#弧节点（存储弧）" class="headerlink" title="弧节点（存储弧）"></a>弧节点（存储弧）</h4><ul><li>绿色tailvex：弧尾顶点编号，指示这条弧是由哪个节点出发的（弧尾）</li><li>橙色headvex：弧头顶点编号，指示这条弧是指向哪个节点的（弧头）</li><li>橙色hlink：弧头相同的下一条弧，可以找到所有指向该节点的弧</li><li>绿色tlink：弧尾相同的下一条弧，可以找到所有从该节点出发的弧</li><li>灰色info：权值，指示该条弧的weight</li></ul><p><img src="/../image/assets/image-20230715180410155.png" alt="image-20230715180410155"></p><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>空间复杂度：O(V+E)</li></ul><p><img src="/../image/assets/image-20230715181800049.png" alt="image-20230715181800049"></p><h3 id="邻接多重表（存储无向图）"><a href="#邻接多重表（存储无向图）" class="headerlink" title="邻接多重表（存储无向图）"></a>邻接多重表（存储无向图）</h3><h4 id="改进邻接表"><a href="#改进邻接表" class="headerlink" title="改进邻接表"></a>改进邻接表</h4><ul><li>邻接表的缺点<ul><li>每条边对应两份冗余信息</li><li>删除顶点、删除边等操作时间复杂度高</li></ul></li></ul><p><img src="/../image/assets/image-20230717193934926.png" alt="image-20230717193934926"></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>边节点<ul><li>i：其中一个顶点的编号</li><li>j：另一个顶点的编号</li><li>iLink：依附于顶点i的下一条边（寻找与i有关的边，从iLink寻找下一个）</li><li>jLink：依附于顶点j的下一条边（寻找与j有关的边，从jLink寻找下一个）</li><li>info：权值</li></ul></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>空间复杂度：O(V+E)  （每条边只对应一份数据）</li><li>删除边、删除节点等操作都很方便</li><li>只适用于存储无向图</li></ul><p><img src="/../image/assets/image-20230717220112624.png" alt="image-20230717220112624"></p><h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>Adjacent(G,x,y): 判断图G是否存在边&lt;x,y&gt;或(x,y)</li><li>Neighbors(G,x): 列出图G中与节点x邻接的边</li><li>InsertVertex(G,x): 在图G中插入顶点x</li><li>DeleteVertex(G,x): 从图G中删除顶点x</li><li>AddEdge(G,x,y): 若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边</li><li>RemoveEdge(G,x,y): 若无向边(x,y)或有向边&lt;x,y&gt;存在,则从图G中删除该边</li><li>FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点，或图中不存在x，则返回-1</li><li>NextNeighbor(G,x,y): 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li><li>Get_edge_value(G,x,y): 获取图G中边(x,y)或&lt;x,y&gt;对应的权值</li><li>Set_edge_value(G,x,y,v): 设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v</li></ul><p><img src="/../image/assets/image-20230717222335244.png" alt="image-20230717222335244"></p><h3 id="判断是否存在边或-x-y"><a href="#判断是否存在边或-x-y" class="headerlink" title="判断是否存在边&lt;x,y&gt;或(x,y)"></a>判断是否存在边&lt;x,y&gt;或(x,y)</h3><ul><li>有向图&#x2F;无向图<ul><li>邻接矩阵 O(1)</li><li>邻接表O(1)~O(V)</li></ul></li></ul><p><img src="/../image/assets/image-20230717222759777.png" alt="image-20230717222759777"></p><h3 id="列出与节点x邻接的边"><a href="#列出与节点x邻接的边" class="headerlink" title="列出与节点x邻接的边"></a>列出与节点x邻接的边</h3><p><img src="/../image/assets/image-20230717223003760.png" alt="image-20230717223003760"></p><p><img src="/../image/assets/image-20230717223054367.png" alt="image-20230717223054367"></p><h3 id="插入新顶点"><a href="#插入新顶点" class="headerlink" title="插入新顶点"></a>插入新顶点</h3><p><img src="/../image/assets/image-20230717224829999.png" alt="image-20230717224829999"></p><h3 id="删除顶点"><a href="#删除顶点" class="headerlink" title="删除顶点"></a>删除顶点</h3><p><img src="/../image/assets/image-20230717224946032.png" alt="image-20230717224946032"></p><p><img src="/../image/assets/image-20230717225047826.png" alt="image-20230717225047826"></p><h3 id="添加新边"><a href="#添加新边" class="headerlink" title="添加新边"></a>添加新边</h3><ul><li>邻接表可以采用头插法，减少时间复杂度</li></ul><p><img src="/../image/assets/image-20230717225158802.png" alt="image-20230717225158802"></p><h3 id="找到第一个邻接点（重点）"><a href="#找到第一个邻接点（重点）" class="headerlink" title="找到第一个邻接点（重点）"></a>找到第一个邻接点（重点）</h3><p><img src="/../image/assets/image-20230718000001514.png" alt="image-20230718000001514"></p><p><img src="/../image/assets/image-20230718000020682.png" alt="image-20230718000020682"></p><h3 id="找到除了邻接点y以外的下一个邻接点-重点"><a href="#找到除了邻接点y以外的下一个邻接点-重点" class="headerlink" title="找到除了邻接点y以外的下一个邻接点(重点)"></a>找到除了邻接点y以外的下一个邻接点(重点)</h3><p><img src="/../image/assets/image-20230718000150388.png" alt="image-20230718000150388"></p><h3 id="找边的权值-设置边的权值"><a href="#找边的权值-设置边的权值" class="headerlink" title="找边的权值&#x2F;设置边的权值"></a>找边的权值&#x2F;设置边的权值</h3><ul><li>核心在于找到边<ul><li>Adjacent(G,x,y)：判断图G中是否存在边&lt;x,y&gt;或(x,y)</li></ul></li></ul><p><img src="/../image/assets/image-20230718000322650.png" alt="image-20230718000322650"></p><h3 id="图的深度优先遍历（重点）（用栈实现）"><a href="#图的深度优先遍历（重点）（用栈实现）" class="headerlink" title="图的深度优先遍历（重点）（用栈实现）"></a>图的深度优先遍历（重点）（用栈实现）</h3><h4 id="树的深度优先遍历"><a href="#树的深度优先遍历" class="headerlink" title="树的深度优先遍历"></a>树的深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的先根遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (R!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">visit</span>(R);<span class="comment">//访问根节点</span></span><br><span class="line">    <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">      <span class="built_in">PreOrder</span>(T);<span class="comment">//先根遍历下一棵子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="comment">//图的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGragh G, <span class="type">int</span> v)</span></span>&#123;                  <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//设已访问标志</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;                    <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230718121855381.png" alt="image-20230718121855381"></p><h4 id="算法存在的问题"><a href="#算法存在的问题" class="headerlink" title="算法存在的问题"></a>算法存在的问题</h4><ul><li>如果是非连通图，无法遍历完所有节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(MGragh G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;                   <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(G,v);           <span class="comment">//从v=0开始遍历</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的深度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGragh G, <span class="type">int</span> v)</span></span>&#123;                  <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//设已访问标志</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;                    <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>空间复杂度<ul><li>最坏情况：O(V)</li><li>最好情况：O(1)</li></ul></li></ul><p><img src="/../image/assets/image-20230718122433238.png" alt="image-20230718122433238"></p><ul><li><p>时间复杂度 &#x3D; 访问各个顶点+探索各条边</p><ul><li>邻接矩阵<ul><li>访问V个顶点需要O(V)的时间</li><li>查找每个顶点的邻接点都需要O(V)的时间，总共有V个顶点</li><li>时间复杂度&#x3D;O(V^2)</li></ul></li><li>邻接表<ul><li>访问V个顶点需要O(V)的时间</li><li>查找各个顶点的邻接点总共需要O(E)的时间</li><li>时间复杂度&#x3D;O(V+E)</li></ul></li></ul><p><img src="/../image/assets/image-20230718123014506.png" alt="image-20230718123014506"></p><h4 id="深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）"><a href="#深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）" class="headerlink" title="深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）"></a>深度优先遍历序列（邻接矩阵唯一，邻接表不唯一遍历序列也不唯一，但是一一对应）</h4><h4 id="邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历"><a href="#邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历" class="headerlink" title="邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历"></a>邻接矩阵的遍历序列可以直接从图中看出来，小的顶点先遍历</h4><p><img src="/../image/assets/image-20230718123316421.png" alt="image-20230718123316421"></p></li></ul><h4 id="邻接表的遍历序列要看邻接表，不能直接从图中得出"><a href="#邻接表的遍历序列要看邻接表，不能直接从图中得出" class="headerlink" title="邻接表的遍历序列要看邻接表，不能直接从图中得出"></a>邻接表的遍历序列要看邻接表，不能直接从图中得出</h4><p><img src="/../image/assets/image-20230718123823625.png" alt="image-20230718123823625"></p><h4 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h4><ul><li>同一个图的邻接矩阵表达方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一</li><li>同一个图邻接表表达方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一</li></ul><p><img src="/../image/assets/image-20230718124045455.png" alt="image-20230718124045455"></p><p><img src="/../image/assets/image-20230718124111846.png" alt="image-20230718124111846"></p><h4 id="深度优先生成森林"><a href="#深度优先生成森林" class="headerlink" title="深度优先生成森林"></a>深度优先生成森林</h4><p><img src="/../image/assets/image-20230718124204653.png" alt="image-20230718124204653"></p><p><img src="/../image/assets/image-20230718124223134.png" alt="image-20230718124223134"></p><h4 id="图的遍历与图的连通性"><a href="#图的遍历与图的连通性" class="headerlink" title="图的遍历与图的连通性"></a>图的遍历与图的连通性</h4><ul><li>无向图<ul><li>进行BFS&#x2F;DFS遍历</li><li>调用BFS&#x2F;DFS函数的次数&#x3D;连通分量数</li><li>对于连通图，只需调用一次BFS&#x2F;DFS</li></ul></li></ul><p><img src="/../image/assets/image-20230718124615536.png" alt="image-20230718124615536"></p><ul><li><p>有向图</p><ul><li><p>进行BFS&#x2F;DFS遍历</p></li><li><p>调用BFS&#x2F;DFS函数的次数要具体问题具体分析</p></li><li><p>若起始顶点到其他各顶点都有路径，则只需调用一次BFS&#x2F;DFS函数</p></li><li><p>对于强连通图之需要调用一次BFS&#x2F;DFS函数</p></li></ul></li></ul><p><img src="/../image/assets/image-20230718124600462.png" alt="image-20230718124600462"></p><h3 id="图的广度优先遍历（重点）（用队列实现）"><a href="#图的广度优先遍历（重点）（用队列实现）" class="headerlink" title="图的广度优先遍历（重点）（用队列实现）"></a>图的广度优先遍历（重点）（用队列实现）</h3><h4 id="树的广度优先遍历-VS-图的广度优先遍历"><a href="#树的广度优先遍历-VS-图的广度优先遍历" class="headerlink" title="树的广度优先遍历 VS 图的广度优先遍历"></a>树的广度优先遍历 VS 图的广度优先遍历</h4><ul><li>树🌲：不存在“回路”，搜索相邻的节点时，不可能搜到已经访问过的节点<ul><li>若树非空，则根节点入队</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li><li>重复2直到队列为空</li></ul></li><li>图✍️：搜索相邻的节点时，有可能搜到已经访问过的节点<ul><li>找到与一个顶点相邻的所有顶点</li><li>标记哪些顶点被访问过</li><li>需要一个辅助队列<ul><li>FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号，若x没有邻接点或图中不存在x，则返回-1</li><li>NextNeighbor(G,x,y): 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li></ul></li></ul></li></ul><p><img src="/../image/assets/image-20230718001912351.png" alt="image-20230718001912351"></p><p><img src="/../image/assets/image-20230718002515580.png" alt="image-20230718002515580"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(MGragh G,<span class="type">int</span> v)</span></span>&#123;                   <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//对x做已访问标记</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);                           <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);                       <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">            <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);                   <span class="comment">//访问顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;   <span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230718004600437.png" alt="image-20230718004600437"></p><h4 id="手算"><a href="#手算" class="headerlink" title="手算"></a>手算</h4><p><img src="/../image/assets/image-20230718004856597.png" alt="image-20230718004856597"></p><h4 id="遍历序列可变（邻接链表存储先后）"><a href="#遍历序列可变（邻接链表存储先后）" class="headerlink" title="遍历序列可变（邻接链表存储先后）"></a>遍历序列可变（邻接链表存储先后）</h4><p><img src="/../image/assets/image-20230718005050465.png" alt="image-20230718005050465"></p><h4 id="算法存在的问题-1"><a href="#算法存在的问题-1" class="headerlink" title="算法存在的问题"></a>算法存在的问题</h4><ul><li>如果是非连通图，则无法遍历完所有代码</li></ul><p><img src="/../image/assets/image-20230718005144167.png" alt="image-20230718005144167"></p><ul><li>但是可以通过visited数组找到未遍历的顶点</li></ul><p><img src="/../image/assets/image-20230718005949817.png" alt="image-20230718005949817"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                    <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 2147483647                 <span class="comment">//最大的int值 (2^31)-1=2147483647</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MaxVertexNum];                 <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(MGragh G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;G.vexnum; ++i) visited[i]=<span class="literal">false</span>;  <span class="comment">//访问标记数组初始化</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);                           <span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum;++i)        <span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) <span class="built_in">BFS</span>(G,i);           <span class="comment">//对每个连通分量调用一次BFS，vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(MGragh G,<span class="type">int</span> v)</span></span>&#123;                   <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//对x做已访问标记</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);                           <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);                       <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">            <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);                   <span class="comment">//访问顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;   <span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>最坏情况：辅助队列O(V)</li><li>所有其他节点都与1相邻</li></ul><p><img src="/../image/assets/image-20230718010216390.png" alt="image-20230718010216390"></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><p>邻接矩阵</p><ul><li><p>访问V个顶点需要O(V)的时间</p></li><li><p>查找每个顶点的邻接点都需要O(V)的时间，而总共有V个顶点</p></li><li><p>时间复杂度&#x3D;O(V^2)</p></li></ul></li><li><p>邻接表</p><ul><li>访问V个节点需要O(V)的时间</li><li>查找各个顶点的邻接点共需要O(E)的时间</li><li>时间复杂度&#x3D;O(V+E)</li></ul></li></ul><p><img src="/../image/assets/image-20230718010608710.png" alt="image-20230718010608710"></p><h4 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h4><ul><li>n个顶点，n-1条边</li><li>广度优先生成树由广度优先遍历过程确定。由于邻接表的表达方式不唯一，因此基于邻接表的广度优先生成树也不唯一</li></ul><p><img src="/../image/assets/image-20230718010903777.png" alt="image-20230718010903777"></p><p><img src="/../image/assets/image-20230718010939467.png" alt="image-20230718010939467"></p><p><img src="/../image/assets/image-20230718010957518.png" alt="image-20230718010957518"></p><h4 id="广度优先生成森林"><a href="#广度优先生成森林" class="headerlink" title="广度优先生成森林"></a>广度优先生成森林</h4><ul><li>对非连通图的广度优先遍历，可得到广度优先生成森林</li></ul><p><img src="/../image/assets/image-20230718011203751.png" alt="image-20230718011203751"></p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><ul><li>连通图的生成树是包含图中所有顶点的一个极小连通子图（边要尽可能小，但要保持连通）</li><li>若图中顶点数为n，则它的生成树含有n-1条边。</li><li>对于生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路</li></ul><p><img src="/../image/assets/image-20230718142718791.png" alt="image-20230718142718791"></p><h4 id="广度优先生成树-1"><a href="#广度优先生成树-1" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h4><p><img src="/../image/assets/image-20230718142810106.png" alt="image-20230718142810106"></p><h4 id="深度优先生成树-1"><a href="#深度优先生成树-1" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h4><p><img src="/../image/assets/image-20230718142829309.png" alt="image-20230718142829309"></p><h4 id="最小生成树（最小代价树）"><a href="#最小生成树（最小代价树）" class="headerlink" title="最小生成树（最小代价树）"></a>最小生成树（最小代价树）</h4><ul><li>对于一个<strong>带权连通无向图</strong>G&#x3D;(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同</li><li>设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树(Minimum-Spanning-Tree,MST)</li></ul><p><img src="/../image/assets/image-20230718143223844.png" alt="image-20230718143223844"></p><ul><li>不唯一<ul><li>可能有多个，但边的权值之和总是唯一且最小的</li></ul></li><li>最小生成树的边数 &#x3D; 顶点数 - 1<ul><li>砍掉一条则不连通，增加一条边则会出现回路</li></ul></li><li>如果连通图本身是一棵树，则其最小生成树就是它本身</li><li>只有连通图才有生成树，非连通图只有生成森林</li></ul><p><img src="/../image/assets/image-20230718143451611.png" alt="image-20230718143451611"></p><p><img src="/../image/assets/image-20230718144321711.png" alt="image-20230718144321711"></p><h4 id="Prim算法（普里姆）（点）"><a href="#Prim算法（普里姆）（点）" class="headerlink" title="Prim算法（普里姆）（点）"></a>Prim算法（普里姆）（点）</h4><ul><li><p>算法实现</p><ul><li><p>从某一个<strong>顶点</strong>开始构建生成树</p></li><li><p>每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止</p></li></ul></li><li><p>时间复杂度</p><ul><li>O(V^2)，适合用于边稠密图<ul><li>从V0开始，总共需要n-1轮处理</li><li>每一轮循环：循环遍历所有节点，找到lowCast最低的，且还没有加入树的节点</li><li>再次循环遍历，更新还没有加入各个节点的lowCast值</li></ul></li></ul></li><li><p>机器实现</p><ul><li>初始：从V0开始<ul><li>声明两个数组<ul><li>isJoin[]: 标记各节点是否已加入树</li><li>lowCost[]: 各节点加入树的最低代价</li></ul></li></ul></li><li>第一轮<ul><li>循环遍历所有的节点，找到lowCast最低的，且还没有加入树的节点</li><li>将该节点加入正在构建的树里，isJoin数组对应元素变为true</li><li>再次循环遍历。更新还没有加入各个顶点的lowCast值<ul><li>遍历刚加入节点的所有边，将这些边的权值与lowCast数组中的值进行比较，取其中较小的一个</li></ul></li></ul></li><li>循环以上操作，直到isJoin数组中不存在false（n-1轮）</li></ul></li></ul><p><img src="/../image/assets/image-20230718144504433.png" alt="image-20230718144504433"></p><p><img src="/../image/assets/image-20230718145024457.png" alt="image-20230718145024457"></p><h4 id="Kruskal算法（克鲁斯卡尔）（边）"><a href="#Kruskal算法（克鲁斯卡尔）（边）" class="headerlink" title="Kruskal算法（克鲁斯卡尔）（边）"></a>Kruskal算法（克鲁斯卡尔）（边）</h4><ul><li><p>算法实现</p><ul><li><p>每次选择一条权值最小的<strong>边</strong>，使这条边的两头连通（原本已经连通的就不选）</p></li><li><p>直到所有节点都连通</p></li></ul></li><li><p>时间复杂度</p><ul><li>O(Elog2E)，适合用于边稀疏图<ul><li>共执行e轮</li><li>每轮判断两个顶点是否属于同一个集合，需要O(log2e)</li></ul></li></ul></li><li><p>机器实现</p><ul><li>初始：<ul><li>将各条边按权值排序</li><li>三个属性<ul><li>Weight: 权值</li><li>Vertex1: 起始节点</li><li>Vertex2: 末尾节点</li></ul></li></ul></li><li>第一轮<ul><li>检查第一条边的两个顶点是否连通（是否属于同一个集合）（并查集）</li><li>如果不属于同一个集合，就将这条边选上，并将其两边的顶点放到同一个集合中</li><li>如果属于同一个集合，就直接跳过</li></ul></li><li>重复以上操作，直到所有顶点都属于一个集合（都连通）</li></ul></li></ul><p><img src="/../image/assets/image-20230718145822232.png" alt="image-20230718145822232"></p><h3 id="图的最短路径"><a href="#图的最短路径" class="headerlink" title="图的最短路径"></a>图的最短路径</h3><h4 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h4><ul><li>一个点到其他点的最短路径</li></ul><h4 id="多源最短路径"><a href="#多源最短路径" class="headerlink" title="多源最短路径"></a>多源最短路径</h4><ul><li>每对顶点间的最短路径</li></ul><p><img src="/../image/assets/image-20230718151235217.png" alt="image-20230718151235217"></p><h3 id="BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）"><a href="#BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）" class="headerlink" title="BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）"></a>BFS求无权图的单源最短路径（只适用于无权图，或所有边权值都相同的图）</h3><ul><li>无权图可以视为一种特殊的带权图，只是每条边的权值都为1</li><li>就是对BFS的一个小修改，在visit一个顶点时，修改其最短路径长度d[]并在path[]记录前驱节点</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(MGragh G,<span class="type">int</span> v)</span></span>&#123;                   <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//对x做已访问标记</span></span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);                           <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);                       <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line">            <span class="comment">//检测v的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);                   <span class="comment">//访问顶点</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;   <span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求顶点u到其他顶点到最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(MGragh G, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d[MaxVertexNum];                     <span class="comment">//d[i]表示u到i的节点的最短路径</span></span><br><span class="line">    <span class="type">int</span> path[MaxVertexNum];                  <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        d[i]=INFINITY;                       <span class="comment">//初始化路径长度</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;                          <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;</span><br><span class="line">    visited[u]=<span class="literal">true</span>;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))&#123;                  <span class="comment">//BFS算法主过程</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,u);                       <span class="comment">//队头元素u出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="built_in">FirstNeighbor</span>(G,u); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextNeighbor</span>(G,u,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;                <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;                <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;                  <span class="comment">//最短路径应从u到w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;            <span class="comment">//设已访问标志</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);               <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230718163858910.png" alt="image-20230718163858910"></p><h3 id="狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）"><a href="#狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）" class="headerlink" title="狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）"></a>狄杰斯特拉求单源最短路径（可以用于无权图、带权图，不能用于负权值的图）</h3><ul><li><p>Dijkstra</p></li><li><p>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p></li><li><p>算法实现</p><ul><li>初始<ul><li>从V0开始，初始化三个数组信息如下</li><li>Final[]: 标记各顶点是否已找到最短路径</li><li>Dist[]: 最短路径长度</li><li>Path[]: 路径上的前驱</li></ul></li><li>第一轮：<ul><li>循环遍历所有节点，找到还没确定最短路径，且dist最小的顶点Vi，令final[i]&#x3D;true</li><li>检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path信息</li><li>如果dist[]里面存储的值   小于   该点的最小距离+该点到另一点的距离，则更新dist和path</li></ul></li><li>重复以上步骤</li></ul></li></ul><p><img src="/../image/assets/image-20230718165636642.png" alt="image-20230718165636642"></p><p><img src="/../image/assets/image-20230718170122893.png" alt="image-20230718170122893"></p><p><img src="/../image/assets/image-20230718170232665.png" alt="image-20230718170232665"></p><p><img src="/../image/assets/image-20230718170606667.png" alt="image-20230718170606667"></p><p><img src="/../image/assets/image-20230718170533775.png" alt="image-20230718170533775"></p><ul><li>使用dist[]和path[]数组可以找到最短带权路径</li></ul><p><img src="/../image/assets/image-20230718170739493.png" alt="image-20230718170739493"></p><ul><li>时间复杂度<ul><li>O(V^2)</li><li>初始<ul><li>Arcs[i][j]表示Vi到Vj的弧的权值</li><li>若从V0开始，令final[0]&#x3D;true; dist[0]&#x3D;0; path[0]&#x3D;-1;</li><li>其余顶点final[k]&#x3D;false; dist[k]&#x3D;arcs[o][k]; path[k]&#x3D;(arcs[0][k]&#x3D;&#x3D;无穷大)? -1:0;</li></ul></li><li>第n-1轮处理<ul><li>循环遍历所有顶点，找到还确定最短路径，且dist最小的顶点Vi，令final[i]&#x3D;true</li><li>检查所有邻接自Vi的顶点，对于邻接自Vi的顶点Vj，若final[j]&#x3D;&#x3D;false且dist[i]+arcs[i][j]&lt;dist[j],则令dist[j]&#x3D;dist[i]+arcs[i][j]; path[j]&#x3D;i</li></ul></li></ul></li></ul><h4 id="算法缺点"><a href="#算法缺点" class="headerlink" title="算法缺点"></a>算法缺点</h4><ul><li>不适用于有负权值的带权图</li></ul><p><img src="/../image/assets/image-20230718172100109.png" alt="image-20230718172100109"></p><h3 id="Floyd算法（求各顶点间最短路径）（可以用于负权图）"><a href="#Floyd算法（求各顶点间最短路径）（可以用于负权图）" class="headerlink" title="Floyd算法（求各顶点间最短路径）（可以用于负权图）"></a>Floyd算法（求各顶点间最短路径）（可以用于负权图）</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li><p>求出每一对顶点之间的最短路径</p></li><li><p>使用<strong>动态规划</strong>思想，将问题的求解分为多个节点</p></li><li><p>对于n个顶点的图G，求任意一对顶点Vi-&gt;Vj之间的最短路径可分为如下几个阶段：</p><ul><li><p>#初始：不允许在其他顶点中转，最短路径是？</p></li><li><p>#0：若允许V0中转，最短路径是？</p></li><li><p>#1：若允许V0、V1中转，最短路径是？</p></li><li><p>#2：若允许V0、V1、V2中转，最短路径是？</p></li><li><p>…</p></li><li><p>#n-1：若允许V0、V1、V2……Vn-1中转，最短路径是？</p></li></ul></li></ul><p><img src="/../image/assets/image-20230719002515354.png" alt="image-20230719002515354"></p><p><img src="/../image/assets/image-20230719002636465.png" alt="image-20230719002636465"></p><p><img src="/../image/assets/image-20230719002812797.png" alt="image-20230719002812797"></p><p><img src="/../image/assets/image-20230719002926947.png" alt="image-20230719002926947"></p><p><img src="/../image/assets/image-20230719002901286.png" alt="image-20230719002901286"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Floyd算法，求每个顶点间距离的最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(MGragh G)</span></span>&#123;</span><br><span class="line">    <span class="comment">//准备工作，根据图的信息初始化矩阵A和path</span></span><br><span class="line">    <span class="type">int</span> A[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    <span class="type">int</span> path[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    <span class="type">int</span> n = G.vexnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++)&#123;                    <span class="comment">//考虑以vk作为中转点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n; i ++)&#123;                  <span class="comment">//遍历整个矩阵，i为行号，j为列号</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; n; j ++)&#123;              </span><br><span class="line">                <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[j][k])&#123;    <span class="comment">//以vk为中转点的路径更短</span></span><br><span class="line">                    A[i][j]=A[i][k]+A[j][k];        <span class="comment">//更新最短路径长度</span></span><br><span class="line">                    path[i][j]=k;                   <span class="comment">//中转点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230719004122837.png" alt="image-20230719004122837"></p><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><ul><li>时间复杂度：O(V^3)</li><li>空间复杂度：O(V^2)</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="/../image/assets/image-20230719004238079.png" alt="image-20230719004238079"></p><p><img src="/../image/assets/image-20230719004655886.png" alt="image-20230719004655886"></p><p><img src="/../image/assets/image-20230719005500094.png" alt="image-20230719005500094"></p><p><img src="/../image/assets/image-20230719005624147.png" alt="image-20230719005624147"></p><p><img src="/../image/assets/image-20230719005659212.png" alt="image-20230719005659212"></p><h4 id="寻找完整路径"><a href="#寻找完整路径" class="headerlink" title="寻找完整路径"></a>寻找完整路径</h4><ul><li>通过path矩阵递归地找到完整路径</li></ul><p><img src="/../image/assets/image-20230719005938122.png" alt="image-20230719005938122"></p><h4 id="算法存在问题"><a href="#算法存在问题" class="headerlink" title="算法存在问题"></a>算法存在问题</h4><ul><li>可以解决负权图的问题</li><li>但是不能解决带有“负权回路”的图（有负权值的边组成回路），这种图可能没有最短路径</li></ul><p><img src="/../image/assets/image-20230719010215338.png" alt="image-20230719010215338"></p><h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>若一个有向图中不存在环，则称为有向无环图，建成DAG图(Directed Acyclic Gragh)</li></ul><p><img src="/../image/assets/image-20230719010643791.png" alt="image-20230719010643791"></p><h3 id="有向无环图描述表达式（简化存储结构）（不唯一）"><a href="#有向无环图描述表达式（简化存储结构）（不唯一）" class="headerlink" title="有向无环图描述表达式（简化存储结构）（不唯一）"></a>有向无环图描述表达式（简化存储结构）（不唯一）</h3><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p><img src="/../image/assets/image-20230719011019240.png" alt="image-20230719011019240"></p><p><img src="/../image/assets/image-20230719011034513.png" alt="image-20230719011034513"></p><p><img src="/../image/assets/image-20230719011052975.png" alt="image-20230719011052975"></p><p><img src="/../image/assets/image-20230719011121655.png" alt="image-20230719011121655"></p><p><img src="/../image/assets/image-20230719011134744.png" alt="image-20230719011134744"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/../image/assets/image-20230719011228174.png" alt="image-20230719011228174"></p><p><img src="/../image/assets/image-20230719011258644.png" alt="image-20230719011258644"></p><p><img src="/../image/assets/image-20230719011309795.png" alt="image-20230719011309795"></p><h4 id="总结方法"><a href="#总结方法" class="headerlink" title="总结方法"></a>总结方法</h4><ul><li>思想：顶点中不可能出现重复的操作数</li><li>第一步<ul><li>把各个操作数不重复地排成一排</li></ul></li><li>第二步<ul><li>标出各个运算符的生效顺序（先后顺序无所谓）</li></ul></li><li>第三步<ul><li>按顺序加入运算符，注意分层</li></ul></li><li>第四步<ul><li><strong>自底向上</strong>逐层检查<strong>同层</strong>的运算符是否可以合体</li></ul></li></ul><p><img src="/../image/assets/image-20230719011351606.png" alt="image-20230719011351606"></p><p><img src="/../image/assets/image-20230719011623851.png" alt="image-20230719011623851"></p><p><img src="/../image/assets/image-20230719011800244.png" alt="image-20230719011800244"></p><p><img src="/../image/assets/image-20230719011906622.png" alt="image-20230719011906622"></p><p><img src="/../image/assets/image-20230719011926673.png" alt="image-20230719011926673"></p><p><img src="/../image/assets/image-20230719011949901.png" alt="image-20230719011949901"></p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul><li>可以用 DFS 实现拓扑排序</li></ul><h4 id="AOV网（用顶点表示活动）"><a href="#AOV网（用顶点表示活动）" class="headerlink" title="AOV网（用顶点表示活动）"></a>AOV网（用顶点表示活动）</h4><ul><li>AOV网(Activity on Vertex NetWork，用顶点表示活动的网)</li><li>用DAG图（有向无环图）表示一个工程。顶点表示活动，有向边&lt;Vi,Vj&gt;表示活动Vi必须先于活动Vj进行</li><li>有环路就不是AOV网</li></ul><p><img src="/../image/assets/image-20230719012714728.png" alt="image-20230719012714728"></p><h4 id="拓扑排序定义"><a href="#拓扑排序定义" class="headerlink" title="拓扑排序定义"></a>拓扑排序定义</h4><ul><li>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序<ul><li>每个顶点出现且只出现一次</li><li>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径</li></ul></li><li>或定义为<ul><li>拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在A的后面</li><li>每个AOV网都有一个或多个拓扑排序序列</li></ul></li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>先找到做事的先后顺序</li></ul><p><img src="/../image/assets/image-20230719013108763.png" alt="image-20230719013108763"></p><p><img src="/../image/assets/image-20230719013138338.png" alt="image-20230719013138338"></p><ul><li><p>机器实现</p><ul><li>从AOV网中选择一个没有前驱（入度为0）的顶点并输出</li><li>从网中删除该顶点和所有以它为起点的有向边</li><li>重复以上步骤知道当前的AOV网为空或当前网中不存在无前驱的顶点为止</li></ul></li><li><p>数据结构</p><ul><li>两个数组<ul><li>Indegree[]: 当前顶点的入度</li><li>Print[]: 记录拓扑序列</li></ul></li><li>栈&#x2F;队列<ul><li>S：保存度为0的顶点</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);                           <span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">Push</span>(S,i);                      <span class="comment">//将所有入度为0的顶点入栈</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;                            <span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;                     <span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">        <span class="built_in">Pop</span>(S,i);                           <span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++]= i;                  <span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            <span class="comment">//将所有i指向的顶点的入度-1，并且将入度减为0的顶点压入栈S</span></span><br><span class="line">            v=p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v])) Push[S,v]; <span class="comment">//入度为0，则入栈</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;                       <span class="comment">//拓扑排序成功</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VertexType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;                     <span class="comment">//边表节点</span></span><br><span class="line">    <span class="type">int</span> adjvex;                             <span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;                <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;                        //网的边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>                        <span class="comment">//顶点表节点</span></span><br><span class="line">&#123;</span><br><span class="line">    VertexType data;                        <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;                      <span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    AdjList vertices;                       <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;                     <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125; Graph;<span class="comment">//Graph是以邻接表存储的图类型</span></span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230719013657678.png" alt="image-20230719013657678"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="/../image/assets/image-20230719155110778.png" alt="image-20230719155110778"></p><p><img src="/../image/assets/image-20230719155314319.png" alt="image-20230719155314319"></p><p><img src="/../image/assets/image-20230719155421430.png" alt="image-20230719155421430"></p><p><img src="/../image/assets/image-20230719155408611.png" alt="image-20230719155408611"></p><p><img src="/../image/assets/image-20230719155604735.png" alt="image-20230719155604735"></p><p><img src="/../image/assets/image-20230719155630295.png" alt="image-20230719155630295"></p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>邻接表：O(V+E)</li><li>邻接矩阵：O(V^2)</li></ul><p><img src="/../image/assets/image-20230719155751183.png" alt="image-20230719155751183"></p><h4 id="无法进行拓扑排序：有回路的图"><a href="#无法进行拓扑排序：有回路的图" class="headerlink" title="无法进行拓扑排序：有回路的图"></a>无法进行拓扑排序：有回路的图</h4><p><img src="/../image/assets/image-20230719013605807.png" alt="image-20230719013605807"></p><ul><li>当前AOV图中每个节点的入度都&gt;0</li></ul><p><img src="/../image/assets/image-20230719013455492.png" alt="image-20230719013455492"></p><h3 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h3><ul><li>拓扑排序是删除入度&#x3D;0的点</li><li>逆拓扑排序是删除出度&#x3D;0的点</li></ul><p><img src="/../image/assets/image-20230719155859372.png" alt="image-20230719155859372"></p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p><img src="/../image/assets/image-20230719155923334.png" alt="image-20230719155923334"></p><p><img src="/../image/assets/image-20230719155938429.png" alt="image-20230719155938429"></p><h4 id="逆拓扑排序的实现"><a href="#逆拓扑排序的实现" class="headerlink" title="逆拓扑排序的实现"></a>逆拓扑排序的实现</h4><ul><li>邻接表<ul><li>保存的是从这个节点出去的边</li></ul></li><li>逆邻接表<ul><li>保存的是指向这个顶点的边</li></ul></li><li>邻接矩阵<ul><li>横行：从该节点出去的边</li><li>竖列：指向这个顶点的边</li></ul></li></ul><p><img src="/../image/assets/image-20230719160056829.png" alt="image-20230719160056829"></p><h4 id="DFS实现逆拓扑排序"><a href="#DFS实现逆拓扑排序" class="headerlink" title="DFS实现逆拓扑排序"></a>DFS实现逆拓扑排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆拓扑排序（DFS算法）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;                  <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;                   <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            <span class="built_in">DFS</span>(G,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS，从顶点v出发，深度优先遍历图G</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);                               <span class="comment">//访问顶点</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;                        <span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;                    <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="built_in">print</span>(v);                               <span class="comment">//输出顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p><img src="/../image/assets/image-20230720001307281.png" alt="image-20230720001307281"></p><p><img src="/../image/assets/image-20230720001337456.png" alt="image-20230720001337456"></p><p><img src="/../image/assets/image-20230720001354364.png" alt="image-20230720001354364"></p><p><img src="/../image/assets/image-20230720001411582.png" alt="image-20230720001411582"></p><p><img src="/../image/assets/image-20230720001433264.png" alt="image-20230720001433264"></p><p><img src="/../image/assets/image-20230720001522660.png" alt="image-20230720001522660"></p><p><img src="/../image/assets/image-20230720001545539.png" alt="image-20230720001545539"></p><p><img src="/../image/assets/image-20230720001605059.png" alt="image-20230720001605059"></p><p><img src="/../image/assets/image-20230720001623820.png" alt="image-20230720001623820"></p><p><img src="/../image/assets/image-20230720001651750-9783412.png" alt="image-20230720001651750"></p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><h4 id="AOE网（用边表示活动）"><a href="#AOE网（用边表示活动）" class="headerlink" title="AOE网（用边表示活动）"></a>AOE网（用边表示活动）</h4><ul><li>在带权有向图中，以<strong>顶点</strong>表示事件，以<strong>有向边</strong>表示活动，以<strong>边上的权值</strong>表示完成该活动的开销（如完成活动所需时间），称之为用边表示活动的网络，简称AOE网（Activity On Edge Network）</li></ul><p><img src="/../image/assets/image-20230720002543969.png" alt="image-20230720002543969"></p><ul><li><p>AOV网的性质</p><ul><li><p>只有在某个顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</p></li><li><p>只有在进入某个顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生</p></li><li><p>另外，有些活动是可以并行进行的</p></li></ul></li><li><p>AOE网的组成</p><ul><li>在AOE网中仅有一个入度为0的顶点，称为<strong>开始顶点（源点）</strong>，表示整个工程的开始</li><li>仅有一个出度为0的点，称为<strong>结束顶点（汇点）</strong>，表示整个工程的结束</li><li>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong></li><li>完成整个工程的最短时间就是<strong>关键路径的长度</strong>，若关键路径不能按时完成，则整个工程完成时间就会延长</li></ul></li></ul><p><img src="/../image/assets/image-20230720003025269.png" alt="image-20230720003025269"></p><p><img src="/../image/assets/image-20230720003229716.png" alt="image-20230720003229716"></p><h4 id="关键路径（类似软件项目管理的里程碑）"><a href="#关键路径（类似软件项目管理的里程碑）" class="headerlink" title="关键路径（类似软件项目管理的里程碑）"></a>关键路径（类似软件项目管理的里程碑）</h4><ul><li>事件Vk的最早发生时间Ve(k)——决定了所有从Vk开始的活动能够开工的最早时间</li><li>活动ai的最早开始时间e(i)——指该活动弧的起点所表示的事件的最早发生时间</li></ul><p><img src="/../image/assets/image-20230720003544094.png" alt="image-20230720003544094"></p><ul><li>事件Vk的最早发生时间Vl(k)——指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间</li><li>活动ai的最早开始时间l(i)——指该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差</li></ul><p><img src="/../image/assets/image-20230720140959200.png" alt="image-20230720140959200"></p><ul><li>活动最早时间e(i) VS 活动最迟开始时间l(i)</li><li>活动ai的时间余量d(i)&#x3D;l(i)-e(i)<ul><li>表示在不增加完成整个工程所需总时间的情况下，活动ai可以拖延的时间</li><li>若一个活动的时间余量&#x3D;0，则说明该活动必须要如期完成，d(i)&#x3D;0即l(i)&#x3D;e(i)的活动ai是关键活动，由关键活动组成的路径就是关键路径</li></ul></li></ul><p><img src="/../image/assets/image-20230720141529642.png" alt="image-20230720141529642"></p><h4 id="求关键路径的步骤"><a href="#求关键路径的步骤" class="headerlink" title="求关键路径的步骤"></a>求关键路径的步骤</h4><ol><li>求所有事件的最早发生时间Ve()<ul><li>按<strong>拓扑排序</strong>序列，依次求各个顶点的Ve(k)</li><li>Ve(源点)&#x3D;0</li><li>Ve(k)&#x3D;Max{Ve(j) + Weight(Vj,Vk)}.  Vj为Vk的任意前驱（即找到前驱节点+事件时间最大的路径）</li></ul></li><li>求所有事件的最迟发生时间Vl()<ul><li>按逆拓扑排序序列，依次求各个顶点的Vl(k)</li><li>Vl(汇点)&#x3D;Ve(汇点)</li><li>Vl(k)&#x3D;Min{Vl(j)+Weight(Vk,Vj)}.     Vj为Vk的任意后继</li></ul></li><li>求所有活动的最早发生时间e()<ul><li>若边&lt;Vk,Vj&gt;表示活动ai，则有e(i)&#x3D;Ve(k)</li></ul></li><li>求所有活动的最迟发生时间l()<ul><li>若边&lt;Vk,Vj&gt;表示活动ai，则有l(i)&#x3D;Vl(j)-Weight(Vk,Vj)</li></ul></li><li>求所有活动的时间余量d()<ul><li>d(i)&#x3D;l(i)-e(i)</li></ul></li><li>求得关键活动、关键路径<ul><li>将d[i]&#x3D;0的路径连接成一条线</li></ul></li></ol><p><strong>d(i)&#x3D;0的活动就是关键活动，由关键活动可得关键路径</strong></p><p><img src="/../image/assets/image-20230720141956503.png" alt="image-20230720141956503"></p><ul><li>求所有事件的最早发生时间</li></ul><p><img src="/../image/assets/image-20230720142518121.png" alt="image-20230720142518121"></p><ul><li>求所有事件的最迟发生时间</li></ul><p><img src="/../image/assets/image-20230720142714515.png" alt="image-20230720142714515"></p><ul><li>求所有活动的最早发生时间</li></ul><p><img src="/../image/assets/image-20230720143204437.png" alt="image-20230720143204437"></p><ul><li>求所有活动的最迟发生时间</li></ul><p><img src="/../image/assets/image-20230720143240311.png" alt="image-20230720143240311"></p><ul><li>求所有活动的最迟发生时间</li></ul><p><img src="/../image/assets/image-20230720143420904.png" alt="image-20230720143420904"></p><ul><li>求所有活动的时间余量</li></ul><p><img src="/../image/assets/image-20230720143524191.png" alt="image-20230720143524191"></p><ul><li>求得关键活动、关键路径</li></ul><p><img src="/../image/assets/image-20230720143604260.png" alt="image-20230720143604260"></p><h4 id="关键活动、关键路径的特性"><a href="#关键活动、关键路径的特性" class="headerlink" title="关键活动、关键路径的特性"></a>关键活动、关键路径的特性</h4><ul><li>若关键活动耗时增加，则整个工程的工期将曾长</li><li>缩短关键活动的时间，可以缩短整个工程的工期</li><li>当缩短到一定程度时，关键活动可能会变成非关键活动（并不是只要压缩关键路径的时间，工期就可以提前）</li><li>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的（或者缩短每一条关键路径上的关键活动）</li></ul><p><img src="/../image/assets/image-20230720143931809.png" alt="image-20230720143931809"></p><p><img src="/../image/assets/image-20230720144157251.png" alt="image-20230720144157251"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1-练习：有向图的BFS过程"><a href="#1-练习：有向图的BFS过程" class="headerlink" title="1.练习：有向图的BFS过程"></a>1.练习：有向图的BFS过程</h3><p><img src="/../image/assets/image-20230718011319698.png" alt="image-20230718011319698"></p><h3 id="2-练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？"><a href="#2-练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？" class="headerlink" title="2.练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？"></a>2.练习：如果存在回路，则不存在逆拓扑排序序列，如何判断回路？</h3><p><img src="/../image/assets/image-20230720001940125.png" alt="image-20230720001940125"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;&gt;&lt;/a&gt;考点总结&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="图" scheme="https://sdumoist.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基本概念</title>
    <link href="https://sdumoist.github.io/2023/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://sdumoist.github.io/2023/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2023-07-03T14:51:14.859Z</published>
    <updated>2024-03-30T19:25:48.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构基础概念"><a href="#数据结构基础概念" class="headerlink" title="数据结构基础概念"></a>数据结构基础概念</h1><h2 id="一、基本概念和术语"><a href="#一、基本概念和术语" class="headerlink" title="一、基本概念和术语"></a>一、基本概念和术语</h2><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h3><p>数据是描述客观事物的符号，是计算机可以操作的对象，是能被计算机识别，并输入到计算机处理的符号集合。</p><p>（数据不仅仅包括整型、实型等数值型，还有字符、声音、图像、视频等非数值类型）</p><h3 id="2-数据元素"><a href="#2-数据元素" class="headerlink" title="2.数据元素"></a>2.数据元素</h3><p>数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也称为记录（元组、结点、顶点）。</p><h3 id="3-数据项（属性、字段）"><a href="#3-数据项（属性、字段）" class="headerlink" title="3.数据项（属性、字段）"></a>3.数据项（属性、字段）</h3><ul><li>一个数据元素可以由若干个数据项组成。</li><li>数据项是数据不可分割的最小单位。</li></ul><h3 id="4-数据对象"><a href="#4-数据对象" class="headerlink" title="4.数据对象"></a>4.数据对象</h3><p>数据对象是性质相同的数据元素的集合，是数据的子集。</p><h3 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5.数据结构"></a>5.数据结构</h3><ul><li>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，这些关系称为结构。</li><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</li><li><strong>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算</strong>。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</li></ul><h2 id="二、逻辑结构和物理结构（存储结构）"><a href="#二、逻辑结构和物理结构（存储结构）" class="headerlink" title="二、逻辑结构和物理结构（存储结构）"></a>二、逻辑结构和物理结构（存储结构）</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>逻辑结构是指数据对象中数据元素之间相互关系（逻辑关系），即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机存储器的。</p><h4 id="2）分类（线性结构和非线性结构）"><a href="#2）分类（线性结构和非线性结构）" class="headerlink" title="2）分类（线性结构和非线性结构）"></a>2）分类（线性结构和非线性结构）</h4><p>根据数据元素之间关系的不同特征，通常有下列4类基本结构，复杂程度依次递进。</p><p>①集合：结构中的数据元素之间除了同属于一个集合外，没有其他的关系。</p><p>②线性结构：线性结构中的数据元素之间是一对一的关系。</p><p>③树形结构：树形结构中的数据元素之间是一对多的关系。</p><p>④图状结构或网状结构：结构中的元素之间是多对多的关系。</p><h3 id="2-物理结构（存储结构）"><a href="#2-物理结构（存储结构）" class="headerlink" title="2.物理结构（存储结构）"></a>2.物理结构（存储结构）</h3><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li><p>数据的物理结构是指数据的逻辑结构在计算机中的存储方式。又称存储结构。</p></li><li><p>它研究的是<strong>数据结构在计算机中的实现方法，包括数据元素的表示和元素之间的关系。</strong></p></li><li><p>数据元素的存储结构形式主要有两种：顺序存储和链式存储</p></li></ul><h4 id="2）顺序存储和链式存储"><a href="#2）顺序存储和链式存储" class="headerlink" title="2）顺序存储和链式存储"></a>2）顺序存储和链式存储</h4><p>①顺序存储结构</p><p>是利用数据元素在存储器中的相对位置来表示数据元素之间的逻辑顺序。<br>顺序存储结构是把数据元素放在地址连续的存储单元中，程序设计中使用数组类型来实现。（逻辑相邻物理相邻）</p><p>②链式存储结构</p><p>利用结点中指针来表示数据元素之间的关系。<br>把数据元素存储在任意的存储单元里，这组存储单元可以是连续的，也可以是连续的，程序设计中使用指针类型来实现。（逻辑相邻物理不一定相邻）</p><h4 id="3）其他存储方式"><a href="#3）其他存储方式" class="headerlink" title="3）其他存储方式"></a>3）其他存储方式</h4><p>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。</p><p>散列存储：通过关键字直接计算出元素的物理地址。</p><p><a href="https://blog.csdn.net/Jacky_Feng/article/details/108538689">逻辑结构和存储结构</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构基础概念&quot;&gt;&lt;a href=&quot;#数据结构基础概念&quot; class=&quot;headerlink&quot; title=&quot;数据结构基础概念&quot;&gt;&lt;/a&gt;数据结构基础概念&lt;/h1&gt;&lt;h2 id=&quot;一、基本概念和术语&quot;&gt;&lt;a href=&quot;#一、基本概念和术语&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="基本概念" scheme="https://sdumoist.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>树与二叉树</title>
    <link href="https://sdumoist.github.io/2023/07/01/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://sdumoist.github.io/2023/07/01/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-07-01T08:41:23.000Z</published>
    <updated>2024-03-30T19:25:42.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="考点总结"><a href="#考点总结" class="headerlink" title="考点总结"></a>考点总结</h2><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="树为什么是一种递归定义的数据结构"><a href="#树为什么是一种递归定义的数据结构" class="headerlink" title="树为什么是一种递归定义的数据结构"></a>树为什么是一种递归定义的数据结构</h4><p>树是一种递归定义的数据结构，因为它的定义可以通过对自身的描述进行递归来完成。</p><p>树由节点组成，每个节点可以有零个或多个子节点。树的定义可以通过以下方式进行递归描述：</p><ol><li>树由一个根节点开始。根节点是树的顶层节点，没有父节点。</li><li>每个节点可以有零个或多个子节点。子节点是相对于父节点而言的。</li><li>每个子节点本身也可以是一个树，即子树。子树可以看作是原始树的一部分。</li></ol><p>这种递归定义的特点在于树的结构可以通过对子树的定义来描述。树的每个节点都可以作为一个根节点，它们可以包含更多的子节点，形成更深层次的结构。</p><p>递归定义使得树具有自相似的性质。树的整体结构与其子树的结构类似，这种递归性质使得树在许多算法和数据结构中具有广泛的应用，例如搜索、排序、存储和组织数据等。</p><p>通过递归定义，我们可以使用相同的规则来构建树的不同部分，从而形成复杂的树结构。这种递归性质使得树成为一种灵活而强大的数据结构。</p><h4 id="线索二叉树寻找前驱后继（先不前，后不继）"><a href="#线索二叉树寻找前驱后继（先不前，后不继）" class="headerlink" title="线索二叉树寻找前驱后继（先不前，后不继）"></a>线索二叉树寻找前驱后继（先不前，后不继）</h4><ul><li>先不前，后不继<ul><li>先序线索二叉树不能找先序前驱</li><li>后序线索二叉树不能找后序后继<ul><li>因为只有根能找到自己的左右子树，而且根没有自己的线索（都是左右孩子）</li><li>先序遍历的时候：根左右，根在最前面，所以找不到自己的前驱</li><li>后序遍历的时候：左右根，根在最后面，所以找不到自己的后继</li></ul></li></ul></li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230702130914954.png" alt="image-20230702130914954"></p><p><img src="/../image/assets/image-20230702131951970.png" alt="image-20230702131951970"></p><p><img src="/../image/assets/image-20230702134009965.png" alt="image-20230702134009965"></p><p><img src="/../image/assets/image-20230702161639310.png" alt="image-20230702161639310"></p><p><img src="/../image/assets/image-20230702173836143.png" alt="image-20230702173836143"></p><p><img src="/../image/assets/image-20230702173848860.png" alt="image-20230702173848860"></p><p><img src="/../image/assets/image-20230704214903786.png" alt="image-20230704214903786"></p><p><img src="/../image/assets/image-20230704215842806.png" alt="image-20230704215842806"></p><p><img src="/../image/assets/image-20230704224529787.png" alt="image-20230704224529787"></p><p><img src="/../image/assets/image-20230705155415191.png" alt="image-20230705155415191"></p><p><img src="/../image/assets/image-20230705165109906.png" alt="image-20230705165109906"></p><p><img src="/../image/assets/image-20230705190952703.png" alt="image-20230705190952703"></p><p><img src="/../image/assets/image-20230705191049589.png" alt="image-20230705191049589"></p><p><img src="/../image/assets/image-20230705200603558.png" alt="image-20230705200603558"></p><p><img src="/../image/assets/image-20230705203548373.png" alt="image-20230705203548373"></p><p><img src="/../image/assets/image-20230705213945765.png" alt="image-20230705213945765"></p><p><img src="/../image/assets/image-20230705223222668.png" alt="image-20230705223222668"></p><p><img src="/../image/assets/image-20230706105227305.png" alt="image-20230706105227305"></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>n(n&gt;&#x3D;0)个节点的有限集合，n&#x3D;0时，称为空树。</p><p>在任何一棵非空树中应满足：</p><ul><li>有且仅有一个特定的成为根的节点</li><li>当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集合T1,T2,…,Tm,其中每个集合本身又是一棵树，并且成为根节点的子树</li></ul><p><img src="/../image/assets/image-20230701165215387.png" alt="image-20230701165215387"></p><p><img src="/../image/assets/image-20230706111114375.png" alt="image-20230706111114375"></p><p><img src="/../image/assets/image-20230706112412312.png" alt="image-20230706112412312"></p><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><h4 id="空树"><a href="#空树" class="headerlink" title="空树"></a>空树</h4><p>节点数为0的树</p><h4 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h4><p>根节点（Root Node）：树的顶层节点，它是树的起点，没有父节点。树中只能有一个根节点。</p><h4 id="边"><a href="#边" class="headerlink" title="边"></a>边</h4><p>连接两个节点的线段，它表示节点之间的关联关系。在树中，边用于连接父节点与子节点。</p><h4 id="分支节点"><a href="#分支节点" class="headerlink" title="分支节点"></a>分支节点</h4><p>有后继的节点，也称为非终端节点，内部节点或非叶子节点，是除了根节点以外的其他节点。分支节点至少有一个子节点。</p><h4 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h4><p>没有后继的节点，也称为终端节点或叶节点，是没有子节点的节点。它们位于树的末端。</p><h4 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h4><p><strong>在树中，节点的前驱是指在树的某一种遍历顺序中，位于该节点之前的节点。</strong></p><p>除了根节点外，任何一个节点都有且仅有一个前驱（根节点没有前驱）</p><h4 id="后继"><a href="#后继" class="headerlink" title="后继"></a>后继</h4><p><strong>在树中，节点的后继是指在树的某一种遍历顺序中，位于该节点之后的节点。</strong></p><p>树中的叶子节点没有后继，因为它们没有子节点</p><h4 id="祖先节点"><a href="#祖先节点" class="headerlink" title="祖先节点"></a>祖先节点</h4><p>对于给定节点，在树中位于其上方的所有节点都是其祖先节点。祖先节点可以是父节点、父节点的父节点，以此类推，直到根节点为止。</p><h4 id="子孙节点"><a href="#子孙节点" class="headerlink" title="子孙节点"></a>子孙节点</h4><p>对于给定节点，在树中位于其下方的所有节点都是其子孙节点。子孙节点可以是子节点、子节点的子节点，以此类推，直到叶子节点为止。</p><h4 id="双亲节点"><a href="#双亲节点" class="headerlink" title="双亲节点"></a>双亲节点</h4><p>对于给定节点，它的直接上一级节点称为双亲节点或父节点。每个节点都只有一个父节点，除了根节点没有父节点。</p><h4 id="孩子节点"><a href="#孩子节点" class="headerlink" title="孩子节点"></a>孩子节点</h4><p>对于给定节点，它的直接下一级节点称为孩子节点或子节点。每个节点可以有零个或多个子节点。</p><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>对于给定节点，具有相同父节点的其他节点称为兄弟节点。兄弟节点之间是同级节点。</p><h4 id="堂兄弟节点"><a href="#堂兄弟节点" class="headerlink" title="堂兄弟节点"></a>堂兄弟节点</h4><p>给定节点，具有相同祖先节点但不是兄弟节点的节点称为堂兄弟节点。换句话说，堂兄弟节点是具有不同的双亲节点但共享同一级祖先的节点。</p><h4 id="两个节点之间的路径"><a href="#两个节点之间的路径" class="headerlink" title="两个节点之间的路径"></a>两个节点之间的路径</h4><p>在树中，两个节点之间的路径是指连接这两个节点的边的序列。路径由起始节点开始，沿着树的边连接到目标节点（只能从上到下）。</p><h4 id="路径长度"><a href="#路径长度" class="headerlink" title="路径长度"></a>路径长度</h4><p>路径长度是指路径上<strong>经过的边的数量</strong>。它表示从起始节点到目标节点之间的距离或步数。</p><p>树的路径长度是指树根到每个节点的路径长的总和</p><p>根到每个节点的路径长度的最大值应该是树的高度-1</p><p>注意与哈夫曼树的带权路径长度的区别</p><h4 id="节点的层次（深度）"><a href="#节点的层次（深度）" class="headerlink" title="节点的层次（深度）"></a>节点的层次（深度）</h4><p>（从上往下数）默认从1开始，要读题看看是不是第一层，有可能根节点是第0层</p><h4 id="节点的高度"><a href="#节点的高度" class="headerlink" title="节点的高度"></a>节点的高度</h4><p>（从下往上数）</p><h4 id="树的高度（深度）"><a href="#树的高度（深度）" class="headerlink" title="树的高度（深度）"></a>树的高度（深度）</h4><p>总共多少层（最多的）</p><h4 id="节点的度"><a href="#节点的度" class="headerlink" title="节点的度"></a>节点的度</h4><p>有几个孩子（分支）       非叶子节点的度&gt;0</p><h4 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h4><p><strong>各节点的度的最大值</strong></p><h4 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h4><p>有序树——逻辑上看，树中结点的各子树从左到右是有次序的，不能互换</p><p>无序树——逻辑上看，树中节点各子树从左到右是无次序的，可以互换</p><p>具体要看用树存什么，是否要用节点的左右位置反应某些逻辑关系</p><p><img src="/../image/assets/image-20230702130621646.png" alt="image-20230702130621646"></p><h4 id="树-和-森林"><a href="#树-和-森林" class="headerlink" title="树 和 森林"></a>树 和 森林</h4><p>森林是m(m&gt;&#x3D;0)棵互不相交的树的集合（可以有空森林）</p><p><img src="/../image/assets/image-20230702130848399.png" alt="image-20230702130848399"></p><h3 id="常考性质"><a href="#常考性质" class="headerlink" title="常考性质"></a>常考性质</h3><h4 id="节点数-总度数-1（根节点没有度数）"><a href="#节点数-总度数-1（根节点没有度数）" class="headerlink" title="节点数 &#x3D; 总度数 + 1（根节点没有度数）"></a>节点数 &#x3D; 总度数 + 1（根节点没有度数）</h4><h4 id="度为m的树、m叉树的区别"><a href="#度为m的树、m叉树的区别" class="headerlink" title="度为m的树、m叉树的区别"></a>度为m的树、m叉树的区别</h4><p>度为m的树要求比较严格，至少有一个节点的度为m，所以一定是非空树，至少m+1个节点</p><p>m叉树要求比较小，只要所以节点的度小于m就可以，可以是空树</p><p><img src="/../image/assets/image-20230702131209681.png" alt="image-20230702131209681"></p><h4 id="度为m的树第i层至多有m-i-1-个节点"><a href="#度为m的树第i层至多有m-i-1-个节点" class="headerlink" title="度为m的树第i层至多有m^(i-1)个节点"></a>度为m的树第i层至多有m^(i-1)个节点</h4><p><img src="/../image/assets/image-20230702131431524.png" alt="image-20230702131431524"></p><h4 id="高度为h的m叉树至多有-m-h-1-m-1-个节点"><a href="#高度为h的m叉树至多有-m-h-1-m-1-个节点" class="headerlink" title="高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个节点"></a>高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个节点</h4><p>等比数列求和公式：a + aq + aq^2 +……+aq^(n-1)&#x3D;a(1-q^n)&#x2F;(1-q)</p><p><img src="/../image/assets/image-20230702131624172.png" alt="image-20230702131624172"></p><h4 id="高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h-m-1个节点"><a href="#高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h-m-1个节点" class="headerlink" title="高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h+m-1个节点"></a>高度为h的m叉树至少有h个节点；高度为h，度为m的树至少有h+m-1个节点</h4><p><img src="/../image/assets/image-20230702131750880.png" alt="image-20230702131750880"></p><h4 id="有n个节点的m叉树的最小高度是logm-n-m-1-1-向下取整"><a href="#有n个节点的m叉树的最小高度是logm-n-m-1-1-向下取整" class="headerlink" title="有n个节点的m叉树的最小高度是logm(n(m-1)+1)向下取整"></a>有n个节点的m叉树的最小高度是logm(n(m-1)+1)向下取整</h4><p><img src="/../image/assets/image-20230702131931837.png" alt="image-20230702131931837"></p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>n(n&gt;&#x3D;0)个节点的有限集合</p><ul><li>或者为空二叉树，即n&#x3D;0</li><li>或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树右分别是一颗二叉树</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每个节点至多只有两颗子树</li><li>左右子树不能颠倒（二叉树是有序树）</li></ul><p><img src="/../image/assets/image-20230702132400074.png" alt="image-20230702132400074"></p><h4 id="二叉树的五种状态"><a href="#二叉树的五种状态" class="headerlink" title="二叉树的五种状态"></a>二叉树的五种状态</h4><ul><li>空二叉树</li><li>只有左子树</li><li>只有右子树</li><li>只有根节点</li><li>左右子树都有</li></ul><p><img src="/../image/assets/image-20230702132457500.png" alt="image-20230702132457500"></p><h4 id="几个特殊的二叉树"><a href="#几个特殊的二叉树" class="headerlink" title="几个特殊的二叉树"></a>几个特殊的二叉树</h4><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ul><li><p>一颗高度为h，且含有2^h-1个节点的二叉树</p></li><li><p>特点：</p><ul><li>只有最后一层有叶子节点</li><li>不存在度为1的节点</li><li>按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为i&#x2F;2向下取整（如果有的话）</li></ul></li></ul><p><img src="/../image/assets/image-20230702132912536.png" alt="image-20230702132912536"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ul><li><p>当且仅当其每个节点都与高度为h的满二叉树中编号为1～n的节点一一对应时，称为完全二叉树</p></li><li><p>特点</p><ul><li><p>只有最后两层可能有叶子节点</p></li><li><p>最多只有一个度为1的节点</p></li><li><p>按层序从1开始编号，节点i的左孩子为2i，右孩子为2i+1，节点i的父节点为i&#x2F;2向下取整（如果有的话）</p></li><li><p>i&lt;&#x3D;n&#x2F;2（向上取整）为分支节点         i&gt;&#x3D;n&#x2F;2（向上取整）为叶子节点</p></li><li><p>如果一个节点只有一个孩子，那一定是左孩子，不是右孩子</p></li></ul></li></ul><p><img src="/../image/assets/image-20230702133421655.png" alt="image-20230702133421655"></p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><ul><li>空二叉树</li><li>具有如下性质的二叉树：<ul><li>左子树上所有节点的关键字均小于根节点的关键字</li><li>右子树上所有节点的关键字均大于根节点的关键字</li><li>左右子树又各是一棵二叉排序树</li></ul></li></ul><p><img src="/../image/assets/image-20230702133719969.png" alt="image-20230702133719969"></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><ul><li><p>树上任一节点的左子树和右子树的深度之差不超过1</p></li><li><p>平衡二叉树能有更高的搜索效率</p></li></ul><p><img src="/../image/assets/image-20230702133922676.png" alt="image-20230702133922676"></p><h4 id="二叉树基本常考性质"><a href="#二叉树基本常考性质" class="headerlink" title="二叉树基本常考性质"></a>二叉树基本常考性质</h4><h4 id="设非空二叉树中度为0、1、2的节点个数分别是n0-n1-n2，则n0-n2-1（叶子节点比二分支节点多一个）"><a href="#设非空二叉树中度为0、1、2的节点个数分别是n0-n1-n2，则n0-n2-1（叶子节点比二分支节点多一个）" class="headerlink" title="设非空二叉树中度为0、1、2的节点个数分别是n0,n1,n2，则n0&#x3D;n2+1（叶子节点比二分支节点多一个）"></a>设非空二叉树中度为0、1、2的节点个数分别是n0,n1,n2，则n0&#x3D;n2+1（叶子节点比二分支节点多一个）</h4><p>假设树中结点总数为n，则</p><ol><li>n&#x3D;n0+n1+n2</li><li>n&#x3D;n1+2n2+1   （树的节点树&#x3D;总度数+1）</li></ol><p><img src="/../image/assets/image-20230702160206974.png" alt="image-20230702160206974"></p><h4 id="二叉树第i层至多有2-i-1-个节点"><a href="#二叉树第i层至多有2-i-1-个节点" class="headerlink" title="二叉树第i层至多有2^(i-1)个节点"></a>二叉树第i层至多有2^(i-1)个节点</h4><p><img src="/../image/assets/image-20230702160304035.png" alt="image-20230702160304035"></p><h4 id="高度为h的二叉树最多有2-h-1个节点"><a href="#高度为h的二叉树最多有2-h-1个节点" class="headerlink" title="高度为h的二叉树最多有2*h-1个节点"></a>高度为h的二叉树最多有2*h-1个节点</h4><p><img src="/../image/assets/image-20230702160346024.png" alt="image-20230702160346024"></p><h4 id="完全二叉树常考性质"><a href="#完全二叉树常考性质" class="headerlink" title="完全二叉树常考性质"></a>完全二叉树常考性质</h4><h4 id="具有n个-n-0-节点的完全二叉树的高度为log2-n-1-向下取整或者log2n向上取整-1"><a href="#具有n个-n-0-节点的完全二叉树的高度为log2-n-1-向下取整或者log2n向上取整-1" class="headerlink" title="具有n个(n&gt;0)节点的完全二叉树的高度为log2(n+1)向下取整或者log2n向上取整+1"></a>具有n个(n&gt;0)节点的完全二叉树的高度为log2(n+1)向下取整或者log2n向上取整+1</h4><p>高为h的满二叉树共有2^h-1个节点</p><p><img src="/../image/assets/image-20230702160719524.png" alt="image-20230702160719524"></p><p><img src="/../image/assets/image-20230702160809404.png" alt="image-20230702160809404"></p><h4 id="对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2"><a href="#对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2" class="headerlink" title="对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2"></a>对于完全二叉树，可以由节点数推出度为0、1和2的节点个数为n0、n1、n2</h4><p>完全二叉树最多只有一个度为1的节点，即</p><ul><li>n1&#x3D;0&#x2F;1</li><li>n0&#x3D;n2+1  —-&gt;  n0 + n2 一定是奇数</li></ul><p>若完全二叉树有2k个节点，则必有<strong>n1&#x3D;1,   n0&#x3D;k,   n2&#x3D;k-1</strong></p><p>若完全二叉树有2k-1个节点，则必有<strong>n1&#x3D;0,   n0&#x3D;k,   n2&#x3D;k-1</strong></p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h4 id="i的左孩子"><a href="#i的左孩子" class="headerlink" title="i的左孩子"></a>i的左孩子</h4><h4 id="i的右孩子"><a href="#i的右孩子" class="headerlink" title="i的右孩子"></a>i的右孩子</h4><h4 id="i的父亲节点"><a href="#i的父亲节点" class="headerlink" title="i的父亲节点"></a>i的父亲节点</h4><h4 id="i所在的层次"><a href="#i所在的层次" class="headerlink" title="i所在的层次"></a>i所在的层次</h4><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    二叉树的顺序存储</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    ElemType value; <span class="comment">//节点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;   <span class="comment">//节点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeNode t[Maxsize];    <span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下、从左到右的顺序依次存储完全二叉树中的各个节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitTree</span><span class="params">(TreeNode t[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i ++)&#123;</span><br><span class="line">        <span class="comment">//初始化时所有节点标记为空</span></span><br><span class="line">        t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230702162321119.png" alt="image-20230702162321119"></p><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li>i的左孩子：2i</li><li>i的右孩子：2i+1</li><li>i的父节点：i&#x2F;2向上取整</li><li>i所在的层次：log2(n+1)（向下取整）或log2n+1(向上取整)</li></ul><p>若完全二叉树中共有n个节点，则</p><ul><li>判断i是否有左孩子：2i&lt;&#x3D; n</li><li>判断i是否有右孩子：2i+1&lt;&#x3D;n</li><li>判断i是否时叶子&#x2F;分支节点：i&gt;n&#x2F;2（向上取整）</li></ul><p><img src="/../image/assets/image-20230702165242874.png" alt="image-20230702165242874"></p><p><img src="/../image/assets/image-20230702165355081.png" alt="image-20230702165355081"></p><p>非完全二叉树通过isEmpty(TreeNode T)来判断是否有左右孩子</p><blockquote><p>二叉树的顺序存储结构只适合存储完全二叉树</p></blockquote><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    二叉树的链式存储</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;                      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;    <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>n个节点的二叉链表共有n+1个空链域（可以用于构造线索二叉树）</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitTree</span><span class="params">(BiTree &amp;root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入根节点</span></span><br><span class="line">    root = (BiTree) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    root-&gt;data =&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">    root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入新节点，作为左孩子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertNewTNode</span><span class="params">(BiTree &amp;root, ElemType pData)</span></span>&#123;</span><br><span class="line">    BiTNode *p = (BiTNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    p-&gt;data=pData;</span><br><span class="line">    p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;lchild=p;     <span class="comment">//作为根节点的左孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种定义方法</p><ul><li>找到指定节点p的左&#x2F;右孩子超简单</li><li>找到指定节点p的父节点很难，只能从根节点开始遍历</li></ul><p><img src="/../image/assets/image-20230702173412228.png" alt="image-20230702173412228"></p><h4 id="改进——三叉链表"><a href="#改进——三叉链表" class="headerlink" title="改进——三叉链表"></a>改进——三叉链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三叉链表————方便找父节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;                      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;    <span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *parent;             <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h2 id="二叉树的先中后序遍历"><a href="#二叉树的先中后序遍历" class="headerlink" title="二叉树的先中后序遍历"></a>二叉树的先中后序遍历</h2><p><strong>先中后代表着根出现的顺序</strong></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li><p>按照某中次序把所有节点都访问一遍</p></li><li><p>线性结构很容易进行遍历</p></li><li><p>树可以层次遍历（基于树的层次特性确定的次序规则）也可以先中后序遍历（基于树的递归特性确定的次序规则）</p></li></ul><p><img src="/../image/assets/image-20230704211658740.png" alt="image-20230704211658740"></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="递归特性"><a href="#递归特性" class="headerlink" title="递归特性"></a>递归特性</h4><ol><li>要么是个空二叉树</li><li>要么就是由“根节点+左子树+右子树”组成的二叉树</li></ol><h4 id="手算口诀（默念）"><a href="#手算口诀（默念）" class="headerlink" title="手算口诀（默念）"></a>手算口诀（默念）</h4><p>先序遍历：根左右（NLR）</p><p>中序遍历：左根右（LNR）</p><p>后序遍历：左右根（LRN）</p><p><img src="/../image/assets/image-20230704212420320.png" alt="image-20230704212420320"></p><p><img src="/../image/assets/image-20230704212634674.png" alt="image-20230704212634674"></p><p><img src="/../image/assets/image-20230704212931789.png" alt="image-20230704212931789"></p><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>若二叉树为空，则什么也不做</li><li>若二叉树非空：<ol><li>访问根节点；</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230704214225071.png" alt="image-20230704214225071"></p><p><img src="/../image/assets/image-20230704214415005.png" alt="image-20230704214415005"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="操作过程-1"><a href="#操作过程-1" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>若二叉树为空，则什么也不做</li><li>若二叉树非空：<ol><li>先序遍历左子树；</li><li>访问根节点；</li><li>先序遍历右子树；</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230704214442776.png" alt="image-20230704214442776"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="操作过程-2"><a href="#操作过程-2" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>若二叉树为空，则什么也不做</li><li>若二叉树非空：<ol><li>先序遍历左子树；</li><li>先序遍历右子树；</li><li>访问根节点；</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230704214502599.png" alt="image-20230704214502599"></p><h3 id="求树的深度（应用）"><a href="#求树的深度（应用）" class="headerlink" title="求树的深度（应用）"></a>求树的深度（应用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">treeDepth</span>(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">treeDepth</span>(T -&gt; rchild);</span><br><span class="line">        <span class="comment">//树的深度=Max(左子树深度，右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l&gt;r? l+<span class="number">1</span>:r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>初始化一个辅助<strong>队列</strong></li><li>根节点入队</li><li>若队列非空，则队头节点入队，访问该节点，并将其左右孩子插入队尾（如果有的话）</li><li>重复3直至队列为空</li></ol><p><img src="/../image/assets/image-20230704215010029.png" alt="image-20230704215010029"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);       <span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,T);       <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123; <span class="comment">//队列不空则循环</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,p);   <span class="comment">//队头节点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);       <span class="comment">//访问出队节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(Q,p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(Q,p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><h3 id="不同二叉树的中序遍历序列"><a href="#不同二叉树的中序遍历序列" class="headerlink" title="不同二叉树的中序遍历序列"></a>不同二叉树的中序遍历序列</h3><p><img src="/../image/assets/image-20230704222841229.png" alt="image-20230704222841229"></p><h3 id="若只给出一棵二叉树的前-中-后-层序遍历序列的一种，不能唯一确定一棵二叉树"><a href="#若只给出一棵二叉树的前-中-后-层序遍历序列的一种，不能唯一确定一棵二叉树" class="headerlink" title="若只给出一棵二叉树的前&#x2F;中&#x2F;后&#x2F;层序遍历序列的一种，不能唯一确定一棵二叉树"></a>若只给出一棵二叉树的前&#x2F;中&#x2F;后&#x2F;层序遍历序列的一种，不能唯一确定一棵二叉树</h3><p>一定要有中序遍历序列才能确定一棵二叉树</p><p><img src="/../image/assets/image-20230704223001314.png" alt="image-20230704223001314"></p><h3 id="前序-中序遍历序列"><a href="#前序-中序遍历序列" class="headerlink" title="前序+中序遍历序列"></a>前序+中序遍历序列</h3><p><img src="/../image/assets/image-20230704223142717.png" alt="image-20230704223142717"></p><p><img src="/../image/assets/image-20230704223536041.png" alt="image-20230704223536041"></p><h3 id="后序-中序遍历序列"><a href="#后序-中序遍历序列" class="headerlink" title="后序+中序遍历序列"></a>后序+中序遍历序列</h3><p><img src="/../image/assets/image-20230704223909246.png" alt="image-20230704223909246"></p><h3 id="层序-中序遍历序列"><a href="#层序-中序遍历序列" class="headerlink" title="层序+中序遍历序列"></a>层序+中序遍历序列</h3><p> <img src="/../image/assets/image-20230704224354379.png" alt="image-20230704224354379"></p><p><img src="/../image/assets/image-20230704224307205.png" alt="image-20230704224307205"></p><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树的作用（更容易寻找遍历后的前驱和后继）"><a href="#线索二叉树的作用（更容易寻找遍历后的前驱和后继）" class="headerlink" title="线索二叉树的作用（更容易寻找遍历后的前驱和后继）"></a>线索二叉树的作用（更容易寻找遍历后的前驱和后继）</h3><h4 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h4><ul><li>遍历只能从根节点出发，不能从一个指定节点开始中序遍历</li><li>找到指定节点p在中序遍历中的前驱或者后继，需要从根节点出发重新进行一次中序遍历<ul><li>用一个指针q记录当前访问的节点，指针pre记录上一个被访问的节点。</li><li>当q&#x3D;&#x3D;p时，pre为前驱</li><li>当pre&#x3D;&#x3D;p时，q为后继</li></ul></li></ul><p><img src="/../image/assets/image-20230704225230624.png" alt="image-20230704225230624"></p><h4 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h4><p><img src="/../image/assets/image-20230704225516383.png" alt="image-20230704225516383"></p><h3 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> ElemType&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树节点（链式存储）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;                      <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;    <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;                     <span class="comment">//左右线索标志（tag=0，表示指针指向孩子；tag=1，表示指针是线索）</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p><img src="/../image/assets/image-20230705154700122.png" alt="image-20230705154700122"></p><h4 id="中序线索二叉树-1"><a href="#中序线索二叉树-1" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h4><p><img src="/../image/assets/image-20230705154812016.png" alt="image-20230705154812016"></p><h4 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h4><p><img src="/../image/assets/image-20230705154921007.png" alt="image-20230705154921007"></p><p><img src="/../image/assets/image-20230705155118817.png" alt="image-20230705155118817"></p><h4 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h4><p><img src="/../image/assets/image-20230705155222541.png" alt="image-20230705155222541"></p><p><img src="/../image/assets/image-20230705155239630.png" alt="image-20230705155239630"></p><h3 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h3><h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><blockquote><p>只有先序线索化的时候才会出现转圈死循环的状态</p><p>因为只有先序线索化是先visit，使得原本为NULL的lchild填充进前驱节点后，再进行PreThread(T-&gt;lchild)</p><p>而其他两种遍历都是先访问lchild再visit</p></blockquote><h4 id="用土方法找到中序前驱"><a href="#用土方法找到中序前驱" class="headerlink" title="用土方法找到中序前驱"></a>用土方法找到中序前驱</h4><p><img src="/../image/assets/image-20230705161227608.png" alt="image-20230705161227608"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找节点p的前驱</span></span><br><span class="line">BiTNode *p;                 <span class="comment">//p指向目标节点</span></span><br><span class="line">BiTNode *pre=<span class="literal">NULL</span>;          <span class="comment">//指向当前访问节点的前驱</span></span><br><span class="line">BiTNode *<span class="keyword">final</span>=<span class="literal">NULL</span>;        <span class="comment">//记录最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问节点q</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)                <span class="comment">//当前访问节点刚好是节点p</span></span><br><span class="line">        <span class="keyword">final</span> = pre;        <span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span> pre = q;           <span class="comment">//pre指向当前访问的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);    <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);    <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序线索化-1"><a href="#中序线索化-1" class="headerlink" title="中序线索化"></a>中序线索化</h4><p><img src="/../image/assets/image-20230705162744790.png" alt="image-20230705162744790"></p><p><img src="/../image/assets/image-20230705163128107.png" alt="image-20230705163128107"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre指向当前访问节点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;              <span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;                  <span class="comment">//建立前驱节点的后继节点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;<span class="comment">//对pre进行更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);            <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);                       <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);            <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                         <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!= <span class="literal">NULL</span>)&#123;                       <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T);                    <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)           </span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;                <span class="comment">//处理遍历的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>书上版本</strong></p><p><img src="/../image/assets/image-20230705163356997.png" alt="image-20230705163356997"></p><h4 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h4><p><img src="/../image/assets/image-20230705163552658.png" alt="image-20230705163552658"></p><blockquote><p>先序线索化容易出现死循环，所以必须对ltag进行判断</p></blockquote><p><img src="/../image/assets/image-20230705163706180.png" alt="image-20230705163706180"></p><ul><li><strong>视频版本</strong></li></ul><p><img src="/../image/assets/image-20230705163818823.png" alt="image-20230705163818823"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre指向当前访问节点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;              <span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;                  <span class="comment">//建立前驱节点的后继节点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;<span class="comment">//对pre进行更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">visit</span>(T);                        <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">if</span>(T-&gt;ltag==<span class="number">0</span>) <span class="comment">//lchild不是前驱线索</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;lchild);          <span class="comment">//中序遍历左子树</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild);            <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                         <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!= <span class="literal">NULL</span>)&#123;                       <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T);                    <span class="comment">//先序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)           </span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;                <span class="comment">//处理遍历的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>书上代码</strong></li></ul><p><img src="/../image/assets/image-20230705164330469.png" alt="image-20230705164330469"></p><h4 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h4><ul><li><strong>视频代码</strong></li></ul><p><img src="/../image/assets/image-20230705164703509.png" alt="image-20230705164703509"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre指向当前访问节点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;              <span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q;                  <span class="comment">//建立前驱节点的后继节点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;<span class="comment">//对pre进行更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostThread</span><span class="params">(ThreadNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);            <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);            <span class="comment">//中序遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);                         <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                         <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!= <span class="literal">NULL</span>)&#123;                       <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T);                    <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild==<span class="literal">NULL</span>)           </span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;                <span class="comment">//处理遍历的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>书上代码</li></ul><p><img src="/../image/assets/image-20230705165000736.png" alt="image-20230705165000736"></p><h3 id="线索二叉树寻找前驱后继（先不前，后不继）-1"><a href="#线索二叉树寻找前驱后继（先不前，后不继）-1" class="headerlink" title="线索二叉树寻找前驱后继（先不前，后不继）"></a>线索二叉树寻找前驱后继（先不前，后不继）</h3><ul><li>先不前，后不继<ul><li>先序线索二叉树不能找先序前驱</li><li>后序线索二叉树不能找后序后继<ul><li>因为只有根能找到自己的左右子树</li><li>先序遍历的时候：根左右，根在最前面，所以找不到自己的前驱</li><li>后序遍历的时候：左右根，根在最后面，所以找不到自己的后继</li></ul></li></ul></li></ul><h4 id="中序线索二叉树找中序后继"><a href="#中序线索二叉树找中序后继" class="headerlink" title="中序线索二叉树找中序后继"></a>中序线索二叉树找中序后继</h4><ul><li>在中序线索二叉树中找到指定节点*p的中序后继next<ul><li>如果p-&gt;rtag&#x3D;&#x3D;1,则next&#x3D;p-&gt;rchild</li><li>如果p-&gt;rtag&#x3D;&#x3D;0,则next&#x3D;p的右子树中最左下节点</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以p为根的子树中，第一个被中序遍历的节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最左下节点(不一定是叶子节点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>) p=p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到节点p的后继节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//右子树中最左下节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Firstnode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;              <span class="comment">//rtag==1直接返回后序线索</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历（利用线索实现的非递归算法）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">Firstnode</span>(T); p!=<span class="literal">NULL</span>;p=<span class="built_in">Nextnode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230705172852595.png" alt="image-20230705172852595"></p><p><img src="/../image/assets/image-20230705173819863.png" alt="image-20230705173819863"></p><h4 id="中序线索二叉树找中序前驱"><a href="#中序线索二叉树找中序前驱" class="headerlink" title="中序线索二叉树找中序前驱"></a>中序线索二叉树找中序前驱</h4><ul><li>在中序线索二叉树中找到指定节点*p的中序前驱pre<ul><li>如果p-&gt;ltag&#x3D;&#x3D;1,则pre&#x3D;p-&gt;lchild</li><li>如果p-&gt;ltag&#x3D;&#x3D;0,则pre&#x3D;p的左子树中最右下节点</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    中序遍历找前驱</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Lastnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最右下节点（不一定是叶节点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag==<span class="number">0</span>) p=p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到节点p的前驱节点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Prenode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//左子树中最右下节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Lastnode</span>(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;lchild;                      <span class="comment">//ltag==1直接返回前驱线索</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">Lastnode</span>(T); p!=<span class="literal">NULL</span>; p=<span class="built_in">Prenode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230705174105589.png" alt="image-20230705174105589"></p><p><img src="/../image/assets/image-20230705174837243.png" alt="image-20230705174837243"></p><h4 id="先序线索二叉树找先序后继"><a href="#先序线索二叉树找先序后继" class="headerlink" title="先序线索二叉树找先序后继"></a>先序线索二叉树找先序后继</h4><ul><li>在先序线索二叉树中找到指定节点*p的先序后继next<ul><li>若p-&gt;rtag&#x3D;&#x3D;1,则next&#x3D;p-&gt;rchild</li><li>若p-&gt;rtag&#x3D;&#x3D;0<ul><li>若p有左孩子则先序后继为左孩子</li><li>若p没有左孩子，则先序后继为右孩子</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705175024236</span>](../image/assets/image<span class="number">-20230705175024236.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 先序线索二叉树找先序前驱（不行）</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705175455248</span>](../image/assets/image<span class="number">-20230705175455248.</span>png)</span><br><span class="line"></span><br><span class="line">- 在先序线索二叉树中找到指定节点*p的先序前驱pre</span><br><span class="line"></span><br><span class="line">  - 若p-&gt;ltag==<span class="number">1</span>,则pre=p-&gt;lchild</span><br><span class="line"></span><br><span class="line">  - **若p-&gt;ltag==<span class="number">0</span>,则先序线索二叉树无法寻找到先序前驱，因为左右子树中的节点只可能是根的后继，不可能是前驱**</span><br><span class="line"></span><br><span class="line">    - 除非用土办法从头开始先序遍历</span><br><span class="line"></span><br><span class="line">    - 或者使用三叉链表（有一个指向父节点的指针）</span><br><span class="line"></span><br><span class="line">      - 如果能找到p的父节点，且**p是左孩子——p的父节点即为其前驱**</span><br><span class="line">      - 如果能找到p的父节点，且**p是右孩子，其左兄弟为空——p的父节点即为其前驱**</span><br><span class="line">      - 如果能找到p的父节点，且**p是右孩子，其左兄弟非空——p的前驱为左兄弟子树中最后一个被先序遍历的节点**</span><br><span class="line">        - 怎么找左兄弟子树中最后一个被先序遍历的节点？</span><br><span class="line">          - （自己的思路）优先寻找左兄弟子树中的右节点，如果没有右节点则寻找左节点，直到叶子节点</span><br><span class="line"></span><br><span class="line">      - p是根节点，则p没有前驱节点</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705175916064</span>](../image/assets/image<span class="number">-20230705175916064.</span>png)</span><br><span class="line"></span><br><span class="line">#### 后序线索二叉树找后序前驱</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705180603206</span>](../image/assets/image<span class="number">-20230705180603206.</span>png)</span><br><span class="line"></span><br><span class="line">- 在后序线索二叉树中找到指定节点*p的后序前驱pre</span><br><span class="line">  - 若p-&gt;ltag==<span class="number">1</span>,则pre=p-&gt;lchild</span><br><span class="line">  - 若p-&gt;ltag==<span class="number">0</span></span><br><span class="line">    - 若p有右孩子，则后序前驱为右孩子</span><br><span class="line">    - 若p没有右孩子，则后序前驱为左孩子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 后序线索二叉树找后序后继（不行）</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705181036104</span>](../image/assets/image<span class="number">-20230705181036104.</span>png)</span><br><span class="line"></span><br><span class="line">- 在后序线索二叉树中找到指定节点*p的后序后继next</span><br><span class="line">  - 若p-&gt;rtag==<span class="number">1</span>,则next=p-&gt;rchild</span><br><span class="line">  - 若p-&gt;rtag==<span class="number">0</span>,则后序线索二叉树无法寻找到后序后驱，因为**左右子树中的节点只可能是根的前驱，不可能是后继**</span><br><span class="line">    - 除非用土办法从头开始后序遍历</span><br><span class="line">    - 或者使用三叉链表（有一个指向父节点的指针）</span><br><span class="line">      - 如果能找到p的父节点，且**p是右孩子——p的父节点即为其后继**</span><br><span class="line">      - 如果能找到p的父节点，且**p是左孩子，其右兄弟为空**——**p的父节点即为其前驱**</span><br><span class="line">      - 如果能找到p的父节点，且**p是左孩子，其右兄弟非空**——**p的前驱为右兄弟子树中第一个被后序遍历的节点**</span><br><span class="line">        - 怎么找右兄弟子树中第一个被后序遍历的节点？</span><br><span class="line">          - （自己的思路）优先寻找右兄弟子树中的左节点，如果没有左节点则寻找右节点，直到叶子节点</span><br><span class="line">      - 如果p是根节点，则p没有后序后继</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 三种线索二叉树</span><br><span class="line"></span><br><span class="line">#### 三种线索二叉树的对比</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705155352784</span>](../image/assets/image<span class="number">-20230705155352784.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 树的存储结构</span><br><span class="line"></span><br><span class="line">### 树的逻辑结构</span><br><span class="line"></span><br><span class="line">- 树是<span class="built_in">n</span> (n&gt;=<span class="number">0</span>)个节点的有限集合，n=<span class="number">0</span>时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：</span><br><span class="line">  - 有且仅有一个特定的称为根的节点</span><br><span class="line">  - 当n&gt;<span class="number">1</span>时，其余节点可分为<span class="built_in">m</span> (m&gt;<span class="number">0</span>) 个互不相交的有限集合T1,T2,...,Tm,其中每个集合本身又是一棵树，并且称为根节点的子树</span><br><span class="line">- 树是一种递归定义的数据结构</span><br><span class="line">  - 二叉树：一个分支节点最多只能右两棵子树</span><br><span class="line">  - 树：一个分支节点可以有多棵子树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705191624631</span>](../image/assets/image<span class="number">-20230705191624631.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 回顾：二叉树的顺序存储</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230705191727964</span>](../image/assets/image<span class="number">-20230705191727964.</span>png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 树的顺序存储</span><br><span class="line"></span><br><span class="line">- 树：一个分支节点可以有多棵子树</span><br><span class="line">- 只依靠数组下标无法反映节点之间的逻辑关系</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 树的存储<span class="number">1</span>:双亲表示法</span><br><span class="line"></span><br><span class="line">#### 思路</span><br><span class="line"></span><br><span class="line">- 用数组顺序存储各个节点。</span><br><span class="line">- **每个节点中保存数据元素、指向双亲节点（父节点）的指针**</span><br><span class="line">- 可以保存森林</span><br><span class="line"></span><br><span class="line">#### 优缺点</span><br><span class="line"></span><br><span class="line">- 优点：</span><br><span class="line">  - 找双亲（父节点）很方便</span><br><span class="line"></span><br><span class="line">- 缺点</span><br><span class="line">  - 找孩子节点很不方便，只能从头遍历整个数组</span><br><span class="line">- 比较适用于找父亲多，找孩子少的应用场景。如：并查集</span><br><span class="line"></span><br><span class="line">#### 代码实现</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    树的存储：双亲表示法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100     <span class="comment">//树中最多的节点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//树的节点定义</span></span><br><span class="line">    <span class="type">int</span> parent;                 <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                 <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;                      <span class="comment">//节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230705192015342.png" alt="image-20230705192015342"></p><p><img src="/../image/assets/image-20230705192413802.png" alt="image-20230705192413802"></p><h4 id="树的存储2-孩子表示法（链式存储-顺序存储）"><a href="#树的存储2-孩子表示法（链式存储-顺序存储）" class="headerlink" title="树的存储2:孩子表示法（链式存储+顺序存储）"></a>树的存储2:孩子表示法（链式存储+顺序存储）</h4><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>用数组顺序存储各个节点。</li><li>每个节点中保存数据元素、孩子链表头指针</li><li>也可以存储森林</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点<ul><li>找孩子很方便</li></ul></li><li>缺点<ul><li>找双亲（父节点）不方便，只能遍历每个链表</li></ul></li><li>适用于找孩子多，找父亲少的应用场景，如：服务流程树</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    树的存储：孩子表示法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> child;      <span class="comment">//孩子节点在数组中的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;  <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *firstChild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n, r;<span class="comment">//节点数和根的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230705192920354.png" alt="image-20230705192920354"></p><p><img src="/../image/assets/image-20230705193937268.png" alt="image-20230705193937268"></p><p><img src="/../image/assets/image-20230705194259393.png" alt="image-20230705194259393"></p><h4 id="树的存储3-孩子兄弟表示法（链式存储结构）"><a href="#树的存储3-孩子兄弟表示法（链式存储结构）" class="headerlink" title="树的存储3:孩子兄弟表示法（链式存储结构）"></a>树的存储3:孩子兄弟表示法（链式存储结构）</h4><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>与二叉树类似，采用二叉链表实现（左孩子右兄弟）</li><li>每个节点内保存数据元素和两个指针，但两个指针的含义与二叉树节点不同</li><li>也可以存储森林，将森林中每棵树的根节点视为平级的兄弟关系</li></ul><p><img src="/../image/assets/image-20230705195912056.png" alt="image-20230705195912056"></p><p><img src="/../image/assets/image-20230705200149154.png" alt="image-20230705200149154"></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h3><ul><li><strong>节点的权</strong>：有某种现实含义的数值（如：节点的重要性）</li><li><strong>节点的带权路径长度</strong>：从树的根到该节点的路径长度（经过的边数）与该节点上权值的乘积</li><li><strong>树的带权路径长度：</strong>树中所有叶子节点的带权路径长度之和（WPL，Weighted Path Length)</li></ul><p><img src="/../image/assets/image-20230705201213503.png" alt="image-20230705201213503"></p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>在含有n个带权叶子节点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树</p><p><img src="/../image/assets/image-20230705201331984.png" alt="image-20230705201331984"></p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul><li>给定n个权值分别为w1,w2,…,w3的节点，构造哈夫曼树的算法描述如下：<ol><li>将n个节点分别作为n棵仅含一个节点的二叉树，构成森林F</li><li>构造一个新节点，从F中选取两棵根节点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根节点的权值之和</li><li>从F中 删除刚才选出的两棵树，同时将新的到的树加入F中</li><li>重复步骤2和3，直至F中只剩下一棵树为止</li></ol></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>每个初始节点最终都成为叶节点，且权值越小的节点到根节点的路径越大</li><li>哈夫曼树的节点总数是2n-1</li><li>哈夫曼树中不存在度为1的点</li><li>哈夫曼树并不唯一，但WPL必然相等且为最优解</li></ul><p><img src="/../image/assets/image-20230705202000675.png" alt="image-20230705202000675"></p><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h4 id="固定长度编码"><a href="#固定长度编码" class="headerlink" title="固定长度编码"></a>固定长度编码</h4><ul><li>每个字符用相等长度的二进制位表示</li></ul><h4 id="可变长度编码"><a href="#可变长度编码" class="headerlink" title="可变长度编码"></a>可变长度编码</h4><ul><li>允许对不同字符用不等长的二进制位表示</li></ul><h4 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h4><ul><li>没有一个编码是另一个编码的前缀</li><li>前缀码解释无歧义</li></ul><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ul><li>用哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子节点，各个字符出现的频度作为节点的权值，根据之前的方法构造哈夫曼树</li><li>哈夫曼树不唯一，因此哈夫曼编码不唯一</li><li>哈夫曼编码可以用于数据的压缩</li></ul><p><img src="/../image/assets/image-20230705202705501.png" alt="image-20230705202705501"></p><p><img src="/../image/assets/image-20230705203033880.png" alt="image-20230705203033880"></p><p><img src="/../image/assets/image-20230705203455986.png" alt="image-20230705203455986"></p><h2 id="树、森林和二叉树的转换（孩子兄弟表示法）"><a href="#树、森林和二叉树的转换（孩子兄弟表示法）" class="headerlink" title="树、森林和二叉树的转换（孩子兄弟表示法）"></a>树、森林和二叉树的转换（孩子兄弟表示法）</h2><h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><h4 id="转换技巧"><a href="#转换技巧" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>现在二叉树中，画一个根节点</li><li>按“树的层序”依次处理每个节点</li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>如果当前处理的节点在树中有孩子，就<strong>把所有孩子节点“用右指针串成糖葫芦”</strong>，并在二叉树中把第一个孩子挂在当前节点的左指针下面</li></ul><p><img src="/../image/assets/image-20230705204752770.png" alt="image-20230705204752770"></p><p><img src="/../image/assets/image-20230705205010792.png" alt="image-20230705205010792"></p><h3 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>森林中各棵树的根节点视为平级的兄弟关系</li></ul><h4 id="转换技巧-1"><a href="#转换技巧-1" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>先把所有树的根节点画出来，在二叉树中用右指针串成糖葫芦</li><li>按<strong>森林的层序</strong>依次处理每个节点</li></ol><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li>如果当前处理的节点在树中有孩子，就把所有孩子节点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前节点的左指针下方</li></ul><p><img src="/../image/assets/image-20230705205544107.png" alt="image-20230705205544107"></p><p><img src="/../image/assets/image-20230705212821411.png" alt="image-20230705212821411"></p><h3 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h3><h4 id="转换技巧-2"><a href="#转换技巧-2" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>先画出树的根节点</li><li>从树的根节点开始，按照<strong>“树的层序”</strong>恢复每个节点的孩子</li></ol><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><ul><li>如何恢复一个节点的孩子：在二叉树中，如果当前处理的节点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前节点的下方</li></ul><p><img src="/../image/assets/image-20230705213239895.png" alt="image-20230705213239895"></p><p><img src="/../image/assets/image-20230705213402764.png" alt="image-20230705213402764"></p><h3 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h3><h4 id="转换技巧-3"><a href="#转换技巧-3" class="headerlink" title="转换技巧"></a>转换技巧</h4><ol><li>先把二叉树的根节点和“一整串右指针糖葫芦”拆下来，作为多棵树的根节点</li><li>按“森林的层序”恢复每个节点的孩子</li></ol><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul><li>在一个二叉树中，如果当前处理的节点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前节点的下方</li></ul><p><img src="/../image/assets/image-20230705213839951.png" alt="image-20230705213839951"></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="使用克鲁斯卡尔Kruskal算法求图的最小生成树"><a href="#使用克鲁斯卡尔Kruskal算法求图的最小生成树" class="headerlink" title="使用克鲁斯卡尔Kruskal算法求图的最小生成树"></a>使用克鲁斯卡尔Kruskal算法求图的最小生成树</h4><p><img src="/../image/assets/image-20230814204400581.png" alt="image-20230814204400581"></p><ul><li><strong>判断是否加入一条边</strong><ul><li>先查找这条边关联的两个顶点是否属于同一个集合<ul><li>即判断加入这条边之后是否形成回路</li></ul></li><li>若形成回路，则继续判断下一条边</li><li>若形不成回路，则将该边和边对应的顶点加入最小生成树 T，并继续判断下一条边</li><li>直到所有顶点都已经加入最小生成树 T</li></ul></li></ul><h4 id="判断无向图的连通性"><a href="#判断无向图的连通性" class="headerlink" title="判断无向图的连通性"></a>判断无向图的连通性</h4><p><img src="/../image/assets/image-20230814204606124.png" alt="image-20230814204606124"></p><ul><li>用并查集判断无向图连通性的方法<ul><li>遍历无向图的边，每遍历到一条边，就把这条边连接的两个顶点合并到同一个集合中</li><li>处理完所有边之后，只要是相互连通的顶点都会被合并到同一个子集合中，相互不连通的顶点一定在不同的子集合中</li></ul></li></ul><p><img src="/../image/assets/image-20230705214230148.png" alt="image-20230705214230148"></p><h3 id="逻辑结构——集合"><a href="#逻辑结构——集合" class="headerlink" title="逻辑结构——集合"></a>逻辑结构——集合</h3><p>逻辑结构分为：线性结构、树形结构、图结构、集合</p><h4 id="全集S"><a href="#全集S" class="headerlink" title="全集S"></a>全集S</h4><ul><li>包含所有元素</li></ul><h4 id="子集S0，S1，S2…"><a href="#子集S0，S1，S2…" class="headerlink" title="子集S0，S1，S2…"></a>子集S0，S1，S2…</h4><ul><li>将各个元素划分为若干个<strong>互不相交</strong>的子集</li></ul><h4 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h4><ul><li>A和B属于同一个集合S0</li><li>A和H属于不同的集合</li></ul><p><img src="/../image/assets/image-20230705214456468.png" alt="image-20230705214456468"></p><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><ul><li>森林是m（m&gt;&#x3D;0)棵互不相交的树的集合</li><li>各个子集中的各个元素，可以组织成一棵树</li><li>三棵树可以组成森林</li></ul><h3 id="如何表示“集合关系”（并-AND-查）"><a href="#如何表示“集合关系”（并-AND-查）" class="headerlink" title="如何表示“集合关系”（并 AND 查）"></a>如何表示“集合关系”（并 AND 查）</h3><h4 id="用互不相交的树，表示多个“集合”"><a href="#用互不相交的树，表示多个“集合”" class="headerlink" title="用互不相交的树，表示多个“集合”"></a>用互不相交的树，表示多个“集合”</h4><h4 id="如何“查”到一个元素到底属于哪一个集合"><a href="#如何“查”到一个元素到底属于哪一个集合" class="headerlink" title="如何“查”到一个元素到底属于哪一个集合"></a>如何“<strong>查</strong>”到一个元素到底属于哪一个集合</h4><ul><li>从指定元素出发，一路向上，直到找到根节点</li></ul><h4 id="如何判断两个元素是否属于同一个集合？"><a href="#如何判断两个元素是否属于同一个集合？" class="headerlink" title="如何判断两个元素是否属于同一个集合？"></a>如何判断两个元素是否属于同一个集合？</h4><ul><li>分别查到两个元素的根，判断根节点是否相等即可</li></ul><h4 id="如何把两个集合“并”为一个集合？"><a href="#如何把两个集合“并”为一个集合？" class="headerlink" title="如何把两个集合“并”为一个集合？"></a>如何把两个集合“并”为一个集合？</h4><ul><li>让一棵树成为另一棵树的子树即可</li></ul><p><img src="/../image/assets/image-20230705215232833.png" alt="image-20230705215232833"></p><h3 id="并查集存储结构"><a href="#并查集存储结构" class="headerlink" title="并查集存储结构"></a>并查集存储结构</h3><h4 id="类比-树的存储——双亲表示法"><a href="#类比-树的存储——双亲表示法" class="headerlink" title="类比: 树的存储——双亲表示法"></a>类比: 树的存储——双亲表示法</h4><p><img src="/../image/assets/image-20230705215357726.png" alt="image-20230705215357726"></p><p><img src="/../image/assets/image-20230705215613856.png" alt="image-20230705215613856"></p><p><img src="/../image/assets/image-20230705215739328.png" alt="image-20230705215739328"></p><h3 id="“并查集”的代码实现"><a href="#“并查集”的代码实现" class="headerlink" title="“并查集”的代码实现"></a>“并查集”的代码实现</h3><ul><li>并 和 查</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作 找x所属集合（返回x所属根节点）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)              <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;                   <span class="comment">//根的S[]小于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作 将两个集合合并为一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//要求Root1和Root2是两个不同的集合</span></span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    并查集</span></span><br><span class="line"><span class="comment">    树的存储：双亲表示法</span></span><br><span class="line"><span class="comment">    通过int S[]这样一个数组来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100     <span class="comment">//树中最多的节点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];               <span class="comment">//集合元素数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//树的节点定义</span></span><br><span class="line">    <span class="type">int</span> parent;                 <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                 <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;                      <span class="comment">//节点数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find &quot;查&quot;操作 找x所属集合（返回x所属根节点）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)              <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;                   <span class="comment">//根的S[]小于0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作 将两个集合合并为一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//要求Root1和Root2是两个不同的集合</span></span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析-与并查集树的高度有关"><a href="#时间复杂度分析-与并查集树的高度有关" class="headerlink" title="时间复杂度分析(与并查集树的高度有关)"></a>时间复杂度分析(与并查集树的高度有关)</h4><p><img src="/../image/assets/image-20230814204810890.png" alt="image-20230814204810890"></p><ul><li>最好时间复杂度：O(1)</li><li>最坏时间复杂度：O(n)</li></ul><p><img src="/../image/assets/image-20230705221938113.png" alt="image-20230705221938113"></p><h3 id="”并查集“的优化"><a href="#”并查集“的优化" class="headerlink" title="”并查集“的优化"></a>”并查集“的优化</h3><ul><li>优化后find()最坏时间复杂度为log2(n)  树高不超过log2(n)+1</li></ul><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><ul><li>每次Union操作构建树的时候，尽可能让树不长高高<ul><li>用根节点的绝对值表示树的节点总数（-number）</li><li><strong>Union操作，让小树合并到大树</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union操作优化 “并”操作 小树合并到大树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[Root2]&gt;S[Root1])&#123;      <span class="comment">//Root2节点数更少</span></span><br><span class="line">        S[Root1] += S[Root2];   <span class="comment">//累加节点总数</span></span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        S[Root2]+=S[Root1];     <span class="comment">//累加节点总数</span></span><br><span class="line">        S[Root1]=Root2;         <span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230705222408759.png" alt="image-20230705222408759"></p><p><img src="/../image/assets/image-20230705223039955.png" alt="image-20230705223039955"></p><h3 id="并查集的终极优化"><a href="#并查集的终极优化" class="headerlink" title="并查集的终极优化"></a>并查集的终极优化</h3><h4 id="Find操作的优化（压缩路径）"><a href="#Find操作的优化（压缩路径）" class="headerlink" title="Find操作的优化（压缩路径）"></a>Find操作的优化（压缩路径）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find 查操作 找x所属集合（返回x所属根节点）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>) x=S[x];<span class="comment">//循环寻找x的根</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find 查操作优化 先找到根节点  再进行“压缩路径”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>) root=S[root];     <span class="comment">//循环找到根节点</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root)&#123;                     <span class="comment">//压缩路径</span></span><br><span class="line">        <span class="type">int</span> t=S[x];                     <span class="comment">//t指向x的父节点</span></span><br><span class="line">        S[x]=root;                      <span class="comment">//x直接挂到根节点下</span></span><br><span class="line">        x=t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;                        <span class="comment">//返回根节点的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul><li>先找到根节点</li><li>再将查找路径上所有节点都挂到根节点下</li></ul><p><img src="/../image/assets/image-20230706110456300.png" alt="image-20230706110456300"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>每次Find操作，先找根，再“压缩路径”，可使树的高度不超过O(a(n)).</li><li>a(n)是一个增长很缓慢的函数，对于常见的n值（&lt;10000)，通常a(n)&lt;&#x3D;4,因此优化后并查集的Find、Union操作时间开销都很低</li></ul><p><img src="/../image/assets/image-20230706110840907.png" alt="image-20230706110840907"></p><h3 id="总结两次优化"><a href="#总结两次优化" class="headerlink" title="总结两次优化"></a>总结两次优化</h3><p><img src="/../image/assets/image-20230706110938473.png" alt="image-20230706110938473"></p><p><img src="/../image/assets/image-20230706111114375.png" alt="image-20230706111114375"></p><h2 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>树是一种递归定义的数据结构</p><h4 id="先根遍历（深度优先遍历，类似二叉树的先序遍历）"><a href="#先根遍历（深度优先遍历，类似二叉树的先序遍历）" class="headerlink" title="先根遍历（深度优先遍历，类似二叉树的先序遍历）"></a>先根遍历（深度优先遍历，类似二叉树的先序遍历）</h4><ul><li>若树非空，先访问根节点，再依次对每棵子树进行先根遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的先根遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(R);       <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            <span class="built_in">PreOrder</span>(T);    <span class="comment">//先根遍历下一棵子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230705225317743.png" alt="image-20230705225317743"></p><h4 id="后根遍历-深度优先遍历，类似二叉树的中序遍历"><a href="#后根遍历-深度优先遍历，类似二叉树的中序遍历" class="headerlink" title="后根遍历(深度优先遍历，类似二叉树的中序遍历)"></a>后根遍历(深度优先遍历，类似二叉树的中序遍历)</h4><ul><li>若树非空，先依次对每棵子树进行后根遍历，最后再访问根节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根的后根遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode *R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">            <span class="built_in">PostOrder</span>(T);   <span class="comment">//后根遍历下一棵子树</span></span><br><span class="line">        <span class="built_in">visit</span>(R);           <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230705225849576.png" alt="image-20230705225849576"></p><h4 id="层序遍历（广度优先遍历）"><a href="#层序遍历（广度优先遍历）" class="headerlink" title="层序遍历（广度优先遍历）"></a>层序遍历（广度优先遍历）</h4><ul><li>用队列实现<ul><li>若树非空，则根节点入队</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li><li>重复2直到队列为空</li></ul></li></ul><p><img src="/../image/assets/image-20230706103738593.png" alt="image-20230706103738593"></p><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><h4 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul><li>森林是m(m&gt;&#x3D;0)棵互不相交的树的集合。每棵树去掉根节点后，其各个子树又组成森林</li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li><p><strong>效果等同于依次对各个树进行先根遍历，对二叉树进行先序遍历</strong></p></li><li><p>若森林非空，则按如下规则进行遍历</p><ol><li>访问森林中第一棵树的根节点</li><li>先序遍历第一棵树中根节点的子树森林</li><li>先序遍历除去第一棵树之后剩余的树组成的森林</li></ol></li></ul><p><img src="/../image/assets/image-20230706104545434.png" alt="image-20230706104545434"></p><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><h5 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h5><ul><li><p><strong>效果等同于依次对各个树进行后根遍历，对二叉树进行中序遍历</strong></p></li><li><p>若森林非空，则按一下规则进行遍历：</p><ol><li>中序遍历森林中第一棵树的根节点的子树森林</li><li>访问第一棵树的根节点</li><li>中序遍历除去第一棵树之后剩余的树构成的森林</li></ol></li></ul><p><img src="/../image/assets/image-20230706105316336.png" alt="image-20230706105316336"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树和二叉树&quot;&gt;&lt;a href=&quot;#树和二叉树&quot; class=&quot;headerlink&quot; title=&quot;树和二叉树&quot;&gt;&lt;/a&gt;树和二叉树&lt;/h1&gt;&lt;h2 id=&quot;考点总结&quot;&gt;&lt;a href=&quot;#考点总结&quot; class=&quot;headerlink&quot; title=&quot;考点总结&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="树与二叉树" scheme="https://sdumoist.github.io/tags/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="https://sdumoist.github.io/2023/07/01/%E4%B8%B2/"/>
    <id>https://sdumoist.github.io/2023/07/01/%E4%B8%B2/</id>
    <published>2023-07-01T02:37:14.491Z</published>
    <updated>2024-03-30T19:25:29.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230701101054536.png" alt="image-20230701101054536"></p><p><img src="/../image/assets/image-20230701125323097.png" alt="image-20230701125323097"></p><p><img src="/../image/assets/image-20230701132729113.png" alt="image-20230701132729113"></p><p><img src="/../image/assets/image-20230701141636054.png" alt="image-20230701141636054"></p><p><img src="/../image/assets/image-20230701143309420.png" alt="![image-20230701155518622](../image/assets/image-20230701155518622.png)"></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由零个或多个字符组成的有限序列。一般记为S&#x3D;’a1,a2,a3…an’(n&gt;&#x3D; 0)</p><p>其中，S是<strong>串名</strong>，单引号括起来的字符序列是串的值；ai可以是数字、字母或者其他字符；串中字符的个数n称为<strong>串的长度</strong>。n&#x3D;0时的串称为<strong>空串</strong></p><p>例如：S&#x3D;”HelloWorld!”  T&#x3D;’iPhone 11 pro max?’</p><h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>串中任意个连续的字符组成的子序列</p><p>例如：‘iPhone’ ‘Pro M’就是串T的子串</p><h4 id="主串"><a href="#主串" class="headerlink" title="主串"></a>主串</h4><p>包含子串的串    </p><p>例如：T是子串’iPhone’的主串</p><h4 id="字符在主串中的位置"><a href="#字符在主串中的位置" class="headerlink" title="字符在主串中的位置"></a>字符在主串中的位置</h4><p>字符在串中的序号</p><p>例如：’1’在T中的位置是8（第一次出现）</p><h4 id="子串在主串中的位置"><a href="#子串在主串中的位置" class="headerlink" title="子串在主串中的位置"></a>子串在主串中的位置</h4><p>子串的第一个字符在主串中的位置</p><p>例如：’11 Pro’在T中的位置是8</p><h4 id="空串-VS-空格串"><a href="#空串-VS-空格串" class="headerlink" title="空串 VS 空格串"></a>空串 VS 空格串</h4><p>M &#x3D; ‘’    M是空串</p><p>N &#x3D; ‘   ‘  N是由三个空格字符组成的空格串，每个空格字符占1B</p><h4 id="串-VS-线性表"><a href="#串-VS-线性表" class="headerlink" title="串 VS 线性表"></a>串 VS 线性表</h4><p>串是一种特殊的线性表，数据元素之间呈线性关系</p><p><img src="/../image/assets/image-20230630224417486.png" alt="image-20230630224417486"></p><p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符）</p><p>串的基本操作，如增删改查等<strong>通常以子串为操作对象</strong></p><h2 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h2><p><img src="/../image/assets/image-20230630225329884.png" alt="image-20230630225329884"></p><ul><li>StrAssigh(&amp;T,chars):  赋值操作。把串赋值为chars</li><li>StrCopy(&amp;T, S): 复制操作。由串S复制得到串T</li><li>StrEmpty(S): 判空操作。若S为空串，则返回TRUE，否则返回FALSE</li><li>StrLength(S): 求串长。返回串S的元素个数</li><li>ClearString(&amp;S): 清空操作。将S清为空串</li><li>DestroyString(&amp;S): 销毁串。将串S销毁（回收存储空间）</li><li>Concat(&amp;T,S1,S2): 串联接。用T返回由S1和S2连接形成的新串</li><li>SubString(&amp;Sub,S,pos,len): 求子串。用sub返回串S的第pos个字符起长度为len的子串</li><li>Index(S,T): 定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</li><li>StrCompare(S,T):比较操作。若S&gt;T,则返回值&gt;0; 若S&#x3D;T，则返回值&#x3D;0；若S&lt;T,则返回值&lt;0.</li></ul><p><img src="/../image/assets/image-20230630225930754.png" alt="image-20230630225930754"></p><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子串。用sub返回串S的第pos个字符起长度为len的子串</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos + len - <span class="number">1</span> &gt; S.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; pos + len; i ++) Sub.ch[i-pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">    Sub.length = len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较操作，若S&gt;T,则返回值&gt;0；若S&lt;T,则返回值&lt;0；若S=T，则返回值=0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= S.length &amp;&amp; i &lt;= T.length; i ++)</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i]) <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, n = <span class="built_in">StrLength</span>(S), m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">SubString</span>(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(sub,T)!=<span class="number">0</span>) ++i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><p>任何数据存到计算机中一定是二进制数。需要确定一个字符和二进制数的对应规则，这就是编码</p><p>“字符集”：英文字符——ASCII字符集；中英文——Unicode字符集</p><ul><li>基于同一个字符集，可以有多种编码方案，如UTF-8，UTF-16</li><li>采用不同编码方式，每个字符所占空间不同，考研只需默认每个字符占1B即可</li></ul><h3 id="拓展：编码问题"><a href="#拓展：编码问题" class="headerlink" title="拓展：编码问题"></a>拓展：编码问题</h3><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的静态结构定义"><a href="#串的静态结构定义" class="headerlink" title="串的静态结构定义"></a>串的静态结构定义</h3><h4 id="静态数组实现"><a href="#静态数组实现" class="headerlink" title="静态数组实现"></a>静态数组实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串:静态数组实现（定长顺序存储）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLen 255  <span class="comment">//预定义最大串长</span></span></span><br><span class="line"></span><br><span class="line">type <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MaxLen];    <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态数组实现"><a href="#动态数组实现" class="headerlink" title="动态数组实现"></a>动态数组实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串：动态数组实现（堆分配存储）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLen 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MaxLen * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">//用完需要手动free</span></span><br><span class="line">S.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230701105048267.png" alt="image-20230701105048267"></p><ul><li><p>方案一：</p></li><li><p>方案二：ch[0]充当Length，最多0-255 存储256个字符</p></li><li><p>方案三：需要遍历才可以知道长度，经常需要长度不建议这样使用</p></li><li><p><strong>方案四：舍弃第一个位序不用，在末尾加一个length变量</strong></p></li></ul><h3 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    串的链式存储</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储密度低，每个字符1B，每个指针4B</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StringNode</span>&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">StringNode</span> *String;</span><br><span class="line">&#125;StringNode, *String;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储密度提高</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StringNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StringNode</span> *next;</span><br><span class="line"></span><br><span class="line">&#125;StringNode, *String;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230701114244242.png" alt="image-20230701114244242"></p><p><img src="/../image/assets/image-20230701114324847.png" alt="image-20230701114324847"></p><blockquote><p>32位操作系统中，指针内存占用4B；4 * 8 &#x3D; 32，指向地址</p><p>64位操作系统中，指针内存占用8B。8 * 8 &#x3D; 64</p></blockquote><h3 id="字符串的模式匹配"><a href="#字符串的模式匹配" class="headerlink" title="字符串的模式匹配"></a>字符串的模式匹配</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>在主串中找到与模式串相同的子串，并且返回其所在位置</p><h4 id="重要术语-1"><a href="#重要术语-1" class="headerlink" title="重要术语"></a>重要术语</h4><ul><li>模式串：不一定能在主串中找到</li><li>子串：主串的一部分，一定存在</li></ul><p><img src="/../image/assets/image-20230701125652455.png" alt="image-20230701125652455"></p><h4 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h4><ul><li><p>主串长度为n，模式串长度为m</p></li><li><p>朴素模式匹配算法：将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止</p></li><li><p>最多对比n-m+1个子串</p></li></ul><h4 id="使用字符串的基本操作实现"><a href="#使用字符串的基本操作实现" class="headerlink" title="使用字符串的基本操作实现"></a>使用字符串的基本操作实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, n = <span class="built_in">StrLength</span>(S), m = <span class="built_in">StrLength</span>(T);</span><br><span class="line">    SString sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">SubString</span>(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(sub,T)!=<span class="number">0</span>) ++i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用两个指针实现"><a href="#使用两个指针实现" class="headerlink" title="使用两个指针实现"></a>使用两个指针实现</h4><p>当发生失配时，应该令i &#x3D; i - j + 2, j &#x3D; 1</p><p><strong>模式串不动，移动主串</strong></p><p><img src="/../image/assets/image-20230701131546260.png" alt="image-20230701131546260"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串的朴素模式匹配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i; ++j;   <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i -j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;      <span class="comment">//指针后退重新匹配</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设主串长度为n，模式串长度为m，则最坏时间复杂度&#x3D;O(nm)</p><p><img src="/../image/assets/image-20230701132709173.png" alt="image-20230701132709173"></p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>有点类似具体问题具体分析</p><p>核心思想是当发生失配的时候，前面的适配的元素都是已知并且跟模式串一致的，所以可以根据失配元素的位置具体枚举分析</p><p>所以可以从最后一个元素匹配失败依次向前进行分析<strong>（主串不动，移动模式串）</strong> </p><p><img src="/../image/assets/image-20230701134407954.png" alt="image-20230701134407954"></p><p>next数组表明了当发生失配的时候，j的值应该指向多少 </p><p><img src="/../image/assets/image-20230701135524778.png" alt="image-20230701135524778"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;                <span class="comment">//继续比较后继指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];       <span class="comment">//模式串向右移动</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230701141611134.png" alt="image-20230701141611134"></p><blockquote><p><strong>只需要掌握手动求next[]数组</strong></p></blockquote><h4 id="求模式串next数组的手算练习"><a href="#求模式串next数组的手算练习" class="headerlink" title="求模式串next数组的手算练习"></a>求模式串next数组的手算练习</h4><ul><li>next[1]始终为0；next[2]始终为1</li><li>当i&gt;2，在不匹配的位置前面，划一根分界线，模式串一步一步向前走，直到分界线之前的元素都能对上或者模式串完全跨过分界线为止。此时线后面的j指向哪，next数组就是多少</li></ul><h4 id="求模式串next数组的机算和优化-可运行"><a href="#求模式串next数组的机算和优化-可运行" class="headerlink" title="求模式串next数组的机算和优化(可运行)"></a>求模式串next数组的机算和优化(可运行)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    KMP算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLen 255  <span class="comment">//预定义最大串长</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MaxLen];    <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i; ++j;</span><br><span class="line">            next[i]=j;          <span class="comment">//若pi = pj, 则next[j+1]=next[j]+1</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];       <span class="comment">//否则令j=next[j],循环继续</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己写的）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Next_KMP</span><span class="params">(SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = T.length;</span><br><span class="line">    next = (<span class="type">int</span> *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1  &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">1</span>, t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; i<span class="number">-1</span>; j ++)&#123;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(T.ch[t] == T.ch[t + j] &amp;&amp; (t &lt; i-j))&#123;</span><br><span class="line">                t ++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(t &gt;= i - j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;t = %d, j = %d\n&quot;, t, j);</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        next[i] = t;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Nextval_KMP</span><span class="params">(SString T, <span class="type">int</span> next[], <span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    nextval[<span class="number">1</span>]= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= T.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])</span><br><span class="line">            nextval[j] = nextval[next[j]];</span><br><span class="line">        <span class="keyword">else</span> nextval[j]=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;                <span class="comment">//继续比较后继指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];       <span class="comment">//模式串向右移动</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SString S, T;</span><br><span class="line">    S.ch[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">3</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">4</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">5</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.ch[<span class="number">6</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    S.length = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> *next, *next1;</span><br><span class="line">    <span class="built_in">get_next</span>(S,next1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Next_KMP</span>(S,next)) <span class="built_in">printf</span>(<span class="string">&quot;Successfully!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习1"><a href="#练习1" class="headerlink" title="练习1:"></a>练习1:</h5><p><img src="/../image/assets/image-20230701142153257.png" alt="image-20230701142153257"></p><p><img src="/../image/assets/image-20230701143412813.png" alt="image-20230701143412813"></p><h5 id="练习2"><a href="#练习2" class="headerlink" title="练习2:"></a>练习2:</h5><p><img src="/../image/assets/image-20230701143043130.png" alt="image-20230701143043130"></p><h4 id="next数组的优化"><a href="#next数组的优化" class="headerlink" title="next数组的优化"></a>next数组的优化</h4><p>根据指向的字符与原本失配的字符是否相等,求nextval[]数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Nextval_KMP</span><span class="params">(SString T, <span class="type">int</span> next[], <span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    nextval[<span class="number">1</span>]= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= T.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])</span><br><span class="line">            nextval[j] = nextval[next[j]];</span><br><span class="line">        <span class="keyword">else</span> nextval[j]=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230701155518622.png" alt="image-20230701155518622"></p><h5 id="练习一："><a href="#练习一：" class="headerlink" title="练习一："></a>练习一：</h5><p><img src="/../image/assets/image-20230701160047594.png" alt="image-20230701160047594"></p><h5 id="练习二"><a href="#练习二" class="headerlink" title="练习二:"></a>练习二:</h5><p><img src="/../image/assets/image-20230701160201715.png" alt="image-20230701160201715"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;串&quot;&gt;&lt;a href=&quot;#串&quot; class=&quot;headerlink&quot; title=&quot;串&quot;&gt;&lt;/a&gt;串&lt;/h1&gt;&lt;h2 id=&quot;做题总结&quot;&gt;&lt;a href=&quot;#做题总结&quot; class=&quot;headerlink&quot; title=&quot;做题总结&quot;&gt;&lt;/a&gt;做题总结&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="字符串" scheme="https://sdumoist.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://sdumoist.github.io/2023/06/28/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://sdumoist.github.io/2023/06/28/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2023-06-28T15:10:59.230Z</published>
    <updated>2024-03-30T19:26:02.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ul><li>栈的应用（先进后出）：括号匹配、表达式求值、中缀转后缀、中缀转前缀、递归、迷宫求解（深度优先算法）、进制转换</li><li>队列的应用（先进先出）：层次遍历（广度优先算法）、缓冲区、资源分配、矩阵压缩、页面替换算法</li><li>中缀转后缀表达式算法：栈中存储运算符</li><li>后缀表达式的计算：栈中存储操作数</li><li>递归求解</li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><h4 id="中缀转后缀的手算方法"><a href="#中缀转后缀的手算方法" class="headerlink" title="中缀转后缀的手算方法"></a>中缀转后缀的手算方法</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，就继续2</li></ol><h4 id="中缀表达式转后缀表达式（机算）"><a href="#中缀表达式转后缀表达式（机算）" class="headerlink" title="中缀表达式转后缀表达式（机算）"></a>中缀表达式转后缀表达式（机算）</h4><ul><li><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符</p></li><li><p>从左向右处理各个元素，直到末尾。</p></li><li><p>可能遇到三种情况：</p><ol><li><p>遇到操作数。直接加入后缀表达式</p></li><li><p>遇到界限符。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。注意：”(“不加入后缀表达式</p></li><li><p>遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再将当前运算符入栈。</p></li></ol></li><li><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p></li></ul><h4 id="后缀表达式的机算"><a href="#后缀表达式的机算" class="headerlink" title="后缀表达式的机算"></a>后缀表达式的机算</h4><p>用栈实现后缀表达式：</p><ol><li>从左往右扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则压入栈，并回到1；否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素（<strong>先出栈的是右操作数</strong>），执行相应运算，运算结果压回栈顶，回到1</li></ol><p><img src="/../image/assets/image-20230629103009744.png" alt="image-20230629103009744"></p><p><img src="/../image/assets/image-20230630170830221.png" alt="image-20230630170830221"></p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>数据结构三要素：逻辑结构、数据的运算、存储结构（物理结构）</p><p><img src="/../image/assets/image-20230628203720101.png" alt="image-20230628203720101"></p><p><img src="/../image/assets/image-20230628223246084.png" alt="image-20230628223246084"></p><p><img src="/../image/assets/image-20230628223758471.png" alt="image-20230628223758471"></p><p><img src="/../image/assets/image-20230629093704498.png" alt="image-20230629093704498"></p><p><img src="/../image/assets/image-20230629102936204.png" alt="image-20230629102936204"></p><p><img src="/../image/assets/image-20230629122344731.png" alt="image-20230629122344731"></p><p><img src="/../image/assets/image-20230629193720289.png" alt="image-20230629193720289"></p><p><img src="/../image/assets/image-20230629203040235.png" alt="image-20230629203040235"></p><p><img src="/../image/assets/image-20230629214408162.png" alt="image-20230629214408162"></p><p><img src="/../image/assets/image-20230629224617293.png" alt="image-20230629224617293"></p><p><img src="/../image/assets/image-20230630144103407.png" alt="image-20230630144103407"></p><p><img src="/../image/assets/image-20230630170813811.png" alt="image-20230630170813811"></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>线性表是具有相同数据类型的n（n&gt;&#x3D;0）个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表，若用L命名线性表，则其一般表示为L&#x3D;(a1,a2,a2……,an)</li><li>栈(Stack)是只允许一段进行插入或删除操作的<strong>线性表</strong></li></ul><h4 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h4><h4 id="栈顶"><a href="#栈顶" class="headerlink" title="栈顶"></a>栈顶</h4><p>允许进行插入和删除的一端</p><h4 id="栈底"><a href="#栈底" class="headerlink" title="栈底"></a>栈底</h4><p>不允许进行插入和删除的一端</p><h4 id="空栈"><a href="#空栈" class="headerlink" title="空栈"></a>空栈</h4><p>空表（没有元素）</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>后进先出（FILO）</p><p><img src="/../image/assets/image-20230628202312363.png" alt="image-20230628202312363"></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h4><ol><li>初始化</li><li>销毁</li><li>插入</li><li>删除</li><li>按值查找</li><li>按位查找</li><li>求表长</li><li>输出</li><li>判空</li></ol><p><img src="/../image/assets/image-20230628202547870.png" alt="image-20230628202547870"></p><h4 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h4><ol><li>InitStack(&amp;S): 初始化栈。创造一个空栈S，分配内存空间</li><li>DestroyStack(&amp;L): 销毁栈。销毁并释放栈S所占用的内存空间</li><li>Push(&amp;S, x): 进栈， 若栈S非满，则将x加入使之成为新栈顶</li><li>Pop(&amp;S, &amp;x): 出栈， 若栈S非空，则弹出栈顶元素，并用x返回              删除栈顶元素</li><li>GetTop(S, &amp;x): 读栈顶元素。若栈S非空，则用x返回栈顶元素               不删除栈顶元素</li><li>StackEmpty(S): 判断一个栈S是否为空，若S为空，则返回true，否则返回false</li></ol><p><img src="/../image/assets/image-20230628203238863.png" alt="image-20230628203238863"></p><h3 id="栈的常考题型"><a href="#栈的常考题型" class="headerlink" title="栈的常考题型"></a>栈的常考题型</h3><p>进栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e</p><p>出栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e   e-&gt;d-&gt;c-&gt;b-&gt;a……..</p><h4 id="n个不同元素进栈，出栈元素的不同排列的个数有1-n-1-Cn-2n"><a href="#n个不同元素进栈，出栈元素的不同排列的个数有1-n-1-Cn-2n" class="headerlink" title="n个不同元素进栈，出栈元素的不同排列的个数有1&#x2F;n+1 * Cn 2n"></a>n个不同元素进栈，出栈元素的不同排列的个数有1&#x2F;n+1 * Cn 2n</h4><p><img src="/../image/assets/image-20230628203530876.png" alt="image-20230628203530876"></p><h3 id="顺序栈（顺序存储方式的实现）"><a href="#顺序栈（顺序存储方式的实现）" class="headerlink" title="顺序栈（顺序存储方式的实现）"></a>顺序栈（顺序存储方式的实现）</h3><h4 id="顺序存储的定义"><a href="#顺序存储的定义" class="headerlink" title="顺序存储的定义"></a>顺序存储的定义</h4><p>缺点：栈的大小不可变</p><p>顺序存储：给各个数据元素分配连续的存储空间。 MaxSize*sizeof(ElemType)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struck&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230628204412528.png" alt="image-20230628204412528"></p><h4 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新元素入栈（Push）"><a href="#新元素入栈（Push）" class="headerlink" title="新元素入栈（Push）"></a>新元素入栈（Push）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈-Pop"><a href="#出栈-Pop" class="headerlink" title="出栈(Pop)"></a>出栈(Pop)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读栈顶元素"><a href="#读栈顶元素" class="headerlink" title="读栈顶元素"></a>读栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struck&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack s;</span><br><span class="line">    <span class="built_in">InitStack</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="共享栈-顺序栈的一种"><a href="#共享栈-顺序栈的一种" class="headerlink" title="共享栈(顺序栈的一种)"></a>共享栈(顺序栈的一种)</h3><h4 id="共享栈定义"><a href="#共享栈定义" class="headerlink" title="共享栈定义"></a>共享栈定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top0;</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br></pre></td></tr></table></figure><h4 id="初始化共享栈"><a href="#初始化共享栈" class="headerlink" title="初始化共享栈"></a>初始化共享栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈满"><a href="#判断栈满" class="headerlink" title="判断栈满"></a>判断栈满</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈满条件：top0 + 1 == top1;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(top0 +<span class="number">1</span> == top1);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="总代码-1"><a href="#总代码-1" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    共享栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top0;</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满条件：top0 + 1 == top1;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackFull</span><span class="params">(ShStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(top0 +<span class="number">1</span> == top1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ShStack s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况</p><h4 id="链栈结构定义"><a href="#链栈结构定义" class="headerlink" title="链栈结构定义"></a>链栈结构定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;      <span class="comment">//数据域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack2</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    S -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断栈空-1"><a href="#判断栈空-1" class="headerlink" title="判断栈空"></a>判断栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty2</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进栈（Push）不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push2</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S -&gt; next;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S -&gt; next= p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈 (Pop) 不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop2</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    S -&gt; next = S -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取栈顶元素"><a href="#读取栈顶元素" class="headerlink" title="读取栈顶元素"></a>读取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem2</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总代码-2"><a href="#总代码-2" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    链栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;      <span class="comment">//数据域</span></span><br><span class="line">&#125; *LiStack;                     <span class="comment">//栈类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack2</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    S -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空(带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty2</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈（Push）带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push2</span><span class="params">(LiStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    p -&gt; next = S -&gt; next;</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    S -&gt; next= p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 不带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 (Pop) 带头节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop2</span><span class="params">(LiStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    S -&gt; next = S -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem2</span><span class="params">(LiStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; next== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    x = S -&gt; next -&gt; data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LiStack s;</span><br><span class="line">    <span class="built_in">InitStack</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The Stack is empty: %d\n&quot;</span>,<span class="built_in">StackEmpty</span>(s));</span><br><span class="line">    <span class="type">int</span> choise;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    <span class="keyword">while</span>(choise != <span class="number">0</span>)&#123;</span><br><span class="line">        ElemType x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter value: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;Successfully!!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Erorr!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">GetElem</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;The value is:%d &quot;</span>, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Erorr!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> choise2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter choise: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise2);</span><br><span class="line">    <span class="keyword">while</span>(choise2 != <span class="number">0</span>)&#123;</span><br><span class="line">        ElemType x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Pop</span>(s,x)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error!!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>队列是只允许在一端进行插入，在另一端进行删除的线性表</p><h4 id="重要术语-1"><a href="#重要术语-1" class="headerlink" title="重要术语"></a>重要术语</h4><h4 id="队头"><a href="#队头" class="headerlink" title="队头"></a>队头</h4><p>允许删除的一端</p><h4 id="队尾"><a href="#队尾" class="headerlink" title="队尾"></a>队尾</h4><p>允许插入的一端</p><h4 id="空队列"><a href="#空队列" class="headerlink" title="空队列"></a>空队列</h4><p>没有元素的队列</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>先进先出（FIFO）</p><p><img src="/../image/assets/image-20230629093336205.png" alt="image-20230629093336205"></p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><blockquote><p>创建 销毁 增删改查</p></blockquote><p><img src="/../image/assets/image-20230629093630075.png" alt="image-20230629093630075"></p><ol><li>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q</li><li>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间</li><li>EnQueue(&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾</li><li>DeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除队头元素，并用x返回</li><li>GetHead(Q, &amp;x)：读队头元素，若队列非空，则将队头元素赋值给x</li><li>QueueEmpty(Q): 判断队列是否为空</li></ol><h3 id="顺序队列（队列的顺序实现）"><a href="#顺序队列（队列的顺序实现）" class="headerlink" title="顺序队列（队列的顺序实现）"></a>顺序队列（队列的顺序实现）</h3><h4 id="定义-浪费一个存储空间"><a href="#定义-浪费一个存储空间" class="headerlink" title="定义(浪费一个存储空间)"></a>定义(浪费一个存储空间)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;        <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p>连续的存储空间，大小：MaxSize*sizeof(ElemType);</p><p><img src="/../image/assets/image-20230629094736245.png" alt="image-20230629094736245"></p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断队空"><a href="#判断队空" class="headerlink" title="判断队空"></a>判断队空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);<span class="comment">//队空条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>)%MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front=[Q.front+<span class="number">1</span>]%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取队列元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + MaxSize - Q.front) % MaxSize); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码-3"><a href="#总代码-3" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    队列的顺序实现(浪费空间)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;        <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear == Q.front);<span class="comment">//队空条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>)%MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front=[Q.front+<span class="number">1</span>]%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得队头元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取队列元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear + MaxSize - Q.front) % MaxSize); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（不浪费存储空间的方法）"><a href="#（不浪费存储空间的方法）" class="headerlink" title="（不浪费存储空间的方法）"></a>（不浪费存储空间的方法）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个size进行判空和判满</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用tag来判空和判满</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230629102348180.png" alt="image-20230629102348180"></p><p><img src="/../image/assets/image-20230629102511110.png" alt="image-20230629102511110"></p><h3 id="链队（队列的链式实现）"><a href="#链队（队列的链式实现）" class="headerlink" title="链队（队列的链式实现）"></a>链队（队列的链式实现）</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;     <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230629103917368.png" alt="image-20230629103917368"></p><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230629120620415.png" alt="image-20230629120620415"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230629120711292.png" alt="image-20230629120711292"></p><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判空（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty2</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新节点赋值</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入其他元素</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear -&gt; next = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s -&gt; data = x;</span><br><span class="line">    s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">        Q.front == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空队列</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//返回值和修改</span></span><br><span class="line">    x = p -&gt; data;</span><br><span class="line">    Q.front -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="comment">//检验是否为最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码-4"><a href="#总代码-4" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    队列的链式实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front, *rear;     <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue2</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front rear 都指向头节点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty2</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkNode &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新节点赋值</span></span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入其他元素</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear -&gt; next = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    s -&gt; data = x;</span><br><span class="line">    s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = s;</span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">        Q.front == <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue2</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空队列</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    <span class="comment">//返回值和修改</span></span><br><span class="line">    x = p -&gt; data;</span><br><span class="line">    Q.front -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="comment">//检验是否为最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="comment">//释放存储空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue q;        <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(q);       <span class="comment">//初始化队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>可以在两端进行输入和输出的队列</p><p><img src="/../image/assets/image-20230629165606815.png" alt="image-20230629165606815"></p><p><img src="/../image/assets/image-20230629165638917.png" alt="image-20230629165638917"> </p><h4 id="考点：判断输出序列合法性"><a href="#考点：判断输出序列合法性" class="headerlink" title="考点：判断输出序列合法性"></a>考点：判断输出序列合法性</h4><p>若数据元素输入序列为1，2，3，4，则哪些输出序列是合法的，哪些是非法的？</p><h4 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h4><p><img src="/../image/assets/image-20230629165955894.png" alt="image-20230629165955894"></p><p><img src="/../image/assets/image-20230629193200265.png" alt="image-20230629193200265"></p><p> <img src="/../image/assets/image-20230629193540166.png" alt="image-20230629193540166"></p><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><h3 id="1-栈的第一个应用：括号匹配中的应用"><a href="#1-栈的第一个应用：括号匹配中的应用" class="headerlink" title="1.栈的第一个应用：括号匹配中的应用"></a>1.栈的第一个应用：括号匹配中的应用</h3><h4 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);   <span class="comment">//初始化一个栈 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length;i ++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">Push</span>(S, str[i]);   <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);    <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码（可运行）"><a href="#总代码（可运行）" class="headerlink" title="总代码（可运行）"></a>总代码（可运行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈在括号匹配中的应用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];    <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                   <span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;                     <span class="comment">//sequence 顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="comment">//注意审题，top是指向最后一个元素的位置还是指向下一个可以插入的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S.top == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满报错</span></span><br><span class="line">    S.top = S.top + <span class="number">1</span>;                    <span class="comment">//指针+1</span></span><br><span class="line">    S.data[S.top] = x;                    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">//S.data[++S.top] = x; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;           <span class="comment">//栈空报错</span></span><br><span class="line">    x = S.data[S.top];                      <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top=S.top - <span class="number">1</span>;                        <span class="comment">//指针-1</span></span><br><span class="line">    <span class="comment">//x = S.data[S.top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);   <span class="comment">//初始化一个栈 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length;i ++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="built_in">Push</span>(S, str[i]);   <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);    <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[]=<span class="string">&quot;&#123;&#125;[&#123;((()))&#125;]&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bracketCheck</span>(s,<span class="built_in">strlen</span>(s))) <span class="built_in">printf</span>(<span class="string">&quot;Right!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-栈的第二个应用：表达式的求值"><a href="#2-栈的第二个应用：表达式的求值" class="headerlink" title="2.栈的第二个应用：表达式的求值"></a>2.栈的第二个应用：表达式的求值</h3><h4 id="中缀、后缀、前缀表达式"><a href="#中缀、后缀、前缀表达式" class="headerlink" title="中缀、后缀、前缀表达式"></a>中缀、后缀、前缀表达式</h4><ul><li>中缀表达式：运算符在两个操作数中间</li><li>后缀表达式：运算符在两个操作数后面</li><li>前缀表达式：运算符在两个操作数前面</li></ul><p><img src="/../image/assets/image-20230629205620005.png" alt="image-20230629205620005"></p><h4 id="中缀转后缀的手算方法-1"><a href="#中缀转后缀的手算方法-1" class="headerlink" title="中缀转后缀的手算方法"></a>中缀转后缀的手算方法</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</li><li>如果还有运算符没被处理，就继续2</li></ol><p><img src="/../image/assets/image-20230629212626321.png" alt="image-20230629212626321"></p><p>运算顺序不唯一，因此对应的后缀表达式也不唯一</p><p>“左优先原则”，不要Freestyle，保证手算和机算结果相同：只要左边的运算符能先计算，就优先算左边（可保证表达式唯一）</p><h4 id="中缀表达式转后缀表达式（机算）-1"><a href="#中缀表达式转后缀表达式（机算）-1" class="headerlink" title="中缀表达式转后缀表达式（机算）"></a>中缀表达式转后缀表达式（机算）</h4><ul><li><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符</p></li><li><p>从左向右处理各个元素，直到末尾。</p></li><li><p>可能遇到三种情况：</p><ol><li><p>遇到操作数。直接加入后缀表达式</p></li><li><p>遇到界限符。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。注意：”(“不加入后缀表达式</p></li><li><p>遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再将当前运算符入栈。</p></li></ol></li><li><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 后缀表达式的机算</span><br><span class="line"></span><br><span class="line">用栈实现后缀表达式：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 从左往右扫描下一个元素，直到处理完所有元素</span><br><span class="line"><span class="number">2.</span> 若扫描到操作数则压入栈，并回到<span class="number">1</span>；否则执行<span class="number">3</span></span><br><span class="line"><span class="number">3.</span> 若扫描到运算符，则弹出两个栈顶元素（先出栈的是右操作数），执行相应运算，运算结果压回栈顶，回到<span class="number">1</span></span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629214241531</span>](../image/assets/image<span class="number">-20230629214241531.</span>png)</span><br><span class="line"></span><br><span class="line">```C++</span><br></pre></td></tr></table></figure><h4 id="中缀转前缀的手算方法"><a href="#中缀转前缀的手算方法" class="headerlink" title="中缀转前缀的手算方法"></a>中缀转前缀的手算方法</h4><ol><li>确定中缀表达式中各个运算符的运算顺序</li><li>选择下个运算符，按照[运算符 左操作数 右操作数] 的方式组合成一个新的操作数</li><li>如果还有操作符没被处理，就继续2</li></ol><p>”右优先原则“：只要右边的运算符能先计算，就优先计算右边的</p><p><img src="/../image/assets/image-20230629214225723.png" alt="image-20230629214225723"></p><h4 id="前缀表达式的机算"><a href="#前缀表达式的机算" class="headerlink" title="前缀表达式的机算"></a>前缀表达式的机算</h4><p>用栈实现前缀表达式的机算：</p><ol><li>从右往左扫描下一个元素，直到处理完所有元素</li><li>若扫描到操作数则压入栈，并回到1；否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素（先出栈的元素是左操作数），执行相应运算，运算结果压回栈顶，回到1</li></ol><p><img src="/../image/assets/image-20230629214129572.png" alt="image-20230629214129572"></p><h4 id="中缀表达式的机算（用栈实现）"><a href="#中缀表达式的机算（用栈实现）" class="headerlink" title="中缀表达式的机算（用栈实现）"></a>中缀表达式的机算（用栈实现）</h4><p>中缀转后缀 + 后缀表达式求值       两个算法结合</p><p>用栈实现中缀表达式的计算：</p><ol><li>初始化两个字栈：操作数栈和运算符栈</li><li>若扫描到操作数，压入操作数栈</li><li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈<strong>（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">3.</span>栈的第三个应用：递归</span><br><span class="line"></span><br><span class="line">函数调用背后的过程：</span><br><span class="line"></span><br><span class="line">#### 函数调用的特点：最后被调用的函数最先被执行结束（FILO）</span><br><span class="line"></span><br><span class="line">#### 函数调用的过程</span><br><span class="line"></span><br><span class="line">函数调用时，需要用一个栈存储：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 调用返回地址</span><br><span class="line"><span class="number">2.</span> 实参</span><br><span class="line"><span class="number">3.</span> 局部变量</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225015684</span>](../image/assets/image<span class="number">-20230629225015684.</span>png)</span><br><span class="line"></span><br><span class="line">栈在递归中的应用：</span><br><span class="line"></span><br><span class="line">**适合用递归算法解决：可以把原始问题转换为属性相同，但规模更小的问题**</span><br><span class="line"></span><br><span class="line">#### 求阶乘和斐波那契数列的和</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225405960</span>](../image/assets/image<span class="number">-20230629225405960.</span>png)</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230629225517294</span>](../image/assets/image<span class="number">-20230629225517294.</span>png)</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20230630143943097</span>](../image/assets/image<span class="number">-20230630143943097.</span>png)</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">/计算阶乘</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span> <span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Fib</span>(n<span class="number">-1</span>)+<span class="built_in">Fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;阶乘是：%d  ,斐波那契数列是：%d&quot;</span>, <span class="built_in">factorial</span>(num),<span class="built_in">Fib</span>(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈应用的缺点"><a href="#栈应用的缺点" class="headerlink" title="栈应用的缺点"></a>栈应用的缺点</h4><p>效率低，太多层递归可能会导致栈溢出；可能包含很多重复计算</p><h4 id="栈的改善方法"><a href="#栈的改善方法" class="headerlink" title="栈的改善方法"></a>栈的改善方法</h4><p>可以自定义栈将递归算法改造成非递归算法</p><h3 id="4-栈的第四个应用：进制转换"><a href="#4-栈的第四个应用：进制转换" class="headerlink" title="4.栈的第四个应用：进制转换"></a>4.栈的第四个应用：进制转换</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>使用stack<int>来存储每一位的数字。</li><li>在函数decimalToBase中，通过不断将十进制数除以目标进制数并取余数，将余数压入栈中。</li><li>将栈中的元素依次弹出，并将其转换为字符串类型，连接起来形成最终的转换结果。</li></ul><h4 id="总代码-5"><a href="#总代码-5" class="headerlink" title="总代码"></a>总代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈在进制转换中的应用</span></span><br><span class="line"><span class="comment">    使用stack&lt;int&gt;来存储每一位的数字。</span></span><br><span class="line"><span class="comment">    在函数decimalToBase中，通过不断将十进制数除以目标进制数并取余数，将余数压入栈中。</span></span><br><span class="line"><span class="comment">    将栈中的元素依次弹出，并将其转换为字符串类型，连接起来形成最终的转换结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制数转换为指定进制数</span></span><br><span class="line"><span class="function">string <span class="title">decimalToBase</span><span class="params">(<span class="type">int</span> number, <span class="type">int</span> base)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; digits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> remainder = number % base;</span><br><span class="line">        digits.<span class="built_in">push</span>(remainder);</span><br><span class="line">        number /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">while</span> (!digits.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> digit = digits.<span class="built_in">top</span>();</span><br><span class="line">        digits.<span class="built_in">pop</span>();</span><br><span class="line">        result += <span class="built_in">to_string</span>(digit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a decimal number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter the base to convert to: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; base;</span><br><span class="line"></span><br><span class="line">    string result = <span class="built_in">decimalToBase</span>(number, base);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-栈的第五个应用：迷宫求解（深度优先算法）"><a href="#5-栈的第五个应用：迷宫求解（深度优先算法）" class="headerlink" title="5. 栈的第五个应用：迷宫求解（深度优先算法）"></a>5. 栈的第五个应用：迷宫求解（深度优先算法）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>栈在迷宫求解中有广泛的应用，主要用于实现<strong>深度优先搜索算法</strong>。下面是栈在迷宫求解中的具体应用：</p><ol><li><p>迷宫表示：首先，我们可以使用二维数组或者矩阵来表示迷宫。迷宫的每个位置可以用0表示可通行的路径，用1表示墙壁或障碍物。这样的表示方式可以方便我们在后续的求解过程中进行遍历和判断。</p></li><li><p>深度优先搜索：在迷宫求解过程中，我们通常采用深度优先搜索算法来寻找从入口到出口的路径。<strong>深度优先搜索算法的核心思想是沿着一个方向尽可能深入地探索迷宫，直到无法继续为止，然后回溯到上一个位置，选择其他的方向进行探索。</strong></p></li><li><p>栈的应用：为了实现深度优先搜索算法，我们可以借助栈来保存当前位置和搜索路径的信息。具体操作如下：</p><ul><li>将起始位置入栈。</li><li>不断出栈并探索当前位置的相邻可通行位置。</li><li>将可通行位置入栈，并标记为已访问。</li><li>重复上述步骤，直到找到出口或者栈为空。</li><li>如果找到出口，则可以通过栈中保存的路径信息来追踪整个路径。</li></ul></li></ol><p>通过使用栈，我们可以有效地管理搜索过程中的状态信息，避免了递归调用带来的函数调用开销，同时也方便了路径的回溯和记录。</p><p>总结起来，栈在迷宫求解中的应用主要体现在深度优先搜索算法的实现中，通过栈来管理搜索状态和路径信息，以便找到从入口到出口的路径。</p><h3 id="1-队列应用——树的层次遍历"><a href="#1-队列应用——树的层次遍历" class="headerlink" title="1.队列应用——树的层次遍历"></a>1.队列应用——树的层次遍历</h3><p><img src="/../image/assets/image-20230630145425126.png" alt="image-20230630145425126"></p><p><img src="/../image/assets/image-20230630145117386.png" alt="image-20230630145117386"></p><p><img src="/../image/assets/image-20230630145256711.png" alt="image-20230630145256711"></p><p><img src="/../image/assets/image-20230630145358106.png" alt="image-20230630145358106"></p><h3 id="2-队列的应用：页面替换算法"><a href="#2-队列的应用：页面替换算法" class="headerlink" title="2.队列的应用：页面替换算法"></a>2.队列的应用：页面替换算法</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><strong>页面替换算法是操作系统中用于管理虚拟内存的一种策略。在计算机系统中，虚拟内存是一种将主存（RAM）扩展到硬盘上的技术。由于硬盘的访问速度较慢，所以在内存空间不足时，操作系统需要根据一定的策略将部分主存中的页面（页框）置换到硬盘上，从而腾出空间供其他页面使用。</strong></p><p>页面替换算法的目标是使得整体的页面访问效率最大化，减少页面置换带来的性能损失。常见的页面替换算法有以下几种：</p><ol><li><p><strong>最佳(OPT)算法</strong>：选择将来最长时间内不再被访问的页面进行置换。该算法是一种理想化的算法，但实际上很难预测将来页面的访问模式。</p></li><li><p><strong>先进先出(FIFO)算法</strong>：选择最早进入内存的页面进行置换。该算法简单直观，但可能会导致”先进入”的页面在后续访问中仍然频繁使用，造成性能下降，即所谓的”Belady现象”。</p></li><li><p><strong>最近最少使用(LRU)算法</strong>：选择最近一段时间内最少被访问的页面进行置换。该算法基于局部性原理，认为最近被访问的页面可能在将来继续被访问，适应了大多数程序的访问模式。</p></li><li><p><strong>最不经常使用(LFU)算法</strong>：选择最近一段时间内访问次数最少的页面进行置换。该算法认为访问次数少的页面可能是不常用的页面，适用于具有较强访问模式的程序。</p></li><li><p><strong>时钟(Clock)算法</strong>：基于FIFO算法的基础上，使用一个”访问位”（也称为”引用位”）来判断页面是否被访问过，将未被访问的页面进行置换。</p></li></ol><p>不同的页面替换算法在不同的工作负载下表现不同，没有一种算法能够适用于所有情况。因此，在实际应用中，根据系统特点和工作负载的特点选择合适的页面替换算法。</p><h4 id="先进先出-FIFO-算法使用队列"><a href="#先进先出-FIFO-算法使用队列" class="headerlink" title="先进先出(FIFO)算法使用队列"></a><strong>先进先出(FIFO)算法</strong>使用队列</h4><h4 id="LRU（最近最少使用）算法也可以使用双端队列"><a href="#LRU（最近最少使用）算法也可以使用双端队列" class="headerlink" title="LRU（最近最少使用）算法也可以使用双端队列"></a>LRU（最近最少使用）算法也可以使用双端队列</h4><h3 id="3-队列的应用：缓冲区"><a href="#3-队列的应用：缓冲区" class="headerlink" title="3.队列的应用：缓冲区"></a>3.队列的应用：缓冲区</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>解决主机 与外部设备之间速度不匹配的问题</li><li>例如：主机输出数据给打印机打印，输出数据的速度比打印数据的速度快很多，由于速度不匹配，若直接把输出的数据给打印机打印显然是不行的。解决方法是设置一个<strong>打印数据缓冲区</strong>，主机把要打印输出的数据依次写入这个缓冲区，写满后就暂停输出，转去做其他事情。打印机就从缓冲区中按照<strong>先进先出</strong>的原则依次取出数据并打印，打印完后再向主机发出请求。主机接到请求之后再向缓冲区写入打印数据。</li><li>这样做既保证了打印数据的正确，又使主机提高了效率。</li><li>打印数据缓冲区中所存储的数据就是一个队列</li></ul><h3 id="4-队列的应用：CPU资源分配"><a href="#4-队列的应用：CPU资源分配" class="headerlink" title="4. 队列的应用：CPU资源分配"></a>4. 队列的应用：CPU资源分配</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><ul><li>解决由多用户引起的资源竞争问题</li><li>在一个多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，分别通过各自的终端向操作系统提出占用CPU的请求，操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用。当相应的程序运行结束或者用完规定的时间间隔后，令其出队，再把CPU分配给新的队首请求的用户使用。</li><li>既能满足每个用户的请求，又使CPU能够正常运行</li></ul><h3 id="5-队列的应用：图的广度优先搜索"><a href="#5-队列的应用：图的广度优先搜索" class="headerlink" title="5.队列的应用：图的广度优先搜索"></a>5.队列的应用：图的广度优先搜索</h3><p>队列在图的广度优先搜索(BFS)中扮演了关键的角色，用于管理待访问的顶点和控制搜索的顺序。下面是队列在图的广度优先搜索中的具体应用：</p><ol><li><p>图的表示：首先，我们需要使用适当的数据结构来表示图。常见的表示方式有邻接矩阵和邻接表。邻接矩阵适用于稠密图，而邻接表适用于稀疏图。无论使用哪种表示方式，我们需要确保能够存储图中顶点之间的连接关系。</p></li><li><p>广度优先搜索：广度优先搜索是一种用于图的遍历的算法，它从图中的一个顶点开始，逐层地访问与该顶点相邻的顶点，直到达到目标顶点或者遍历完所有可达的顶点。这种搜索方式确保了先访问离起始顶点最近的顶点，然后再逐渐扩展到离起始顶点更远的顶点。</p></li><li><p>队列的应用：为了实现广度优先搜索算法，我们需要使用队列来管理待访问的顶点。具体操作如下：</p><ul><li>将起始顶点入队列。</li><li>从队列中取出一个顶点并标记为已访问。</li><li>遍历该顶点的所有相邻顶点，将未访问的顶点入队列。</li><li>重复上述步骤，直到队列为空或者找到目标顶点。</li><li>如果找到目标顶点，则可以通过记录顶点间的连接关系来追踪整个路径。</li></ul></li></ol><p>通过使用队列，我们能够按照广度优先的顺序逐层遍历图中的顶点，保证了离起始顶点近的顶点优先被访问。队列的先进先出(FIFO)特性确保了每个顶点在队列中只被访问一次。</p><p>综上所述，队列在图的广度优先搜索中的应用主要体现在管理待访问的顶点和控制搜索顺序方面，通过队列来按照广度优先的方式遍历图中的顶点，并追踪整个路径。</p><h3 id="6-队列的应用：特殊矩阵的压缩"><a href="#6-队列的应用：特殊矩阵的压缩" class="headerlink" title="6.队列的应用：特殊矩阵的压缩"></a>6.队列的应用：特殊矩阵的压缩</h3><h4 id="主要术语"><a href="#主要术语" class="headerlink" title="主要术语"></a>主要术语</h4><ul><li><strong>压缩存储</strong>：为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。目的是节省存储空间</li><li><strong>特殊矩阵</strong>：具有许多相同矩阵元素或零元素，这些相同的矩阵元素或零元素的分布有一定规律的矩阵。 常见有：对称矩阵、上（下）三角矩阵、对角矩阵</li><li><strong>特殊矩阵的压缩存储方法</strong>：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间</li></ul><h4 id="二维数组的存储结构"><a href="#二维数组的存储结构" class="headerlink" title="二维数组的存储结构"></a>二维数组的存储结构</h4><p><img src="/../image/assets/image-20230630151537264.png" alt="image-20230630151537264"></p><h4 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h4><p><img src="/../image/assets/image-20230630152013425.png" alt="image-20230630152013425"></p><p>矩阵下标  a(i,j)           一维数组下标B[k]</p><p>a(i,j)  (i &gt;&#x3D; j):  k &#x3D; i*(i-1)&#x2F;2+j-1;</p><p>a(i,j)  (i &lt; j):  k &#x3D; j*(j-1)&#x2F;2+i-1;</p><h4 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h4><p><img src="/../image/assets/image-20230630152935003.png" alt="image-20230630152935003"></p><p><img src="/../image/assets/image-20230630165439721.png" alt="image-20230630165439721"></p><h4 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h4><p><img src="/../image/assets/image-20230630165850992.png" alt="image-20230630165850992"></p><p><img src="/../image/assets/image-20230630170018814.png" alt="image-20230630170018814"></p><h4 id="稀疏矩阵的压缩存储"><a href="#稀疏矩阵的压缩存储" class="headerlink" title="稀疏矩阵的压缩存储"></a>稀疏矩阵的压缩存储</h4><p>非零元素远远少于矩阵元素的个数</p><h4 id="顺序存储——三元组"><a href="#顺序存储——三元组" class="headerlink" title="顺序存储——三元组&lt;行，列，值&gt;"></a>顺序存储——三元组&lt;行，列，值&gt;</h4><p><img src="/../image/assets/image-20230630170531882.png" alt="image-20230630170531882"></p><h4 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h4><ul><li><a href="https://blog.csdn.net/qq_42185999/article/details/105083274">十字链表法的实现</a></li></ul><p><img src="/../image/assets/image-20230630170726655.png" alt="image-20230630170726655"></p><p><strong>使用条件</strong>：当矩阵的非零元个数和位置在操作过程中变化较大时，就不宜采用顺序存储结构来表示三元组的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a>。对这种类型的矩阵，采用链式存储结构表示三元组的线性表更为恰当。</p><p><strong>使用方法</strong>：在链表中，每个非零元可用一个含 5 个域的结点表示，其中 i , j , e 这 3 个域分别表示该非零元所在的行、列和非零元的值，向右域 right 用以链接同一行中下一个非零元，向下域 down 用以链接同一列中下一个非零元。</p><p>同一行的非零元通过 right 域链接成一个线性链表，同一列的非零元通过 down 域链接成一个线性链表，每个非零元既是某个行链表中的一个结点，又是某个列链表中的一个结点，整个矩阵构成了一个十字交叉的链表，故称这样的存储结构为十字链表。<br>可用两个分别存储行链表的头指针和列链表的头指针的一维数组表示之</p><p><img src="/../image/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><em><strong>采用十字链表存储稀疏矩阵的示例：</strong></em></p><p> <img src="/../image/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTg1OTk5,size_16,color_FFFFFF,t_70-20230630181803252.png" alt="img"></p><blockquote><p>由于十字链表存储结构中的非零元素是按其所在行、列插入相应的链表的，所以，在创建稀疏矩阵输入非零元时，可以按<strong>任意顺序</strong>输入非零元素。每个非零元结点按升序被插入到两个没有头结点的单链表中：一个是所在行链表；另一个是所在列链表。当插入或删除结点时，只要修改相关的行、列链表即可，比较灵活。</p></blockquote><p>总代码（不知道能不能运行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean; <span class="comment">/* Boolean是布尔类型,其值是TRUE或FALSE */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span> <span class="comment">/* malloc()等 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* EOF(=^Z或F6),NULL */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;process.h&gt;</span> <span class="comment">/* exit() */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span> <span class="comment">/* 标准头文件，提供宏va_start，va_arg和va_end， */</span></span></span><br><span class="line"><span class="comment">/* 用于存取变长参数表 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数结果状态代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2 </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ---------------------------    稀疏矩阵的十字链表存储表示    ------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">OLNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j; <span class="comment">/* 该非零元的行和列下标 */</span></span><br><span class="line">ElemType e; <span class="comment">/* 非零元素值 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OLNode</span> *right, *down; <span class="comment">/* 该非零元所在行表和列表的后继链域 */</span></span><br><span class="line">&#125;OLNode, *OLink;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">OLink *rhead, *chead; <span class="comment">/* 行和列链表头指针向量基址,由CreatSMatrix_OL()分配 */</span></span><br><span class="line"><span class="type">int</span> mu, nu, tu; <span class="comment">/* 稀疏矩阵的行数、列数和非零元个数 */</span></span><br><span class="line">&#125;CrossList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ---------------------------  稀疏矩阵的十字链表存储的基本操作(9个)  --------------------------*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">InitSMatrix</span><span class="params">(CrossList *M)</span> <span class="comment">/* 加 */</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始化M(CrossList类型的变量必须初始化,否则创建、复制矩阵将出错) */</span></span><br><span class="line">(*M).rhead = (*M).chead = <span class="literal">NULL</span>;</span><br><span class="line">(*M).mu = (*M).nu = (*M).tu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">DestroySMatrix</span><span class="params">(CrossList *M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 销毁稀疏矩阵M */</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">OLNode *p, *q;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*M).mu; i++) <span class="comment">/* 按行释放结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = *((*M).rhead + i);</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>((*M).rhead);</span><br><span class="line"><span class="built_in">free</span>((*M).chead);</span><br><span class="line">(*M).rhead = (*M).chead = <span class="literal">NULL</span>;</span><br><span class="line">(*M).mu = (*M).nu = (*M).tu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CreateSMatrix</span><span class="params">(CrossList *M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 创建稀疏矩阵M,采用十字链表存储表示。算法5.4 */</span></span><br><span class="line"><span class="type">int</span> i, j, k, m, n, t;</span><br><span class="line">ElemType e;</span><br><span class="line">OLNode *p, *q;</span><br><span class="line"><span class="keyword">if</span> ((*M).rhead)</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(M);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入稀疏矩阵的行数 列数 非零元个数: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;t);</span><br><span class="line">(*M).mu = m;</span><br><span class="line">(*M).nu = n;</span><br><span class="line">(*M).tu = t;</span><br><span class="line">(*M).rhead = (OLink*)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*M).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*M).chead = (OLink*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*M).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= m; k++) <span class="comment">/* 初始化行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*M).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++) <span class="comment">/* 初始化列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*M).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请按任意次序输入%d个非零元的行 列 元素值:\n&quot;</span>, (*M).tu);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;i, &amp;j, &amp;e);</span><br><span class="line">p = (OLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode));</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;i = i; <span class="comment">/* 生成结点 */</span></span><br><span class="line">p-&gt;j = j;</span><br><span class="line">p-&gt;e = e;</span><br><span class="line"><span class="keyword">if</span> ((*M).rhead[i] == <span class="literal">NULL</span> || (*M).rhead[i]-&gt;j &gt; j) <span class="comment">/* p插在该行的第一个结点处 */</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;right = (*M).rhead[i];</span><br><span class="line">(*M).rhead[i] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 寻查在行表中的插入位置 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (q = (*M).rhead[i]; q-&gt;right&amp;&amp;q-&gt;right-&gt;j &lt; j; q = q-&gt;right);</span><br><span class="line">p-&gt;right = q-&gt;right; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">q-&gt;right = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*M).chead[j] == <span class="literal">NULL</span> || (*M).chead[j]-&gt;i &gt; i) <span class="comment">/* p插在该列的第一个结点处 */</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;down = (*M).chead[j];</span><br><span class="line">(*M).chead[j] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 寻查在列表中的插入位置 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (q = (*M).chead[j]; q-&gt;down&amp;&amp;q-&gt;down-&gt;i &lt; i; q = q-&gt;down);</span><br><span class="line">p-&gt;down = q-&gt;down; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">q-&gt;down = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">PrintSMatrix</span><span class="params">(CrossList M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 按行或按列输出稀疏矩阵M */</span></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">OLink p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d行%d列%d个非零元素\n&quot;</span>, M.mu, M.nu, M.tu);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入选择(1.按行输出 2.按列输出): &quot;</span>);</span><br><span class="line"><span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.mu; j++)</span><br><span class="line">&#123;</span><br><span class="line">p = M.rhead[j];</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d行%d列值为%d\n&quot;</span>, p-&gt;i, p-&gt;j, p-&gt;e);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.nu; j++)</span><br><span class="line">&#123;</span><br><span class="line">p = M.chead[j];</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d行%d列值为%d\n&quot;</span>, p-&gt;i, p-&gt;j, p-&gt;e);</span><br><span class="line">p = p-&gt;down;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSMatrix1</span><span class="params">(CrossList M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 按矩阵形式输出M</span></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">OLink p;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++)</span><br><span class="line">&#123; <span class="comment">// 从第1行到最后1行</span></span><br><span class="line">p = M.rhead[i]; <span class="comment">// p指向该行的第1个非零元素</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= M.nu; j++) <span class="comment">// 从第1列到最后1列</span></span><br><span class="line"><span class="keyword">if</span> (!p || p-&gt;j != j) <span class="comment">// 已到该行表尾或当前结点的列值不等于当前列值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, <span class="number">0</span>); <span class="comment">// 输出0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, p-&gt;e);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">CopySMatrix</span><span class="params">(CrossList M, CrossList *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 由稀疏矩阵M复制得到T */</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">OLink p, q = <span class="literal">NULL</span>, q1 = <span class="literal">NULL</span>, q2;</span><br><span class="line"><span class="keyword">if</span> ((*T).rhead)</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(T);</span><br><span class="line">(*T).mu = M.mu;</span><br><span class="line">(*T).nu = M.nu;</span><br><span class="line">(*T).tu = M.tu;</span><br><span class="line">(*T).rhead = (OLink*)<span class="built_in">malloc</span>((M.mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*T).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*T).chead = (OLink*)<span class="built_in">malloc</span>((M.nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*T).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 初始化矩阵T的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*T).rhead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.nu; i++) <span class="comment">/* 初始化矩阵T的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*T).chead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行复制 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = M.rhead[i];</span><br><span class="line"><span class="keyword">while</span> (p) <span class="comment">/* 没到行尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">q = (OLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!q)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">q-&gt;i = p-&gt;i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">q-&gt;j = p-&gt;j;</span><br><span class="line">q-&gt;e = p-&gt;e;</span><br><span class="line"><span class="keyword">if</span> (!(*T).rhead[i]) <span class="comment">/* 插在行表头 */</span></span><br><span class="line">(*T).rhead[i] = q1 = q;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在行表尾 */</span></span><br><span class="line">q1 = q1-&gt;right = q;</span><br><span class="line"><span class="keyword">if</span> (!(*T).chead[q-&gt;j]) <span class="comment">/* 插在列表头 */</span></span><br><span class="line">&#123;</span><br><span class="line">(*T).chead[q-&gt;j] = q;</span><br><span class="line">q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在列表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">q2 = (*T).chead[q-&gt;j];</span><br><span class="line"><span class="keyword">while</span> (q2-&gt;down)</span><br><span class="line">q2 = q2-&gt;down;</span><br><span class="line">q2-&gt;down = q;</span><br><span class="line">q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">AddSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M与N的行数和列数对应相等。 */</span></span><br><span class="line">  <span class="comment">/* 操作结果: 求稀疏矩阵的和Q=M+N */</span></span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line">OLink p, pq = <span class="literal">NULL</span>, pm, pn;</span><br><span class="line">OLink *col;</span><br><span class="line"><span class="keyword">if</span> (M.mu != N.mu || M.nu != N.nu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;两个矩阵不是同类型的,不能相加\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">&#125;</span><br><span class="line">(*Q).mu = M.mu; <span class="comment">/* 初始化Q矩阵 */</span></span><br><span class="line">(*Q).nu = M.nu;</span><br><span class="line">(*Q).tu = <span class="number">0</span>; <span class="comment">/* 元素个数的初值 */</span></span><br><span class="line">(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).mu; k++) <span class="comment">/* 初始化Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*Q).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 初始化Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*Q).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line">col = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink)); <span class="comment">/* 生成指向列的最后结点的数组 */</span></span><br><span class="line"><span class="keyword">if</span> (!col)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 赋初值 */</span></span><br><span class="line">col[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行的顺序相加 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = M.rhead[i]; <span class="comment">/* pm指向矩阵M的第i行的第1个结点 */</span></span><br><span class="line">pn = N.rhead[i]; <span class="comment">/* pn指向矩阵N的第i行的第1个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (pm&amp;&amp;pn) <span class="comment">/* pm和pn均不空 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pm-&gt;j &lt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列小于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;j &gt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列大于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;e + pn-&gt;e) <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和不为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e + pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之和为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pm) <span class="comment">/* 将矩阵M该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pn) <span class="comment">/* 将矩阵N该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++)</span><br><span class="line"><span class="keyword">if</span> (col[k]) <span class="comment">/* k列有结点 */</span></span><br><span class="line">col[k]-&gt;down = <span class="literal">NULL</span>; <span class="comment">/*  令该列最后一个结点的down指针为空 */</span></span><br><span class="line"><span class="built_in">free</span>(col);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">SubtSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M与N的行数和列数对应相等。 */</span></span><br><span class="line">  <span class="comment">/* 操作结果: 求稀疏矩阵的差Q=M-N */</span></span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line">OLink p, pq = <span class="literal">NULL</span>, pm, pn;</span><br><span class="line">OLink *col;</span><br><span class="line"><span class="keyword">if</span> (M.mu != N.mu || M.nu != N.nu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;两个矩阵不是同类型的,不能相加\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">&#125;</span><br><span class="line">(*Q).mu = M.mu; <span class="comment">/* 初始化Q矩阵 */</span></span><br><span class="line">(*Q).nu = M.nu;</span><br><span class="line">(*Q).tu = <span class="number">0</span>; <span class="comment">/* 元素个数的初值 */</span></span><br><span class="line">(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).mu; k++) <span class="comment">/* 初始化Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*Q).rhead[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 初始化Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*Q).chead[k] = <span class="literal">NULL</span>;</span><br><span class="line">col = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink)); <span class="comment">/* 生成指向列的最后结点的数组 */</span></span><br><span class="line"><span class="keyword">if</span> (!col)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++) <span class="comment">/* 赋初值 */</span></span><br><span class="line">col[k] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M.mu; i++) <span class="comment">/* 按行的顺序相减 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = M.rhead[i]; <span class="comment">/* pm指向矩阵M的第i行的第1个结点 */</span></span><br><span class="line">pn = N.rhead[i]; <span class="comment">/* pn指向矩阵N的第i行的第1个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (pm&amp;&amp;pn) <span class="comment">/* pm和pn均不空 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pm-&gt;j &lt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列小于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;j &gt; pn-&gt;j) <span class="comment">/* 矩阵M当前结点的列大于矩阵N当前结点的列 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = -pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pm-&gt;e - pn-&gt;e) <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之差不为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e - pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 矩阵M、N当前结点的列相等且两元素之差为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pn指针向右移 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pm) <span class="comment">/* 将矩阵M该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pm-&gt;j;</span><br><span class="line">p-&gt;e = pm-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pm = pm-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pn) <span class="comment">/* 将矩阵N该行的剩余元素插入矩阵Q */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成矩阵Q的结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">p-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">p-&gt;j = pn-&gt;j;</span><br><span class="line">p-&gt;e = -pn-&gt;e;</span><br><span class="line">p-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">pn = pn-&gt;right; <span class="comment">/* pm指针向右移 */</span></span><br><span class="line"><span class="keyword">if</span> ((*Q).rhead[i] == <span class="literal">NULL</span>) <span class="comment">/* p为该行的第1个结点 */</span></span><br><span class="line">(*Q).rhead[i] = pq = p; <span class="comment">/* p插在该行的表头且pq指向p(该行的最后一个结点) */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在pq所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;right = p; <span class="comment">/* 完成行插入 */</span></span><br><span class="line">pq = pq-&gt;right; <span class="comment">/* pq指向该行的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*Q).chead[p-&gt;j] == <span class="literal">NULL</span>) <span class="comment">/* p为该列的第1个结点 */</span></span><br><span class="line">(*Q).chead[p-&gt;j] = col[p-&gt;j] = p; <span class="comment">/* p插在该列的表头且col[p-&gt;j]指向p */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 插在col[p-&gt;j]所指结点之后 */</span></span><br><span class="line">&#123;</span><br><span class="line">col[p-&gt;j]-&gt;down = p; <span class="comment">/* 完成列插入 */</span></span><br><span class="line">col[p-&gt;j] = col[p-&gt;j]-&gt;down; <span class="comment">/* col[p-&gt;j]指向该列的最后一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= (*Q).nu; k++)</span><br><span class="line"><span class="keyword">if</span> (col[k]) <span class="comment">/* k列有结点 */</span></span><br><span class="line">col[k]-&gt;down = <span class="literal">NULL</span>; <span class="comment">/* 令该列最后一个结点的down指针为空 */</span></span><br><span class="line"><span class="built_in">free</span>(col);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">MultSMatrix</span><span class="params">(CrossList M, CrossList N, CrossList *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M的列数等于N的行数。操作结果: 求稀疏矩阵乘积Q=M*N */</span></span><br><span class="line"><span class="type">int</span> i, j, e;</span><br><span class="line">OLink q = <span class="literal">NULL</span>, p0, q0, q1 = <span class="literal">NULL</span>, q2;</span><br><span class="line"><span class="built_in">InitSMatrix</span>(Q);</span><br><span class="line">(*Q).mu = M.mu;</span><br><span class="line">(*Q).nu = N.nu;</span><br><span class="line">(*Q).tu = <span class="number">0</span>;</span><br><span class="line">(*Q).rhead = (OLink*)<span class="built_in">malloc</span>(((*Q).mu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*Q).chead = (OLink*)<span class="built_in">malloc</span>(((*Q).nu + <span class="number">1</span>) * <span class="built_in">sizeof</span>(OLink));</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).mu; i++) <span class="comment">/* 初始化矩阵Q的行头指针向量;各行链表为空链表 */</span></span><br><span class="line">(*Q).rhead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).nu; i++) <span class="comment">/* 初始化矩阵Q的列头指针向量;各列链表为空链表 */</span></span><br><span class="line">(*Q).chead[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (*Q).mu; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= (*Q).nu; j++)</span><br><span class="line">&#123;</span><br><span class="line">p0 = M.rhead[i];</span><br><span class="line">q0 = N.chead[j];</span><br><span class="line">e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p0&amp;&amp;q0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q0-&gt;i &lt; p0-&gt;j)</span><br><span class="line">q0 = q0-&gt;down; <span class="comment">/* 列指针后移 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (q0-&gt;i &gt; p0-&gt;j)</span><br><span class="line">p0 = p0-&gt;right; <span class="comment">/* 行指针后移 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* q0-&gt;i==p0-&gt;j */</span></span><br><span class="line">&#123;</span><br><span class="line">e += p0-&gt;e*q0-&gt;e; <span class="comment">/* 乘积累加 */</span></span><br><span class="line">q0 = q0-&gt;down; <span class="comment">/* 行列指针均后移 */</span></span><br><span class="line">p0 = p0-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e) <span class="comment">/* 值不为0 */</span></span><br><span class="line">&#123;</span><br><span class="line">(*Q).tu++; <span class="comment">/* 非零元素数加1 */</span></span><br><span class="line">q = (OLink)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(OLNode)); <span class="comment">/* 生成结点 */</span></span><br><span class="line"><span class="keyword">if</span> (!q) <span class="comment">/* 生成结点失败 */</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">q-&gt;i = i; <span class="comment">/* 给结点赋值 */</span></span><br><span class="line">q-&gt;j = j;</span><br><span class="line">q-&gt;e = e;</span><br><span class="line">q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">q-&gt;down = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!(*Q).rhead[i]) <span class="comment">/* 行表空时插在行表头 */</span></span><br><span class="line">(*Q).rhead[i] = q1 = q;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 否则插在行表尾 */</span></span><br><span class="line">q1 = q1-&gt;right = q;</span><br><span class="line"><span class="keyword">if</span> (!(*Q).chead[j]) <span class="comment">/* 列表空时插在列表头 */</span></span><br><span class="line">(*Q).chead[j] = q;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 否则插在列表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line">q2 = (*Q).chead[j]; <span class="comment">/* q2指向j行第1个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (q2-&gt;down)</span><br><span class="line">q2 = q2-&gt;down; <span class="comment">/* q2指向j行最后1个结点 */</span></span><br><span class="line">q2-&gt;down = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">TransposeSMatrix</span><span class="params">(CrossList M, CrossList *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 初始条件: 稀疏矩阵M存在。操作结果: 求稀疏矩阵M的转置矩阵T */</span></span><br><span class="line"><span class="type">int</span> u, i;</span><br><span class="line">OLink *head, p, q, r;</span><br><span class="line"><span class="keyword">if</span> ((*T).rhead)</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(T);</span><br><span class="line"><span class="built_in">CopySMatrix</span>(M, T); <span class="comment">/* T=M */</span></span><br><span class="line">u = (*T).mu; <span class="comment">/* 交换(*T).mu和(*T).nu */</span></span><br><span class="line">(*T).mu = (*T).nu;</span><br><span class="line">(*T).nu = u;</span><br><span class="line">head = (*T).rhead; <span class="comment">/* 交换(*T).rhead和(*T).chead */</span></span><br><span class="line">(*T).rhead = (*T).chead;</span><br><span class="line">(*T).chead = head;</span><br><span class="line"><span class="keyword">for</span> (u = <span class="number">1</span>; u &lt;= (*T).mu; u++) <span class="comment">/* 对T的每一行 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (*T).rhead[u]; <span class="comment">/* p为行表头 */</span></span><br><span class="line"><span class="keyword">while</span> (p) <span class="comment">/* 没到表尾,对T的每一结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;down; <span class="comment">/* q指向下一个结点 */</span></span><br><span class="line">i = p-&gt;i; <span class="comment">/* 交换.i和.j */</span></span><br><span class="line">p-&gt;i = p-&gt;j;</span><br><span class="line">p-&gt;j = i;</span><br><span class="line">r = p-&gt;down; <span class="comment">/* 交换.down.和right */</span></span><br><span class="line">p-&gt;down = p-&gt;right;</span><br><span class="line">p-&gt;right = r;</span><br><span class="line">p = q; <span class="comment">/* p指向下一个结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------------------------*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*  检验以上操作的主程序 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CrossList A, B, C;</span><br><span class="line"><span class="built_in">InitSMatrix</span>(&amp;A); <span class="comment">/* CrossList类型的变量在初次使用之前必须初始化 */</span></span><br><span class="line"><span class="built_in">InitSMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵A: &quot;</span>);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;由矩阵A复制矩阵B: &quot;</span>);</span><br><span class="line"><span class="built_in">CopySMatrix</span>(A, &amp;B);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;B); <span class="comment">/* CrossList类型的变量在再次使用之前必须先销毁 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁矩阵B后:\n&quot;</span>);</span><br><span class="line"><span class="built_in">PrintSMatrix</span>(B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵B2:(与矩阵A的行、列数相同，行、列分别为%d,%d)\n&quot;</span>, A.mu, A.nu);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C1(A+B): &quot;</span>);</span><br><span class="line"><span class="built_in">AddSMatrix</span>(A, B, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C2(A-B): &quot;</span>);</span><br><span class="line"><span class="built_in">SubtSMatrix</span>(A, B, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C3(A的转置): &quot;</span>);</span><br><span class="line"><span class="built_in">TransposeSMatrix</span>(A, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵A2: &quot;</span>);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建矩阵B3:(行数应与矩阵A2的列数相同=%d)\n&quot;</span>, A.nu);</span><br><span class="line"><span class="built_in">CreateSMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;矩阵C5(A*B): &quot;</span>);</span><br><span class="line"><span class="built_in">MultSMatrix</span>(A, B, &amp;C);</span><br><span class="line"><span class="built_in">PrintSMatrix1</span>(C);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;A);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;B);</span><br><span class="line"><span class="built_in">DestroySMatrix</span>(&amp;C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p><img src="/../image/assets/image-20230630183803349.png" alt="image-20230630183803349"></p><p>答：C</p><p>存储空间是数组A[21],说明空间大小是MaxSize &#x3D; 21；</p><p>rear指向队尾元素，front指向队头元素前一个位置 &#x3D;&#x3D;  rear指向队尾元素下一个的位置，front指向队头元素</p><p>所以 长度length &#x3D; rear + MaxSize - front</p><p><img src="/../image/assets/image-20230630184303469.png" alt="image-20230630184303469"></p><p><img src="/../image/assets/image-20230630184318704.png" alt="image-20230630184318704"></p><p>一般情况下队列不为空，删除操作只要修改头指针：head -&gt; next  &#x3D; head -&gt; next -&gt; next;</p><p>但是只有一个元素的时候，尾指针也要修改: head -&gt; next &#x3D; NULL; rear &#x3D; head;</p><p><img src="/../image/assets/image-20230630184604551.png" alt="image-20230630184604551"></p><p><img src="/../image/assets/image-20230630184548970.png" alt="image-20230630184548970"></p><p>读题要认真！！！！！！！做法要严谨！！！！！！ 在复习一遍：</p><p>入队操作有三步: rear -&gt; next &#x3D; x; x -&gt; next &#x3D; NULL; rear &#x3D; x;</p><p><img src="/../image/assets/image-20230630184752987.png" alt="image-20230630184752987"></p><p><img src="/../image/assets/image-20230630184808759.png" alt="image-20230630184808759"></p><p>进队操作在队尾！！！！！！出队操作在队头！！！！</p><p>出队是O(1), 入队是O(n)</p><p><img src="/../image/assets/image-20230630185223956.png" alt="image-20230630185223956"></p><p><img src="/../image/assets/image-20230630185318491.png" alt="image-20230630185318491"></p><p><img src="/../image/assets/image-20230630222455612.png" alt="image-20230630222455612"></p><p><img src="/../image/assets/image-20230630222439474.png" alt="image-20230630222439474"></p><p>答：A</p><p>若存放一个元素A[0]，end1为0，end2为1，所以没有元素（队空）的时候，end1&#x3D;&#x3D;end2</p><p>若队满，end1 &#x3D; 0，end2 &#x3D; m-1，所以条件为end1 &#x3D;&#x3D; (end2+1) mod M</p><p><img src="/../image/assets/image-20230703220139729.png" alt="image-20230703220139729"></p><p><img src="/../image/assets/image-20230703220200177.png" alt="image-20230703220200177"></p><p>答：A. ABCD- * -    B. AB-C * D-     C. ABC * -D-    D. AB-CD-*</p><p>将ABCD四个后缀表达式写出来，会发现只有B最多两个数存在栈里</p><p><img src="/../image/assets/image-20230703220611030.png" alt="image-20230703220611030"></p><p><img src="/../image/assets/image-20230703220531448.png" alt="image-20230703220531448"></p><p><img src="/../image/assets/image-20230703220549091.png" alt="image-20230703220549091"></p><p><img src="/../image/assets/image-20230703220640471.png" alt="image-20230703220640471"></p><p><img src="/../image/assets/image-20230703220704632.png" alt="image-20230703220704632"></p><p><img src="/../image/assets/image-20230703220816968.png" alt="image-20230703220816968"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h1&gt;&lt;h2 id=&quot;做题总结&quot;&gt;&lt;a href=&quot;#做题总结&quot; class=&quot;headerlink&quot; title=&quot;做题总结&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="栈" scheme="https://sdumoist.github.io/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://sdumoist.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="https://sdumoist.github.io/2023/06/26/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://sdumoist.github.io/2023/06/26/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2023-06-26T13:23:47.325Z</published>
    <updated>2024-03-30T19:25:58.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li>一定要读完所有选项，考虑周全</li><li>每个选项加以验证，有些明显感觉错的选项可能是判断失误</li><li>……</li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ul><li>p、q所指指针：p、q是指针，其实就是所指的元素，不是指后继节点</li><li>数组排序的最好时间复杂度：O(nlog2n)      链表排序的最好时间复杂度：O(n2)</li><li>顺序存储结构同样适用于图和树</li><li>顺序表长度为n的意思应该是存了n个 不是数组长度为n       因为顺序表只能一个接一个的存取</li><li>取线性表第i个元素的时间与i的大小：顺序表    无关；链表    有关</li><li>在长度为n的有序单链表中插入一个新节点并且保持有序，时间复杂度是O(N)</li><li>长度为n的单链表接到长度为m的单链表后面，时间复杂度是O(M)</li><li>各种结构优点：<ul><li>顺序表：表长可估计，查询（搜索）操作较多（或者只删除、增加表尾元素）</li><li>单链表：表长难以预估，经常要增加&#x2F;删除元素</li><li>双链表：访问前后相邻节点更加灵活，方便插入和删除数据</li><li>循环单链表：带有尾指针的循环单链表访问头节点和尾节点很方便（可是删除最后一个元素不方便）</li><li>循环双链表：插入和删除最后一个元素很方便</li></ul></li><li>有时候会使用带有尾指针的循环单链表，这样访问头节点和尾节点就很方便</li><li><strong>带头节点的循环单链表</strong>当head-&gt;next-&gt;next &#x3D; head时，长度可能为0或1</li><li><strong>设有头指针和尾指针的单链表</strong>执行删除最后一个元素的操作与链表长度有关，因为要进行遍历寻找尾节点前一个节点</li><li><strong>带头节点的双循环链表</strong>在末尾插入和删除节点最方便</li><li><strong>只有头节点没有尾节点的循环双链表</strong>删除第一个元素，删除最后一个元素，在第一个元素前面插入新元素，在最后一个元素之后插入新元素最方便</li></ul><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p><img src="/../image/assets/image-20230628183838155.png" alt="image-20230628183838155"></p><p><img src="/../image/assets/image-20230626222106120.png" alt="3"></p><p><img src="/../image/assets/image-20230626225358258.png" alt="image-20230626225358258"></p><p><img src="/../image/assets/image-20230627114059329.png" alt="6"></p><p><img src="/../image/assets/image-20230627185203205.png" alt="image-20230627185203205"></p><p><img src="/../image/assets/image-20230627191832663.png" alt="image-20230627191832663"></p><p><img src="/../image/assets/image-20230627195139625.png" alt="image-20230627195139625"></p><p><img src="/../image/assets/image-20230627212920273.png" alt="image-20230627212920273"></p><p><img src="/../image/assets/image-20230627225053385.png" alt="image-20230627225053385"></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p><img src="/../image/assets/image-20230626211955546.png" alt="1"></p><h3 id="静态实现"><a href="#静态实现" class="headerlink" title="静态实现"></a>静态实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i ++)</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList l;</span><br><span class="line">    <span class="built_in">InitList</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src="/../image/assets/image-20230626215744625.png" alt="2"></p><h3 id="动态实现"><a href="#动态实现" class="headerlink" title="动态实现"></a>动态实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//申请一片连续的存储空间</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加动态数组长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数据备份</span></span><br><span class="line">    <span class="type">int</span> *p=L.data;</span><br><span class="line">    <span class="comment">//空间申请</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len) * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">//数据复制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;L.length;i++)&#123;</span><br><span class="line">        L.data[i]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//长度增加</span></span><br><span class="line">    L.MaxSize=L.MaxSize+len;</span><br><span class="line">    <span class="comment">//空间释放</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqList l;</span><br><span class="line">    <span class="built_in">InitList</span>(l);</span><br><span class="line">    <span class="built_in">IncreaseSize</span>(l,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, l.MaxSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><img src="/../image/assets/image-20230627113912100.png" alt="5"></p><h3 id="单链表（带头节点和不带头节点）"><a href="#单链表（带头节点和不带头节点）" class="headerlink" title="单链表（带头节点和不带头节点）"></a>单链表（带头节点和不带头节点）</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化链表(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建链表传入值"><a href="#创建链表传入值" class="headerlink" title="创建链表传入值"></a>创建链表传入值</h4><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法可以实现链表逆置</span></span><br><span class="line"><span class="comment">//逆向建立单链表 头插法（带头节点）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt; data = x;</span><br><span class="line">        s -&gt;next = L -&gt;next;</span><br><span class="line">        L -&gt;next = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正向建立单链表 尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    ElemType x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立头节点</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//r为表尾节点</span></span><br><span class="line">    LNode *s, *r = L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="comment">//s为一个新申请的节点</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt;data = x;</span><br><span class="line">        r -&gt;next = s;</span><br><span class="line">        <span class="comment">//r指向新的表尾节点s</span></span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾节点指针后续</span></span><br><span class="line">    r -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否空表（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return (L == NULL);</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求表长度(有头节点)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p -&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len ++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h4 id="按值查询"><a href="#按值查询" class="headerlink" title="按值查询"></a>按值查询</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据==e的节点(有头节点)</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据==e的节点的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem2</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next, i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="built_in">Length2</span>(L)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找,返回第i个元素（带头节点）</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem2</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LNode *<span class="title">GetElem3</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt; next;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    s -&gt;data = p -&gt;data;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    p -&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存分配失败</span></span><br><span class="line"></span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在第i个位置插入"><a href="#在第i个位置插入" class="headerlink" title="在第i个位置插入"></a>在第i个位置插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断第一个节点单独操作</span></span><br><span class="line">    <span class="keyword">if</span>(i ==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        s -&gt; data = e;</span><br><span class="line">        s -&gt; next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索操作</span></span><br><span class="line">    <span class="comment">//指针p指向扫描的节点，j指向位序</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验第i-1个的节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s -&gt; next = p -&gt;next;</span><br><span class="line">    p -&gt; next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsertPlus2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索操作</span></span><br><span class="line">    LNode *p = <span class="built_in">GetElem2</span>(L, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InsertNextNode</span>(p,e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果p节点是最后一个节点，存在bug（空指针异常）</span></span><br><span class="line">    p -&gt; next = q -&gt; next;</span><br><span class="line">    p -&gt; data = q -&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找删除某个节点并返回值"><a href="#查找删除某个节点并返回值" class="headerlink" title="查找删除某个节点并返回值"></a>查找删除某个节点并返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第i个节点并返回数据（有头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //搜索操作</span></span><br><span class="line">    <span class="comment">// LNode *p = GetElem2(L, i-1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i <span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p -&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并且返回数据</span></span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line">    e = q -&gt;data;</span><br><span class="line">    p -&gt;next = q -&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码（可执行）"><a href="#总代码（可执行）" class="headerlink" title="总代码（可执行）"></a>总代码（可执行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    单链表的局限性：无法逆向检索，有时候不太方便</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表(不带头节点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求表长度(有头节点)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p -&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len ++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否空表（不带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return (L == NULL);</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为空表（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty2</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L -&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据==e的节点</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据==e的节点的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem2</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next, i++;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="built_in">Length2</span>(L)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位查找,返回第i个元素（带头节点）</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem2</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LNode *<span class="title">GetElem3</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L -&gt; next;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    s -&gt;data = p -&gt;data;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    p -&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后插操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存分配失败</span></span><br><span class="line"></span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断第一个节点单独操作</span></span><br><span class="line">    <span class="keyword">if</span>(i ==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">        s -&gt; data = e;</span><br><span class="line">        s -&gt; next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    s -&gt;data = e;</span><br><span class="line">    s -&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="comment">//return InsertNextNode(p,e);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //搜索操作</span></span><br><span class="line">    <span class="comment">// LNode *p = GetElem2(L, i-1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针p指向扫描的节点，j指向位序</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="comment">//return InsertNextNode(p,e); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验第i-1个的节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s -&gt; next = p -&gt;next;</span><br><span class="line">    p -&gt; next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置插入e（带头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsertPlus2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索操作</span></span><br><span class="line">    LNode *p = <span class="built_in">GetElem2</span>(L, i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">InsertNextNode</span>(p,e); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个节点并返回数据（有头节点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete2</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断合法性</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //搜索操作</span></span><br><span class="line">    <span class="comment">// LNode *p = GetElem2(L, i-1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找第i-1个节点</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i <span class="number">-1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p -&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除并且返回数据</span></span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line">    e = q -&gt;data;</span><br><span class="line">    p -&gt;next = q -&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p -&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果p节点是最后一个节点，存在bug（空指针异常）</span></span><br><span class="line">    p -&gt; next = q -&gt; next;</span><br><span class="line">    p -&gt; data = q -&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正向建立单链表 尾插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    ElemType x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立头节点</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//r为表尾节点</span></span><br><span class="line">    LNode *s, *r = L;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="comment">//s为一个新申请的节点</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt;data = x;</span><br><span class="line">        r -&gt;next = s;</span><br><span class="line">        <span class="comment">//r指向新的表尾节点s</span></span><br><span class="line">        r = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾节点指针后续</span></span><br><span class="line">    r -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法可以实现链表逆置</span></span><br><span class="line"><span class="comment">//逆向建立单链表 头插法（带头节点）</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s -&gt; data = x;</span><br><span class="line">        s -&gt;next = L -&gt;next;</span><br><span class="line">        L -&gt;next = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印整个链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">Empty</span>(p))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList l;</span><br><span class="line">    l = <span class="built_in">List_TailInsert2</span>(l);</span><br><span class="line">    <span class="built_in">PrintList</span>(l);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Select what you want: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    1.Search\n    2.Insert\n    3.Delete\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> choise;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    <span class="keyword">while</span>(choise != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(choise == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;        1.Search by value, please enter the value you want:\n        2. Search by location, please enter the location you want:\n&quot;</span>);</span><br><span class="line">            <span class="type">int</span> choise2, a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;choise2, &amp;a);</span><br><span class="line">            <span class="keyword">if</span>(choise2 == <span class="number">1</span>)&#123;</span><br><span class="line">                b = <span class="built_in">LocateElem2</span>(l,a);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The location is %d\n&quot;</span>, b);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(choise2 == <span class="number">2</span>)&#123;</span><br><span class="line">                b = <span class="built_in">GetElem2</span>(l, a) -&gt; data;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The value is %d\n&quot;</span>, b);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error enter!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(choise == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;        Please enter the loaction and the value you want to Insert\n&quot;</span>);</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListInsert2</span>(l, a, b)) <span class="built_in">printf</span>(<span class="string">&quot;Insert Successfull!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error Insert!!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(choise == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;        Please enter the loaction you want to delete:\n&quot;</span>);</span><br><span class="line">            <span class="type">int</span> loc, value;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;loc);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">ListDelete2</span>(l, loc, value)) <span class="built_in">printf</span>(<span class="string">&quot;The value deleted is %d, delete successfully!!\n&quot;</span>, value);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Error delete!!!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PrintList</span>(l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Select what you want: \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    1.Search\n    2.Insert\n    3.Delete\n    0.exit\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choise);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior,*next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; prior = <span class="literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入 将p节点之后插入s节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) p-&gt;next-&gt;prior = s;</span><br><span class="line">    s -&gt;prior = p;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 删除p节点的后继节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q -&gt;next != <span class="literal">NULL</span>) q -&gt;next -&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据节点</span></span><br><span class="line">    <span class="keyword">while</span>(L -&gt;next != <span class="literal">NULL</span>) <span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><img src="/../image/assets/image-20230627211604117.png" alt="image-20230627211604117"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p -&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历（跳过头节点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总代码（不可执行）"><a href="#总代码（不可执行）" class="headerlink" title="总代码（不可执行）"></a>总代码（不可执行）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior,*next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; prior = <span class="literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入 将p节点之后插入s节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s -&gt;next = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) p-&gt;next-&gt;prior = s;</span><br><span class="line">    s -&gt;prior = p;</span><br><span class="line">    p -&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 删除p节点的后继节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q -&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q -&gt;next != <span class="literal">NULL</span>) q -&gt;next -&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据节点</span></span><br><span class="line">    <span class="keyword">while</span>(L -&gt;next != <span class="literal">NULL</span>) <span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Traverse</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//对节点p做相应处理</span></span><br><span class="line">        p = p -&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前向遍历（跳过头节点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DLinkList L;</span><br><span class="line">    <span class="built_in">InitDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环单链表：从一个节点出发可以找到其他任何一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头节点next指针指向头节点</span></span><br><span class="line">    L -&gt;next = L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L-&gt;next == L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断节点p是否为循环单链表的表尾节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(LinkList L, LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p -&gt;next == L) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList l;</span><br><span class="line">    <span class="built_in">InitList</span>(l);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">Empty</span>(l));</span><br><span class="line"></span><br><span class="line">    LNode *p = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    p = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">isTail</span>(l,p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环单链表-1"><a href="#循环单链表-1" class="headerlink" title="循环单链表"></a>循环单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环双链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;</span><br><span class="line">&#125;DNode, DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt;prior = L;</span><br><span class="line">    L -&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L -&gt;next == L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是尾节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L, DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p -&gt; next == L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在p节点之后插入s节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    s -&gt; prior = p;</span><br><span class="line">    p -&gt; next -&gt; prior = s;</span><br><span class="line">    p -&gt; next = s; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除p的后继节点q</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    DNode *q = p -&gt;next;</span><br><span class="line">    p-&gt;next = q -&gt;next;</span><br><span class="line">    q -&gt;next -&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DLinkList l;</span><br><span class="line">    <span class="built_in">InitDLinkList</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    静态链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SLinkList a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">typedef</span> Node&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> a[MaxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_32643313/article/details/105339069">【数据结构】C++实现之静态链表</a></p><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间”一对一”的逻辑关系通过一个整形变量（称为”游标”，和指针功能类似）维持（和链表类似）。</p><h4 id="2、存储结构"><a href="#2、存储结构" class="headerlink" title="2、存储结构"></a>2、存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="type">int</span> cur;        <span class="comment">//代表游标，为0时无指向</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Component StaticLinkList[MAXSIZE];   <span class="comment">//结构体数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h4><p>数组中的第一个元素和最后一个元素作为特殊元素处理，不存放数据。通常把数组中未存放数据的元素称为备用链表。而数组的第一个元素，即下表为0的元素的cur存放备用链表的第一个结点的下标；数组中最后一个元素，即下标为（MAXSIZE － 1）的元素的cur存放第一个有数值的元素的下标，相当于单链表中头结点的作用。</p><p><img src="/../image/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNjQzMzEz,size_16,color_FFFFFF,t_70-7923546-7923550.jpeg" alt="静态数组"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化数组线性表，也是将数组链接成备用链表，其中space[0].cur代表头指针*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList &amp;space)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">//目前静态链表为空，所以最后一元素的cur=0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、静态链表插入操作"><a href="#4、静态链表插入操作" class="headerlink" title="4、静态链表插入操作"></a><strong>4、静态链表插入操作</strong></h4><p>1）插入前我们需要考虑，由于要多存入一个元素，那么就要考虑分配空间问题。即从链表中备用空间里拿出一空间，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*静态链表返回空闲空间下标，也是进行插入元素的准备操作（类似动态链表的分配空间）*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Malloc_SL</span><span class="params">(StaticLinkList space)</span><span class="comment">//返回分配的结点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">//当前数组第一个元素的cur的值，该值代表备用链表起始位置</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">//由于要出空闲链表中拿一个空间出来，因此需要将它相邻的空间的下标给头节点的cur</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）插入新元素，具体我们这里举例将在“乙” “丁”中间插入“丙”</p><p><img src="/../image/assets/20200406103034506.jpg" alt="静态数组2"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*静态链表的插入操作*/</span></span><br><span class="line"><span class="function">Status <span class="title">Listinsert</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*在L链表中第i个元素前面插入新的数据元素*/</span></span><br><span class="line"><span class="type">int</span> k, j;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;<span class="comment">//k为最后一个元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L) + <span class="number">1</span>)    <span class="comment">//插入位置错误，异常抛出</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">j = <span class="built_in">Malloc_SL</span>(L);</span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line">L[j].data = e;                      <span class="comment">//将新值放入刚刚知道的空闲下标的数组元素值中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表插入新值时，不会改变插入值在数组中的位置，只会跟新插入前后数据的游标cur值*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt;= i - <span class="number">1</span>; n++)<span class="comment">//此时k为第i元素之前的下标</span></span><br><span class="line">k = L[k].cur;                  </span><br><span class="line">L[j].cur = L[k].cur;<span class="comment">//把第i前元素的cur赋值给新元素的cur</span></span><br><span class="line">L[k].cur = j;<span class="comment">//再更新第i前元素的cur</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、静态链表删除操作"><a href="#5、静态链表删除操作" class="headerlink" title="5、静态链表删除操作"></a><strong>5、静态链表删除操作</strong></h4><p>1）删除时，需要考虑第一删除位置合不合理？<br>2）删除元素数据后，数据空间的回收问题，即怎么将它恢复到备用链表中？<br>3）删除元素的目标链表实际元素数据长度？多长问题<br>4）就是删除元素的前后元素游标怎么变化?下面以删除“甲”为例</p><p><img src="/../image/assets/20200406103236983.jpg" alt="静态数组3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将删除节点空间进行回收，回收为备用链表中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Free_SL</span><span class="params">(StaticLinkList &amp;space, <span class="type">int</span> k)</span>  <span class="comment">//k表示删除元素再链表中的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*如何回收？即将该节点作为备用链表的第1节点*/</span></span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur;          <span class="comment">//将头节点中的指向备用链表的第一节点下标赋值为当前节点的游标值</span></span><br><span class="line">space[<span class="number">0</span>].cur = k;   <span class="comment">//更新头节点游标值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回静态链表中数据元素的个数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="type">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;   <span class="comment">//得到链表中第1有值元素的下标</span></span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">i = L[i].cur;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除L中第i元素的数据e*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)<span class="comment">//找到第i元素之前元素的下标</span></span><br><span class="line">k = L[k].cur;</span><br><span class="line">j = L[k].cur;                 <span class="comment">//第i元素之前元素的游标</span></span><br><span class="line">L[k].cur = L[j].cur;<span class="comment">//将第i元素之后的元素的下标 交给 第i前元素的游标</span></span><br><span class="line"><span class="built_in">Free_SL</span>(L, j);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-完整代码"><a href="#6-完整代码" class="headerlink" title="6.  完整代码"></a>6.  完整代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线性表的操作包括如下几种</span></span><br><span class="line"><span class="comment">（1） InitList(&amp;L)初始化，构造一个空的线性表</span></span><br><span class="line"><span class="comment">（2） ListEmpty(&amp;L)判断线性表是否为空,true or flase</span></span><br><span class="line"><span class="comment">（3） ClearList(&amp;L)清空线性表中的内容</span></span><br><span class="line"><span class="comment">（4） GetElem(&amp;L，i，e)返回线性表i位置上的元素值，通过e返回</span></span><br><span class="line"><span class="comment">（5） LocateElem(&amp;L,e)在线性表中找到与e相同的元素，成功则返回其序号，否则返回0表示失败</span></span><br><span class="line"><span class="comment">（9） Listinsert(&amp;L,i,e)如果线性表存在了，而且i符合条件，则在i位置插入一个元素e</span></span><br><span class="line"><span class="comment">（10）ListDelete(&amp;L,i,)删除i位置上的元素</span></span><br><span class="line"><span class="comment">（5） ListLength(L)返回线性表的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="type">int</span> cur;        <span class="comment">//代表游标，为0时无指向</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Component StaticLinkList[MAXSIZE];   <span class="comment">//typedef可以掩饰复合类型，如指针和数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化数组线性表，也是将数组链接成备用链表，其中space[0].cur代表头指针*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList &amp;space)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">//目前静态链表为空，所以最后一元素的cur=0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表返回空闲空间下标，也是进行插入元素的准备操作（类似动态链表的分配空间）*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Malloc_SL</span><span class="params">(StaticLinkList space)</span><span class="comment">//返回分配的结点下标，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">//当前数组第一个元素的cur的值，该值代表备用链表起始位置</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">&#123;</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">//由于要出空闲链表中拿一个空间出来，因此需要将它相邻的空间的下标给头节点的cur</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回静态链表中数据元素的个数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="type">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;   <span class="comment">//得到链表中第1有值元素的下标</span></span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">i = L[i].cur;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表的插入操作*/</span></span><br><span class="line"><span class="function">Status <span class="title">Listinsert</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*在L链表中第i个元素前面插入新的数据元素*/</span></span><br><span class="line"><span class="comment">/*注意：在开展插入操作时，静态链表不能为空链表,至少长度&gt;=1*/</span></span><br><span class="line"><span class="type">int</span> k, j;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;<span class="comment">//k为最后一个元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L) + <span class="number">1</span>)    <span class="comment">//插入位置错误，异常抛出</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">j = <span class="built_in">Malloc_SL</span>(L);</span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line">L[j].data = e;                      <span class="comment">//将新值放入刚刚知道的空闲下标的数组元素值中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*静态链表插入新值时，不会改变插入值在数组中的位置，只会跟新插入前后数据的游标cur值*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt;= i - <span class="number">1</span>; n++)<span class="comment">//此时k为第i元素之前的下标</span></span><br><span class="line">k = L[k].cur;                  </span><br><span class="line">L[j].cur = L[k].cur;<span class="comment">//把第i前元素的cur赋值给新元素的cur</span></span><br><span class="line">L[k].cur = j;<span class="comment">//再更新第i前元素的cur</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将删除节点空间进行回收，回收为备用链表中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Free_SL</span><span class="params">(StaticLinkList &amp;space, <span class="type">int</span> k)</span>  <span class="comment">//k表示删除元素再链表中的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*如何回收？即将该节点作为备用链表的第1节点*/</span></span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur;          <span class="comment">//将头节点中的指向备用链表的第一节点下标赋值为当前节点的游标值</span></span><br><span class="line">space[<span class="number">0</span>].cur = k;   <span class="comment">//更新头节点游标值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除L中第i元素的数据e*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList &amp;L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;<span class="built_in">ListLength</span>(L))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)<span class="comment">//找到第i元素之前元素的下标</span></span><br><span class="line">k = L[k].cur;</span><br><span class="line">j = L[k].cur;                 <span class="comment">//第i元素之前元素的游标</span></span><br><span class="line">L[k].cur = L[j].cur;<span class="comment">//将第i元素之后的元素的下标 交给 第i前元素的游标</span></span><br><span class="line"><span class="built_in">Free_SL</span>(L, j);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StaticLinkList  mylist;</span><br><span class="line"><span class="built_in">InitList</span>(mylist); <span class="comment">//初始化静态链表，空闲链表此时，默认头节点为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h = <span class="built_in">Malloc_SL</span>(mylist);</span><br><span class="line">mylist[h].cur = <span class="number">0</span>; <span class="comment">//初始链表元素存储头节点h=1,</span></span><br><span class="line">mylist[h].data = <span class="number">50</span>;</span><br><span class="line">mylist[<span class="number">999</span>].cur = h;<span class="comment">//更新数组最后元素的指向的第1元素下标，cur=1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Listinsert</span>(mylist,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Listinsert</span>(mylist, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">Listinsert</span>(mylist, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历并输出该链表上的所有数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;遍历并输出该链表上的所有数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i = mylist[<span class="number">999</span>].cur;</span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; mylist[i].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">i = mylist[i].cur;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;please hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ListDelete</span>(mylist, <span class="number">2</span>);         <span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">//遍历并输出该链表上的所有数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;遍历并输出该链表上的所有数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">i = mylist[<span class="number">999</span>].cur;</span><br><span class="line"><span class="keyword">while</span> (i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; mylist[i].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">i = mylist[i].cur;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><p>都属于线性表，都是线性结构</p><p><img src="/../image/assets/image-20230628120312484.png" alt="image-20230628120312484"></p><h3 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2.存储结构"></a>2.存储结构</h3><ul><li><p>顺序表：<strong>（顺序存储结构）</strong></p></li><li><p>优点：支持随机存取，存储密度高</p></li><li><p>缺点：大片连续空间分配不方便，改变容量不方便</p></li><li><p>链表：**(链式存储结构)**</p></li><li><p>优点：离散的小空间分配方便，改变容量方便</p></li><li><p>缺点：不可随机存取，存储密度低</p></li></ul><p><img src="/../image/assets/image-20230628120429304.png" alt="image-20230628120429304"></p><h3 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3.基本操作"></a>3.基本操作</h3><blockquote><p>创建 销毁 增删改查</p></blockquote><p><img src="/../image/assets/image-20230628120449816.png" alt="image-20230628120449816"></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li><p>顺序表（静态分配：静态数组   动态分配：动态数组）</p></li><li><p>需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源</p></li><li><p>链表</p></li><li><p>只需分配一个头节点（也可以不要头节点，只声明一个头指针）之后方便拓展</p></li></ul><p><img src="/../image/assets/image-20230628120607282.png" alt="image-20230628120607282"></p><h4 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h4><ul><li><p>顺序表（静态分配：静态数组   动态分配：动态数组）</p></li><li><p>静态分配：静态数组             系统自动回收空间</p></li><li><p>动态分配：动态数组             需要手动free</p></li><li><p>链表</p></li><li><p>依次删除各个节点（free）</p></li></ul><p><img src="/../image/assets/image-20230628121809812.png" alt="image-20230628121809812"></p><h4 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h4><ul><li><p>顺序表（顺序存储）</p></li><li><p>插入&#x2F;删除元素要将后续元素都后移&#x2F;前移</p></li><li><p>时间复杂度O(n)时间开销主要来自移动元素（若数据元素很大，则移动的时间代价很高）</p></li><li><p>链表（链式存储）</p></li><li><p>插入&#x2F;删除元素只需修改指针即可</p></li><li><p>时间复杂度O(n)，时间开销主要来自查找目标元素（查找元素的时间代价低）</p></li></ul><p><img src="/../image/assets/image-20230628121945141.png" alt="image-20230628121945141"></p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><ul><li><p>顺序表（顺序存储）</p></li><li><p>按位查找 O(1)</p></li><li><p>按值查找 O(n) 若表内元素有序，可以在O(log2n)时间内找到</p></li><li><p>链表</p></li><li><p>按位查找：O(n)</p></li><li><p>按值查找：O(n)</p></li></ul><p><img src="/../image/assets/image-20230628122016514.png" alt="image-20230628122016514"></p><h4 id="用顺序表还是链表？"><a href="#用顺序表还是链表？" class="headerlink" title="用顺序表还是链表？"></a>用顺序表还是链表？</h4><ul><li><p>查：顺序表表长可估计，查询（搜索）操作较多（或者只删除、增加表尾元素）</p></li><li><p>创建、增、删：链表             表长难以预估，经常要增加&#x2F;删除元素</p></li></ul><p><img src="/../image/assets/image-20230628122047901.png" alt="image-20230628122047901"></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p><img src="/../image/assets/image-20230628174331911.png" alt="image-20230628174331911"></p><p>答：A</p><p>​顺序存取结构即顺序表，该题考查顺序表和链表的不同。顺序表不像链表那样，要在节点中存放指针域，因此存储密度更大。</p><p><img src="/../image/assets/image-20230628174603606.png" alt="image-20230628174603606"></p><p>答：A</p><p>​存取方式是指读写方式，顺序表是一种支持随机存取的存储结构，根据起始地址加上元素序号，可以很方便地访问任意一个元素，这就是随机存取的概念。</p><p><a href="https://blog.csdn.net/wq6ylg08/article/details/103358596">数据结构考研:随机存取、顺序存取、随机存储和顺序存储的区别&#x2F;详细解释(计算机&#x2F;软件工程&#x2F;王道论坛)</a></p><h4 id="1-存取结构-随机存取和顺序存取"><a href="#1-存取结构-随机存取和顺序存取" class="headerlink" title="**1.存取结构:随机存取和顺序存取 **"></a>**1.存取结构:随机存取和顺序存取 **</h4><h4 id="1-1随机存取"><a href="#1-1随机存取" class="headerlink" title="1.1随机存取"></a><strong>1.1随机存取</strong></h4><p>随机存取（直接存取,Random Access）指的是当存储器中的数据被读取或写入时，<strong>所需要的时间与该数据所在的物理地址无关</strong>。</p><p><strong>随机存取的微观现实例子就是编程语言中的数组。</strong><br>随机存取的宏观现实例子就是我们的随机存取存储器(RAM:Random Access Memory)，通俗的说也就是我们电脑的内存条。因为RAM利用电容存储电荷的原理保存信息，所以RAM可以高速存取，且与物理地址无关。</p><h4 id="1-2顺序存取"><a href="#1-2顺序存取" class="headerlink" title="1.2顺序存取"></a><strong>1.2顺序存取</strong></h4><p>顺序存取(Sequential Access)是一种按记录的逻辑顺序进行读、写操作的存取方法，<strong>所需要的时间与该数据所在的物理地址有关</strong>。顺序存取表现为:<strong>在存取第N个数据时，必须先访问前（N-1）个数据</strong>。<br><strong>顺序存取的微观现实例子就是数据结构中的链表</strong>。<br>顺序存取的现实例子就是我们的录音磁带、光盘、机械硬盘里面的磁盘。磁带、光盘、磁盘上的数据分别存储在不同扇区、不同磁道上，磁盘的读写磁头通过切换不同扇区和磁道来读取物理地址不连续的数据时，该过程中要经过不同扇区和不同磁道上的无关数据，磁盘的读写磁头在切换不同扇区和磁道所需时间也不同，故为顺序存取。</p><p><img src="/../image/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxNnlsZzA4,size_16,color_FFFFFF,t_70.png" alt="随机存取和链式存取"></p><h4 id="2-存储结构-顺序存储、随机存储"><a href="#2-存储结构-顺序存储、随机存储" class="headerlink" title="2.存储结构:顺序存储、随机存储"></a>2.存储结构:顺序存储、随机存储</h4><p>存储结构是数据元素三大组成要素之一，下图是博主对数据元素三要素所画的思维导图。</p><p><img src="/../image/assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxNnlsZzA4,size_16,color_FFFFFF,t_70-20230628181201363.png" alt="思维导图"></p><h4 id="2-1顺序存储"><a href="#2-1顺序存储" class="headerlink" title="2.1顺序存储"></a>2.1顺序存储</h4><ul><li><p><strong>顺序存储是把逻辑上相邻的数据元素存储在物理位置上相邻的存储单元中，数据元素之间的逻辑关系由存储单元的邻接关系来体现。</strong></p></li><li><p>顺序存储的主要优点：</p><ul><li>节省存储空间。因为分配给数据的存储单元全用存放数据元素（不考虑c&#x2F;c++语言中数组需指定大小的情况），数据元素之间的逻辑关系没有占用额外的存储空间。</li><li>可实现对数据元素的随机存取(直接存取)。即每一个数据元素对应一个元素下标，由该元素下标可以直接计算出来数据元素的物理存储地址。</li></ul></li><li><p>顺序存储的主要缺点：</p><ul><li>不便于数据修改。对数据元素的插入、删除运算时，可能要移动一系列的数据元素。</li><li>产生磁盘碎片。因为顺序存储只能使用相邻的一整块存储单元，因此会产生较多的磁盘碎片</li></ul></li></ul><p>顺序存储的典型实例就是编程语言中的<code>数组</code>。例如，使用<a href="https://so.csdn.net/so/search?q=%E9%A1%BA%E5%BA%8F%E8%A1%A8&spm=1001.2101.3001.7020">顺序表</a>存储集合 {1,2,3,4,5}，数据最终的存储状态如下图所示：</p><p><img src="/../image/assets/20191203201006798.png" alt="数组顺序存储"></p><p>数组中的所有元素存储在一个连续性的内存块中，并通过数组的首地址和元素下标来访问。因此一个数组就是由1个数组首地址和N个数组元素构成，数组不需要像链表一样，链表的每个节点必须存储下一个结点的物理地址，在存储同样多的数据下，数组比链表节省空间。</p><p>数组可通过数组的首地址和元素下标来直接存取数组中的没每一个元素，而不需要像链表一样，在存取第N个链表结点的数据时，必须先访问前（N-1）个链表结点。</p><p>但对数组的数据元素的插入、删除运算时，可能要移动一系列的数据元素，特别的麻烦，因此顺序存储结构的数组不便于修改。</p><h4 id="2-2随机存储"><a href="#2-2随机存储" class="headerlink" title="2.2随机存储"></a>2.2随机存储</h4><p><strong>在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。</strong></p><p><strong>它不要求逻辑上相邻的元素在物理位置上也相邻，而是借助指示元素存储地址的指针来表示元素之间的逻辑关系。</strong></p><ul><li><p>顺序存储的主要优点：</p><ul><li><p>不会产生磁盘碎片。因为随机存储不要求逻辑上相邻的元素在物理位置上也相邻，而是借助指示元素存储地址的指针来表示元素之间的逻辑关系，因此不会产生磁盘碎片。</p></li><li><p>数据修改方便。对数据元素的插入、删除运算时，随机存储不必移动结点，只要改变结点中的指针。</p></li></ul></li><li><p>顺序存储的主要缺点：</p><ul><li>占用空间大。随机存储的每个结点都由数据域和指针域组成，所以相同空间内假设全存满，顺序存储比随机存储可存更多数据。</li><li>查找结点时链式存储要比顺序存储慢，且只能实现顺序存取。</li></ul></li></ul><p><strong>2.2.1 随机存储——链式存储</strong></p><p>链式存储是随机存储最典型的代表，因此链式存储的定义、优点和缺点就是2.2随机存储中的定义、优点和缺点。</p><p><strong>2.2.2 随机存储——索引存储</strong><br>除建立存储结点信息外，还建立附加的索引表来标识结点的地址，索引表由若干索引项组成，索引项的一般形式是(关键字，地址)。</p><p>索引存储的主要优点：检索速度快。<br>索引存储的主要缺点：增加了附加的索引表,会占用较多的存储空间。</p><p><strong>2.2.3 随机存储——散列存储</strong><br>散列存储，又称Hash存储，是一种将数据元素的存储位置与关键码之间建立确定对应关系的查找技术，即根据元素的关键字直接计算出该元素的存储地址。</p><ul><li><p>散列存储的主要优点：检索、增加和删除节点的操作更快。</p></li><li><p>散列存储的主要缺点：若散列函数不好，则可能出现元素存储单元的冲突。</p></li><li><p>散列法存储的基本思想是：由节点的关键码值决定节点的存储地址。散列技术除了可以用于查找外，还可以用于存储。</p></li></ul><p>特点：</p><p>散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的，而不像在数组中的遍历过程，采用存储数组中内容的部分元素作为映射函数的输入，映射函数的输出就是存储数据的位置，这样的访问速度就省去了遍历数组的实现，因此时间复杂度可以认为为O(1)，而数组遍历的时间复杂度为O(n)。</p><p><img src="/../image/assets/image-20230628181044838.png" alt="image-20230628181044838"></p><p><img src="/../image/assets/image-20230628181110567.png" alt="image-20230628181110567"></p><p>答案： B</p><p>线性表元素的序号是从1开始，而在第n+1个位置插入，相当于在表尾追加</p><p>长度为n的意思应该是存了n个 不是数组长度为n（呜呜呜呜呜呜）</p><h4 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h4><p><strong>前驱结点是指在链表或树等数据结构中，某个节点的前面一个节点。具体来说：</strong></p><ol><li>在链表中，每个节点通常包含一个数据元素和一个指向下一个节点的指针。前驱结点是指在链表中，某个节点的前一个节点，即指向该节点的指针指向的节点。</li><li>在树的二叉搜索树（Binary Search Tree）中，前驱结点是指中序遍历顺序中，某个节点的前面一个节点。在中序遍历中，节点按照从小到大的顺序进行访问，前驱结点即是在这个顺序中的前一个节点。</li></ol><p>前驱结点的概念主要用于确定节点在某种特定顺序中的前一个节点，可以在某些操作中起到辅助作用。在链表和树等数据结构中，我们可以通过相应的指针或遍历方式来找到节点的前驱结点</p><p><img src="/../image/assets/image-20230628192706921.png" alt="image-20230628192706921"></p><p>答案：D</p><p>​          顺序存储结构同样适用于图和树</p><p><img src="/../image/assets/image-20230628192636888.png" alt="image-20230628192636888"></p><p>答：D</p><p>​       若先建立链表，然后依次插入建立有序表，则每插入一个元素就需要遍历链表寻找插入位置，即直接插入排序，时间复杂度O(N2)</p><p>​       若先讲数组进行排序，然后建立链表，建立链表的时间复杂度是O(N)，数组排序的最好时间复杂度是O(Nlog2N)，总时间复杂度是O(Nlog2N)</p><p><img src="/../image/assets/image-20230628193300102.png" alt="image-20230628193300102"></p><p>答：C</p><p>​需要先遍历找到长度为m的单链表的尾节点，然后将其next域指向另一个单链表的首节点</p><p><img src="/../image/assets/image-20230628193540185.png" alt="image-20230628193540185"></p><p>答：C</p><p>​<strong>设有头指针和尾指针的单链表执行删除最后一个元素的操作与链表长度有 关，因为要进行遍历寻找尾节点前一个节点</strong></p><p>​D选项没有考虑顺序表，数组存放的元素存取与i无关</p><p><img src="/../image/assets/image-20230628200207710.png" alt="image-20230628200207710"></p><p><img src="/../image/assets/image-20230628200146372.png" alt="image-20230628200146372"></p><h3 id="论述题"><a href="#论述题" class="headerlink" title="论述题"></a>论述题</h3><p><img src="/../image/assets/image-20230628122125234.png" alt="image-20230628122125234"></p><h4 id="顺序表-VS-链表"><a href="#顺序表-VS-链表" class="headerlink" title="顺序表 VS 链表"></a>顺序表 VS 链表</h4><h4 id="顺序表动态数组实现-VS-静态数组实现"><a href="#顺序表动态数组实现-VS-静态数组实现" class="headerlink" title="顺序表动态数组实现 VS 静态数组实现"></a>顺序表动态数组实现 VS 静态数组实现</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h1&gt;&lt;h2 id=&quot;做题总结&quot;&gt;&lt;a href=&quot;#做题总结&quot; class=&quot;headerlink&quot; title=&quot;做题总结&quot;&gt;&lt;/a&gt;做题总</summary>
      
    
    
    
    <category term="数据结构" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="408" scheme="https://sdumoist.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/408/"/>
    
    
    <category term="线性表" scheme="https://sdumoist.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
</feed>
